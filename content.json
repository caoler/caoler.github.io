{"meta":{"title":"Caole's blog","subtitle":"Caole的个人博客","description":"会写代码，学着做菜","author":"Caole","url":"https://caoler.cn"},"pages":[{"title":"My2018","date":"2018-10-14T12:57:08.421Z","updated":"2018-10-14T12:57:08.421Z","comments":true,"path":"about/index.html","permalink":"https://caoler.cn/about/index.html","excerpt":"","text":"2018.10月月度计划目标 寻找mybatis框架的更敏捷的开发方法并运用在实战之中 在新项目编码的同时完善组内java工具类库 继续自己的阅读计划–《高性能MySQL》第一二章，输出学习笔记 老大说：“能力”其实包含很多方面的内容，技术是能力，但是解决问题，更是难得的能力。你可以思考如何提升自己“解决问题的能力” 通过提升自己解决问题的能力来提高自己的能力。 因为找工作的原因，感觉最近很没有状态，很不舒服，心情很低落。需要调整 完成状况总结2018.9月月度计划目标 第一目标当然是“秋招”啦（暂时不更新到Caole’s Blog，不然被老大看到可能会打死我），因为在学校的时间可能不是特别够，细分一下就是下面这些，尽量按顺序完成吧 9月2号-9月3号复习《深入理解JAVA虚拟机》、《JAVA并发编程的艺术》 9月4号写答辩文档，PPT，加快速度，完事了继续看书，可能晚上要去浪哈哈 9月5号一天默写基础排序算法。 9月6号复习JAVA集合框架，这个一天应该不能搞定，可以延长半天到7号上午 9月7号了解dubbo，redis，这两个虽然没用过，但是不能一问三不知 9月8号，数据库，得看看索引，什么B+树，引擎 左连接右连接一类 9月10号，手写，单例（安全），同步异步 Callable，可以获得的一个异步结果Future ？属于这里吗？ 。。。先写到这里，过完一天在下面写一天。 完成状况以上计划均已完成！ 总结9月份算是大起大落了一次，像是高考中没中举一样。前半个月请假回学校就每天泡自习室，刷面经，刷题，终于子啊9月12号迎来了面试，直到今天（1009）中午12：40才刚刚结束了面试，在未收当前公司到offer意向书之前，我只能说我的秋招是失败的。这部分到时候另起一文做一下总结吧。人生总是有一些不尽人意的地方，说到底 菜是原罪，我也接受这个结果。努力！:fist::fist::fist: 2018.8月月度计划目标 学习JAVA的类加载机制（因为今天已经8.12号了，所以这一部分已经完成了） spring部分源码阅读，掌握其实现原理 阅读JAVA并发编程的艺术（大公司对这一块实在是太看重了，而这一部分却是我最薄弱的部分） 公司的话，最近八月份没有正经的项目，只有一些组内需求，重点是在项目自动化部署、组件创建，代码重构这一部分，所以计划就不在这里列出了。 完成状况 学习JAVA的类加载机制（因为今天已经8.12号了，所以这一部分已经完成了） spring部分源码阅读，掌握其实现原理 阅读JAVA并发编程的艺术（大公司对这一块实在是太看重了，而这一部分却是我最薄弱的部分） 公司的话，最近八月份没有正经的项目，只有一些组内需求，重点是在项目自动化部署、组件创建，代码重构这一部分，所以计划就不在这里列出了。 总结又是每月总结时，听着赵雷的《我们的时光》和《理想》，又重新找回了当时6点起床去公司的感觉，哈哈。说正事，8月份的计划算是我从5月份写计划以来完成度最高的一次，可以说非常的开心了，前10天左右因为公司事情太多 所以只看了一下类加载机制，看了部分Spring IOC的源码，但是没有复习，这几天着手复习一下。然后剩下的时间，大概半个月，我看完了《JAVA并发编程的艺术》，这也是我第一次看的最完整的一本书:sweat_smile:，尴尬，还是非常有收获的。好啦，总结结束，去写一下9月计划~ 2018.7月月度计划目标非公司任务目标： 《Spring实战》第1.2.3.4.21章必须详细认真的看完，按照实例写出Demo，并输出学习笔记 《Spring源码深度解析》第2,3,4章必须详细认真的看完，并输出学习笔记。 每周做一道《剑指Offer》编程题。输出学习笔记，坚持！ 公司目标： 熟悉组内自测流程 学习SpringAOP的知识，输出学习笔记，并将其运用在项目之中，之前虽然使用springboot已经开始写项目了，但是它的核心组件并没有具体使用过。 熟悉springboot单元测试，之前都是直接通过启动项目进行测试，效率低下。 学习并构建组内Java组件。 完成状况非公司任务目标： 《Spring实战》第1.2.3.4.21章必须详细认真的看完，按照实例写出Demo，并输出学习笔记 《Spring源码深度解析》第2,3,4章必须详细认真的看完，并输出学习笔记。 每周做一道《剑指Offer》编程题。输出学习笔记，坚持！ 公司目标： 熟悉组内自测流程 学习SpringAOP的知识，输出学习笔记，并将其运用在项目之中，之前虽然使用springboot已经开始写项目了，但是它的核心组件并没有具体使用过。 熟悉springboot单元测试，之前都是直接通过启动项目进行测试，效率低下。 学习并构建组内Java组件。 总结今天已经8.12号了才来做总结 :cry:，主要是太忙了（前十二天都在找借口）。《Spring实战》像他的名字一样，太注重于实战了，对于入门来说还是很好的一本书，但是我现在不太适合看，所以大概看了一下就放下了。Spring源码解析的深度又太深了，现在看起来实在是太吃力了。所以现在很纠结，在找方法。 公司的整个开发流程算是比较掌握了，AOP也在SpringBoot中实践过了，但是具体应用到项目中还没有找到合适的场景，所以暂时靠后。 2018.6月月度计划目标 熟悉公司项目开发流程，主要是前后端联调，以及之后的和测试、产品沟通的流程。 了解该阶段的流程，明确需要做的事情 输出项目开发流程总结 开发效率比较低，原因之一是组内业务相关的可用组件很少，思考并构建部分内部组件，并应用在项目中 准备期末考试 完成状况 熟悉公司项目开发流程，主要是前后端联调，以及之后的和测试、产品沟通的流程。 了解该阶段的流程，明确需要做的事情 输出项目开发流程总结 开发效率比较低，原因之一是组内业务相关的可用组件很少，思考并构建部分内部组件，并应用在项目中 准备期末考试 总结六月份只有一半时间在公司工作，剩下一半时间回到学校考试，学校考试应该来说很顺利，再考完两门，就等着出成绩了。项目整体的开发流程较之前已经非常熟悉了，总结下来就是：一定要和产品沟通好，由于之前的沟通不当导致我写了一大堆没有必要的代码，使开发进度拖延严重。 今天拿出书本打算好好看一下，但是总是感觉静不下心，现在的主要问题就是太浮躁了，完全不能进入状态，很严重，必须赶快调整过来。可怕的是网易京东华为的秋招已经开始了！ 7月9日返岗，完成公司任务的同时一定要好好准备秋招，不然你就完蛋了！ 2018.5月月度计划目标 通过项目熟悉springboot框架和mybatis框架的使用。 学会使用mybatis的动态SQL的参数配置以及多表级联查询，完成项目中部分的内容或输出相关Demo 学会使用springboot框架使用事务管理，结合spring框架研究IOC原理，并输出学习笔记。 熟悉整个项目的开发流程，学习并熟悉相关代码规范。 了解项目开发的各个阶段，明确每个阶段要做的事情。 输出项目开发流程总结报告。 学习mysql索引相关知识，并加以实际运用。 学习MySQL索引原理并输出学习笔记。 完成状况 通过项目熟悉springboot框架和mybatis框架的使用。 学会使用mybatis的动态SQL的参数配置以及多表级联查询，完成项目中部分的内容或输出相关Demo 学会使用springboot框架使用事务管理，结合spring框架研究IOC原理，并输出学习笔记。 熟悉整个项目的开发流程，学习并熟悉相关代码规范。 了解项目开发的各个阶段，明确每个阶段要做的事情。 输出项目开发流程总结报告。 学习mysql索引相关知识，并加以实际运用。 学习MySQL索引原理并输出学习笔记。 总结由于前半个月都在熟悉环境，不知道自己该做些什么，所以制定计划的时候已经过去一半了。且后半月一直在项目中踩坑，所以后面的两个任务也没有完成。在通过一个月的学习之后 熟悉了项目从需求分析到编码阶段的过程 熟悉springboot和mybatis的使用，但是由于没有经验，所以不断踩坑，导致开发效率低下。 对Mysql的动态SQL参数配置和多表级联查询有了很深入的了解。"},{"title":"分类","date":"2017-11-27T11:41:23.483Z","updated":"2017-11-27T11:41:23.483Z","comments":false,"path":"categories/index.html","permalink":"https://caoler.cn/categories/index.html","excerpt":"","text":""},{"title":"这里会展示一些平时碰到的有价值的博客(•̀ᴗ•́)و ̑̑","date":"2018-03-12T03:56:42.842Z","updated":"2018-03-12T03:56:42.842Z","comments":false,"path":"collection/index.html","permalink":"https://caoler.cn/collection/index.html","excerpt":"","text":"读书笔记之类 深入理解JVM读书笔记合集 - GinoBeFunny 技术博文 Java NIO系列教程 - 并发编程网 与面试有关 就职于阿里的大牛的经验- GinoBeFunny 博客搭建相关等看到了再收藏吧… 待更新…"},{"title":"标签","date":"2017-11-27T11:38:10.000Z","updated":"2017-11-27T11:40:46.526Z","comments":false,"path":"tags/index.html","permalink":"https://caoler.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Spring Boot + Mybatis 多数据源配置","slug":"Spring Boot + Mybatis 多数据源配置","date":"2018-10-11T08:38:00.000Z","updated":"2018-10-14T12:55:47.391Z","comments":true,"path":"/post/2018/spring-mybatis-more-db.html","link":"","permalink":"https://caoler.cn/post/2018/spring-mybatis-more-db.html","excerpt":"应用场景项目需要同时连接两个不同的数据库poi、pos，暂未涉及到主从，仅仅是因为两个数据库相互独立。","text":"应用场景项目需要同时连接两个不同的数据库poi、pos，暂未涉及到主从，仅仅是因为两个数据库相互独立。 多数据源首先要将spring boot自带的DataSourceAutoConfiguration禁掉，因为它会读取application.properties文件的spring.datasource.*属性并自动配置单数据源。在@SpringBootApplication注解中添加exclude属性即可： 12345678@SpringBootApplication(exclude = &#123; DataSourceAutoConfiguration.class&#125;)public class WebApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(WebApplication.class, args); &#125;&#125; 然后在application.yml中配置多数据源连接信息： 12345678910111213spring: datasource: type: com.alibaba.druid.pool.DruidDataSource poi: driverClassName: com.mysql.cj.jdbc.Driver url: jdbc:mysql://127.0.0.1:3306/poi username: root password: root pos: driverClassName: com.mysql.cj.jdbc.Driver url: jdbc:mysql://127.0.0.1:3306/pos username: root password: root 由于我们禁掉了自动数据源配置，因些下一步就需要手动将这些数据源创建出来： poi数据源配置注意，配置类需要对DataSource、DataSourceTransactionManager、SqlSessionFactory 、SqlSessionTemplate四个数据项进行配置；DataSource类型需要引入javax.sql.DataSource @MapperScan对指定dao包建立映射，确保在多个数据源下，自动选择合适的数据源，而在service层里不需要做特殊说明. 12345678910111213141516171819202122232425262728293031@Configuration@MapperScan(basePackages = \"cn.caoler.poi.mapper\", sqlSessionTemplateRef = \"poiSqlSessionTemplate\")public class BaseDataSourceConfig &#123; @Bean(name = \"poiDataSource\") @ConfigurationProperties(prefix = \"spring.datasource.poi\") @Primary public DataSource setDataSource() &#123; return DataSourceBuilder.create().build(); &#125; @Bean(name = \"poiTransactionManager\") @Primary public DataSourceTransactionManager setTransactionManager1(@Qualifier(\"poiDataSource\") DataSource dataSource) &#123; return new DruidDataSource(); &#125; @Bean(name = \"poiSqlSessionFactory\") @Primary public SqlSessionFactory setSqlSessionFactory(@Qualifier(\"poiDataSource\") DataSource dataSource) throws Exception &#123; SqlSessionFactoryBean bean = new SqlSessionFactoryBean(); bean.setDataSource(dataSource); bean.setMapperLocations(new PathMatchingResourcePatternResolver().getResources(\"classpath:mapper/poi/*.xml\")); return bean.getObject(); &#125; @Bean(name = \"poiSqlSessionTemplate\") @Primary public SqlSessionTemplate setSqlSessionTemplate(@Qualifier(\"poiSqlSessionFactory\") SqlSessionFactory sqlSessionFactory) throws Exception &#123; return new SqlSessionTemplate(sqlSessionFactory); &#125;&#125; 经过如上配置，cn.caoler.poi.mapper包下的Mapper接口，都会使用poi数据源。同理可配第二个 pos数据源配置12345678910111213141516171819202122232425262728293031@Configuration@MapperScan(basePackages = \"cn.caoler.pos.mapper\", sqlSessionTemplateRef = \"poiSqlSessionTemplate\")public class BaseDataSourceConfig &#123; @Bean(name = \"posDataSource\") @ConfigurationProperties(prefix = \"spring.datasource.pos\") @Primary public DataSource setDataSource() &#123; return DataSourceBuilder.create().build(); &#125; @Bean(name = \"posTransactionManager\") @Primary public DataSourceTransactionManager setTransactionManager2(@Qualifier(\"posDataSource\") DataSource dataSource) &#123; return new DruidDataSource(); &#125; @Bean(name = \"posSqlSessionFactory\") @Primary public SqlSessionFactory setSqlSessionFactory(@Qualifier(\"posDataSource\") DataSource dataSource) throws Exception &#123; SqlSessionFactoryBean bean = new SqlSessionFactoryBean(); bean.setDataSource(dataSource); bean.setMapperLocations(new PathMatchingResourcePatternResolver().getResources(\"classpath:mapper/pos/*.xml\")); return bean.getObject(); &#125; @Bean(name = \"posSqlSessionTemplate\") @Primary public SqlSessionTemplate setSqlSessionTemplate(@Qualifier(\"posSqlSessionFactory\") SqlSessionFactory sqlSessionFactory) throws Exception &#123; return new SqlSessionTemplate(sqlSessionFactory); &#125;&#125; 完成这些配置后，假设有2个Mapper poi.mapper.UserMapper和pos.mapper.RoleMapper，使用前者时会自动连接poi库，后者连接pos库。 踩坑1. jdbcUrl is required with driverClassName报错解决方法：在配置文件中使用spring.datasource.jdbcUrl，而不是通常使用的spring.datasource.url。 1234567datasource: type: com.alibaba.druid.pool.DruidDataSource poi: driverClassName: com.mysql.cj.jdbc.Driver jdbcUrl: jdbc:mysql://127.0.0.1:3306/poi #此处必须使用jdbcUrl而不是url username: root password: root 2. 访问 接口时提示：DataSourceTransactionManager 重复12345@Bean(name = \"posTransactionManager\")@Primarypublic DataSourceTransactionManager setTransactionManager2(@Qualifier(\"posDataSource\") DataSource dataSource) &#123; return new DruidDataSource();&#125; 在配置DataSourceTransactionManager时，Bean命名为posTransactionManager和poiTransactionManager，已经做了区分，但是调用时还会提示有两个TransactionManager，产生原因暂不明确，但是解决方法为： 修改函数名，保证函数名之间有严格区分即可（例：setTransactionManager1、setTransactionManager2） 3. 提示mapper/xxx/*.xml未找到只要保证程序运行之前，上述位置生成好对应的mapping.xml文件即可，若该位置无xml文件，则会报上述错误。 至此，大功告成。 参考 https://blog.csdn.net/acquaintanceship/article/details/75350653 https://blog.csdn.net/newhanzhe/article/details/80763581 https://blog.csdn.net/neosmith/article/details/61202084","categories":[{"name":"Spring","slug":"Spring","permalink":"https://caoler.cn/categories/Spring/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"https://caoler.cn/tags/springboot/"}]},{"title":"Java RestTemplate post请求传递参数","slug":"Java RestTemplate post请求传递参数","date":"2018-10-10T08:38:00.000Z","updated":"2018-10-14T12:54:44.487Z","comments":true,"path":"/post/2018/Java-RestTemplate.html","link":"","permalink":"https://caoler.cn/post/2018/Java-RestTemplate.html","excerpt":"最近使用Spring 的 RestTemplate 工具类请求接口的时候发现参数传递的一个坑，也就是当我们把参数封装在Map里面的时候，Map 的类型选择。 使用RestTemplate post请求的时候主要可以通过三种方式实现 调用postForObject方法 使用postForEntity方法 调用exchange方法","text":"最近使用Spring 的 RestTemplate 工具类请求接口的时候发现参数传递的一个坑，也就是当我们把参数封装在Map里面的时候，Map 的类型选择。 使用RestTemplate post请求的时候主要可以通过三种方式实现 调用postForObject方法 使用postForEntity方法 调用exchange方法 postForObject和postForEntity方法的区别主要在于可以在postForEntity方法中设置header的属性，当需要指定header的属性值的时候，使用postForEntity方法。exchange方法和postForEntity类似，但是更灵活，exchange还可以调用get请求。使用这三种方法传递参数，Map不能定义为以下两种类型 1Map&lt;String, Object&gt; paramMap = new HashMap&lt;String, Object&gt;(); 1Map&lt;String, Object&gt; paramMap = new LinkedHashMap&lt;String, Object&gt;(); 经过测试，我发现这两种map里面的参数都不能被后台接收到，这个问题困扰我两天，终于，当我把Map类型换成LinkedMultiValueMap后，参数成功传递到后台 1MultiValueMap&lt;String, Object&gt; paramMap = new LinkedMultiValueMap&lt;String, Object&gt;(); 经过测试，正确的传参方式如下 12345678910111213141516171819202122public static void main(String[] args) &#123; RestTemplate template = new RestTemplate(); String url = \"http://192.168.2.40:8081/channel/channelHourData/getHourNewUserData\"; // 封装参数，千万不要替换为Map与HashMap，否则参数无法传递 MultiValueMap&lt;String, Object&gt; paramMap = new LinkedMultiValueMap&lt;String, Object&gt;(); paramMap.add(\"dt\", \"20180416\"); // 1、使用postForObject请求接口 String result = template.postForObject(url, paramMap, String.class); System.out.println(\"result1==================\" + result); // 2、使用postForEntity请求接口 HttpHeaders headers = new HttpHeaders(); HttpEntity&lt;MultiValueMap&lt;String, Object&gt;&gt; httpEntity = new HttpEntity&lt;MultiValueMap&lt;String, Object&gt;&gt;(paramMap,headers); ResponseEntity&lt;String&gt; response2 = template.postForEntity(url, httpEntity, String.class); System.out.println(\"result2====================\" + response2.getBody()); // 3、使用exchange请求接口 ResponseEntity&lt;String&gt; response3 = template.exchange(url, HttpMethod.POST, httpEntity, String.class); System.out.println(\"result3====================\" + response3.getBody()); &#125;","categories":[{"name":"JAVASE","slug":"JAVASE","permalink":"https://caoler.cn/categories/JAVASE/"}],"tags":[{"name":"JAVASE","slug":"JAVASE","permalink":"https://caoler.cn/tags/JAVASE/"},{"name":"请求发送","slug":"请求发送","permalink":"https://caoler.cn/tags/请求发送/"}]},{"title":"KafKa存储结构详解","slug":"kafka存储结构","date":"2018-09-29T11:38:00.000Z","updated":"2018-10-14T12:55:19.255Z","comments":true,"path":"/post/2018/kafka-storage.html","link":"","permalink":"https://caoler.cn/post/2018/kafka-storage.html","excerpt":"整体存储结构Kafka中的Message是以topic为基本单位组织的，不同的topic之间是相互独立的。每个topic又可以分成几个不同的partition(每个topic有几个partition是在创建topic时指定的)，每个partition存储一部分Message。借用官方的一张图，可以直观地看到topic和partition的关系。","text":"整体存储结构Kafka中的Message是以topic为基本单位组织的，不同的topic之间是相互独立的。每个topic又可以分成几个不同的partition(每个topic有几个partition是在创建topic时指定的)，每个partition存储一部分Message。借用官方的一张图，可以直观地看到topic和partition的关系。 partition是以文件的形式存储在文件系统中，比如，创建了一个名为page_visits的topic，其有5个partition，那么在Kafka的数据目录中(由配置文件中的log.dirs指定的)中就有这样5个目录: page_visits-0， page_visits-1，page_visits-2，page_visits-3，page_visits-4，其命名规则为&lt;topic_name&gt;-&lt;partition_id&gt;，里面存储的分别就是这5个partition的数据。 接下来，本文将分析partition目录中的文件的存储格式和相关的代码所在的位置。 Partition的数据文件Partition中的每条Message由offset来表示它在这个partition中的偏移量，这个offset不是该Message在partition数据文件中的实际存储位置，而是逻辑上一个值，它唯一确定了partition中的一条Message。因此，可以认为offset是partition中Message的id。partition中的每条Message包含了以下三个属性： offset MessageSize data 其中offset为long型，MessageSize为int32，表示data有多大，data为message的具体内容。它的格式和Kafka通讯协议中介绍的MessageSet格式是一致。 我们来思考一下，如果一个partition只有一个数据文件会怎么样？ 新数据是添加在文件末尾（调用FileMessageSet的append方法），不论文件数据文件有多大，这个操作永远都是O(1)的。 查找某个offset的Message（调用FileMessageSet的searchFor方法）是顺序查找的。因此，如果数据文件很大的话，查找的效率就低。 那Kafka是如何解决查找效率的的问题呢？有两大法宝：1) 分段 2) 索引。 数据文件的分段Kafka解决查询效率的手段之一是将数据文件分段，比如有100条Message，它们的offset是从0到99。假设将数据文件分成5段，第一段为0-19，第二段为20-39，以此类推，每段放在一个单独的数据文件里面，数据文件以该段中最小的offset命名。这样在查找指定offset的Message的时候，用二分查找就可以定位到该Message在哪个段中。 为数据文件创建索引数据文件分段使得可以在一个较小的数据文件中查找对应offset的Message了，但是这依然需要顺序扫描才能找到对应offset的Message。为了进一步提高查找的效率，Kafka为每个分段后的数据文件建立了索引文件，文件名与数据文件的名字是一样的，只是文件扩展名为.index。索引文件中包含若干个索引条目，每个条目表示数据文件中一条Message的索引。索引包含两个部分（均为4个字节的数字），分别为相对offset和position。 相对offset：因为数据文件分段以后，每个数据文件的起始offset不为0，相对offset表示这条Message相对于其所属数据文件中最小的offset的大小。举例，分段后的一个数据文件的offset是从20开始，那么offset为25的Message在index文件中的相对offset就是25-20 = 5。存储相对offset可以减小索引文件占用的空间。 position，表示该条Message在数据文件中的绝对位置。只要打开文件并移动文件指针到这个position就可以读取对应的Message了。 index文件中并没有为数据文件中的每条Message建立索引，而是采用了稀疏存储的方式，每隔一定字节的数据建立一条索引。这样避免了索引文件占用过多的空间，从而可以将索引文件保留在内存中。但缺点是没有建立索引的Message也不能一次定位到其在数据文件的位置，从而需要做一次顺序扫描，但是这次顺序扫描的范围就很小了。 小结我们以几张图来总结一下Message是如何在Kafka中存储的，以及如何查找指定offset的Message的。 Message是按照topic来组织，每个topic可以分成多个的partition，比如：有5个partition的名为为page_visits的topic的目录结构为： partition是分段的，每个段叫LogSegment，包括了一个数据文件和一个索引文件，下图是某个partition目录下的文件：可以看到，这个partition有4个LogSegment。 展示是如何查找Message的。比如：要查找绝对offset为7的Message： 首先是用二分查找确定它是在哪个LogSegment中，自然是在第一个Segment中。 打开这个Segment的index文件，也是用二分查找找到offset小于或者等于指定offset的索引条目中最大的那个offset。自然offset为6的那个索引是我们要找的，通过索引文件我们知道offset为6的Message在数据文件中的位置为9807。 打开数据文件，从位置为9807的那个地方开始顺序扫描直到找到offset为7的那条Message。 这套机制是建立在offset是有序的。索引文件被映射到内存中，所以查找的速度还是很快的。 一句话，Kafka的Message存储采用了分区(partition)，分段(LogSegment)和稀疏索引这几个手段来达到了高效性。 本文转自CSDN,原文链接：https://blog.csdn.net/gongxinju/article/details/72672375","categories":[{"name":"KafKa","slug":"KafKa","permalink":"https://caoler.cn/categories/KafKa/"}],"tags":[{"name":"kafka","slug":"kafka","permalink":"https://caoler.cn/tags/kafka/"},{"name":"消息队列","slug":"消息队列","permalink":"https://caoler.cn/tags/消息队列/"}]},{"title":"生产者消费者模型","slug":"生产者消费者模型","date":"2018-09-29T08:38:00.000Z","updated":"2018-10-14T12:55:59.620Z","comments":true,"path":"/post/2018/producer-consumer.html","link":"","permalink":"https://caoler.cn/post/2018/producer-consumer.html","excerpt":"什么是生产者消费者用一个不是特别恰当的例子做比喻：鸡下蛋，人吃鸡蛋，鸡每天下10个蛋，但是人每天只能吃2个蛋，吃不及蛋就会造成阻塞。生产者消费者模型呢，给中间放了个篮子，鸡下蛋放进篮子，人吃蛋从篮子里拿，将人与鸡的强耦合解开，变成了弱耦合。","text":"什么是生产者消费者用一个不是特别恰当的例子做比喻：鸡下蛋，人吃鸡蛋，鸡每天下10个蛋，但是人每天只能吃2个蛋，吃不及蛋就会造成阻塞。生产者消费者模型呢，给中间放了个篮子，鸡下蛋放进篮子，人吃蛋从篮子里拿，将人与鸡的强耦合解开，变成了弱耦合。 生产者消费者模型需要关注的几个点： 生产者生产的时候消费者不能消费 消费者消费的时候生产者不能生产 缓冲区空时消费者不能消费 缓冲区满时生产者不能生产 为什么要用生产者消费者模型？优点在哪里？ 解耦 。因为多了一个缓冲区，所以生产者和消费者并不直接相互调用，这一点很容易想到，这样生产者和消费者的代码发生变化，都不会对对方产生影响，这样其实就把生产者和消费者之间的强耦合解开，变为了生产者和缓冲区/消费者和缓冲区之间的弱耦合 通过平衡生产者和消费者的处理能力来提高整体处理数据的速度，这是生产者/消费者模型最重要的一个优点。如果消费者直接从生产者这里拿数据，如果生产者生产的速度很慢，但消费者消费的速度很快，那消费者就得占用CPU的时间片白白等在那边。有了生产者/消费者模型，生产者和消费者就是两个独立的并发体，生产者把生产出来的数据往缓冲区一丢就好了，不必管消费者；消费者也是，从缓冲区去拿数据就好了，也不必管生产者，缓冲区满了就不生产，缓冲区空了就不消费，使生产者/消费者的处理能力达到一个动态的平衡 实现生产者消费者模型的两个简单Demo 利用wait()/notify()实现生产者/消费者模型 既然生产者/消费者模型有一个缓冲区，那么我们就自己做一个缓冲区，生产者和消费者的通信都是通过这个缓冲区的。value为””表示缓冲区空，value不为””表示缓冲区满： 1234public class ValueObject&#123; public static String value = \"\";&#125; 接下来就是一个生产者了，如果缓冲区满了的，那么就wait()，不再生产了，等待消费者消费完通知；如果缓冲区是空的，那么就生产数据到缓冲区中 12345678910111213141516171819202122232425package com.myhexin.ioc.producerConsumer;public class Producer &#123; private Object lock; public Producer(Object lock)&#123; this.lock = lock; &#125; public void setValue()&#123; try &#123; synchronized (lock)&#123; if (!ValueObject.value.equals(\"\"))&#123; lock.wait(); &#125; String value = System.currentTimeMillis() + \"_\" + System.nanoTime(); System.out.println(\"Set的值为：\" + value); ValueObject.value = value; lock.notify(); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 消费者类似，如果缓冲区是空的，那么就不再消费，wait()等待，等待生产者生产完通知；如果缓冲区不是空的，那么就去拿数据： 123456789101112131415161718192021222324package com.myhexin.ioc.producerConsumer;public class Customer &#123; private Object lock; public Customer(Object lock)&#123; this.lock = lock; &#125; public void getValue()&#123; try &#123; synchronized (lock)&#123; if (ValueObject.value.equals(\"\"))&#123; lock.wait(); &#125; System.out.println(\"Get的值为：\" + ValueObject.value); ValueObject.value = \"\"; lock.notify(); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 写个主函数，开两个线程调用Producer里面的getValue()方法和Customer()里面的setValue()方法： 1234567891011121314151617181920212223242526272829303132package com.myhexin.ioc.producerConsumer;public class Hello &#123; public static void main(String[] args) &#123; Object lock = new Object(); final Producer producer = new Producer(lock); final Customer customer = new Customer(lock); Runnable producerRunnable = new Runnable() &#123; @Override public void run() &#123; while (true)&#123; producer.setValue(); &#125; &#125; &#125;; Runnable customerRunnable = new Runnable() &#123; @Override public void run() &#123; while (true)&#123; customer.getValue(); &#125; &#125; &#125;; Thread p = new Thread(producerRunnable); Thread c = new Thread(customerRunnable); p.start(); c.start(); &#125;&#125; 看一下运行结果： 12345678...Set的值是：1444025677743_162366875965845Get的值是：1444025677743_162366875965845Set的值是：1444025677743_162366875983541Get的值是：1444025677743_162366875983541Set的值是：1444025677743_162366876004776Get的值是：1444025677743_162366876004776... 生产数据和消费数据一定是成对出现的，生产一个消费一个，满了不生产，空了不消费，生产者不能无限生产，消费者也不能无限消费，符合生产者/消费者模型。生产者速度快，就不占用CPU时间片，等着消费者消费完通知它继续生产，这块时间片可以用来给其他线程用。 利用await()/signal()实现生产者和消费者模型 一样，先定义一个缓冲区： 1234public class ValueObject&#123; public static String value = \"\";&#125; 换种写法，生产和消费方法放在一个类里面： 123456789101112131415161718192021222324252627282930313233343536373839package com.myhexin.ioc.pc2;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.ReentrantLock;public class ThreadDomain extends ReentrantLock &#123; private Condition condition = newCondition(); public void set()&#123; try &#123; lock(); while (!\"\".equals(ValueObject.value)) condition.await(); ValueObject.value = \"123\"; System.out.println(Thread.currentThread().getName() + \"生产了：\" + ValueObject.value); condition.signal(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; unlock(); &#125; &#125; public void get()&#123; try &#123; lock(); while (\"\".equals(ValueObject.value)) condition.await(); System.out.println(Thread.currentThread().getName() + \"消费了：\" + ValueObject.value); ValueObject.value = \"\"; condition.signal(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; unlock(); &#125; &#125;&#125; 同样的，开两个线程，一个线程调用set()方法生产，另一个线程调用get()方法消费： 1234567891011121314151617181920212223242526272829package com.myhexin.ioc.pc2;public class Hello &#123; public static void main(String[] args) &#123; final ThreadDomain td = new ThreadDomain(); Runnable pRunnable = new Runnable() &#123; @Override public void run() &#123; while (true) td.set(); &#125; &#125;; Runnable cRunnable = new Runnable() &#123; @Override public void run() &#123; while (true) td.get(); &#125; &#125;; Thread p = new Thread(pRunnable); p.setName(\"P\"); Thread c = new Thread(cRunnable); c.setName(\"C\"); p.start(); c.start(); &#125;&#125; 和wait()/notify()机制的实现效果一样，同样符合生产者/消费者模型. 小心假死生产者/消费者模型最终达到的目的是平衡生产者和消费者的处理能力，达到这个目的的过程中，并不要求只有一个生产者和一个消费者。可以多个生产者对应多个消费者，可以一个生产者对应一个消费者，可以多个生产者对应一个消费者。 假死就发生在上面三种场景下。理论分析就能说明问题，所以就不写代码了。代码要写也很简单，上面的两个例子随便修改一个，开一个生产者线程/多个消费者线程、开多个生产者线程/消费者线程、开多个生产者线程/多个消费者线程都可以。假死指的是全部线程都进入了WAITING状态，那么程序就不再执行任何业务功能了，整个项目呈现停滞状态。 比方说有生产者A和生产者B，缓冲区由于空了，消费者处于WAITING。生产者B处于WAITING，生产者A被消费者通知生产，生产者A生产出来的产品本应该通知消费者，结果通知了生产者B，生产者B被唤醒，发现缓冲区满了，于是继续WAITING。至此，两个生产者线程处于WAITING，消费者处于WAITING，系统假死。 上面的分析可以看出，假死出现的原因是因为notify的是同类，所以非单生产者/单消费者的场景，可以采取两种方法解决 这个问题： 1、synchronized用notifyAll()唤醒所有线程、ReentrantLock用signalAll()唤醒所有线程 2、用ReentrantLock定义两个Condition，一个表示生产者的Condition，一个表示消费者的Condition，唤醒的时候调用相应的Condition的signal()方法就可以了 本文转自五月的仓颉大神，原文链接：https://www.cnblogs.com/xrq730/p/4855663.html","categories":[{"name":"并发编程","slug":"并发编程","permalink":"https://caoler.cn/categories/并发编程/"},{"name":"生产者消费者","slug":"并发编程/生产者消费者","permalink":"https://caoler.cn/categories/并发编程/生产者消费者/"}],"tags":[{"name":"生产者消费者","slug":"生产者消费者","permalink":"https://caoler.cn/tags/生产者消费者/"}]},{"title":"Queue、BlockingQueue以及利用BlockingQueue实现生产者消费者模型","slug":"Queue、BlockingQueue以及利用BlockingQueue实现生产者消费者模型","date":"2018-09-28T08:38:00.000Z","updated":"2018-10-14T12:55:41.464Z","comments":true,"path":"/post/2018/BlockingQueue.html","link":"","permalink":"https://caoler.cn/post/2018/BlockingQueue.html","excerpt":"Queue是什么 队列，是一种数据结构。除了优先级队列和LIFO队列外，队列都是以FIFO（先进先出）的方式对各个元素进行排序的。无论使用哪种排序方式，队列的头都是调用remove()或poll()移除元素的。在FIFO队列中，所有新元素都插入队列的末尾。","text":"Queue是什么 队列，是一种数据结构。除了优先级队列和LIFO队列外，队列都是以FIFO（先进先出）的方式对各个元素进行排序的。无论使用哪种排序方式，队列的头都是调用remove()或poll()移除元素的。在FIFO队列中，所有新元素都插入队列的末尾。 Queue中的方法 Queue中的方法不难理解，6个，每2对是一个也就是总共3对。看一下JDK API就知道了： 注意一点就好，Queue通常不允许插入Null，尽管某些实现（比如LinkedList）是允许的，但是也不建议。 BlockingQueue 1、BlockingQueue概述 只讲BlockingQueue，因为BlockingQueue是Queue中的一个重点，并且通过BlockingQueue我们再次加深对于生产者/消费者模型的理解。其他的Queue都不难，通过查看JDK API和简单阅读源码完全可以理解他们的作用。 BlockingQueue，顾名思义，阻塞队列。BlockingQueue是在java.util.concurrent下的，因此不难理解，BlockingQueue是为了解决多线程中数据高效安全传输而提出的。 多线程中，很多场景都可以使用队列实现，比如经典的生产者/消费者模型，通过队列可以便利地实现两者之间数据的共享，定义一个生产者线程，定义一个消费者线程，通过队列共享数据就可以了。 当然现实不可能都是理想的，比如消费者消费速度比生产者生产的速度要快，那么消费者消费到 一定程度上的时候，必须要暂停等待一下了（使消费者线程处于WAITING状态）。BlockingQueue的提出，就是为了解决这个问题的，他不用程序员去控制这些细节，同时还要兼顾效率和线程安全。 阻塞队列所谓的”阻塞”，指的是某些情况下线程会挂起（即阻塞），一旦条件满足，被挂起的线程又会自动唤醒。使用BlockingQueue，不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程，这些内容BlockingQueue都已经做好了 2、BlockingQueue中的方法 BlockingQueue既然是Queue的子接口，必然有Queue中的方法，上面已经列了。看一下BlockingQueue中特有的方法： （1）void put(E e) throws InterruptedException 把e添加进BlockingQueue中，如果BlockingQueue中没有空间，则调用线程被阻塞，进入等待状态，直到BlockingQueue中有空间再继续 （2）void take() throws InterruptedException 取走BlockingQueue里面排在首位的对象，如果BlockingQueue为空，则调用线程被阻塞，进入等待状态，直到BlockingQueue有新的数据被加入 （3）int drainTo(Collection&lt;? super E&gt; c, int maxElements) 一次性取走BlockingQueue中的数据到c中，可以指定取的个数。通过该方法可以提升获取数据效率，不需要多次分批加锁或释放锁 3、ArrayBlockingQueue 基于数组的阻塞队列，必须指定队列大小。比较简单。ArrayBlockingQueue中只有一个ReentrantLock对象，这意味着生产者和消费者无法并行运行（见下面的代码）。另外，创建ArrayBlockingQueue时，可以指定ReentrantLock是否为公平锁，默认采用非公平锁。 123456/** Main lock guarding all access */private final ReentrantLock lock;/** Condition for waiting takes */private final Condition notEmpty;/** Condition for waiting puts */private final Condition notFull; 4、LinkedBlockingQueue 基于链表的阻塞队列，和ArrayBlockingQueue差不多。不过LinkedBlockingQueue如果不指定队列容量大小，会默认一个类似无限大小的容量，之所以说是类似是因为这个无限大小是Integer.MAX_VALUE，这么说就好理解ArrayBlockingQueue为什么必须要制定大小了，如果ArrayBlockingQueue不指定大小的话就用Integer.MAX_VALUE，那将造成大量的空间浪费，但是基于链表实现就不一样的，一个一个节点连起来而已。另外，LinkedBlockingQueue生产者和消费者都有自己的锁（见下面的代码），这意味着生产者和消费者可以”同时”运行。 1234567891011/** Lock held by take, poll, etc */private final ReentrantLock takeLock = new ReentrantLock();/** Wait queue for waiting takes */private final Condition notEmpty = takeLock.newCondition();/** Lock held by put, offer, etc */private final ReentrantLock putLock = new ReentrantLock();/** Wait queue for waiting puts */private final Condition notFull = putLock.newCondition(); 5、SynchronousQueue 比较特殊，一种没有缓冲的等待队列。什么叫做没有缓冲区，ArrayBlocking中有： 12/** The queued items */private final E[] items; 数组用以存储队列。LinkedBlockingQueue中有： 123456789/** * Linked list node class */static class Node&lt;E&gt; &#123; /** The item, volatile to ensure barrier separating write and read */ volatile E item; Node&lt;E&gt; next; Node(E x) &#123; item = x; &#125;&#125; 将队列以链表形式连接。 生产者/消费者操作数据实际上都是通过这两个”中介”来操作数据的，但是SynchronousQueue则是生产者直接把数据给消费者（消费者直接从生产者这里拿数据），好像又回到了没有生产者/消费者模型的老办法了。换句话说，每一个插入操作必须等待一个线程对应的移除操作。SynchronousQueue又有两种模式： 1、公平模式 采用公平锁，并配合一个FIFO队列（Queue）来管理多余的生产者和消费者 2、非公平模式 采用非公平锁，并配合一个LIFO栈（Stack）来管理多余的生产者和消费者，这也是SynchronousQueue默认的模式 利用BlockingQueue实现生产者消费者模型 上一篇我们写的生产者消费者模型有局限，局限体现在： 缓冲区内只能存放一个数据，实际生产者/消费者模型中的缓冲区内可以存放大量生产者生产出来的数据 生产者和消费者处理数据的速度几乎一样 OK，我们就用BlockingQueue来简单写一个例子，并且让生产者、消费者处理数据速度不同。子类选择的是ArrayBlockingQueue，大小定为10： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public static void main(String[] args)&#123; final BlockingQueue&lt;String&gt; bq = new ArrayBlockingQueue&lt;String&gt;(10); Runnable producerRunnable = new Runnable() &#123; int i = 0; public void run() &#123; while (true) &#123; try &#123; System.out.println(\"我生产了一个\" + i++); bq.put(i + \"\"); Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;; Runnable customerRunnable = new Runnable() &#123; public void run() &#123; while (true) &#123; try &#123; System.out.println(\"我消费了一个\" + bq.take()); Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;; Thread producerThread = new Thread(producerRunnable); Thread customerThread = new Thread(customerRunnable); producerThread.start(); customerThread.start();&#125; 代码的做法是让生产者生产速度快于消费者消费速度的，看一下运行结果： 123456789101112131415161718192021222324252627 1 我生产了一个0 2 我消费了一个1 3 我生产了一个1 4 我生产了一个2 5 我消费了一个2 6 我生产了一个3 7 我生产了一个4 8 我生产了一个5 9 我消费了一个310 我生产了一个611 我生产了一个712 我生产了一个813 我消费了一个414 我生产了一个915 我生产了一个1016 我生产了一个1117 我消费了一个518 我生产了一个1219 我生产了一个1320 我生产了一个1421 我消费了一个622 我生产了一个1523 我生产了一个1624 我消费了一个725 我生产了一个1726 我消费了一个827 我生产了一个18 分两部分来看输出结果： 1、第1行~第23行。这块BlockingQueue未满，所以生产者随便生产，消费者随便消费，基本上都是生产3个消费1个，消费者消费速度慢 2、第24行~第27行，从前面我们可以看出，生产到16，消费到6，说明到了ArrayBlockingQueue的极限10了，这时候没办法，生产者生产一个ArrayBlockingQueue就满了，所以不能继续生产了，只有等到消费者消费完才可以继续生产。所以之后的打印内容一定是一个生产者、一个消费者 这就是前面一章开头说的”通过平衡生产者和消费者的处理能力来提高整体处理数据的速度“，这给例子应该体现得很明显。另外，也不要担心非单一生产者/消费者场景下的系统假死问题，缓冲区空、缓冲区满的场景BlockingQueue都是定义了不同的Condition，所以不会唤醒自己的同类。","categories":[{"name":"并发编程","slug":"并发编程","permalink":"https://caoler.cn/categories/并发编程/"},{"name":"阻塞队列","slug":"并发编程/阻塞队列","permalink":"https://caoler.cn/categories/并发编程/阻塞队列/"}],"tags":[{"name":"阻塞队列","slug":"阻塞队列","permalink":"https://caoler.cn/tags/阻塞队列/"}]},{"title":"梦想破灭","slug":"梦想破灭","date":"2018-09-26T13:48:57.000Z","updated":"2018-09-26T13:49:20.907Z","comments":true,"path":"/post/2018/over.html","link":"","permalink":"https://caoler.cn/post/2018/over.html","excerpt":"","text":"梦想破灭 2018年9月26日21:48:48","categories":[{"name":"CodingLife","slug":"CodingLife","permalink":"https://caoler.cn/categories/CodingLife/"}],"tags":[{"name":"CodingLife","slug":"CodingLife","permalink":"https://caoler.cn/tags/CodingLife/"}]},{"title":"JAVA获取当前函数名","slug":"java 获取当前函数名","date":"2018-09-20T08:38:00.000Z","updated":"2018-10-14T12:55:06.311Z","comments":true,"path":"/post/2018/getFileLineMethod.html","link":"","permalink":"https://caoler.cn/post/2018/getFileLineMethod.html","excerpt":"无具体描述","text":"无具体描述 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import java.text.SimpleDateFormat; import java.util.Date; /** * Java实现类似C/C++中的__FILE__、__FUNC__、__LINE__等,主要用于日志等功能中。 * * @version 1.0 2011-07-13 * */ public abstract class CommonFunction &#123; /** * 打印日志时获取当前的程序文件名、行号、方法名 输出格式为：[FileName | LineNumber | MethodName] * * @return */ public static String getFileLineMethod() &#123; StackTraceElement traceElement = ((new Exception()).getStackTrace())[1]; StringBuffer toStringBuffer = new StringBuffer(\"[\").append( traceElement.getFileName()).append(\" | \").append( traceElement.getLineNumber()).append(\" | \").append( traceElement.getMethodName()).append(\"]\"); return toStringBuffer.toString(); &#125; // 当前文件名 public static String _FILE_() &#123; StackTraceElement traceElement = ((new Exception()).getStackTrace())[1]; return traceElement.getFileName(); &#125; // 当前方法名 public static String _FUNC_() &#123; StackTraceElement traceElement = ((new Exception()).getStackTrace())[1]; return traceElement.getMethodName(); &#125; // 当前行号 public static int _LINE_() &#123; StackTraceElement traceElement = ((new Exception()).getStackTrace())[1]; return traceElement.getLineNumber(); &#125; // 当前时间 public static String _TIME_() &#123; Date now = new Date(); SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss.SSS\"); return sdf.format(now); &#125; &#125;","categories":[{"name":"JAVASE","slug":"JAVASE","permalink":"https://caoler.cn/categories/JAVASE/"}],"tags":[{"name":"JAVASE","slug":"JAVASE","permalink":"https://caoler.cn/tags/JAVASE/"}]},{"title":"如何“做成”个人计划","slug":"如何“做成”个人计划","date":"2018-08-21T08:38:00.000Z","updated":"2018-10-14T12:55:56.800Z","comments":true,"path":"/post/2018/how-to-plan.html","link":"","permalink":"https://caoler.cn/post/2018/how-to-plan.html","excerpt":"老大的一篇好笔记，偷走 做成个人计划能给你带来什么个人计划是一个让你走向优秀的途径。 能够给你带来能力上的提升，能够让你更加自信，能够让你拥有更多的机会。 上述文字绝非喊口号，而是根据亲身观察身边同事得出的结论。","text":"老大的一篇好笔记，偷走 做成个人计划能给你带来什么个人计划是一个让你走向优秀的途径。 能够给你带来能力上的提升，能够让你更加自信，能够让你拥有更多的机会。 上述文字绝非喊口号，而是根据亲身观察身边同事得出的结论。 为什么大家的个人计划完成度都很低真的是因为没有时间么？还是说定的个人计划，其实并不是你真正想做的？亦或者是你确实想做成某个计划，但是却苦于不知道该怎么有效的去实施？ 我们需要先找准自己的问题，才能针对性的加以改进。 什么样才算做成个人计划做成和完成，在标准和意义上，是完全不一样的。这个不只是对个人计划而言，对你工作、生活中的任何事情，都是通用的。 完成，仅仅只是完成既定的、可见的工作，比如完成某个工具的编码工作之类的。这部分工作很容易，但是这并不能帮助你真正实现目标。 做成，则是从结果角度去衡量，有没有真正解决问题。 我们公司的行为做事准则是：以终为始，以结果为导向。这也是程序员十大素养中的两条。 这里举个例子，比如你感觉目前内网开发，跨部门合作因为数据问题很麻烦，想做一个mock工具来解决这个问题。那么： 这个mock工具的编码开发，就属于完成，但是完成这个工作，并不能解决问题 完成工具的开发，并推广给所有人使用，让大家都接受这个工具和流程机制，从而让数据不再是内网开发的瓶颈，这才是做成这个事情 还有追女朋友的例子，不管过程中你送了多少礼物，发了多少信息，最终没追到，就是没有达到目标，你还是不能脱离单身汪的行列。 如何制定个人计划先思考一个问题：你想成为什么样的人？ 然后带着这个问题的答案，去制定你的个人计划。 个人感觉，一个优秀的个人计划，必须包含如下几个要素： 0、有自我提升的意愿(可以理解为上进心。如果你不想让自己变得更好，那么是不可能克服提升过程中的痛苦的) 1、一定是你自己想做的(包括发自内心想做的事情，以及你面临的必须解决的困难) 2、具有持续性，周期比较长(想短短几天就给自己带来很大的提升，不现实；半年完成一个核心计划即可，做成一个比完成多个更好) 3、一定是对你个人有用的，能够帮你解决某个问题；如果能够同时帮助公司解决问题，那就更好了 4、具备可行性(成功率；比如你的计划是一个产品相关的计划，那么要考虑能否打败竞争对手、能否抢占市场和先机) 5、你认可这个计划，觉得它是有价值的 当心里有一个想法后，你可以思考下：做成这个计划，能给我带来什么？借此来帮助自己判断该计划的价值。 当计划的方向确定后，具体制定细节内容时，可以参考SMART原则。 假如你是一个刚进入大学的新生，你想提升个人的英语水平，准备制定一个计划： 具体的(Specific)提高英语水平(模糊) VS 通过英语四级(具体) 可衡量的(Measurable)四级考试分数 可达到的(Attainable)英语四级(可达到) VS 英语八级(不可达到) 相关性(Relevant)课程相关，且过不了就没法毕业 截止期限(Time-bound)同考试日期 如何做成个人计划这个可以参考身边的同事，看看他们是怎么做的。通过成功失败的案例来分析，是最直观的。 成功案例李晓栋的健身(这个案例比较特殊，不是公司内的个人计划)焦生康的订餐系统余庆的用户反馈流程淼哥的新人培训、重构版、虚拟桌面、运维系统、CRM王海波的Docker容器化失败案例小组的API平台我的周会主题机制问答助手建议大家都去了解下上述案例(可以通过询问你的导师来了解)，然后自己思考下：上面的案例为什么成功/失败？决定成功与否的关键因素有哪些？ 组长在组员的个人计划中，应该承担哪些角色在制定计划阶段，组长起到的，是一个引导者和审核者的角色；在计划执行过程中，则起到一个激励者的作用。 这是目前我们做得很差的地方。 常见误区没有思考过个人规划，目标不明确具体的表现，就是定的个人计划很散乱。因为自己也不清楚自己将来想要成为什么样的人、当前欠缺什么，因此定计划就会很迷茫。经常是每个月都定好几个计划，然后每个月的计划都没什么关联，上个月还计划搞Node，下个月又去计划搞Java，最终什么也没做成。 好的计划，一定是具有持续性的，而不是短短一个月，做完就扔。 如果你对个人规划感到迷茫，建议你先通过身边的同事，或者你的导师，先对我们团队有一个清晰的了解，知道我们团队的现状、在团队中的发展机会(包括技术和非技术的)，然后让导师帮助你明确好自己的规划。 计划内容脱离实际工作范围能力的提升，必须要有一个环境，能够让你不断将学习到的东西进行实践，强化练习。否则你的知识都只会停留在理论层面。就像学校读书，为什么要有课后练习题？这是同样的道理。 所以计划最好能够和你的工作环境相结合。注意这里的结合，不是说将计划定成具体的工作内容，而是指你的计划能够在这个工作环境中加以运用、体现价值。 只有在战场上才会诞生将军。 举个例子：你在一个软件公司工作，然后你给自己定的计划是成为一个职业篮球运动员，那这个计划就是脱离实际工作范围的：一方面软件公司不具备让你成为职业篮球运动员的环境；另一方面即使你成为了职业篮球运动员，在这个公司也无法体现你在这方面的价值。 另外还有同事经常将个人计划定位学习XX技术，但是近期的工作内容根本不涉及这个技术，你学了之后，没有实际工作内容来给你锻炼和强化这个技术，这也是不合适的。 将目标和要做的事情弄反了做某件事情，是为了帮助我们达成某个目标；而我们很容易将两者弄反，最后只着眼于做某件事，至于能不能达成目标，反而被忽视了。 具体的体现就是，很多同事定的个人计划，都是“做XX工具”、“学习XX技术”，深入思考下，这些内容都只是做某件事，你真正想达到的目标，并不是这些表面上的事情。 通过分配任务的方式给组员制定计划计划应该通过激励来促进大家执行，而不应该通过任务的形式来督促大家执行。 舒适的执行计划个人计划的执行过程，是自我提升的过程，这肯定不是一个舒适的过程，如果你一直处于舒适区，那你肯定是没有什么提升的。我们可以通过自我激励，来度过这段非舒适的区域，最终享受成功带来的喜悦。 将自己的个人计划，弄成了别人的个人计划计划的内容不是自己想做的，只是简单的参与别人的计划，或者完成别人给的任务，没有自己去主导计划。 好的计划都是自下而上的，只有坏的计划才是自上而下。 计划都拖到月末才处理都拖到月末了，说明你肯定是不重视这个计划的。发现这种问题，要及时调整：要么想办法让自己真正理解这个计划的重要性；要么更换你的计划，改为一个你自己想做的。 好的计划是灯塔，坏的计划是束缚。 个人计划是为了帮助你，而不是为了打击你如果每个月的计划都不重视，都完成得很差，那么久而久之就会让你形成惰性；然后每次月末过总结，这些计划都会成给你的自信造成打击。我们一定要避免这种情况，让计划形成一个良性循环。","categories":[{"name":"计划","slug":"计划","permalink":"https://caoler.cn/categories/计划/"}],"tags":[{"name":"计划","slug":"计划","permalink":"https://caoler.cn/tags/计划/"}]},{"title":"Java并发之AQS详解","slug":"Java并发之AQS详解","date":"2018-08-20T08:38:00.000Z","updated":"2018-10-14T12:55:15.530Z","comments":true,"path":"/post/2018/aqs.html","link":"","permalink":"https://caoler.cn/post/2018/aqs.html","excerpt":"人老了就有个习惯，看到好文就想保存下来。就担心一不留神哪天文章被删除了，可谓：楼主写的很好 可下一秒 这篇文章就是我的了。但是本着尊重作者劳动成果的前提，在知道来源的情况下，每篇转载的文章我都会注明原作者，且仅用作个人学习，若您看到这篇文章是你写的或者不允许转载，那还请您联系一下我，我会立刻删除，还望见谅！ 多线程，并发编程一直是我能力最薄弱的地方，所以最近一直在补自己的短板，秋招也好，工作也好，对自己能力的提升还是很有帮助了，故转此下文。","text":"人老了就有个习惯，看到好文就想保存下来。就担心一不留神哪天文章被删除了，可谓：楼主写的很好 可下一秒 这篇文章就是我的了。但是本着尊重作者劳动成果的前提，在知道来源的情况下，每篇转载的文章我都会注明原作者，且仅用作个人学习，若您看到这篇文章是你写的或者不允许转载，那还请您联系一下我，我会立刻删除，还望见谅！ 多线程，并发编程一直是我能力最薄弱的地方，所以最近一直在补自己的短板，秋招也好，工作也好，对自己能力的提升还是很有帮助了，故转此下文。 本文来自cnblogs的大神水岩，原文链接：Java并发之AQS详解 [TOC] 一、概述 谈到并发，不得不谈ReentrantLock；而谈到ReentrantLock，不得不谈AbstractQueuedSynchronizer（AQS）！ 类如其名，抽象的队列式的同步器，AQS定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它，如常用的ReentrantLock/Semaphore/CountDownLatch…。 以下是本文的目录大纲： 概述 框架 源码详解 简单应用 若有不正之处，请谅解和批评指正，不胜感激。 请尊重作者劳动成果，转载请标明原文链接：http://www.cnblogs.com/waterystone/p/4920797.html 手机版可访问：https://mp.weixin.qq.com/s/eyZyzk8ZzjwzZYN4a4H5YA 二、框架 它维护了一个volatile int state（代表共享资源）和一个FIFO线程等待队列（多线程争用资源被阻塞时会进入此队列）。这里volatile是核心关键词，具体volatile的语义，在此不述。state的访问方式有三种: getState() setState() compareAndSetState() AQS定义两种资源共享方式：Exclusive（独占，只有一个线程能执行，如ReentrantLock）和Share（共享，多个线程可同时执行，如Semaphore/CountDownLatch）。 不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法： isHeldExclusively()：该线程是否正在独占资源。只有用到condition才需要去实现它。 tryAcquire(int)：独占方式。尝试获取资源，成功则返回true，失败则返回false。 tryRelease(int)：独占方式。尝试释放资源，成功则返回true，失败则返回false。 tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。 tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。 以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。 再以CountDownLatch以例，任务分为N个子线程去执行，state也初始化为N（注意N要与线程个数一致）。这N个子线程是并行执行的，每个子线程执行完后countDown()一次，state会CAS减1。等到所有子线程都执行完后(即state=0)，会unpark()主调用线程，然后主调用线程就会从await()函数返回，继续后余动作。 一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。但AQS也支持自定义同步器同时实现独占和共享两种方式，如ReentrantReadWriteLock。 三、源码详解 本节开始讲解AQS的源码实现。依照acquire-release、acquireShared-releaseShared的次序来。 3.1 acquire(int) 此方法是独占模式下线程获取共享资源的顶层入口。如果获取到资源，线程直接返回，否则进入等待队列，直到获取到资源为止，且整个过程忽略中断的影响。这也正是lock()的语义，当然不仅仅只限于lock()。获取到资源后，线程就可以去执行其临界区代码了。下面是acquire()的源码： 12345public final void acquire(int arg) &#123;if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt();&#125; 函数流程如下： tryAcquire()尝试直接去获取资源，如果成功则直接返回； addWaiter()将该线程加入等待队列的尾部，并标记为独占模式； acquireQueued()使线程在等待队列中获取资源，一直获取到资源后才返回。如果在整个等待过程中被中断过，则返回true，否则返回false。 如果线程在等待过程中被中断过，它是不响应的。只是获取资源后才再进行自我中断selfInterrupt()，将中断补上。 这时单凭这4个抽象的函数来看流程还有点朦胧，不要紧，看完接下来的分析后，你就会明白了。就像《大话西游》里唐僧说的：等你明白了舍生取义的道理，你自然会回来和我唱这首歌的。 3.1.1 tryAcquire(int) 此方法尝试去获取独占资源。如果获取成功，则直接返回true，否则直接返回false。这也正是tryLock()的语义，还是那句话，当然不仅仅只限于tryLock()。如下是tryAcquire()的源码： 123protected boolean tryAcquire(int arg) &#123; throw new UnsupportedOperationException();&#125; 什么？直接throw异常？说好的功能呢？好吧，还记得概述里讲的AQS只是一个框架，具体资源的获取/释放方式交由自定义同步器去实现吗？就是这里了！！！AQS这里只定义了一个接口，具体资源的获取交由自定义同步器去实现了（通过state的get/set/CAS）！！！至于能不能重入，能不能加塞，那就看具体的自定义同步器怎么去设计了！！！当然，自定义同步器在进行资源访问时要考虑线程安全的影响。 这里之所以没有定义成abstract，是因为独占模式下只用实现tryAcquire-tryRelease，而共享模式下只用实现tryAcquireShared-tryReleaseShared。如果都定义成abstract，那么每个模式也要去实现另一模式下的接口。说到底，Doug Lea还是站在咱们开发者的角度，尽量减少不必要的工作量。 3.1.2 addWaiter(Node) 此方法用于将当前线程加入到等待队列的队尾，并返回当前线程所在的结点。还是上源码吧： 123456789101112131415161718private Node addWaiter(Node mode) &#123; //以给定模式构造结点。mode有两种：EXCLUSIVE（独占）和SHARED（共享） Node node = new Node(Thread.currentThread(), mode); //尝试快速方式直接放到队尾。 Node pred = tail; if (pred != null) &#123; node.prev = pred; if (compareAndSetTail(pred, node)) &#123; pred.next = node; return node; &#125; &#125; //上一步失败则通过enq入队。 enq(node); return node;&#125; 不用再说了，直接看注释吧。这里我们说下Node。Node结点是对每一个访问同步代码的线程的封装，其包含了需要同步的线程本身以及线程的状态，如是否被阻塞，是否等待唤醒，是否已经被取消等。变量waitStatus则表示当前被封装成Node结点的等待状态，共有4种取值CANCELLED、SIGNAL、CONDITION、PROPAGATE。 CANCELLED：值为1，在同步队列中等待的线程等待超时或被中断，需要从同步队列中取消该Node的结点，其结点的waitStatus为CANCELLED，即结束状态，进入该状态后的结点将不会再变化。 SIGNAL：值为-1，被标识为该等待唤醒状态的后继结点，当其前继结点的线程释放了同步锁或被取消，将会通知该后继结点的线程执行。说白了，就是处于唤醒状态，只要前继结点释放锁，就会通知标识为SIGNAL状态的后继结点的线程执行。 CONDITION：值为-2，与Condition相关，该标识的结点处于等待队列中，结点的线程等待在Condition上，当其他线程调用了Condition的signal()方法后，CONDITION状态的结点将从等待队列转移到同步队列中，等待获取同步锁。 PROPAGATE：值为-3，与共享模式相关，在共享模式中，该状态标识结点的线程处于可运行状态。 0状态：值为0，代表初始化状态。 AQS在判断状态时，通过用waitStatus&gt;0表示取消状态，而waitStatus&lt;0表示有效状态。 3.1.2.1 enq(Node) 此方法用于将node加入队尾。源码如下： 12345678910111213141516private Node enq(final Node node) &#123; //CAS\"自旋\"，直到成功加入队尾 for (;;) &#123; Node t = tail; if (t == null) &#123; // 队列为空，创建一个空的标志结点作为head结点，并将tail也指向它。 if (compareAndSetHead(new Node())) tail = head; &#125; else &#123;//正常流程，放入队尾 node.prev = t; if (compareAndSetTail(t, node)) &#123; t.next = node; return t; &#125; &#125; &#125;&#125; 如果你看过AtomicInteger.getAndIncrement()函数源码，那么相信你一眼便看出这段代码的精华。CAS自旋volatile变量，是一种很经典的用法。还不太了解的，自己去百度一下吧。 3.1.3 acquireQueued(Node, int) OK，通过tryAcquire()和addWaiter()，该线程获取资源失败，已经被放入等待队列尾部了。聪明的你立刻应该能想到该线程下一部该干什么了吧：进入等待状态休息，直到其他线程彻底释放资源后唤醒自己，自己再拿到资源，然后就可以去干自己想干的事了。没错，就是这样！是不是跟医院排队拿号有点相似~~acquireQueued()就是干这件事：在等待队列中排队拿号（中间没其它事干可以休息），直到拿到号后再返回。这个函数非常关键，还是上源码吧： 1234567891011121314151617181920212223242526final boolean acquireQueued(final Node node, int arg) &#123; boolean failed = true;//标记是否成功拿到资源 try &#123; boolean interrupted = false;//标记等待过程中是否被中断过 //又是一个“自旋”！ for (;;) &#123; final Node p = node.predecessor();//拿到前驱 //如果前驱是head，即该结点已成老二，那么便有资格去尝试获取资源（可能是老大释放完资源唤醒自己的，当然也可能被interrupt了）。 if (p == head &amp;&amp; tryAcquire(arg)) &#123; setHead(node);//拿到资源后，将head指向该结点。所以head所指的标杆结点，就是当前获取到资源的那个结点或null。 p.next = null; // setHead中node.prev已置为null，此处再将head.next置为null，就是为了方便GC回收以前的head结点。也就意味着之前拿完资源的结点出队了！ failed = false; return interrupted;//返回等待过程中是否被中断过 &#125; //如果自己可以休息了，就进入waiting状态，直到被unpark() if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true;//如果等待过程中被中断过，哪怕只有那么一次，就将interrupted标记为true &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125;&#125; 到这里了，我们先不急着总结acquireQueued()的函数流程，先看看shouldParkAfterFailedAcquire()和parkAndCheckInterrupt()具体干些什么。 3.1.3.1 shouldParkAfterFailedAcquire(Node, Node) 此方法主要用于检查状态，看看自己是否真的可以去休息了（进入waiting状态，如果线程状态转换不熟，可以参考本人上一篇写的Thread详解），万一队列前边的线程都放弃了只是瞎站着，那也说不定，对吧！ 1234567891011121314151617181920private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123; int ws = pred.waitStatus;//拿到前驱的状态 if (ws == Node.SIGNAL) //如果已经告诉前驱拿完号后通知自己一下，那就可以安心休息了 return true; if (ws &gt; 0) &#123; /* * 如果前驱放弃了，那就一直往前找，直到找到最近一个正常等待的状态，并排在它的后边。 * 注意：那些放弃的结点，由于被自己“加塞”到它们前边，它们相当于形成一个无引用链，稍后就会被保安大叔赶走了(GC回收)！ */ do &#123; node.prev = pred = pred.prev; &#125; while (pred.waitStatus &gt; 0); pred.next = node; &#125; else &#123; //如果前驱正常，那就把前驱的状态设置成SIGNAL，告诉它拿完号后通知自己一下。有可能失败，人家说不定刚刚释放完呢！ compareAndSetWaitStatus(pred, ws, Node.SIGNAL); &#125; return false;&#125; 整个流程中，如果前驱结点的状态不是SIGNAL，那么自己就不能安心去休息，需要去找个安心的休息点，同时可以再尝试下看有没有机会轮到自己拿号。 3.1.3.2 parkAndCheckInterrupt() 如果线程找好安全休息点后，那就可以安心去休息了。此方法就是让线程去休息，真正进入等待状态。 1234private final boolean parkAndCheckInterrupt() &#123; LockSupport.park(this);//调用park()使线程进入waiting状态 return Thread.interrupted();//如果被唤醒，查看自己是不是被中断的。&#125; park()会让当前线程进入waiting状态。在此状态下，有两种途径可以唤醒该线程：1）被unpark()；2）被interrupt()。（再说一句，如果线程状态转换不熟，可以参考本人写的Thread详解）。需要注意的是，Thread.interrupted()会清除当前线程的中断标记位。 3.1.3.3 小结 OK，看了shouldParkAfterFailedAcquire()和parkAndCheckInterrupt()，现在让我们再回到acquireQueued()，总结下该函数的具体流程： 结点进入队尾后，检查状态，找到安全休息点； 调用park()进入waiting状态，等待unpark()或interrupt()唤醒自己； 被唤醒后，看自己是不是有资格能拿到号。如果拿到，head指向当前结点，并返回从入队到拿到号的整个过程中是否被中断过；如果没拿到，继续流程1。 3.1.4 小结 OKOK，acquireQueued()分析完之后，我们接下来再回到acquire()！再贴上它的源码吧： 12345public final void acquire(int arg) &#123; if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt();&#125; 再来总结下它的流程吧： 调用自定义同步器的tryAcquire()尝试直接去获取资源，如果成功则直接返回； 没成功，则addWaiter()将该线程加入等待队列的尾部，并标记为独占模式； acquireQueued()使线程在等待队列中休息，有机会时（轮到自己，会被unpark()）会去尝试获取资源。获取到资源后才返回。如果在整个等待过程中被中断过，则返回true，否则返回false。 如果线程在等待过程中被中断过，它是不响应的。只是获取资源后才再进行自我中断selfInterrupt()，将中断补上。 由于此函数是重中之重，我再用流程图总结一下： 至此，acquire()的流程终于算是告一段落了。这也就是ReentrantLock.lock()的流程，不信你去看其lock()源码吧，整个函数就是一条acquire(1)！！！ 3.2 release(int) 上一小节已经把acquire()说完了，这一小节就来讲讲它的反操作release()吧。此方法是独占模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果彻底释放了（即state=0）,它会唤醒等待队列里的其他线程来获取资源。这也正是unlock()的语义，当然不仅仅只限于unlock()。下面是release()的源码： 123456789public final boolean release(int arg) &#123; if (tryRelease(arg)) &#123; Node h = head;//找到头结点 if (h != null &amp;&amp; h.waitStatus != 0) unparkSuccessor(h);//唤醒等待队列里的下一个线程 return true; &#125; return false;&#125; 逻辑并不复杂。它调用tryRelease()来释放资源。有一点需要注意的是，它是根据tryRelease()的返回值来判断该线程是否已经完成释放掉资源了！所以自定义同步器在设计tryRelease()的时候要明确这一点！！ 3.2.1 tryRelease(int) 此方法尝试去释放指定量的资源。下面是tryRelease()的源码： 123protected boolean tryRelease(int arg) &#123; throw new UnsupportedOperationException();&#125; 跟tryAcquire()一样，这个方法是需要独占模式的自定义同步器去实现的。正常来说，tryRelease()都会成功的，因为这是独占模式，该线程来释放资源，那么它肯定已经拿到独占资源了，直接减掉相应量的资源即可(state-=arg)，也不需要考虑线程安全的问题。但要注意它的返回值，上面已经提到了，release()是根据tryRelease()的返回值来判断该线程是否已经完成释放掉资源了！所以自义定同步器在实现时，如果已经彻底释放资源(state=0)，要返回true，否则返回false。 3.2.2 unparkSuccessor(Node) 此方法用于唤醒等待队列中下一个线程。下面是源码： 12345678910111213141516private void unparkSuccessor(Node node) &#123; //这里，node一般为当前线程所在的结点。 int ws = node.waitStatus; if (ws &lt; 0)//置零当前线程所在的结点状态，允许失败。 compareAndSetWaitStatus(node, ws, 0); Node s = node.next;//找到下一个需要唤醒的结点s if (s == null || s.waitStatus &gt; 0) &#123;//如果为空或已取消 s = null; for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev) if (t.waitStatus &lt;= 0)//从这里可以看出，&lt;=0的结点，都是还有效的结点。 s = t; &#125; if (s != null) LockSupport.unpark(s.thread);//唤醒&#125; 这个函数并不复杂。一句话概括：用unpark()唤醒等待队列中最前边的那个未放弃线程，这里我们也用s来表示吧。此时，再和acquireQueued()联系起来，s被唤醒后，进入if (p == head &amp;&amp; tryAcquire(arg))的判断（即使p!=head也没关系，它会再进入shouldParkAfterFailedAcquire()寻找一个安全点。这里既然s已经是等待队列中最前边的那个未放弃线程了，那么通过shouldParkAfterFailedAcquire()的调整，s也必然会跑到head的next结点，下一次自旋p==head就成立啦），然后s把自己设置成head标杆结点，表示自己已经获取到资源了，acquire()也返回了！！And then, DO what you WANT! 3.2.3 小结 release()是独占模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果彻底释放了（即state=0）,它会唤醒等待队列里的其他线程来获取资源。 3.3 acquireShared(int) 此方法是共享模式下线程获取共享资源的顶层入口。它会获取指定量的资源，获取成功则直接返回，获取失败则进入等待队列，直到获取到资源为止，整个过程忽略中断。下面是acquireShared()的源码： 1234public final void acquireShared(int arg) &#123; if (tryAcquireShared(arg) &lt; 0) doAcquireShared(arg);&#125; 这里tryAcquireShared()依然需要自定义同步器去实现。但是AQS已经把其返回值的语义定义好了：负值代表获取失败；0代表获取成功，但没有剩余资源；正数表示获取成功，还有剩余资源，其他线程还可以去获取。所以这里acquireShared()的流程就是： tryAcquireShared()尝试获取资源，成功则直接返回； 失败则通过doAcquireShared()进入等待队列，直到获取到资源为止才返回。 3.3.1 doAcquireShared(int) 此方法用于将当前线程加入等待队列尾部休息，直到其他线程释放资源唤醒自己，自己成功拿到相应量的资源后才返回。下面是doAcquireShared()的源码： 1234567891011121314151617181920212223242526272829private void doAcquireShared(int arg) &#123; final Node node = addWaiter(Node.SHARED);//加入队列尾部 boolean failed = true;//是否成功标志 try &#123; boolean interrupted = false;//等待过程中是否被中断过的标志 for (;;) &#123; final Node p = node.predecessor();//前驱 if (p == head) &#123;//如果到head的下一个，因为head是拿到资源的线程，此时node被唤醒，很可能是head用完资源来唤醒自己的 int r = tryAcquireShared(arg);//尝试获取资源 if (r &gt;= 0) &#123;//成功 setHeadAndPropagate(node, r);//将head指向自己，还有剩余资源可以再唤醒之后的线程 p.next = null; // help GC if (interrupted)//如果等待过程中被打断过，此时将中断补上。 selfInterrupt(); failed = false; return; &#125; &#125; //判断状态，寻找安全点，进入waiting状态，等着被unpark()或interrupt() if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125;&#125; 有木有觉得跟acquireQueued()很相似？对，其实流程并没有太大区别。只不过这里将补中断的selfInterrupt()放到doAcquireShared()里了，而独占模式是放到acquireQueued()之外，其实都一样，不知道Doug Lea是怎么想的。 跟独占模式比，还有一点需要注意的是，这里只有线程是head.next时（“老二”），才会去尝试获取资源，有剩余的话还会唤醒之后的队友。那么问题就来了，假如老大用完后释放了5个资源，而老二需要6个，老三需要1个，老四需要2个。老大先唤醒老二，老二一看资源不够，他是把资源让给老三呢，还是不让？答案是否定的！老二会继续park()等待其他线程释放资源，也更不会去唤醒老三和老四了。独占模式，同一时刻只有一个线程去执行，这样做未尝不可；但共享模式下，多个线程是可以同时执行的，现在因为老二的资源需求量大，而把后面量小的老三和老四也都卡住了。当然，这并不是问题，只是AQS保证严格按照入队顺序唤醒罢了（保证公平，但降低了并发）。 3.3.1.1 setHeadAndPropagate(Node, int)12345678910private void setHeadAndPropagate(Node node, int propagate) &#123; Node h = head; setHead(node);//head指向自己 //如果还有剩余量，继续唤醒下一个邻居线程 if (propagate &gt; 0 || h == null || h.waitStatus &lt; 0) &#123; Node s = node.next; if (s == null || s.isShared()) doReleaseShared(); &#125;&#125; 此方法在setHead()的基础上多了一步，就是自己苏醒的同时，如果条件符合（比如还有剩余资源），还会去唤醒后继结点，毕竟是共享模式！ doReleaseShared()我们留着下一小节的releaseShared()里来讲。 3.3.2 小结 OK，至此，acquireShared()也要告一段落了。让我们再梳理一下它的流程： tryAcquireShared()尝试获取资源，成功则直接返回； 失败则通过doAcquireShared()进入等待队列park()，直到被unpark()/interrupt()并成功获取到资源才返回。整个等待过程也是忽略中断的。 其实跟acquire()的流程大同小异，只不过多了个自己拿到资源后，还会去唤醒后继队友的操作（这才是共享嘛）。 3.4 releaseShared() 上一小节已经把acquireShared()说完了，这一小节就来讲讲它的反操作releaseShared()吧。此方法是共享模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果成功释放且允许唤醒等待线程，它会唤醒等待队列里的其他线程来获取资源。下面是releaseShared()的源码： 1234567public final boolean releaseShared(int arg) &#123; if (tryReleaseShared(arg)) &#123;//尝试释放资源 doReleaseShared();//唤醒后继结点 return true; &#125; return false;&#125; 此方法的流程也比较简单，一句话：释放掉资源后，唤醒后继。跟独占模式下的release()相似，但有一点稍微需要注意：独占模式下的tryRelease()在完全释放掉资源（state=0）后，才会返回true去唤醒其他线程，这主要是基于独占下可重入的考量；而共享模式下的releaseShared()则没有这种要求，共享模式实质就是控制一定量的线程并发执行，那么拥有资源的线程在释放掉部分资源时就可以唤醒后继等待结点。例如，资源总量是13，A（5）和B（7）分别获取到资源并发运行，C（4）来时只剩1个资源就需要等待。A在运行过程中释放掉2个资源量，然后tryReleaseShared(2)返回true唤醒C，C一看只有3个仍不够继续等待；随后B又释放2个，tryReleaseShared(2)返回true唤醒C，C一看有5个够自己用了，然后C就可以跟A和B一起运行。而ReentrantReadWriteLock读锁的tryReleaseShared()只有在完全释放掉资源（state=0）才返回true，所以自定义同步器可以根据需要决定tryReleaseShared()的返回值。 3.4.1 doReleaseShared() 此方法主要用于唤醒后继。下面是它的源码： 123456789101112131415161718private void doReleaseShared() &#123; for (;;) &#123; Node h = head; if (h != null &amp;&amp; h != tail) &#123; int ws = h.waitStatus; if (ws == Node.SIGNAL) &#123; if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0)) continue; unparkSuccessor(h);//唤醒后继 &#125; else if (ws == 0 &amp;&amp; !compareAndSetWaitStatus(h, 0, Node.PROPAGATE)) continue; &#125; if (h == head)// head发生变化 break; &#125;&#125; 3.5 小结 本节我们详解了独占和共享两种模式下获取-释放资源(acquire-release、acquireShared-releaseShared)的源码，相信大家都有一定认识了。值得注意的是，acquire()和acquireSahred()两种方法下，线程在等待队列中都是忽略中断的。AQS也支持响应中断的，acquireInterruptibly()/acquireSharedInterruptibly()即是，这里相应的源码跟acquire()和acquireSahred()差不多，这里就不再详解了。 四、简单应用 通过前边几个章节的学习，相信大家已经基本理解AQS的原理了。这里再将“框架”一节中的一段话复制过来： 不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法： isHeldExclusively()：该线程是否正在独占资源。只有用到condition才需要去实现它。 tryAcquire(int)：独占方式。尝试获取资源，成功则返回true，失败则返回false。 tryRelease(int)：独占方式。尝试释放资源，成功则返回true，失败则返回false。 tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。 tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。 OK，下面我们就以AQS源码里的Mutex为例，讲一下AQS的简单应用。 4.1 Mutex（互斥锁） Mutex是一个不可重入的互斥锁实现。锁资源（AQS里的state）只有两种状态：0表示未锁定，1表示锁定。下边是Mutex的核心源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Mutex implements Lock, java.io.Serializable &#123; // 自定义同步器 private static class Sync extends AbstractQueuedSynchronizer &#123; // 判断是否锁定状态 protected boolean isHeldExclusively() &#123; return getState() == 1; &#125; // 尝试获取资源，立即返回。成功则返回true，否则false。 public boolean tryAcquire(int acquires) &#123; assert acquires == 1; // 这里限定只能为1个量 if (compareAndSetState(0, 1)) &#123;//state为0才设置为1，不可重入！ setExclusiveOwnerThread(Thread.currentThread());//设置为当前线程独占资源 return true; &#125; return false; &#125; // 尝试释放资源，立即返回。成功则为true，否则false。 protected boolean tryRelease(int releases) &#123; assert releases == 1; // 限定为1个量 if (getState() == 0)//既然来释放，那肯定就是已占有状态了。只是为了保险，多层判断！ throw new IllegalMonitorStateException(); setExclusiveOwnerThread(null); setState(0);//释放资源，放弃占有状态 return true; &#125; &#125; // 真正同步类的实现都依赖继承于AQS的自定义同步器！ private final Sync sync = new Sync(); //lock&lt;--&gt;acquire。两者语义一样：获取资源，即便等待，直到成功才返回。 public void lock() &#123; sync.acquire(1); &#125; //tryLock&lt;--&gt;tryAcquire。两者语义一样：尝试获取资源，要求立即返回。成功则为true，失败则为false。 public boolean tryLock() &#123; return sync.tryAcquire(1); &#125; //unlock&lt;--&gt;release。两者语文一样：释放资源。 public void unlock() &#123; sync.release(1); &#125; //锁是否占有状态 public boolean isLocked() &#123; return sync.isHeldExclusively(); &#125;&#125; 同步类在实现时一般都将自定义同步器（sync）定义为内部类，供自己使用；而同步类自己（Mutex）则实现某个接口，对外服务。当然，接口的实现要直接依赖sync，它们在语义上也存在某种对应关系！！而sync只用实现资源state的获取-释放方式tryAcquire-tryRelelase，至于线程的排队、等待、唤醒等，上层的AQS都已经实现好了，我们不用关心。 除了Mutex，ReentrantLock/CountDownLatch/Semphore这些同步类的实现方式都差不多，不同的地方就在获取-释放资源的方式tryAcquire-tryRelelase。掌握了这点，AQS的核心便被攻破了！ OK，至此，整个AQS的讲解也要落下帷幕了。希望本文能够对学习Java并发编程的同学有所借鉴，中间写的有不对的地方，也欢迎讨论和指正~ 作者：水岩 出处：http://www.cnblogs.com/waterystone/","categories":[{"name":"并发编程","slug":"并发编程","permalink":"https://caoler.cn/categories/并发编程/"},{"name":"锁","slug":"并发编程/锁","permalink":"https://caoler.cn/categories/并发编程/锁/"}],"tags":[{"name":"AQS","slug":"AQS","permalink":"https://caoler.cn/tags/AQS/"}]},{"title":"logrotate解决Tomcat catalina.out日志过大的问题","slug":"logrotate解决Tomcat catalina.out日志过大的问题","date":"2018-08-18T08:38:00.000Z","updated":"2018-10-14T12:55:23.579Z","comments":true,"path":"/post/2018/logrotate.html","link":"","permalink":"https://caoler.cn/post/2018/logrotate.html","excerpt":"由于tomcat不能按照日志的大小、保存日期进行自动切割，导致日志文件过大，查找分析日志的效率变低。所以利用linux的一个工具进行管理。","text":"由于tomcat不能按照日志的大小、保存日期进行自动切割，导致日志文件过大，查找分析日志的效率变低。所以利用linux的一个工具进行管理。 一、介绍日志切割logrotate 对于Linux系统安全来说，日志文件是极其重要的工具。不知为何，我发现很多运维同学的服务器上都运行着一些诸如每天切分Nginx日志之类的CRON脚本，大家似乎遗忘了Logrotate，争相发明自己的轮子，这真是让人沮丧啊！就好比明明身边躺着现成的性感美女，大家却忙着自娱自乐，罪过！ logrotate程序是一个日志文件管理工具。用于分割日志文件，删除旧的日志文件，并创建新的日志文件，起到”转储”作用。可以节省磁盘空间。例如，你可以设置logrotate，让/var/log/logfile日志文件每30天轮循，并删除超过6个月的日志。配置完后，logrotate的运作完全自动化，不必进行任何进一步的人为干预。 二、安装配置这里安装和配置过程省略。 三、配置tomcat首先创建tomcat.conf(需要在logrotate的安装目录对应位置) include tomcat.out 到 catalina.out tomcat.conf的配置如下： 123456789vim /etc/logrotate.d/config/tomcat/catalina.out &#123; daily rotate 15 missingok notifempty dateext compress create 644 root root&#125; 配置解释： 配置参数 说明 monthly 日志文件将按月轮循。其它可用值为’daily’，’weekly’或者’yearly’。 rotate 5 一次将存储5个归档日志。对于第六个归档，时间最久的归档将被删除。 compress 在轮循任务完成后，已轮循的归档将使用gzip进行压缩。 delaycompress 总是与compress选项一起用，delaycompress选项指示logrotate不要将最近的归档压缩，压缩将在下一次轮循周期进行。这在你或任何软件仍然需要读取最新归档时很有用。 missingok 在日志轮循期间，任何错误将被忽略，例如“文件无法找到”之类的错误。 notifempty 如果日志文件为空，轮循不会进行。 dateext 切换后的日志文件会附加上一个短横线和YYYYMMDD格式的日期，没有这个配置项会附加一个小数点加一个数字序号 sharedscripts 在所有其它指令完成后，postrotate和endscript里面指定的命令将被执行。在这种情况下，rsyslogd 进程将立即再次读取其配置并继续运行。 create 644 root root 以指定的权限创建全新的日志文件，同时logrotate也会重命名原始日志文件。 postrotate/endscript 在所有其它指令完成后，postrotate和endscript里面指定的命令将被执行。在这种情况下，rsyslogd 进程将立即再次读取其配置并继续运行。 这里只列举了一部分。可按需进行配置。 四、参考 https://www.imooc.com/article/37104?block_id=tuijian_wz http://blog.51cto.com/5iqiong/790908","categories":[{"name":"实用教程","slug":"实用教程","permalink":"https://caoler.cn/categories/实用教程/"},{"name":"日志分割","slug":"实用教程/日志分割","permalink":"https://caoler.cn/categories/实用教程/日志分割/"}],"tags":[{"name":"logrotate","slug":"logrotate","permalink":"https://caoler.cn/tags/logrotate/"}]},{"title":"全面理解Java内存模型","slug":"内存模型","date":"2018-08-13T08:38:00.000Z","updated":"2018-10-14T12:55:51.630Z","comments":true,"path":"/post/2018/jmm.html","link":"","permalink":"https://caoler.cn/post/2018/jmm.html","excerpt":"转载自CSDN-全面理解Java内存模型(JMM)及volatile关键字 理解Java内存区域与Java内存模型Java内存区域 Java虚拟机在运行程序时会把其自动管理的内存划分为以上几个区域，每个区域都有的用途以及创建销毁的时机，其中蓝色部分代表的是所有线程共享的数据区域，而绿色部分代表的是每个线程的私有数据区域。","text":"转载自CSDN-全面理解Java内存模型(JMM)及volatile关键字 理解Java内存区域与Java内存模型Java内存区域 Java虚拟机在运行程序时会把其自动管理的内存划分为以上几个区域，每个区域都有的用途以及创建销毁的时机，其中蓝色部分代表的是所有线程共享的数据区域，而绿色部分代表的是每个线程的私有数据区域。 方法区（Method Area）： 方法区属于线程共享的内存区域，又称Non-Heap（非堆），主要用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据，根据Java 虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError 异常。值得注意的是在方法区中存在一个叫运行时常量池(Runtime Constant Pool）的区域，它主要用于存放编译器生成的各种字面量和符号引用，这些内容将在类加载后存放到运行时常量池中，以便后续使用。 JVM堆（Java Heap）： Java 堆也是属于线程共享的内存区域，它在虚拟机启动时创建，是Java 虚拟机所管理的内存中最大的一块，主要用于存放对象实例，几乎所有的对象实例都在这里分配内存，注意Java 堆是垃圾收集器管理的主要区域，因此很多时候也被称做GC 堆，如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError 异常。 程序计数器(Program Counter Register)： 属于线程私有的数据区域，是一小块内存空间，主要代表当前线程所执行的字节码行号指示器。字节码解释器工作时，通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。 虚拟机栈(Java Virtual Machine Stacks)： 属于线程私有的数据区域，与线程同时创建，总数与线程关联，代表Java方法执行的内存模型。每个方法执行时都会创建一个栈桢来存储方法的的变量表、操作数栈、动态链接方法、返回值、返回地址等信息。每个方法从调用直结束就对于一个栈桢在虚拟机栈中的入栈和出栈过程，如下（图有误，应该为栈桢）： 本地方法栈(Native Method Stacks)： 本地方法栈属于线程私有的数据区域，这部分主要与虚拟机用到的 Native 方法相关，一般情况下，我们无需关心此区域。 这里之所以简要说明这部分内容，注意是为了区别Java内存模型与Java内存区域的划分，毕竟这两种划分是属于不同层次的概念。 Java内存模型概述Java内存模型(即Java Memory Model，简称JMM)本身是一种抽象的概念，并不真实存在，它描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式。由于JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存(有些地方称为栈空间)，用于存储线程私有的数据，而Java内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问，但线程对变量的操作(读取赋值等)必须在工作内存中进行，首先要将变量从主内存拷贝的自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量，工作内存中存储着主内存中的变量副本拷贝，前面说过，工作内存是每个线程的私有数据区域，因此不同的线程间无法访问对方的工作内存，线程间的通信(传值)必须通过主内存来完成，其简要访问过程如下图 需要注意的是，JMM与Java内存区域的划分是不同的概念层次，更恰当说JMM描述的是一组规则，通过这组规则控制程序中各个变量在共享数据区域和私有数据区域的访问方式，JMM是围绕原子性，有序性、可见性展开的(稍后会分析)。JMM与Java内存区域唯一相似点，都存在共享数据区域和私有数据区域，在JMM中主内存属于共享数据区域，从某个程度上讲应该包括了堆和方法区，而工作内存数据线程私有数据区域，从某个程度上讲则应该包括程序计数器、虚拟机栈以及本地方法栈。或许在某些地方，我们可能会看见主内存被描述为堆内存，工作内存被称为线程栈，实际上他们表达的都是同一个含义。关于JMM中的主内存和工作内存说明如下 主内存 主要存储的是Java实例对象，所有线程创建的实例对象都存放在主内存中，不管该实例对象是成员变量还是方法中的本地变量(也称局部变量)，当然也包括了共享的类信息、常量、静态变量。由于是共享数据区域，多条线程对同一个变量进行访问可能会发现线程安全问题。 工作内存 主要存储当前方法的所有本地变量信息(工作内存中存储着主内存中的变量副本拷贝)，每个线程只能访问自己的工作内存，即线程中的本地变量对其它线程是不可见的，就算是两个线程执行的是同一段代码，它们也会各自在自己的工作内存中创建属于当前线程的本地变量，当然也包括了字节码行号指示器、相关Native方法的信息。注意由于工作内存是每个线程的私有数据，线程间无法相互访问工作内存，因此存储在工作内存的数据不存在线程安全问题。 弄清楚主内存和工作内存后，接了解一下主内存与工作内存的数据存储类型以及操作方式，根据虚拟机规范，对于一个实例对象中的成员方法而言，如果方法中包含本地变量是基本数据类型（boolean,byte,short,char,int,long,float,double），将直接存储在工作内存的帧栈结构中，但倘若本地变量是引用类型，那么该变量的引用会存储在功能内存的帧栈中，而对象实例将存储在主内存(共享数据区域，堆)中。但对于实例对象的成员变量，不管它是基本数据类型或者包装类型(Integer、Double等)还是引用类型，都会被存储到堆区。至于static变量以及类本身相关信息将会存储在主内存中。需要注意的是，在主内存中的实例对象可以被多线程共享，倘若两个线程同时调用了同一个对象的同一个方法，那么两条线程会将要操作的数据拷贝一份到自己的工作内存中，执行完成操作后才刷新到主内存，简单示意图如下所示： 硬件内存架构与Java内存模型硬件内存架构 正如上图所示，经过简化CPU与内存操作的简易图，实际上没有这么简单，这里为了理解方便，我们省去了南北桥并将三级缓存统一为CPU缓存(有些CPU只有二级缓存，有些CPU有三级缓存)。就目前计算机而言，一般拥有多个CPU并且每个CPU可能存在多个核心，多核是指在一枚处理器(CPU)中集成两个或多个完整的计算引擎(内核),这样就可以支持多任务并行执行，从多线程的调度来说，每个线程都会映射到各个CPU核心中并行运行。在CPU内部有一组CPU寄存器，寄存器是cpu直接访问和处理的数据，是一个临时放数据的空间。一般CPU都会从内存取数据到寄存器，然后进行处理，但由于内存的处理速度远远低于CPU，导致CPU在处理指令时往往花费很多时间在等待内存做准备工作，于是在寄存器和主内存间添加了CPU缓存，CPU缓存比较小，但访问速度比主内存快得多，如果CPU总是操作主内存中的同一址地的数据，很容易影响CPU执行速度，此时CPU缓存就可以把从内存提取的数据暂时保存起来，如果寄存器要取内存中同一位置的数据，直接从缓存中提取，无需直接从主内存取。需要注意的是，寄存器并不每次数据都可以从缓存中取得数据，万一不是同一个内存地址中的数据，那寄存器还必须直接绕过缓存从内存中取数据。所以并不每次都得到缓存中取数据，这种现象有个专业的名称叫做缓存的命中率，从缓存中取就命中，不从缓存中取从内存中取，就没命中，可见缓存命中率的高低也会影响CPU执行性能，这就是CPU、缓存以及主内存间的简要交互过程，总而言之当一个CPU需要访问主存时，会先读取一部分主存数据到CPU缓存(当然如果CPU缓存中存在需要的数据就会直接从缓存获取)，进而在读取CPU缓存到寄存器，当CPU需要写数据到主存时，同样会先刷新寄存器中的数据到CPU缓存，然后再把数据刷新到主内存中。 Java线程与硬件处理器了解完硬件的内存架构后，接着了解JVM中线程的实现原理，理解线程的实现原理，有助于我们了解Java内存模型与硬件内存架构的关系，在Window系统和Linux系统上，Java线程的实现是基于一对一的线程模型，所谓的一对一模型，实际上就是通过语言级别层面程序去间接调用系统内核的线程模型，即我们在使用Java线程时，Java虚拟机内部是转而调用当前操作系统的内核线程来完成当前任务。这里需要了解一个术语，内核线程(Kernel-Level Thread，KLT)，它是由操作系统内核(Kernel)支持的线程，这种线程是由操作系统内核来完成线程切换，内核通过操作调度器进而对线程执行调度，并将线程的任务映射到各个处理器上。每个内核线程可以视为内核的一个分身,这也就是操作系统可以同时处理多任务的原因。由于我们编写的多线程程序属于语言层面的，程序一般不会直接去调用内核线程，取而代之的是一种轻量级的进程(Light Weight Process)，也是通常意义上的线程，由于每个轻量级进程都会映射到一个内核线程，因此我们可以通过轻量级进程调用内核线程，进而由操作系统内核将任务映射到各个处理器，这种轻量级进程与内核线程间1对1的关系就称为一对一的线程模型。如下图 如图所示，每个线程最终都会映射到CPU中进行处理，如果CPU存在多核，那么一个CPU将可以并行执行多个线程任务。 Java内存模型与硬件内存架构的关系通过对前面的硬件内存架构、Java内存模型以及Java多线程的实现原理的了解，我们应该已经意识到，多线程的执行最终都会映射到硬件处理器上进行执行，但Java内存模型和硬件内存架构并不完全一致。对于硬件内存来说只有寄存器、缓存内存、主内存的概念，并没有工作内存(线程私有数据区域)和主内存(堆内存)之分，也就是说Java内存模型对内存的划分对硬件内存并没有任何影响，因为JMM只是一种抽象的概念，是一组规则，并不实际存在，不管是工作内存的数据还是主内存的数据，对于计算机硬件来说都会存储在计算机主内存中，当然也有可能存储到CPU缓存或者寄存器中，因此总体上来说，Java内存模型和计算机硬件内存架构是一个相互交叉的关系，是一种抽象概念划分与真实物理硬件的交叉。(注意对于Java内存区域划分也是同样的道理) JMM存在的必要性在明白了Java内存区域划分、硬件内存架构、Java多线程的实现原理与Java内存模型的具体关系后，接着来谈谈Java内存模型存在的必要性。由于JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存(有些地方称为栈空间)，用于存储线程私有的数据，线程与主内存中的变量操作必须通过工作内存间接完成，主要过程是将变量从主内存拷贝的每个线程各自的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，如果存在两个线程同时对一个主内存中的实例对象的变量进行操作就有可能诱发线程安全问题。如下图，主内存中存在一个共享变量x，现在有A和B两条线程分别对该变量x=1进行操作，A/B线程各自的工作内存中存在共享变量副本x。假设现在A线程想要修改x的值为2，而B线程却想要读取x的值，那么B线程读取到的值是A线程更新后的值2还是更新前的值1呢？答案是，不确定，即B线程有可能读取到A线程更新前的值1，也有可能读取到A线程更新后的值2，这是因为工作内存是每个线程私有的数据区域，而线程A变量x时，首先是将变量从主内存拷贝到A线程的工作内存中，然后对变量进行操作，操作完成后再将变量x写回主内，而对于B线程的也是类似的，这样就有可能造成主内存与工作内存间数据存在一致性问题，假如A线程修改完后正在将数据写回主内存，而B线程此时正在读取主内存，即将x=1拷贝到自己的工作内存中，这样B线程读取到的值就是x=1，但如果A线程已将x=2写回主内存后，B线程才开始读取的话，那么此时B线程读取到的就是x=2，但到底是哪种情况先发生呢？这是不确定的，这也就是所谓的线程安全问题。 为了解决类似上述的问题，JVM定义了一组规则，通过这组规则来决定一个线程对共享变量的写入何时对另一个线程可见，这组规则也称为Java内存模型（即JMM），JMM是围绕着程序执行的原子性、有序性、可见性展开的，下面我们看看这三个特性。 Java内存模型的承诺这里我们先来了解几个概念，即原子性？可见性？有序性？最后再阐明JMM是如何保证这3个特性。 原子性原子性指的是一个操作是不可中断的，即使是在多线程环境下，一个操作一旦开始就不会被其他线程影响。比如对于一个静态变量int x，两条线程同时对他赋值，线程A赋值为1，而线程B赋值为2，不管线程如何运行，最终x的值要么是1，要么是2，线程A和线程B间的操作是没有干扰的，这就是原子性操作，不可被中断的特点。有点要注意的是，对于32位系统的来说，long类型数据和double类型数据(对于基本数据类型，byte,short,int,float,boolean,char读写是原子操作)，它们的读写并非原子性的，也就是说如果存在两条线程同时对long类型或者double类型的数据进行读写是存在相互干扰的，因为对于32位虚拟机来说，每次原子读写是32位的，而long和double则是64位的存储单元，这样会导致一个线程在写时，操作完前32位的原子操作后，轮到B线程读取时，恰好只读取到了后32位的数据，这样可能会读取到一个既非原值又不是线程修改值的变量，它可能是“半个变量”的数值，即64位数据被两个线程分成了两次读取。但也不必太担心，因为读取到“半个变量”的情况比较少见，至少在目前的商用的虚拟机中，几乎都把64位的数据的读写操作作为原子操作来执行，因此对于这个问题不必太在意，知道这么回事即可。 理解指令重排计算机在执行程序时，为了提高性能，编译器和处理器的常常会对指令做重排，一般分以下3种 编译器优化的重排 编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。 指令并行的重排 现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性(即后一个执行的语句无需依赖前面执行的语句的结果)，处理器可以改变语句对应的机器指令的执行顺序 内存系统的重排 由于处理器使用缓存和读写缓存冲区，这使得加载(load)和存储(store)操作看上去可能是在乱序执行，因为三级缓存的存在，导致内存与缓存的数据同步存在时间差。 其中编译器优化的重排属于编译期重排，指令并行的重排和内存系统的重排属于处理器重排，在多线程环境中，这些重排优化可能会导致程序出现内存可见性问题，下面分别阐明这两种重排优化可能带来的问题 编译器重排下面我们简单看一个编译器重排的例子： 123线程 1 线程 21： x2 = a ; 3: x1 = b ;2: b = 1; 4: a = 2 ; 两个线程同时执行，分别有1、2、3、4四段执行代码，其中1、2属于线程1 ， 3、4属于线程2 ，从程序的执行顺序上看，似乎不太可能出现x1 = 1 和x2 = 2 的情况，但实际上这种情况是有可能发现的，因为如果编译器对这段程序代码执行重排优化后，可能出现下列情况 123线程 1 线程 22: b = 1; 4: a = 2 ; 1：x2 = a ; 3: x1 = b ; 这种执行顺序下就有可能出现x1 = 1 和x2 = 2 的情况，这也就说明在多线程环境下，由于编译器优化重排的存在，两个线程中使用的变量能否保证一致性是无法确定的。 处理器指令重排先了解一下指令重排的概念，处理器指令重排是对CPU的性能优化，从指令的执行角度来说一条指令可以分为多个步骤完成，如下 取指 IF 译码和取寄存器操作数 ID 执行或者有效地址计算 EX 存储器访问 MEM 写回 WB CPU在工作时，需要将上述指令分为多个步骤依次执行(注意硬件不同有可能不一样),由于每一个步会使用到不同的硬件操作，比如取指时会只有PC寄存器和存储器，译码时会执行到指令寄存器组，执行时会执行ALU(算术逻辑单元)、写回时使用到寄存器组。为了提高硬件利用率，CPU指令是按流水线技术来执行的，如下： 从图中可以看出当指令1还未执行完成时，第2条指令便利用空闲的硬件开始执行，这样做是有好处的，如果每个步骤花费1ms，那么如果第2条指令需要等待第1条指令执行完成后再执行的话，则需要等待5ms，但如果使用流水线技术的话，指令2只需等待1ms就可以开始执行了，这样就能大大提升CPU的执行性能。虽然流水线技术可以大大提升CPU的性能，但不幸的是一旦出现流水中断，所有硬件设备将会进入一轮停顿期，当再次弥补中断点可能需要几个周期，这样性能损失也会很大，就好比工厂组装手机的流水线，一旦某个零件组装中断，那么该零件往后的工人都有可能进入一轮或者几轮等待组装零件的过程。因此我们需要尽量阻止指令中断的情况，指令重排就是其中一种优化中断的手段，我们通过一个例子来阐明指令重排是如何阻止流水线技术中断的 12a = b + c ;d = e + f ; 下面通过汇编指令展示了上述代码在CPU执行的处理过程 LW指令 表示 load，其中LW R1,b表示把b的值加载到寄存器R1中 LW R2,c 表示把c的值加载到寄存器R2中 ADD 指令表示加法，把R1 、R2的值相加，并存入R3寄存器中。 SW 表示 store 即将 R3寄存器的值保持到变量a中 LW R4,e 表示把e的值加载到寄存器R4中 LW R5,f 表示把f的值加载到寄存器R5中 SUB 指令表示减法，把R4 、R5的值相减，并存入R6寄存器中。 SW d,R6 表示将R6寄存器的值保持到变量d中 上述便是汇编指令的执行过程，在某些指令上存在X的标志，X代表中断的含义，也就是只要有X的地方就会导致指令流水线技术停顿，同时也会影响后续指令的执行，可能需要经过1个或几个指令周期才可能恢复正常，那为什么停顿呢？这是因为部分数据还没准备好，如执行ADD指令时，需要使用到前面指令的数据R1，R2，而此时R2的MEM操作没有完成，即未拷贝到存储器中，这样加法计算就无法进行，必须等到MEM操作完成后才能执行，也就因此而停顿了，其他指令也是类似的情况。前面阐述过，停顿会造成CPU性能下降，因此我们应该想办法消除这些停顿，这时就需要使用到指令重排了，如下图，既然ADD指令需要等待，那我们就利用等待的时间做些别的事情，如把LW R4,e 和 LW R5,f 移动到前面执行，毕竟LW R4,e 和 LW R5,f执行并没有数据依赖关系，对他们有数据依赖关系的SUB R6,R5,R4指令在R4,R5加载完成后才执行的，没有影响，过程如下： 正如上图所示，所有的停顿都完美消除了，指令流水线也无需中断了，这样CPU的性能也能带来很好的提升，这就是处理器指令重排的作用。关于编译器重排以及指令重排(这两种重排我们后面统一称为指令重排)相关内容已阐述清晰了，我们必须意识到对于单线程而已指令重排几乎不会带来任何影响，比竟重排的前提是保证串行语义执行的一致性，但对于多线程环境而已，指令重排就可能导致严重的程序轮序执行问题，如下 1234567891011121314class MixedOrder&#123; int a = 0; boolean flag = false; public void writer()&#123; a = 1; flag = true; &#125; public void read()&#123; if(flag)&#123; int i = a + 1； &#125; &#125;&#125; 如上述代码，同时存在线程A和线程B对该实例对象进行操作，其中A线程调用写入方法，而B线程调用读取方法，由于指令重排等原因，可能导致程序执行顺序变为如下： 12345线程A 线程Bwriter： read：1:flag = true; 1:flag = true;2:a = 1; 2: a = 0 ; //误读 3: i = 1 ; 由于指令重排的原因，线程A的flag置为true被提前执行了，而a赋值为1的程序还未执行完，此时线程B，恰好读取flag的值为true，直接获取a的值（此时B线程并不知道a为0）并执行i赋值操作，结果i的值为1，而不是预期的2，这就是多线程环境下，指令重排导致的程序乱序执行的结果。因此，请记住，指令重排只会保证单线程中串行语义的执行的一致性，但并不会关心多线程间的语义一致性。 可见性理解了指令重排现象后，可见性容易了，可见性指的是当一个线程修改了某个共享变量的值，其他线程是否能够马上得知这个修改的值。对于串行程序来说，可见性是不存在的，因为我们在任何一个操作中修改了某个变量的值，后续的操作中都能读取这个变量值，并且是修改过的新值。但在多线程环境中可就不一定了，前面我们分析过，由于线程对共享变量的操作都是线程拷贝到各自的工作内存进行操作后才写回到主内存中的，这就可能存在一个线程A修改了共享变量x的值，还未写回主内存时，另外一个线程B又对主内存中同一个共享变量x进行操作，但此时A线程工作内存中共享变量x对线程B来说并不可见，这种工作内存与主内存同步延迟现象就造成了可见性问题，另外指令重排以及编译器优化也可能导致可见性问题，通过前面的分析，我们知道无论是编译器优化还是处理器优化的重排现象，在多线程环境下，确实会导致程序轮序执行的问题，从而也就导致可见性问题。 有序性有序性是指对于单线程的执行代码，我们总是认为代码的执行是按顺序依次执行的，这样的理解并没有毛病，毕竟对于单线程而言确实如此，但对于多线程环境，则可能出现乱序现象，因为程序编译成机器码指令后可能会出现指令重排现象，重排后的指令与原指令的顺序未必一致，要明白的是，在Java程序中，倘若在本线程内，所有操作都视为有序行为，如果是多线程环境下，一个线程中观察另外一个线程，所有操作都是无序的，前半句指的是单线程内保证串行语义执行的一致性，后半句则指指令重排现象和工作内存与主内存同步延迟现象。 JMM提供的解决方案在理解了原子性，可见性以及有序性问题后，看看JMM是如何保证的，在Java内存模型中都提供一套解决方案供Java工程师在开发过程使用，如原子性问题，除了JVM自身提供的对基本数据类型读写操作的原子性外，对于方法级别或者代码块级别的原子性操作，可以使用synchronized关键字或者重入锁(ReentrantLock)保证程序执行的原子性，关于synchronized的详解，看博主另外一篇文章( 深入理解Java并发之synchronized实现原理)。而工作内存与主内存同步延迟现象导致的可见性问题，可以使用synchronized关键字或者volatile关键字解决，它们都可以使一个线程修改后的变量立即对其他线程可见。对于指令重排导致的可见性问题和有序性问题，则可以利用volatile关键字解决，因为volatile的另外一个作用就是禁止重排序优化，关于volatile稍后会进一步分析。除了靠sychronized和volatile关键字来保证原子性、可见性以及有序性外，JMM内部还定义一套happens-before 原则来保证多线程环境下两个操作间的原子性、可见性以及有序性。 理解JMM中的happens-before 原则倘若在程序开发中，仅靠sychronized和volatile关键字来保证原子性、可见性以及有序性，那么编写并发程序可能会显得十分麻烦，幸运的是，在Java内存模型中，还提供了happens-before 原则来辅助保证程序执行的原子性、可见性以及有序性的问题，它是判断数据是否存在竞争、线程是否安全的依据，happens-before 原则内容如下 程序顺序原则，即在一个线程内必须保证语义串行性，也就是说按照代码顺序执行。 锁规则 解锁(unlock)操作必然发生在后续的同一个锁的加锁(lock)之前，也就是说，如果对于一个锁解锁后，再加锁，那么加锁的动作必须在解锁动作之后(同一个锁)。 volatile规则 volatile变量的写，先发生于读，这保证了volatile变量的可见性，简单的理解就是，volatile变量在每次被线程访问时，都强迫从主内存中读该变量的值，而当该变量发生变化时，又会强迫将最新的值刷新到主内存，任何时刻，不同的线程总是能够看到该变量的最新值。 线程启动规则 线程的start()方法先于它的每一个动作，即如果线程A在执行线程B的start方法之前修改了共享变量的值，那么当线程B执行start方法时，线程A对共享变量的修改对线程B可见 传递性 A先于B ，B先于C 那么A必然先于C 线程终止规则 线程的所有操作先于线程的终结，Thread.join()方法的作用是等待当前执行的线程终止。假设在线程B终止之前，修改了共享变量，线程A从线程B的join方法成功返回后，线程B对共享变量的修改将对线程A可见。 线程中断规则 对线程 interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测线程是否中断。 对象终结规则 对象的构造函数执行，结束先于finalize()方法 上述8条原则无需手动添加任何同步手段(synchronized|volatile)即可达到效果，下面我们结合前面的案例演示这8条原则如何判断线程是否安全，如下： 1234567891011121314class MixedOrder&#123; int a = 0; boolean flag = false; public void writer()&#123; a = 1; flag = true; &#125; public void read()&#123; if(flag)&#123; int i = a + 1； &#125; &#125;&#125; 同样的道理，存在两条线程A和B，线程A调用实例对象的writer()方法，而线程B调用实例对象的read()方法，线程A先启动而线程B后启动，那么线程B读取到的i值是多少呢？现在依据8条原则，由于存在两条线程同时调用，因此程序次序原则不合适。writer()方法和read()方法都没有使用同步手段，锁规则也不合适。没有使用volatile关键字，volatile变量原则不适应。线程启动规则、线程终止规则、线程中断规则、对象终结规则、传递性和本次测试案例也不合适。线程A和线程B的启动时间虽然有先后，但线程B执行结果却是不确定，也是说上述代码没有适合8条原则中的任意一条，也没有使用任何同步手段，所以上述的操作是线程不安全的，因此线程B读取的值自然也是不确定的。修复这个问题的方式很简单，要么给writer()方法和read()方法添加同步手段，如synchronized或者给变量flag添加volatile关键字，确保线程A修改的值对线程B总是可见。 volatile内存语义volatile在并发编程中很常见，但也容易被滥用，现在我们就进一步分析volatile关键字的语义。volatile是Java虚拟机提供的轻量级的同步机制。volatile关键字有如下两个作用 保证被volatile修饰的共享变量对所有线程总数可见的，也就是当一个线程修改了一个被volatile修饰共享变量的值，新值总数可以被其他线程立即得知。 禁止指令重排序优化。 volatile的可见性关于volatile的可见性作用，我们必须意识到被volatile修饰的变量对所有线程总数立即可见的，对volatile变量的所有写操作总是能立刻反应到其他线程中，但是对于volatile变量运算操作在多线程环境并不保证安全性(原子性不能保证)，如下 1234567public class VolatileVisibility &#123; public static volatile int i =0; public static void increase()&#123; i++; &#125;&#125; 正如上述代码所示，i变量的任何改变都会立马反应到其他线程中，但是如此存在多条线程同时调用increase()方法的话，就会出现线程安全问题，毕竟i++;操作并不具备原子性，该操作是先读取值，然后写回一个新值，相当于原来的值加上1，分两步完成，如果第二个线程在第一个线程读取旧值和写回新值期间读取i的域值，那么第二个线程就会与第一个线程一起看到同一个值，并执行相同值的加1操作，这也就造成了线程安全失败，因此对于increase方法必须使用synchronized修饰，以便保证线程安全，需要注意的是一旦使用synchronized修饰方法后，由于synchronized本身也具备与volatile相同的特性，即可见性 （简单来说就是有运算操作的一般都是先读后写，但是这个过程并不能保证写的就是刚刚读的，所以用volatile关键字修饰的话就不能保证安全性了，这个时候就得使用synchronize关键字修饰该方法） ，因此在这样种情况下就完全可以省去volatile修饰变量。 1234567public class VolatileVisibility &#123; public static int i =0; //这里无需再用volatile修饰，因为synchronize和它具有相同的特性 public synchronized static void increase()&#123; i++; &#125;&#125; 现在来看另外一种场景，可以使用volatile修饰变量达到线程安全的目的，如下 1234567891011121314public class VolatileSafe &#123; volatile boolean close; public void close()&#123; close=true; &#125; public void doWork()&#123; while (!close)&#123; System.out.println(\"safe....\"); &#125; &#125;&#125; 由于对于boolean变量close值的修改属于原子性操作，因此可以通过使用volatile修饰变量close，使用该变量对其他线程立即可见，从而达到线程安全的目的。那么JMM是如何实现让volatile变量对其他线程立即可见的呢？实际上，当写一个volatile变量时，JMM会把该线程对应的工作内存中的共享变量值刷新到主内存中，当读取一个volatile变量时，JMM会把该线程对应的工作内存置为无效，那么该线程将只能从主内存中重新读取共享变量。 volatile变量正是通过这种写-读方式实现对其他线程可见（但其内存语义实现则是通过内存屏障，稍后会说明）。 volatile禁止重排优化volatile关键字另一个作用就是禁止指令重排优化，从而避免多线程环境下程序出现乱序执行的现象，关于指令重排优化前面已详细分析过，这里主要简单说明一下volatile是如何实现禁止指令重排优化的。先了解一个概念，内存屏障(Memory Barrier）。内存屏障，又称内存栅栏，是一个CPU指令，它的作用有两个，一是保证特定操作的执行顺序，二是保证某些变量的内存可见性（利用该特性实现volatile的内存可见性） 。由于编译器和处理器都能执行指令重排优化。如果在指令间插入一条Memory Barrier则会告诉编译器和CPU，不管什么指令都不能和这条Memory Barrier指令重排序，也就是说通过插入内存屏障禁止在内存屏障前后的指令执行重排序优化。Memory Barrier的另外一个作用是强制刷出各种CPU的缓存数据，因此任何CPU上的线程都能读取到这些数据的最新版本。总之，volatile变量正是通过内存屏障实现其在内存中的语义，即可见性和禁止重排优化。下面看一个非常典型的禁止重排优化的例子DCL（双检锁），如下： 12345678910111213141516171819202122232425/** * Created by zejian on 2017/6/11. * Blog : http://blog.csdn.net/javazejian [原文地址,请尊重原创] */public class DoubleCheckLock &#123; private static DoubleCheckLock instance; private DoubleCheckLock()&#123;&#125; public static DoubleCheckLock getInstance()&#123; //第一次检测 if (instance==null)&#123; //同步 synchronized (DoubleCheckLock.class)&#123; if (instance == null)&#123; //多线程环境下可能会出现问题的地方 instance = new DoubleCheckLock(); &#125; &#125; &#125; return instance; &#125;&#125; 上述代码一个经典的单例的双重检测的代码，这段代码在单线程环境下并没有什么问题，但如果在多线程环境下就可以出现线程安全问题。原因在于某一个线程执行到第一次检测，读取到的instance不为null时，instance的引用对象可能没有完成初始化。因为instance = new DoubleCheckLock();可以分为以下3步完成(伪代码) 123memory = allocate(); //1.分配对象内存空间instance(memory); //2.初始化对象instance = memory; //3.设置instance指向刚分配的内存地址，此时instance！=null123 由于步骤1和步骤2间可能会重排序，如下： 123memory = allocate(); //1.分配对象内存空间instance = memory; //3.设置instance指向刚分配的内存地址，此时instance！=null，但是对象还没有初始化完成！instance(memory); //2.初始化对象123 由于步骤2和步骤3不存在数据依赖关系，而且无论重排前还是重排后程序的执行结果在单线程中并没有改变，因此这种重排优化是允许的。但是指令重排只会保证串行语义的执行的一致性(单线程)，但并不会关心多线程间的语义一致性。所以当一条线程访问instance不为null时，由于instance实例未必已初始化完成，也就造成了线程安全问题。那么该如何解决呢，很简单，我们使用volatile禁止instance变量被执行指令重排优化即可。 12//禁止指令重排优化private volatile static DoubleCheckLock instance; ok~，到此相信我们对Java内存模型和volatile应该都有了比较全面的认识，总而言之，我们应该清楚知道，JMM就是一组规则，这组规则意在解决在并发编程可能出现的线程安全问题，并提供了内置解决方案（happen-before原则）及其外部可使用的同步手段(synchronized/volatile等)，确保了程序执行在多线程环境中的应有的原子性，可视性及其有序性。 如有错误，欢迎留言，谢谢！ 参考资料：http://tutorials.jenkov.com/java-concurrency/java-memory-model.htmlhttp://blog.csdn.net/iter_zc/article/details/41843595http://ifeve.com/wp-content/uploads/2014/03/JSR133%E4%B8%AD%E6%96%87%E7%89%881.pdf 《深入理解JVM虚拟机》《Java高并发程序设计》","categories":[{"name":"JVM","slug":"JVM","permalink":"https://caoler.cn/categories/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://caoler.cn/tags/JVM/"},{"name":"jmm","slug":"jmm","permalink":"https://caoler.cn/tags/jmm/"}]},{"title":"详解类加载机制","slug":"类加载机制","date":"2018-08-12T08:38:00.000Z","updated":"2018-10-14T12:56:05.423Z","comments":true,"path":"/post/2018/java-lload-class.html","link":"","permalink":"https://caoler.cn/post/2018/java-lload-class.html","excerpt":"从类被加载到虚拟机内存中开始，到卸御出内存为止，它的整个生命周期分为7个阶段，加载(Loading)、验证(Verification)、准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using)、卸御(Unloading)。其中验证、准备、解析三个部分统称为连接。","text":"从类被加载到虚拟机内存中开始，到卸御出内存为止，它的整个生命周期分为7个阶段，加载(Loading)、验证(Verification)、准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using)、卸御(Unloading)。其中验证、准备、解析三个部分统称为连接。 7个阶段发生的顺序如下： 类的生命周期 1. 加载 通过一个类的全限定名来获取定义此类的二进制字节流。 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。 注意：JVM中的ClassLoader类加载器加载Class发生在此阶段 2. 验证2.1 文件格式的验证 主要验证字节流是否符合Class文件格式的规范，如果符合则把字节流加载到方法区中进行存储。 文件头、主次版本验证等等 2.2 元数据验证主要对字节码描述的信息进行语义分析，保证其描述符合Java语言的要求。 类是否有父类 是否继承了不允许被继承的类（final修饰过的类） 如果这个类不是抽象类，是否实现其父类或接口中所有要求实现的方法 类中的字段、方法是否与父类产生矛盾（如：覆盖父类final类型的字段，或者不符合个则的方法） 2.3 字节码验证最复杂的一个阶段。主要目的是通过数据量和控制流分析，确定程序语义是合法的，符合逻辑的。保证被校验类的方法在运行时不会做出危害虚拟机安全的事件。 2.4 符号引用验证符号引用中通过字符串描述的全限定名是否能找到对应的类。在指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段。符号引用中的类、字段、方法的访问性（private、protected、public、default）是否可被当前类访问。 3、准备准备阶段正式为类变量分配内存并设置初始值阶段。public static int value=123; 初始后为 value=0;对于static final类型，在准备阶段会被赋予正确的值public static final value=123;初始化为 value=123; 如果是boolean值默认赋值为：false如果是对象引用默认赋值为：null… 注意：只设置类中的静态变量（方法区中），不包括实例变量（堆内存中），实例变量是在对象实例化的时候初始化分配值的 4、解析解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。 符号引用：简单的理解就是字符串，比如引用一个类，java.util.ArrayList 这就是一个符号引用，字符串引用的对象不一定被加载。 直接引用：指针或者地址偏移量。引用对象一定在内存（已经加载）。 5、初始化 执行类构造器 初始化静态变量、静态块中的数据等（一个类加载器只会初始化一次） 子类的调用前保证父类的被调用 **注意： 是线程安全的，执行的线程需要先获取锁才能进行初始化操作，保证只有一个线程能执行(利用此特性可以实现线程安全的懒汉单例模式)。** 什么是类装载器ClassLoader ClassLoader是一个抽象类 ClassLoader的实例将读入Java字节码将类装载到JVM中 ClassLoader可以定制，满足不同的字节码流获取方式 ClassLoader负责类装载过程中的加载阶段。 JVM中的类加载器 启动类加载器（BootStrap ClassLoader）：引导类装入器是用本地代码实现的类装入器，它负责将 jdk中jre/lib下面的核心类库或-Xbootclasspath选项指定的jar包加载到内存中。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。 扩展类加载器（Extension ClassLoader）：扩展类加载器是由Sun的ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的。它负责将jdk中jre/lib/ext或者由系统变量-Djava.ext.dir指定位置中的类库加载到内存中。开发者可以直接使用标准扩展类加载器。 系统类加载器（System ClassLoader）：系统类加载器是由 Sun的 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的。它负责将系统类路径java -classpath或-Djava.class.path变量所指的目录下的类库加载到内存中。开发者可以直接使用系统类加载器。 双亲委派模型下图中展示了类加载器直接的关系和双亲委派模型 类加载器双亲委派模型 从图中我们发现除启动类加载器外，每个加载器都有父的类加载器。双亲委派机制：如果一个类加载器在接到加载类的请求时，它首先不会自己尝试去加载这个类，而是把这个请求任务委托给父类加载器去完成，依次递归，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。 ClassLoader类关系图 从类的继承关系来看，ExtClassLoader和AppClassLoader都是继承URLClassLoader，都是ClassLoader的子类。而BootStrapClassLoader是有C写的，不再java的ClassLoader子类中。 注意：从图中可以看到类加载器间的父子关系不是以继承的方式实现的，而是以组合关系的方式来复用父加载器的代码。如果一个类加载器收到了类加载的请求，它首先会把这个请求委派给父加载器去完成，每一个层次的类加载器都是如此。 双亲委派模型的好处Java类随着加载它的类加载器一起具备了一种带有优先级的层次关系。比如，Java中的Object类，它存放在rt.jar之中,无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此Object在各种类加载环境中都是同一个类。如果不采用双亲委派模型，那么由各个类加载器自己取加载的话，那么系统中会存在多种不同的Object类。 破坏双亲委派模型案例一双亲委派模型的问题：顶层ClassLoader，无法加载底层ClassLoader的类。JDK的javax.xml.parsers包中定义了xml解析的类接口Service Provider Interface SPI 位于rt.jar 即接口在启动ClassLoader中。而SPI的实现类，可能由第三方提供，AppClassLoader进行加载。解决思路：可以在线程中放入底层的ClassLoader到Thread. setContextClassLoader()中，然后在顶层ClassLoader中使用Thread.getContextClassLoader()获得底层的ClassLoader进行加载第三方实现。 案例二Tomcat中使用了自定ClassLoader，并且也破坏了双亲委托机制。每个应用使用WebAppClassloader进行单独加载，他首先使用WebAppClassloader进行类加载，如果加载不了再委托父加载器去加载，这样可以保证每个应用中的类不冲突。每个tomcat中可以部署多个项目，每个项目中存在很多相同的class文件（很多相同的jar包），他们加载到jvm中可以做到互不干扰。 案例三：利用破坏双亲委派来java的类热部署实现（每次修改类文件，不需要重启服务）。因为一个Class只能被一个ClassLoader加载一次，否则会报java.lang.LinkageError。当我们想要实现代码热部署时，可以每次都new一个自定义的ClassLoader来加载新的Class文件。JSP的实现动态修改就是使用此特性实现。 Class加密实现思路ClassLoader加载.class文件的方式不仅限于从jar包中读取，还可以从种地方读取，因为ClassLoader加载时需要的是byte[]数组. ClassLoader加载Class文件方式： 从本地系统中直接加载 通过网络下载.class文件 从zip，jar等归档文件中加载.class文件 从专有数据库中提取.class文件 将Java源文件动态编译为.class文件 加密实现思路：加载Class文件的方式灵活，我们可以自定义ClassLoader，把加密后的Class文件，在加载Class前先进行解密，然后在通过ClassLoader进行加载。","categories":[{"name":"JVM","slug":"JVM","permalink":"https://caoler.cn/categories/JVM/"}],"tags":[{"name":"jvm","slug":"jvm","permalink":"https://caoler.cn/tags/jvm/"}]},{"title":"IOC概念和SpringBean的生命周期","slug":"IOC概念和SpringBean的生命周期","date":"2018-08-10T08:38:00.000Z","updated":"2018-10-14T12:54:13.742Z","comments":true,"path":"/post/2018/springioc-bean.html","link":"","permalink":"https://caoler.cn/post/2018/springioc-bean.html","excerpt":"之前有写过SpringBean的文章，但是大部分都是搬运的，自己对它的深层次思想并没有掌握，所以在这里重写一下。 IOC部分在第一次学Spring的时候就已经在接触了，但是还是了解的不够深入，最近在看了一部分SpringIOC的源码之后，才模模糊糊的明白了一些，正好赶上组内技术分享，做此下文","text":"之前有写过SpringBean的文章，但是大部分都是搬运的，自己对它的深层次思想并没有掌握，所以在这里重写一下。 IOC部分在第一次学Spring的时候就已经在接触了，但是还是了解的不够深入，最近在看了一部分SpringIOC的源码之后，才模模糊糊的明白了一些，正好赶上组内技术分享，做此下文 1. WEB发展简史老一辈的软件开发人员一般经历了从Model1到Model2，然后到后来的三层模型，最后到现在的Spring Boot。如果从Model1到Model2说起到我们现在使用的Spring Boot为整个时间轴的话，大致可以分为4个阶段： (1)初级阶段：使用Model1/Model2/三层模模型进行开发; (2)中级阶段：使用EJB进行分布式应用开发，忍受重量级框架带来的种种麻烦; (3)高级阶段：使用Spring春天带给我们的美好，但是还要忍受很多繁琐的配置; (4)骨灰级阶段：使用Spring Boot，畅享“预定大于配置”带给我们的种种乐趣! 1.1 Web发展初级阶段 1、Model1开发模式： Model1的开发模式是：JSP+JavaBean的模式，它的核心是Jsp页面，在这个页面中，Jsp页面负责整合页面和JavaBean(业务逻辑)，而且渲染页面，它的基本流程如下： 相信很多小伙伴在刚学习Web的时候，肯定使用到了Model1开发模式，也就是我们的业务代码、持久化代码直接写在Jsp页面里边，使用Jsp直接处理Web浏览器的请求，并使用JavaBean处理业务逻辑。 利用我们现在熟悉的MVC模型的思想去看，虽然编写代码十分容易，但Jsp混淆了MVC模型中的视图层和控制层，高度耦合的结果是Jsp代码十分复杂，后期维护困难! 2、Model2开发模式： Model1虽然在一定程度上解耦了，但JSP依旧即要负责页面控制，又要负责逻辑处理，职责不单一!此时Model2应运而生，使得各个部分各司其职，Model2是基于MVC模式的。 Model2的开发模式是：Jsp+Servlet+JavaBean的模式，它和Model1不同的是，增加了Servlet，将调用页面数据，调用业务逻辑等工作放到了Servlet中处理，从而减轻了Jsp的工作负担!它的基本流程如下： Model2开发模式将Servlet的概念引入架构体系中，使用它来分配视图层Jsp的显示页面，同时调用模型层的JavaBean来控制业务逻辑。 3、Model1和Model2的区别： Model1：简单，适合小型项目的开发，但是Jsp的职责过于繁重，职责分工不明确。在后期的维护工作中，必将为此付出代价! Model2：相对于Model1来说，职责分工更为明确，在Model1的基础上，抽取了Servlet层，体现了一个分层的思想，适合大型的项目开发!(当时的评判标准是适合大型项目开发的，现在看起来已经过时了!) Model2看起来已经尽善尽美了，尽管如此，他还不能称之为一个比较完善的MVC设计模式! 4、Model1和Model2与三层的对比： 在Model2中，我们将Servlet抽取出单独的一层，和Jsp协作完成用户数据交互的工作，也就是表示层。那么作为三层结构来说，又做了什么样的改进呢?三层则是在此基础上，将JavaBean再一次进行分割：业务逻辑、数据持久化，三层如下： (1)表示层，JSP/Servlet; (2)业务逻辑层：业务规则; (3)持久化层：主要包装持久化的逻辑 ; 各个的耦合性如下图： Model1、Model2、三层是在解耦的基础上一步步进化而来，通过解耦我们可以进行进一步的抽象，以应对现实需求的变动。 1.2 Web发展初级阶段存在的问题 经历过初级阶段的小伙伴肯定看得懂下边的一个项目结构，一个简单的MVC三层结构，使用JSP+Servlet+MySQL+JDBC技术，面向接口编程： 1、面向接口编程的实例化对象 以用户管理模块为例，有一个UserDao接口，有一个接口的实现类UserDaoImpl，如下： 由于是面向接口编程，因此我们在每次使用UserDao的时候，都要进行实例化一次，实例化代码如下： 1UserDao userDao = new UserDaoImpl(); 我们在每次使用UserDao的时候都需要进行实例化，当然不仅仅有UserDao需要进行实例化，还有很多需要进行实例化的，举例如下： 可以看出，每一个方法中都需要进行实例化我们需要用到的接口的实现类，这就会存在大量的实例化对象，并且他们的生命周期可能就是从方法的调用开始到方法的调用结束为止，加大了GC回收的压力! 2、使用单例模式的一次改进 了解设计模式的可能会想到使用单例模式的方式来解决这个问题，以此来避免大量重复的创建对象，但是我们还要考虑到众多的这种对象的创建都需要改成单例模式的话，是一个耗时耗力的操作。 对于这个系统来说，如果都把这种面向接口的对象实现类转换为单例模式的方式的话，大概也要写十几个或者上百个这种单例模式代码，而对于一个单例模式的写法来说，往往是模板式的代码，以静态内部类的方式实现代理模式如下： 可以看出，这种方式有两个问题： (1)业务代码与单例模式的模板代码放在一个类里，耦合性较高; (2)大量重复的单例模式的模板代码; 从上述可以看出，使用的单例模式虽然从性能上有所提高，但是却加重了我们的开发成本。因此只会小规模的使用，例如我们操作JDBC的Utils对象等。 3、我们开发中遇到的痛点 从上述代码的演进过程我们可以看得出来，我们即需要一个单例的对象来避免系统中大量重复对象的创建和销毁，又不想因为使用单例模式造成大量重复无用的模板代码和代码的耦合! 4、我们还能怎么做 作为学院派的书生来说，我们可能会联想到“数据库连接池”,我们在获取数据库连接的时候会从这个池子中拿到一个连接的，假设这个数据库连接池很特殊，有且只能有N个数据库连接，并且每一个连接对象都不同(假设)，那么这个不就相当于每一个连接都是单例的了吗?既可以避免大量对象的创建，也可以实现不会出现大量重复性的模板代码。 因此，这里应该有一个大胆的想法，我们是否可以建立一个池子，将我们的接口实现类对象放入到这个池子中，我们在使用的时候直接从这个池子里边取就行了! 5、这个池子 如果我们要创建这个池子，首先要确定需要把哪些对象放进这个池子，通过怎样的方式放进去，放进去之后如何进行管理，如何进行获取，池子中的每一个对象的生命周期是怎么样的等等这些东西都是我们需要考虑到的! ​ 所以，Spring应运而生了！ 2. IOC理论概念2.1 背景我们都知道，在采用面向对象方法设计的软件系统中，它的底层实现都是由N个对象组成的，所有的对象通过彼此的合作，最终实现系统的业务逻辑。 如果我们打开机械式手表的后盖，就会看到与上面类似的情形，但是如果有一个齿轮出了问题，就可能会影响到整个齿轮组的正常运转。 齿轮组中齿轮之间的啮合关系,与软件系统中对象之间的耦合关系非常相似。对象之间的耦合关系是无法避免的，也是必要的，这是协同工作的基础。 为了解决对象之间的耦合度过高的问题，软件专家Michael Mattson提出了IOC理论，用来实现对象之间的“解耦”，目前这个理论已经被成功地应用到实践当中，很多的J2EE项目均采用了IOC框架产品Spring。 2.2 什么是控制反转（IOC）IOC是Inversion of Control的缩写，多数书籍翻译成“控制反转”，还有些书籍翻译成为“控制反向”或者“控制倒置”。 观点大体是这样的：借助于“第三方”实现具有依赖关系的对象之间的解耦。 由于引进了中间位置的“第三方”，也就是IOC容器，使得A、B、C、D这4个对象没有了耦合关系，齿轮之间的传动全部依靠“第三方”了，全部对象的控制权全部上缴给“第三方”IOC容器，所以，IOC容器成了整个系统的关键核心，它起到了一种类似“粘合剂”的作用，把系统中的所有对象粘合在一起发挥作用，如果没有这个“粘合剂”，对象与对象之间会彼此失去联系，这就是有人把IOC容器比喻成“粘合剂”的由来。 拿掉IoC容器后的系统就是现在看到的画面，就是我们要实现整个系统所需要完成的全部内容。 这时候，A、B、C、D这4个对象之间已经没有了耦合关系，彼此毫无联系，这样的话，当你在实现A的时候，根本无须再去考虑B、C和D了，对象之间的依赖关系已经降低到了最低程度。 对比： 引入IOC容器之前： 如图1所示，对象A依赖于对象B，那么对象A在初始化或者运行到某一点的时候，自己必须主动去创建对象B或者使用已经创建的对象B。无论是创建还是使用对象B，控制权都在自己手上。 引入IOC容器之后 如图3所示，由于IOC容器的加入，对象A与对象B之间失去了直接联系，所以，当对象A运行到需要对象B的时候，IOC容器会主动创建一个对象B注入到对象A需要的地方。 通过前后的对比，我们不难看出来：对象A获得依赖对象B的过程,由主动行为变为了被动行为，控制权颠倒过来了，这就是“控制反转”这个名称的由来。 2.3 IOC的别名：依赖注入（DI）既然IOC是控制反转，那么到底是“哪些方面的控制被反转了呢？” “获得依赖对象的过程被反转了” 控制被反转之后，获得依赖对象的过程由自身管理变为了由IOC容器主动注入。 所谓依赖注入，就是由IOC容器在运行期间，动态地将某种依赖关系注入到对象之中。 所以，依赖注入(DI)和控制反转(IOC)是从不同的角度的描述的同一件事情，就是指通过引入IOC容器，利用依赖关系注入的方式，实现对象之间的解耦。 收到任务：从外部USB设备读取一个文件。 电脑主机读取文件的时候，它一点也不会关心USB接口上连接的是什么外部设备，而且它确实也无须知道。它的任务就是读取USB接口，挂接的外部设备只要符合USB接口标准即可。所以，如果我给电脑主机连接上一个U盘，那么主机就从U盘上读取文件；如果我给电脑主机连接上一个外置硬盘，那么电脑主机就从外置硬盘上读取文件。挂接外部设备的权力由我作主，即控制权归我，至于USB接口挂接的是什么设备，电脑主机是决定不了，它只能被动的接受。电脑主机需要外部设备的时候，根本不用它告诉我，我就会主动帮它挂上它想要的外部设备，你看我的服务是多么的到位。这就是我们生活中常见的一个依赖注入的例子。在这个过程中，我就起到了IOC容器的作用。 当电脑主机读取文件的时候，我就把它所要依赖的外部设备，帮他挂接上。整个外部设备注入的过程和一个被依赖的对象在系统运行时被注入另外一个对象内部的过程完全一样。 我们把依赖注入应用到软件系统中，再来描述一下这个过程：对象A依赖于对象B,当对象 A需要用到对象B的时候，IOC容器就会立即创建一个对象B送给对象A。IOC容器就是一个对象制造工厂，你需要什么，它会给你送去，你直接使用就行了，而再也不用去关心你所用的东西是如何制成的，也不用关心最后是怎么被销毁的，这一切全部由IOC容器包办。 在传统的实现中，由程序内部代码来控制组件之间的关系。我们经常使用new关键字来实现两个组件之间关系的组合，这种实现方式会造成组件之间耦合。IOC很好地解决了该问题，它将实现组件间关系从程序内部提到外部容器，也就是说由容器在运行期将组件间的某种依赖关系动态注入组件中。 2.4 IOC带来的好处 USB设备作为电脑主机的外部设备，在插入主机之前，与电脑主机没有任何的关系，只有被我们连接在一起之后，两者才发生联系，具有相关性。出问题了互不影响，便于调试，可维护性好。 USB设备和电脑主机的之间无关性，还带来了另外一个好处，生产USB设备的厂商和生产电脑主机的厂商完全可以是互不相干的人，各干各事，他们之间唯一需要遵守的就是USB接口标准。每个开发团队的成员都只需要关心实现自身的业务逻辑，完全不用去关心其它的人工作进展，因为你的任务跟别人没有任何关系，你的任务可以单独测试，你的任务也不用依赖于别人的组件，再也不用扯不清责任了。 同一个USB外部设备可以插接到任何支持USB的设备。可复用性好 同USB外部设备一样，模块具有热插拔特性。IOC生成对象的方式转为外置方式，也就是把对象生成放在配置文件里进行定义，这样，当我们更换一个实现子类将会变得很简单，只要修改配置文件就可以了，完全具有热插拨的特性。 3. IOC容器的技术剖析 Spring 是一个“引擎”； Spring MVC 是基于Spring的一个 MVC 框架 ； Spring Boot 是基于Spring的条件注册的一套快速开发整合包。 IOC中最基本的技术就是“反射(Reflection)”编程，目前.Net C#、Java和PHP5等语言均支持，其中PHP5的技术书籍中，有时候也被翻译成“映射”。有关反射的概念和用法，大家应该都很清楚，通俗来讲就是根据给出的类名（字符串方式）来动态地生成对象。 我们可以把IOC容器的工作模式看做是工厂模式的升华，可以把IOC容器看作是一个工厂，这个工厂里要生产的对象都在配置文件中给出定义，然后利用编程语言的的反射编程，根据配置文件中给出的类名生成相应的对象。从实现来看，IOC是把以前在工厂方法里写死的对象生成代码，改变为由配置文件来定义，也就是把工厂和对象生成这两者独立分隔开来，目的就是提高灵活性和可维护性。 先看下最基本的启动 Spring 容器的例子： 123public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"classpath:applicationfile.xml\");&#125; ApplicationContext context = new ClassPathXmlApplicationContext(...) 其实很好理解，从名字上就可以猜出一二，就是在 ClassPath 中寻找 xml 配置文件，根据 xml 文件内容来构建 ApplicationContext。当然，除了 ClassPathXmlApplicationContext 以外，我们也还有其他构建 ApplicationContext 的方案可供选择，我们先来看看大体的继承结构是怎么样的： 我们可以看到，ClassPathXmlApplicationContext 兜兜转转了好久才到 ApplicationContext 接口，同样的，我们也可以使用绿颜色的 FileSystemXmlApplicationContext 和 AnnotationConfigApplicationContext 这两个类。 FileSystemXmlApplicationContext 的构造函数需要一个 xml 配置文件在系统中的路径，其他和 ClassPathXmlApplicationContext 基本上一样。 AnnotationConfigApplicationContext 是基于注解来使用的，它不需要配置文件，采用 java 配置类和各种注解来配置，是比较简单的方式，也是大势所趋吧。 不过今天旨在帮助大家理解整个构建流程，所以决定使用 ClassPathXmlApplicationContext 进行分析。 定义接口实现类： 12345public class MessageServiceImpl implements MessageService &#123; public String getMessage() &#123; return \"hello world\"; &#125;&#125; 接下来，我们在 resources 目录新建一个配置文件，文件名随意，通常叫 application.xml 或 application-xxx.xml 就可以了： 1234567&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;beans xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://www.springframework.org/schema/beans\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\" default-autowire=\"byName\"&gt; &lt;bean id=\"messageService\" class=\"com.javadoop.example.MessageServiceImpl\"/&gt;&lt;/beans&gt; 这样，我们就可以跑起来了： 12345678910111213public class App &#123; public static void main(String[] args) &#123; // 用我们的配置文件来启动一个 ApplicationContext ApplicationContext context = new ClassPathXmlApplicationContext(\"classpath:application.xml\"); System.out.println(\"context 启动成功\"); // 从 context 中取出我们的 Bean，而不是用 new MessageServiceImpl() 这种方式 MessageService messageService = context.getBean(MessageService.class); // 这句将输出: hello world System.out.println(messageService.getMessage()); &#125;&#125; 以上例子很简单，不过也够引出本文的主题了，就是怎么样通过配置文件来启动 Spring 的 ApplicationContext？也就是我们今天要分析的 IOC 的核心了。ApplicationContext 启动过程中，会负责创建实例 Bean，往各个 Bean 中注入依赖等。 3.1BeanFactory 简介BeanFactory，从名字上也很好理解，生产 bean 的工厂，它负责生产和管理各个 bean 实例。 初学者可别以为我之前说那么多和 BeanFactory 无关，前面说的 ApplicationContext 其实就是一个 BeanFactory。我们来看下和 BeanFactory 接口相关的主要的继承结构： 我想，大家看完这个图以后，可能就不是很开心了。ApplicationContext 往下的继承结构前面一张图说过了，这里就不重复了。 ApplicationContext 继承了 ListableBeanFactory，这个 Listable 的意思就是，通过这个接口，我们可以获取多个 Bean。 ApplicationContext 继承了 HierarchicalBeanFactory，Hierarchical 单词本身已经能说明问题了，也就是说我们可以在应用中起多个 BeanFactory，然后可以将各个 BeanFactory 设置为父子关系。 AutowireCapableBeanFactory 这个名字中的 Autowire 大家都非常熟悉，它就是用来自动装配 Bean 用的，但是仔细看上图，ApplicationContext 并没有继承它，不过不用担心，不使用继承，不代表不可以使用组合，如果你看到 ApplicationContext 接口定义中的最后一个方法 getAutowireCapableBeanFactory() 就知道了。 ConfigurableListableBeanFactory 也是一个特殊的接口，看图，特殊之处在于它继承了第二层所有的三个接口，而 ApplicationContext 没有。 3.2 SpringBean的生命周期Spring Bean的完整生命周期从创建Spring容器开始，直到最终Spring容器销毁Bean，这其中包含了一系列关键点。 3.3接口分类Bean的完整生命周期经历了各种方法调用，这些方法可以划分为以下几类： Bean自身的方法：这个包括了Bean本身调用的方法和通过配置文件中的init-method和destroy-method指定的方法 Bean级生命周期接口方法：这个包括了BeanNameAware、BeanFactoryAware、InitializingBean和DiposableBean这些接口的方法 容器级生命周期接口方法：这个包括了InstantiationAwareBeanPostProcessor 和 BeanPostProcessor 这两个接口实现，一般称它们的实现类为“后处理器”。 工厂后处理器接口方法：这个包括了AspectJWeavingEnabler, ConfigurationClassPostProcessor, CustomAutowireConfigurer等等非常有用的工厂后处理器 接口的方法。工厂后处理器也是容器级的。在应用上下文装配配置文件之后立即调用。 3.4 演示先来看看，Spring在Bean从创建到销毁的生命周期中可能做得事情。 详细代码在文章底部附录 3.4.1 实现*Aware接口 在Bean中使用Spring框架的一些对象有些时候我们需要在Bean的初始化中使用Spring框架自身的一些对象来执行一些操作，比如获取ServletContext的一些参数，获取ApplicaitionContext中的BeanDefinition的名字，获取Bean在容器中的名字等等。为了让Bean可以获取到框架自身的一些对象，Spring提供了一组名为Aware的接口。这些接口均继承于org.springframework.beans.factory.Aware标记接口，并提供一个将由Bean实现的set方法,Spring通过基于setter的依赖注入方式使相应的对象可以被Bean使用。 网上说，这些接口是利用观察者模式实现的，因为时间有限，所以我暂时还不太明白，有兴趣的话大家可以去详细的看一下。 重要的Aware接口： ApplicationContextAware: 获得ApplicationContext对象,可以用来获取所有Bean definition的名字。 BeanFactoryAware:获得BeanFactory对象，可以用来检测Bean的作用域。 BeanNameAware:获得Bean在配置文件中定义的名字。 ResourceLoaderAware:获得ResourceLoader对象，可以获得classpath中某个文件。 ServletContextAware:在一个MVC应用中可以获取ServletContext对象，可以读取context中的参数。 ServletConfigAware在一个MVC应用中可以获取ServletConfig对象，可以读取config中的参数。 3.4.2 BeanPostProcessor上面的*Aware接口是针对某个实现这些接口的Bean定制初始化的过程，Spring同样可以针对容器中的所有Bean，或者某些Bean定制初始化过程，只需提供一个实现BeanPostProcessor接口的类即可。 该接口中包含两个方法，postProcessBeforeInitialization和postProcessAfterInitialization。 postProcessBeforeInitialization方法会在容器中的Bean初始化之前执行， postProcessAfterInitialization方法在容器中的Bean初始化之后执行。 3.5 总结所以。。。结合第一节控制台输出的内容，Spring Bean的生命周期是这样纸的： Bean容器找到配置文件中Spring Bean的定义。 Bean容器利用Java Reflection API创建一个Bean的实例。 如果涉及到一些属性值 利用set方法设置一些属性值。 如果Bean实现了BeanNameAware接口，调用setBeanName()方法，传入Bean的名字。 如果Bean实现了BeanClassLoaderAware接口，调用setBeanClassLoader()方法，传入ClassLoader对象的实例。 如果Bean实现了BeanFactoryAware接口，调用setBeanClassLoader()方法，传入ClassLoader对象的实例。 与上面的类似，如果实现了其他*Aware接口，就调用相应的方法。 如果有和加载这个Bean的Spring容器相关的BeanPostProcessor对象，执行postProcessBeforeInitialization()方法 如果Bean实现了InitializingBean接口，执行afterPropertiesSet()方法。 如果Bean在配置文件中的定义包含init-method属性，执行指定的方法。 如果有和加载这个Bean的Spring容器相关的BeanPostProcessor对象，执行postProcessAfterInitialization()方法 当要销毁Bean的时候，如果Bean实现了DisposableBean接口，执行destroy()方法。 当要销毁Bean的时候，如果Bean在配置文件中的定义包含destroy-method属性，执行指定的方法。 参考这篇文章参考了大量的博客，一一列举如下： 自己之前写的一篇博客 - Spring Bean生命周期 简书 - Spring Bean生命周期 小姐姐Giraffe的博客 -【Spring】Bean的生命周期 yqj2065-什么是控制反转（Inversion of Control）-渗透了部分严老师的思想 Spring Bean的生命周期（非常详细）- 确实非常详细！ 大佬的技术博客 - 里面还有大量好文章 Spring IOC的原理及详解 - 原理讲的很透彻 这里详细描述了Spring的诞生史 附录演示部分的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293package com.myhexin.ioc.bean;import org.springframework.beans.BeansException;import org.springframework.beans.factory.*;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.stereotype.Component;// 实现InitializingBean和DisposableBean接口public class Person1 implements BeanFactoryAware, BeanNameAware, InitializingBean, DisposableBean &#123; private String name; private String address; private int phone; private BeanFactory beanFactory; private String beanName; public Person1() &#123; System.out.println(\"【构造器】调用Person1的构造器实例化\"); &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; System.out.println(\"【注入属性】注入属性name\"); this.name = name; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; System.out.println(\"【注入属性】注入属性address\"); this.address = address; &#125; public int getPhone() &#123; return phone; &#125; public void setPhone(int phone) &#123; System.out.println(\"【注入属性】注入属性phone\"); this.phone = phone; &#125; //为一个bean设置属性，除了上面的通过setter注入的方式还有哪几种？ @Override public String toString() &#123; return \"Person&#123;\" + \"name='\" + name + '\\'' + \", address='\" + address + '\\'' + \", phone=\" + phone + '&#125;'; &#125; // 这种方法比较简单，但是不建议使用。因为这样会将Bean的实现和Spring框架耦合在一起。 @Override public void destroy() throws Exception &#123; System.out.println(\"执行DisposableBean接口的destroy方法\"); &#125; @Override public void afterPropertiesSet() throws Exception &#123; System.out.println(\"执行InitializingBean接口的afterPropertiesSet方法\"); &#125; @Override public void setBeanFactory(BeanFactory beanFactory) throws BeansException &#123; System.out.println(\"【BeanFactoryAware接口】调用BeanFactoryAware.setBeanFactory()\"); this.beanFactory = beanFactory; &#125; @Override public void setBeanName(String s) &#123; System.out.println(\"【BeanNameAware接口】调用BeanNameAware.setBeanName()\"); this.beanName = name; &#125; //自定义的初始化函数 public void myInit() &#123; System.out.println(\"myInit被调用\"); &#125; //自定义的销毁方法 public void myDestroy() &#123; System.out.println(\"myDestroy被调用\"); &#125;&#125; 12345678910111213141516171819202122232425package com.myhexin.ioc.bean;import org.springframework.stereotype.Component;import javax.annotation.PostConstruct;import javax.annotation.PreDestroy;//使用@PostConstruct和@PreDestroy注解//@Componentpublic class Person2&#123; public Person2() &#123; System.out.println(\"【构造器】调用Person2的构造器实例化\"); &#125; @PostConstruct public void initPostConstruct()&#123; System.out.println(\"执行PostConstruct注解标注的方法,初始化bean\"); &#125; @PreDestroy public void preDestroy()&#123; System.out.println(\"执行preDestroy注解标注的方法，销毁bean\"); &#125;&#125; 123456789101112131415package com.myhexin.ioc.bean;import org.springframework.beans.BeansException;import org.springframework.beans.factory.config.BeanDefinition;import org.springframework.beans.factory.config.BeanFactoryPostProcessor;import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;public class PersonBeanFactoryPostProcessor implements BeanFactoryPostProcessor &#123; @Override public void postProcessBeanFactory(ConfigurableListableBeanFactory configurableListableBeanFactory) throws BeansException &#123; System.out.println(\"BeanFactoryPostProcessor调用postProcessBeanFactory方法\"); BeanDefinition bd = configurableListableBeanFactory.getBeanDefinition(\"person1\"); bd.getPropertyValues().addPropertyValue(\"phone\", \"110\"); &#125;&#125; 12345678910111213141516171819package com.myhexin.ioc.bean;import org.springframework.beans.BeansException;import org.springframework.beans.factory.config.BeanPostProcessor;import org.springframework.stereotype.Component;public class PersonBeanPostProcessor implements BeanPostProcessor &#123; @Override public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123; System.out.println(\"BeanPostProcessor接口方法postProcessBeforeInitialization对属性进行更改！\"); return bean; &#125; @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123; System.out.println(\"BeanPostProcessor接口方法postProcessAfterInitialization对属性进行更改！\"); return bean; &#125;&#125; 123456789101112131415161718192021package com.myhexin.ioc;import com.myhexin.ioc.bean.Person1;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class IocApplication &#123; public static void main(String[] args) &#123; System.out.println(\"开始初始化容器\"); ApplicationContext ac = new ClassPathXmlApplicationContext(\"classpath:bean.xml\"); System.out.println(\"xml加载完毕\"); Person1 person1 = (Person1) ac.getBean(\"person1\"); System.out.println(person1); System.out.println(\"关闭容器\"); ((ClassPathXmlApplicationContext)ac).close(); &#125;&#125; 12345678910111213141516171819202122232425&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:p=\"http://www.springframework.org/schema/p\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd\"&gt; &lt;bean id=\"person1\" destroy-method=\"myDestroy\" init-method=\"myInit\" class=\"com.myhexin.ioc.bean.Person1\"&gt; &lt;property name=\"name\"&gt; &lt;value&gt;巫妖王&lt;/value&gt; &lt;/property&gt; &lt;property name=\"address\"&gt; &lt;value&gt;东北&lt;/value&gt; &lt;/property&gt; &lt;!--&lt;property name=\"phone\"&gt;--&gt; &lt;!--&lt;value&gt;888&lt;/value&gt;--&gt; &lt;!--&lt;/property&gt;--&gt; &lt;/bean&gt; &lt;!-- 配置自定义的后置处理器 --&gt; &lt;bean id=\"personBeanPostProcessor\" class=\"com.myhexin.ioc.bean.PersonBeanPostProcessor\" /&gt; &lt;bean id=\"personBeanFactoryPostProcessor\" class=\"com.myhexin.ioc.bean.PersonBeanFactoryPostProcessor\" /&gt;&lt;/beans&gt;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://caoler.cn/categories/Spring/"},{"name":"IOC","slug":"Spring/IOC","permalink":"https://caoler.cn/categories/Spring/IOC/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://caoler.cn/tags/spring/"}]},{"title":"Java ConcurrentModificationException异常原因和解决方法","slug":"Java ConcurrentModificationException异常原因和解决方法","date":"2018-08-07T08:38:00.000Z","updated":"2018-10-14T12:54:20.517Z","comments":true,"path":"/post/2018/ConcurrentModificationException.html","link":"","permalink":"https://caoler.cn/post/2018/ConcurrentModificationException.html","excerpt":"在前面一篇文章中提到，对Vector、ArrayList在迭代的时候如果同时对其进行修改就会抛出java.util.ConcurrentModificationException异常。下面我们就来讨论以下这个异常出现的原因以及解决办法。","text":"在前面一篇文章中提到，对Vector、ArrayList在迭代的时候如果同时对其进行修改就会抛出java.util.ConcurrentModificationException异常。下面我们就来讨论以下这个异常出现的原因以及解决办法。 以下是本文目录大纲： 一.ConcurrentModificationException异常出现的原因 二.在单线程环境下的解决办法 三.在多线程环境下的解决方法 若有不正之处请多多谅解，并欢迎批评指正 请尊重作者劳动成果，转载请标明原文链接： http://www.cnblogs.com/dolphin0520/p/3933551.html 一.ConcurrentModificationException异常出现的原因 先看下面这段代码： public class Test { public static void main(String[] args) { ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); list.add(2); Iterator&lt;Integer&gt; iterator = list.iterator(); while(iterator.hasNext()){ Integer integer = iterator.next(); if(integer==2) list.remove(integer); } } } 运行结果： 从异常信息可以发现，异常出现在checkForComodification()方法中。 我们不忙看checkForComodification()方法的具体实现，我们先根据程序的代码一步一步看ArrayList源码的实现： 首先看ArrayList的iterator()方法的具体实现，查看源码发现在ArrayList的源码中并没有iterator()这个方法，那么很显然这个方法应该是其父类或者实现的接口中的方法，我们在其父类AbstractList中找到了iterator()方法的具体实现，下面是其实现代码： public Iterator&lt;E&gt; iterator() { return new Itr(); } 从这段代码可以看出返回的是一个指向Itr类型对象的引用，我们接着看Itr的具体实现，在AbstractList类中找到了Itr类的具体实现，它是AbstractList的一个成员内部类，下面这段代码是Itr类的所有实现： private class Itr implements Iterator&lt;E&gt; { int cursor = 0; int lastRet = -1; int expectedModCount = modCount; public boolean hasNext() { return cursor != size(); } public E next() { checkForComodification(); try { E next = get(cursor); lastRet = cursor++; return next; } catch (IndexOutOfBoundsException e) { checkForComodification(); throw new NoSuchElementException(); } } public void remove() { if (lastRet == -1) throw new IllegalStateException(); checkForComodification(); try { AbstractList.this.remove(lastRet); if (lastRet &lt; cursor) cursor--; lastRet = -1; expectedModCount = modCount; } catch (IndexOutOfBoundsException e) { throw new ConcurrentModificationException(); } } final void checkForComodification() { if (modCount != expectedModCount) throw new ConcurrentModificationException(); } } 首先我们看一下它的几个成员变量： cursor：表示下一个要访问的元素的索引，从next()方法的具体实现就可看出 lastRet：表示上一个访问的元素的索引 expectedModCount：表示对ArrayList修改次数的期望值，它的初始值为modCount。 modCount是AbstractList类中的一个成员变量 protected transient int modCount = 0; 该值表示对List的修改次数，查看ArrayList的add()和remove()方法就可以发现，每次调用add()方法或者remove()方法就会对modCount进行加1操作。 好了，到这里我们再看看上面的程序： 当调用list.iterator()返回一个Iterator之后，通过Iterator的hashNext()方法判断是否还有元素未被访问，我们看一下hasNext()方法，hashNext()方法的实现很简单： public boolean hasNext() { return cursor != size(); } 如果下一个访问的元素下标不等于ArrayList的大小，就表示有元素需要访问，这个很容易理解，如果下一个访问元素的下标等于ArrayList的大小，则肯定到达末尾了。 然后通过Iterator的next()方法获取到下标为0的元素，我们看一下next()方法的具体实现： public E next() { checkForComodification(); try { E next = get(cursor); lastRet = cursor++; return next; } catch (IndexOutOfBoundsException e) { checkForComodification(); throw new NoSuchElementException(); } } 这里是非常关键的地方：首先在next()方法中会调用checkForComodification()方法，然后根据cursor的值获取到元素，接着将cursor的值赋给lastRet，并对cursor的值进行加1操作。初始时，cursor为0，lastRet为-1，那么调用一次之后，cursor的值为1，lastRet的值为0。注意此时，modCount为0，expectedModCount也为0。 接着往下看，程序中判断当前元素的值是否为2，若为2，则调用list.remove()方法来删除该元素。 我们看一下在ArrayList中的remove()方法做了什么： public boolean remove(Object o) { if (o == null) { for (int index = 0; index &lt; size; index++) if (elementData[index] == null) { fastRemove(index); return true; } } else { for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) { fastRemove(index); return true; } } return false; } ​​ private void fastRemove(int index) {​ modCount++;​ int numMoved = size - index - 1;​ if (numMoved &gt; 0)​ System.arraycopy(elementData, index+1, elementData, index,​ numMoved);​ elementData[–size] = null; // Let gc do its work​ } 通过remove方法删除元素最终是调用的fastRemove()方法，在fastRemove()方法中，首先对modCount进行加1操作（因为对集合修改了一次），然后接下来就是删除元素的操作，最后将size进行减1操作，并将引用置为null以方便垃圾收集器进行回收工作。 那么注意此时各个变量的值：对于iterator，其expectedModCount为0，cursor的值为1，lastRet的值为0。 对于list，其modCount为1，size为0。 接着看程序代码，执行完删除操作后，继续while循环，调用hasNext方法()判断，由于此时cursor为1，而size为0，那么返回true，所以继续执行while循环，然后继续调用iterator的next()方法： 注意，此时要注意next()方法中的第一句：checkForComodification()。 在checkForComodification方法中进行的操作是： final void checkForComodification() { if (modCount != expectedModCount) throw new ConcurrentModificationException(); } 如果modCount不等于expectedModCount，则抛出ConcurrentModificationException异常。 很显然，此时modCount为1，而expectedModCount为0，因此程序就抛出了ConcurrentModificationException异常。 到这里，想必大家应该明白为何上述代码会抛出ConcurrentModificationException异常了。 关键点就在于：调用list.remove()方法导致modCount和expectedModCount的值不一致。 注意，像使用for-each进行迭代实际上也会出现这种问题。 二.在单线程环境下的解决办法 既然知道原因了，那么如何解决呢？ 其实很简单，细心的朋友可能发现在Itr类中也给出了一个remove()方法： public void remove() { if (lastRet == -1) throw new IllegalStateException(); checkForComodification(); try { AbstractList.this.remove(lastRet); if (lastRet &lt; cursor) cursor--; lastRet = -1; expectedModCount = modCount; } catch (IndexOutOfBoundsException e) { throw new ConcurrentModificationException(); } } 在这个方法中，删除元素实际上调用的就是list.remove()方法，但是它多了一个操作： expectedModCount = modCount; 因此，在迭代器中如果要删除元素的话，需要调用Itr类的remove方法。 将上述代码改为下面这样就不会报错了： public class Test { public static void main(String[] args) { ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); list.add(2); Iterator&lt;Integer&gt; iterator = list.iterator(); while(iterator.hasNext()){ Integer integer = iterator.next(); if(integer==2) iterator.remove(); //注意这个地方 } } } 三.在多线程环境下的解决方法 上面的解决办法在单线程环境下适用，但是在多线程下适用吗？看下面一个例子： public class Test { static ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); public static void main(String[] args) { list.add(1); list.add(2); list.add(3); list.add(4); list.add(5); Thread thread1 = new Thread(){ public void run() { Iterator&lt;Integer&gt; iterator = list.iterator(); while(iterator.hasNext()){ Integer integer = iterator.next(); System.out.println(integer); try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } } }; }; Thread thread2 = new Thread(){ public void run() { Iterator&lt;Integer&gt; iterator = list.iterator(); while(iterator.hasNext()){ Integer integer = iterator.next(); if(integer==2) iterator.remove(); } }; }; thread1.start(); thread2.start(); } } 运行结果： 有可能有朋友说ArrayList是非线程安全的容器，换成Vector就没问题了，实际上换成Vector还是会出现这种错误。 原因在于，虽然Vector的方法采用了synchronized进行了同步，但是实际上通过Iterator访问的情况下，每个线程里面返回的是不同的iterator，也即是说expectedModCount是每个线程私有。假若此时有2个线程，线程1在进行遍历，线程2在进行修改，那么很有可能导致线程2修改后导致Vector中的modCount自增了，线程2的expectedModCount也自增了，但是线程1的expectedModCount没有自增，此时线程1遍历时就会出现expectedModCount不等于modCount的情况了。 因此一般有2种解决办法： 1）在使用iterator迭代的时候使用synchronized或者Lock进行同步； 2）使用并发容器CopyOnWriteArrayList代替ArrayList和Vector。 关于并发容器的内容将在下一篇文章中讲述。 参考资料： http://blog.csdn.net/izard999/article/details/6708738 http://www.2cto.com/kf/201403/286536.html","categories":[{"name":"JAVASE","slug":"JAVASE","permalink":"https://caoler.cn/categories/JAVASE/"},{"name":"集合框架","slug":"JAVASE/集合框架","permalink":"https://caoler.cn/categories/JAVASE/集合框架/"}],"tags":[{"name":"ArrayList","slug":"ArrayList","permalink":"https://caoler.cn/tags/ArrayList/"}]},{"title":"Gson解析动态key的JSON文件以及优化记录","slug":"Gson解析动态key的JSON文件以及优化记录","date":"2018-07-21T08:38:00.000Z","updated":"2018-10-14T12:54:04.828Z","comments":true,"path":"/post/2018/gson-dynamic-key.html","link":"","permalink":"https://caoler.cn/post/2018/gson-dynamic-key.html","excerpt":"先说说具体场景，当前正在做一个项目，有部分接口是通过股票代码去后台请求数据的，但是作为初入职场的小白，并没有对传入的参数进行判断，所以导致测试服务器上项目每天都是处于504状态（因为安全部门每天凌晨都会对测试服务器上的接口进行注入式攻击，以保证提前发现问题，防止线上灾难）。","text":"先说说具体场景，当前正在做一个项目，有部分接口是通过股票代码去后台请求数据的，但是作为初入职场的小白，并没有对传入的参数进行判断，所以导致测试服务器上项目每天都是处于504状态（因为安全部门每天凌晨都会对测试服务器上的接口进行注入式攻击，以保证提前发现问题，防止线上灾难）。 于是，我得对传入的参数进行判断，由此进入正题： 现有a.json文件（以下只做模拟，具体JSON文件大小为1MB左右），文件内容为： 1234567891011121314&#123; \"600000\":&#123; \"name\":\"股票1\" \"source\":\"股票细节\" &#125;, \"600003\":&#123; \"name\":\"股票2\" \"source\":\"股票细节\" &#125;, \"600006\":&#123; \"name\":\"股票3\" \"source\":\"股票细节\" &#125;&#125; 现在需要解析出上述JSON的key与请求参数做一对照。 以下列出我的解析以及优化过程。 方式一：（原始，解析时间长达4000ms!太恐怖了！） 12345678910111213141516171819202122232425262728293031//首先通过read方法读入json文件，以String方式返回public static boolean read() throws IOException &#123; StringBuilder sb = new StringBuilder(); String str; try (BufferedReader br = new BufferedReader(new FileReader(\"C:\\\\Users\\\\viruser.v-desktop\\\\Desktop\\\\a_code.json\"))) &#123; while (null != (str = br.readLine())) &#123; sb.append(str); &#125; br.close(); &#125; catch (Exception e) &#123; System.out.println(\"无法在指定目录下找到名为：1.json 的文件！\"); System.exit(0); &#125; return sb.toString();&#125;public static boolean isTrue(String code) throws IOException &#123; String s = read(); long startDate = System.currentTimeMillis(); JSONObject jsonObject = JSONObject.fromObject(\"\"); Iterator&lt;String&gt; it = jsonObject.keys(); while (it.hasNext())&#123; String key = it.next(); if (key.equals(code))&#123; long endDate = System.currentTimeMillis(); System.out.println(\"耗时:\"+ (endDate-startDate)); return true; &#125; &#125; return false;&#125; 方式二：(运行时间稍有改观，但是平均也在3000毫秒左右) 123456789101112131415161718192021222324252627282930//首先通过read方法读入json文件，以String方式返回public static boolean read() throws IOException &#123; StringBuilder sb = new StringBuilder(); String str; try (BufferedReader br = new BufferedReader(new FileReader(\"C:\\\\Users\\\\viruser.v-desktop\\\\Desktop\\\\a_code.json\"))) &#123; while (null != (str = br.readLine())) &#123; sb.append(str); &#125; br.close(); &#125; catch (Exception e) &#123; System.out.println(\"无法在指定目录下找到名为：1.json 的文件！\"); System.exit(0); &#125; return sb.toString();&#125;public static boolean isTrue(String code) throws IOException &#123; String s = read(); long startDate = System.currentTimeMillis(); Type type = new TypeToken&lt;ArrayList&lt;StockCodeEntity&gt;&gt;()&#123;&#125;.getType(); Gson gson = new Gson(); List&lt;String&gt; stringList = gson.fromJson(s,type); System.out.println(\"stringList:\"+stringList); if (stringList.contains(code))&#123; long endDate = System.currentTimeMillis(); System.out.println(\"耗时:\"+ (endDate-startDate)); return true; &#125; return false;&#125; 方式三：（为什么要将文件读入完（将近2000毫秒）再拿去循环解析呢？我太笨了！） 1234567891011121314public static boolean read(String code) throws IOException &#123; long startDate = System.currentTimeMillis(); JsonParser parser = new JsonParser(); JsonObject json = (JsonObject) parser.parse(new FileReader(\"C:\\\\Users\\\\viruser.v-desktop\\\\Desktop\\\\a_code.json\")); Iterator&lt;String&gt; it = json.keySet(); while (it.hasNext())&#123; String key = it.next(); if (key.equals(code))&#123; long endDate = System.currentTimeMillis(); System.out.println(\"耗时:\"+ (endDate-startDate)); return true; &#125; &#125;&#125; 方式四：经过上面的优化，我已经将解析时间缩小到了1000毫秒左右，但是对于一个请求过来，就光解析json就花了1秒，那也太不能接受了！所以我再次进行优化 12345678910111213public static boolean read(String code) throws IOException &#123; long startDate = System.currentTimeMillis(); JsonParser parser = new JsonParser(); JsonObject json = (JsonObject) parser.parse(new FileReader(\"C:\\\\Users\\\\viruser.v-desktop\\\\Desktop\\\\a_code.json\")); for(String key:json.keySet())&#123; if (key.equals(code))&#123; System.out.println(\"key:\"+key); long endDate = System.currentTimeMillis(); System.out.println(\"耗时:\"+ (endDate-startDate)); return true; &#125; &#125;&#125; 经过上述优化，我已经可以将解析时间控制在400毫秒以内.但是还是不能满足要求！ 方式五：目前技术极限 12345678910111213public static boolean read(String code) throws IOException &#123; long startDate = System.currentTimeMillis(); JsonParser parser = new JsonParser(); JsonObject json = (JsonObject) parser.parse(new FileReader(\"C:\\\\Users\\\\viruser.v-desktop\\\\Desktop\\\\a_code.json\")); for(Map.Entry&lt;String, JsonElement&gt; map : json.entrySet())&#123; if (map.getKey().equals(code))&#123; long endDate = System.currentTimeMillis(); System.out.println(\"耗时:\"+ (endDate-startDate)); return true; &#125; &#125; return false;&#125; 优化完成之后，解析时间大概在150ms左右，可以说差不多可以满足要求了，但是对于1MB的文件解析花了0.1秒，也是很不理想的！所以说留给自己提升的机会还有很大哈哈！ 总结 这里顺便一提遍历Map的两种方法keySet()，entrySet()的差别。 keySet()方法返回的是key的集合set，entrySet()返回的是键值对的集合set。虽然两者从set遍历取出元素的方法是一样的，但是根据这个元素取出value的效率有些不同。前者取出的元素是key，还要去原map中遍历取出value。后者取出的元素是键值对，直接调用getkey()，getvalue()方法就能快速取出key和value。显然在map中存在大量键值对时，使用entrySet()来取出value的效率更高。 问题： 我有点想不明白的是，我现在只需要获取键值对中的key，使用keySet()方法为什么耗费的时间要比使用entrySet()方法获取到键值对再去getKey()花费的时间还要长呢？？？非常奇怪！ 这里参考了很多博客，对我的帮助很大 Gson解析JSON中动态未知字段key的方法 JSONObject遍历获取键值 JAVA解析JSON数据 几种Java的JSON解析库速度对比","categories":[{"name":"实用教程","slug":"实用教程","permalink":"https://caoler.cn/categories/实用教程/"},{"name":"JSON","slug":"实用教程/JSON","permalink":"https://caoler.cn/categories/实用教程/JSON/"}],"tags":[{"name":"JSON","slug":"JSON","permalink":"https://caoler.cn/tags/JSON/"}]},{"title":"网络抓包工具 wireshark 入门教程","slug":"网络抓包工具 wireshark 入门教程","date":"2018-07-20T08:48:00.000Z","updated":"2018-10-14T12:56:09.659Z","comments":true,"path":"/post/2018/wireshark.html","link":"","permalink":"https://caoler.cn/post/2018/wireshark.html","excerpt":"Wireshark（前称Ethereal）是一个网络数据包分析软件。网络数据包分析软件的功能是截取网络数据包，并尽可能显示出最为详细的网络数据包数据。Wireshark使用WinPCAP作为接口，直接与网卡进行数据报文交换。 网络管理员使用Wireshark来检测网络问题，网络安全工程师使用Wireshark来检查资讯安全相关问题，开发者使用Wireshark来为新的通讯协定除错，普通使用者使用Wireshark来学习网络协定的相关知识。当然，有的人也会“居心叵测”的用它来寻找一些敏感信息……。Wireshark相对于tcpdump而言，界面更友好，功能更强大。","text":"Wireshark（前称Ethereal）是一个网络数据包分析软件。网络数据包分析软件的功能是截取网络数据包，并尽可能显示出最为详细的网络数据包数据。Wireshark使用WinPCAP作为接口，直接与网卡进行数据报文交换。 网络管理员使用Wireshark来检测网络问题，网络安全工程师使用Wireshark来检查资讯安全相关问题，开发者使用Wireshark来为新的通讯协定除错，普通使用者使用Wireshark来学习网络协定的相关知识。当然，有的人也会“居心叵测”的用它来寻找一些敏感信息……。Wireshark相对于tcpdump而言，界面更友好，功能更强大。 安装mac上安装wireshark windows上安装wireshark linux下安装wireshark 基本使用以下的介绍都是以mac下的wireshark 1.12.2版本为基础。 认识界面 说明： 常用按钮从左到右的功能依次是： 1、列出可用接口。 2、抓包时需要设置的一些选项。一般会保留最后一次的设置结果。 3、开始新的一次抓包。 4、暂停抓包。 5、继续进行本次抓包。 6、打开抓包文件。可以打开之前抓包保存后的文件。不仅可以打开wireshark软件保存的文件，也可以打开tcpdump使用-w参数保存的文件。 7、保存文件。把本次抓包或者分析的结果进行保存。 8、关闭打开的文件。文件被关闭后，就会切换到初始界面。 9、重载抓包文件。 设置数据抓取选项点击常用按钮中的设置按钮，就会弹出设置选项对话框。在这个对话框中我们可以选中需要监听的接口，设置混杂模式，设置抓取数据包的过滤条件。如下图： 首先，选中需要监听获取数据包的接口。接口列表区列出了所有可以使用的接口。如果接口前面的复选框被选中，说明对这个接口监听捕获数据包。 其次，设置混杂模式。设置混杂模式的作用是将网卡设置到混杂模式。如果不设置混杂模式，你的计算机只能获取数据包发往的目标是你计算机和从你计算机出去的数据包。如果设置了混杂模式，你就可以捕获局域网中所有的数据包。如果窗口中的 “Use promiscuous mode on all interfaces”前面的复选框被选中，说明对所有的接口使用混杂模式。如果想单独设置，可以双击接口列表中的接口，会弹出如下的对话框。然后选中或者去掉“Capture packets in promiscuous mode”前面复选框。然后点ok按钮。 再次，设置捕获过滤条件。在点设置按钮弹出的主设置对话框中和双击接口列表弹出的对话框中都会有“Capture Filter”项。在文本框中我们可以设置捕获过滤条件。如，我们只捕获http相关的数据包，我们就可以设置捕获条件为“port 80”。因为http使用的是80端口。 最后，所有的设置完毕后，点击设置主窗口中的“Start”按钮，开始捕获数据。数据捕获完后，可以点常用按钮中的“保存”按钮保存数据。 使用显示过滤器显示过滤器应用于捕获文件，用来告诉wireshark只显示那些符合过滤条件的数据包。显示过滤器比捕获过滤器更常用。他可以用来过滤不想看到的数据包，但是不会把数据删除。如果想恢复原状，只要把过滤条件删除即可。 过滤器表达式对话框，是的wireshark的可以很简单的设置过滤表达式。点击“Expression”按钮就可以打开这个对话框。如下图： 对话框分左中右三部分。左边为可以使用的所有协议域。右边为和协议域相关的条件值。中间为协议域与条件值之间的关系。过滤器表达式对于初学者很有用。如上图，我们创建的表达式的作用是，只显示http协议包中包含关键词“bo56.com”的所有数据包。 Field name说明：这个列表中展示了所有支持的协议。点击前面的三角标志后，可以列出本协议的可过滤字段。当选中“Field name”列表中的任何一项，只需要输入你想要的协议域，就会自动定位到相应的协议域选项。 Relation说明：is present 如果选择的协议域存在，则显示相关数据包。contains 判断一个协议，字段或者分片包含一个值matches 判断一个协议或者字符串匹配一个给定的Perl表达式。 Value（Protocol）说明：此处输入合适的值。如果选择的协议域和这个值满足Relation中指定的关系，则显示相关数据包。 Predefined values说明：有些协议域包含了预先定义的值，有点类似于c语言中的枚举类型。如果你选择的协议域包含这样的值，你可以在这个列表中选择。 Function函数说明：过滤器的语言还有下面几个函数：upper(string－field)－把字符串转换成大写lower(string－field)－把字符串转换成小写upper((和lower((在处理大小写敏感的字符串比较时很有用。例如：upper(ncp.nds_stream_name) contains “BO56.COM”lower(mount.dump.hostname) ==”BO56.COM” 如果你熟悉了这个规则之后你就会发现手动输入表达式更有效率。当时手动在flter文本框中输入表达时，如果输入的语法有问题，文本框的背景色会变成红色。这时候，你可以继续输入或者修改，知道文本框中的表达式正确后，文本框的背景色又会变成绿色。 使用着色规则你经常会在数据包列表区域中看到不同的颜色。这就是wireshark做的很人性化的一方面。它可以让你指定条件，把符合条件的数据包按指定的颜色显示。这样你查找数据包会更方便些。下面我们说一下如何设置颜色规则。 点击“view”菜单，然后选择“Coloring Rules”选项就会弹出设置颜色规则设置对话框。你点击颜色规则设置的快捷按钮也可以打开颜色设置对话框。如下图： 打开的对话框中默认已经有一些规则。我们抓取的数据包中经常会看到一些不同的颜色，就是应用的这些默认的规则。点击“New”按钮可以添加规则。如下图： name字段中填写规则的名称，方便记忆。 string字段中填写过滤规则。这里的语法和显示规则表达式一致。点击 上图中的“Expression”按钮，你就会看到熟悉的规则表达式对话。 Foreground Color按钮用于选择前景色。 Background Color按钮用于选择背景色。 Disabled按钮用于指示是否禁用这条规则。 点击ok按钮后，规则自动会添加到规则列表中的最前端。 注意：wireshark在应用规则的时候，是按自上而下的顺序去应用规则。因此刚添加的规则会优先应用。如果你想调整顺序，可以选中要调整顺序的规则，然后点击右边的“UP” 或则 “Down” 按钮。 颜色规则设置好后，只需要点apply按钮就可以应用规则了。规则效果应用如下图： 使用图表图形分析是数据分析中必不可少的一部分。也是wireshark的一大亮点。wireshark有不同的图形展现功能，以帮助你了解捕获的数据包。下面我们对经常使用的IO图，双向时间图做下介绍。 IO图wireshark的IO图让你可以对网络上的吞吐量绘图。让你了解网络数据传输过程中的峰值和波动情况。通过“Statistics”菜单中的“IO Graphs”选项可以打开这个IO图对话框。如下图： 可以看到IO图表对话框中会分为三个区。 过滤器区：设置过滤条件，用于图形化展示过滤条件相关数据包的变化情况。而且可以为每个不同的条件指定不同的颜色。过滤条件的语法和之前介绍的显示过滤器的语法一致。过滤条件为空，此图形显示所有流量。 坐标区：在这里可以设置图表的x轴和y轴。x轴为时间，y轴为包的数量。如图，我们设置Y轴的单位是Bytes/Tick。 趋势图区：根据过滤器设置的条件和坐标区设置，数据分析后回在这个区域以图形化方式展示。点击图形中的点，会自动定位到相应的数据包。点击趋势图中的低谷点，你会发现大量的数据包重传。 IO图表还可以通过函数对数据进行聚合处理。 点击Y轴中Unit选项中的Advanced后，就会再过滤器区就会增加Calc选项。如下图： 相关函数说明： MIN( ), AVG( ), MAX( ) 分别是统计协议域中数值的最小，平均和最大值。注意，这三个聚合函数只对协议域的值为数字的才有效。 Count( ) 此函数计算时间间隔内事件发生的次数，在查看TCP分析标识符时很有用，例如重传。 Sum( ) 该函数统计事件的累加值。和MIN()函数一样，这个也只有协议域的值为数字的情况下才有效。 双向时间图wireshark还有一个功能就是可以对网络传输中的双向时间进行绘图。双向时间（round-trip time, RTT）,就是一个数据包被确认正常接收所花费的时间。以tcp协议为例，就是你push一个数据到一台主机，主机回应一个ack给你的主机，你的主机并成功接收ack回应。这两个过程花费的时间总和就是双向时间。双向时间通常用来寻找网络传输过程中的慢点和瓶颈，用以判断网络传输是否有延迟。 通过“Statistics”菜单中的“Tcp StreamGraph”中的“Round Trip Time Graph”选项可以打开这个双向时间图对话框。如下图： 这个图表中的每个点代表一个数据包的双向时间。你可以单机图表中的任何一点，然后在数据包列表区就会自动定位到相应的数据包。从数据表来看，我们下载压缩包还是比较稳定的。数据包的rtt时间大多数在0.05s以下，其他大多数在0.1s左右，少数超过了1.5s。 跟踪tcp流Wireshark分析功能中最不错的一个功能是它能够将TCP流重组。重组后的数据格式更容易阅读。跟踪TCP流这个功能可以将接收到的数据排好顺序使之容易查看，而不需要一小块一小块地看。这在查看HTTP、FTP等纯文本应用层协议时非常有用。 我们以一个简单的HTTP请求举例来说明一下。打开wireshark_bo56_pcap.pcapng，并在显示过滤器中输入“http contains wireshark”，点击“apply”按钮后，在数据包列表框中就会只剩下一条记录。如下图。 右键单击这条记录并选择Follow TCP Stream。这时TCP流就会在一个单独的窗口中显示出来。如下图： 我们看到这个窗口中的文字会有两种颜色。其中红色用于表示从源地址到目标地址的流量。在我们的例子里面就是从我们本机到web服务器的流量。你可以看到最开始的红色部分是一个GET请求。蓝色部分是和红色部分相反的方向，也就是从目标地址到源地址的流量。在我们的例子中，蓝色部分的第一行是“HTTP/1.1 200 OK”，是来自服务器的一个http成功响应。 在这个窗口中除了能够看到这些原始数据，你还可以在文本间进行搜索，将其保存成一个文件、打印，或者以ASCII码、EBCDIC、十六进制或者C数组的格式去查看。这些选项都可以在跟踪TCP流窗口的下面找到。 转载自：https://blog.csdn.net/zjy900507/article/details/79303359","categories":[{"name":"实用教程","slug":"实用教程","permalink":"https://caoler.cn/categories/实用教程/"},{"name":"网络抓包","slug":"实用教程/网络抓包","permalink":"https://caoler.cn/categories/实用教程/网络抓包/"}],"tags":[{"name":"wireshark","slug":"wireshark","permalink":"https://caoler.cn/tags/wireshark/"}]},{"title":"MAVEN多模块项目的创建以及部署(SpringBoot+MyBatis+IDEA)","slug":"MAVEN多模块项目的创建以及部署(SpringBoot+MyBatis+IDEA)","date":"2018-07-20T08:38:00.000Z","updated":"2018-10-14T12:55:27.810Z","comments":true,"path":"/post/2018/maven-springboot-mybatis.html","link":"","permalink":"https://caoler.cn/post/2018/maven-springboot-mybatis.html","excerpt":"项目基于SpringBoot+MyBatis+Maven构建，由于需要将定时任务与前台业务模块分离开来，所以需要进行maven多模块项目的开发。","text":"项目基于SpringBoot+MyBatis+Maven构建，由于需要将定时任务与前台业务模块分离开来，所以需要进行maven多模块项目的开发。 项目整体结构如下： kiv-parent |----pom.xml |----kiv-core |----pom.xml |----kiv-job |----pom.xml ##多模块项目的创建 这里使用IDEA开发工具进行创建，步骤如下： 创建父moudle 新建MAVEN项目 输入GroupId（一般为域名反写，类似com.myhexin）和artifactid（项目名），后面步骤直接next，最后finish 创建完成之后，删除项目中除pom.xml文件以外的所有文件，因为这里是父节点，只对下面的模块进行管理，之后在pom中添加： pom 最终结构如下： 创建第一个子模块 在主项目名称上点右键，创建第一个子模块 创建子模块，因为是springboot项目，所以选择下面项目 这一步保证groupId和之前创建的ID一致，Artifact为模块名称 配置依赖 完成之后，结构如下： 创建第二个子模块至此，一个模块已经创建好了，再创建第二个模块： 由于第二个模块为utils，所以不需要任何maven模板，按照默认maven工程创建即可。 创建新的模块 简单配置 接下来保证子模块路径在父模块路径之下即可 模块关联关系的配置完成之后，项目结构如下： 添加项目依赖： 我们希望api项目能够使用utils项目的类，需要在api项目中引用utils项目 ，在api项目的pom.xml的dependencies节点添加如下内容 123456&lt;!--引用springboot-utils项目 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.gl&lt;/groupId&gt; &lt;artifactId&gt;springboot-utils&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; 在IDEA中配置: 按Ctrl+Shift+s打开项目设置，选择左侧module，选中将依赖其他模块的模块，在右侧选择dependence，点击绿色加号，选中被依赖的模块，apply即可。 多模块项目的部署待完善。 遇到的问题1. Idea在导入有maven项目时，不能自动识别pom.xml 当在idea中导入maven项目时，不能自动识别pom文件，显示为普通橙色xml文件。 解决方法：点击最右侧侧边栏MavenProjects点击添加（蓝的的小加号），选择你导入项目的pom.xml文件 2. 提示“Unmapped Spring configuration files found.Please configure Spring facet.”解决办法、 首先为模块新增spring配置，“Ctrl+Shift+Alt+S”打开project的配置界面，选择“Modules”页签， 再选择报“Unmapped Spring configuration files found.”的Module，点击“+”按钮； 在弹出的窗口内，全部勾选Unmapped的Spring配置文件，点击“确定”，然后在父界面中点击“应用”或“确定”完成保存。 如果是SpringBoot项目，添加各种config即可，application.yml无需添加。 3. 多模块项目Module must not contain source root. The root already belongs to module 打开页面，删除报错提示的ContentRoot即可，右侧。 4. Failed to load property source from location ‘classpath:/application.yml’ 解决办法仔细的检查一下你的配置文件;我出现该错误的原因是因为未删除干净分模块的配置文件分隔符--- 参考 https://www.cnblogs.com/xdp-gacl/p/4242221.html https://www.cnblogs.com/tibit/p/6185704.html https://blog.csdn.net/qq_36467463/article/details/77851421 https://blog.csdn.net/flyingnet/article/details/78009254 https://blog.csdn.net/willjgl/article/details/77773634","categories":[{"name":"Spring","slug":"Spring","permalink":"https://caoler.cn/categories/Spring/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"https://caoler.cn/tags/springboot/"},{"name":"maven","slug":"maven","permalink":"https://caoler.cn/tags/maven/"}]},{"title":"MySQL存储引擎及其对比","slug":"MySql存储引擎及其对比","date":"2018-07-15T16:41:28.000Z","updated":"2018-10-14T12:55:36.890Z","comments":true,"path":"/post/2018/mysql-engine.html","link":"","permalink":"https://caoler.cn/post/2018/mysql-engine.html","excerpt":"MySql中有哪些存储引擎？","text":"MySql中有哪些存储引擎？ MyISAM： 这种引擎是mysql最早提供的。这种引擎又可以分为静态MyISAM、动态MyISAM 和压缩MyISAM三种： 静态MyISAM：如果数据表中的各数据列的长度都是预先固定好的，服务器将自动选择这种表类型。因为数据表中每一条记录所占用的空间都是一样的，所以这种表存取和更新的效率非常高。当数据受损时，恢复工作也比较容易做。 动态MyISAM：如果数据表中出现varchar、xxxtext或xxxBLOB字段时，服务器将自动选择这种表类型。相对于静态MyISAM，这种表存储空间比较小，但由于每条记录的长度不一，所以多次修改数据后，数据表中的数据就可能离散的存储在内存中，进而导致执行效率下降。同时，内存中也可能会出现很多碎片。因此，这种类型的表要经常用optimize table 命令或优化工具来进行碎片整理。 压缩MyISAM：以上说到的两种类型的表都可以用myisamchk工具压缩。这种类型的表进一步减小了占用的存储，但是这种表压缩之后不能再被修改。另外，因为是压缩数据，所以这种表在读取的时候要先时行解压缩。 静态表是默认的存储格式，静态表中的字段都是非变长的字段，优点是：存储非常迅速，容易缓存，出现故障容易恢复；缺点是：占用的空间通常比动态表多。（注意： 在存储时，列的宽度不足时，用空格补足，当时在访问的时候并不会得到这些空格）动态表的字段是变长的，优点是：占用的空间相对较少，但是频繁地更新删除记录会产生碎片，需要定期改善性能，并且出现故障的时候恢复相对比较困难。 但是，不管是何种MyISAM表，目前它都不支持事务，行级锁和外键约束的功能。 MyISAM Merge引擎： 这种类型是MyISAM类型的一种变种。合并表是将几个相同的MyISAM表合并为一个虚表。常应用于日志和数据仓库。 InnoDB： InnoDB表类型可以看作是对MyISAM的进一步更新产品，它提供了事务、行级锁机制和外键约束的功能。 memory(heap)： 这种类型的数据表只存在于内存中。它使用散列索引，所以数据的存取速度非常快。因为是存在于内存中，所以这种类型常应用于临时表中. archive： 这种类型只支持select 和 insert语句，而且不支持索引。常应用于日志记录和聚合分析方面。 当然MySql支持的表类型不止上面几种。 MyISAM vs InnoDBInnoDB定义：（默认的存储引擎） InnoDB是一个事务型的存储引擎，有行级锁定和外键约束。 Innodb引擎提供了对数据库ACID事务的支持，并且实现了SQL标准的四种隔离级别，关于数据库事务与其隔离级别的内容请见数据库事务与其隔离级别这类型的文章。该引擎还提供了行级锁和外键约束，它的设计目标是处理大容量数据库系统，它本身其实就是基于MySQL后台的完整数据库系统，MySQL运行时Innodb会在内存中建立缓冲池，用于缓冲数据和索引。但是该引擎不支持FULLTEXT类型的索引，而且它没有保存表的行数，当SELECT COUNT(*) FROM TABLE时需要扫描全表。当需要使用数据库事务时，该引擎当然是首选。由于锁的粒度更小，写操作不会锁定全表，所以在并发较高时，使用Innodb引擎会提升效率。但是使用行级锁也不是绝对的，如果在执行一个SQL语句时MySQL不能确定要扫描的范围，InnoDB表同样会锁全表。 12//这个就是select锁表的一种，不明确主键。增删改查都可能会导致锁全表，在以后我们会详细列出。SELECT * FROM products WHERE name='Mouse' FOR UPDATE; 适用场景： 经常更新的表，适合处理多重并发的更新请求。 支持事务。 可以从灾难中恢复（通过bin-log日志等）。 外键约束。只有他支持外键。 支持自动增加列属性auto_increment。 MySQL官方对InnoDB的讲解： InnoDB给MySQL提供了具有提交、回滚和崩溃恢复能力的事务安全（ACID兼容）存储引擎。 InnoDB锁定在行级并且也在SELECT语句提供一个Oracle风格一致的非锁定读，这些特色增加了多用户部署和性能。没有在InnoDB中扩大锁定的需要，因为在InnoDB中行级锁定适合非常小的空间。 InnoDB也支持FOREIGN KEY强制。在SQL查询中，你可以自由地将InnoDB类型的表与其它MySQL的表的类型混合起来，甚至在同一个查询中也可以混合。 InnoDB是为处理巨大数据量时的最大性能设计，它的CPU效率可能是任何其它基于磁盘的关系数据库引擎所不能匹敌的。 InnoDB被用来在众多需要高性能的大型数据库站点上产生。 补充：什么叫事务？简称ACID A 事务的原子性(Atomicity)：指一个事务要么全部执行,要么不执行.也就是说一个事务不可能只执行了一半就停止了.比如你从取款机取钱,这个事务可以分成两个步骤:1划卡,2出钱.不可能划了卡,而钱却没出来.这两步必须同时完成.要么就不完成. C 事务的一致性(Consistency)：指事务的运行并不改变数据库中数据的一致性.例如,完整性约束了a+b=10,一个事务改变了a,那么b也应该随之改变. I 独立性(Isolation）:事务的独立性也有称作隔离性,是指两个以上的事务不会出现交错执行的状态.因为这样可能会导致数据不一致. D 持久性(Durability）:事务的持久性是指事务执行成功以后,该事务所对数据库所作的更改便是持久的保存在数据库之中，不会无缘无故的回滚. MyIsam定义： MyIASM是MySQL默认的引擎，但是它没有提供对数据库事务的支持，也不支持行级锁和外键，因此当INSERT(插入)或UPDATE(更新)数据时即写操作需要锁定整个表，效率便会低一些。 MyIsam 存储引擎独立于操作系统，也就是可以在windows上使用，也可以比较简单的将数据转移到linux操作系统上去。 意味着：引擎在创建表的时候，会创建三个文件，一个是.frm文件用于存储表的定义，一个是.MYD文件用于存储表的数据，另一个是.MYI文件，存储的是索引。操作系统对大文件的操作是比较慢的，这样将表分为三个文件，那么.MYD这个文件单独来存放数据自然可以优化数据库的查询等操作。有索引管理和字段管理。MyISAM还使用一种表格锁定的机制，来优化多个并发的读写操作，其代价是你需要经常运行OPTIMIZE TABLE命令，来恢复被更新机制所浪费的空间。 适用场景： 不支持事务的设计，但是并不代表着有事务操作的项目不能用MyIsam存储引擎，可以在service层进行根据自己的业务需求进行相应的控制。 不支持外键的表设计。 查询速度很快，如果数据库insert和update的操作比较多的话不太适用。 整天 对表进行加锁的场景。 MyISAM极度强调快速读取操作。 MyIASM中存储了表的行数，于是SELECT COUNT(*) FROM TABLE时只需要直接读取已经保存好的值而不需要进行全表扫描。如果表的读操作远远多于写操作且不需要数据库事务的支持，那么MyIASM也是很好的选择。 缺点： 就是不能在表损坏后恢复数据。（是不能主动恢复）","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://caoler.cn/categories/Mysql/"}],"tags":[]},{"title":"学习Spring的长期or短期目标","slug":"学习Spring的长期目标or短期目标","date":"2018-07-13T14:27:11.000Z","updated":"2018-07-13T14:27:18.692Z","comments":true,"path":"/post/2018/SpringAims.html","link":"","permalink":"https://caoler.cn/post/2018/SpringAims.html","excerpt":"最近非常想研究透彻Spring，但是又找不到合适的方法。之前一直打算阅读Spring源码，但是又有人说 如果什么框架要你必须阅读源代码才能掌握，那这个框架一定很烂、不成熟，或者说至少处于成熟的前期。 显然Spring不是这样的框架。","text":"最近非常想研究透彻Spring，但是又找不到合适的方法。之前一直打算阅读Spring源码，但是又有人说 如果什么框架要你必须阅读源代码才能掌握，那这个框架一定很烂、不成熟，或者说至少处于成熟的前期。 显然Spring不是这样的框架。 想想自己详细认真读过spring所有项目的reference，并对所有API doc了如指掌吗？我直接开始读源代码干嘛？ 说明书和各种电器参数都不看就想把家里的电视拆了研究的，只能是熊孩子干出来的事。 有时候认为实战是最好的老师。 但是有些事情又是迫不得已必须去做的，必须得在正确的时间里做正确的事。 所以短期目标是看一下源码~嘻嘻，主要是Bean的加载，IOC原理，还有就是SpringAOP。 提供给自己一点资源： 这个是目前最新版的说明书：https://docs.spring.io/spring/docs/5.0.7.RELEASE/spring-framework-reference/ 大神翻译的中文版：https://muyinchen.gitbooks.io/spring-framework-5-0-0-m3/content/ 可以说非常想看英文原版了，奈何自己的英语水平实在是太差了！难受啊 :cry:","categories":[{"name":"SSM框架","slug":"SSM框架","permalink":"https://caoler.cn/categories/SSM框架/"},{"name":"Spring","slug":"SSM框架/Spring","permalink":"https://caoler.cn/categories/SSM框架/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://caoler.cn/tags/Spring/"}]},{"title":"《Spring实战》读书笔记3-SpringAOP","slug":"三、SpringAOP","date":"2018-07-13T14:25:11.000Z","updated":"2018-07-13T14:27:20.139Z","comments":true,"path":"/post/2018/SpringInAction-3.html","link":"","permalink":"https://caoler.cn/post/2018/SpringInAction-3.html","excerpt":"1. 参考 Spring 4 学习笔记5：Spring AOP 《Spring实战 第四版》 SpringAop 详尽教程","text":"1. 参考 Spring 4 学习笔记5：Spring AOP 《Spring实战 第四版》 SpringAop 详尽教程 2. AOP术语 通知（active） 切面的工作被称为通知，比如抄表员去每家每户抄电表的数据，这个动作（活动）就是通知。 通知一共包含以下五种： 前置通知（Before）：在目标方法被调用之前调用通知功能； 后置通知（After）：在目标方法完成之后调用通知，此时不会关心方法的输出是什么； 返回通知（After-returning）：在目标方法成功执行之后调用通知； 异常通知（After-throwing）：在目标方法抛出异常后调用通知； 环绕通知（Around）：通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为。 连接点（Join point） 可以被插入的时机 就是连接点。连接点是在应用执行过程中能够插入切面的一个点。这个点可以是调用方法时、抛出异常时、甚至修改一个字段时。切面代码可以利用这些点插入到应用的正常流程之中，并添加新的行为。 切点（Poincut） 如果说通知定义了切面的“什么”和“何时”的话，那么切点就定义了 “何处”。切点的定义会匹配通知所要织入的一个或多个连接点。我们通常使用明确的类和方法名称，或是利用正则表达式定义所匹配的类和方法名称来指定这些切点。有些AOP框架允许我们创建动态的切点，可以根据运行时的决策（比如方法的参数值）来决定是否应用通知。 切面（Aspect） 当抄表员开始一天的工作时，他知道自己要做的事情（报告用电量）和从哪些房屋收集信息。因此，他知道要完成工作所需要的一切东西。 切面是通知和切点的结合。通知和切点共同定义了切面的全部内容——它是什么，在何时和何处完成其功能。 引入（Introduction） 引入允许我们向现有的类添加新方法或属性 。例如，我们可以创建一个Auditable通知类，该类记录了对象最后一次修改时的状态。这很简单，只需一个方法，setLastModified(Date)，和一个实例变量来保存这个状态。然后，这个新方法和实例变量就可以被引入到现有的类中，从而可以在无需修改这些现有的类的情况下，让它们具有新的行为和状态。 织入（Weaving） 织入是把切面应用到目标对象并创建新的代理对象的过程。切面在指定的连接点被织入到目标对象中。在目标对象的生命周期里有多个点可以进行织入： 编译期：切面在目标类编译时被织入。这种方式需要特殊的编译器。AspectJ的织入编译器就是以这种方式织入切面的。 类加载期：切面在目标类加载到JVM时被织入。这种方式需要特殊的类加载器（ClassLoader），它可以在目标类被引入应用之前增强该目标类的字节码。AspectJ5的加载时织入（load-time weaving，LTW）就支持以这种方式织入切面。 运行期：切面在应用运行的某个时刻被织入。一般情况下，在织入切面时，AOP容器会为目标对象动态地创建一个代理对象。Spring AOP就是以这种方式织入切面的。 在AOP术语中这些关注点被称为横切关注点（crosscutting）。如下图所示： 通知（Advice）的类型： 类型 执行点 Before 在主方法调用之前执行 After 通知在主方法完成之后执行，不管主方法的调用结果如何 After-returnning 通知在主方法正常返回后执行。比如在不抛出异常时正常返回 After-throwing 通知在主方法抛出异常后执行 Around 通知包装了主方法，提供在方法调用一直或之后提供一些功能 3. 代码示例首先，我们定义被代理的接口和实现： 清单1. 被代理接口和实现 123456789101112131415161718192021// MyBean.javapackage org.archerie.aop.bean;public interface MyBean &#123; void sayHello(String msg);&#125;// MyBeanImpl.javapackage org.archerie.aop.bean;import org.springframework.stereotype.Component;// 使用spring @Component注解，加载到spring上下文中@Componentpublic class MyBeanImpl implements MyBean &#123; public void sayHello(String msg) &#123; System.out.println(msg); &#125;&#125; 接下来，我们就开始定义我们的切面。如下： 清单2. 切面 1234567891011121314151617181920212223242526272829303132package org.archerie.aop.aspect;import org.aspectj.lang.annotation.After;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import org.aspectj.lang.annotation.Pointcut;import org.springframework.stereotype.Component;@Component@Aspectpublic class AdviceExampleAspect &#123; // 定义切点 @Pointcut(\"execution(** org.archerie..*Bean.*(..))\") public void beanPointCut() &#123;&#125; @Before(\"beanPointCut()\") public void silenceCellPhone() &#123; System.out.println(\"手机静音！\"); &#125; @Before(\"execution(** org.archerie..MyBean.sayHello(String)) &amp;&amp; args(msg)\") public void printMsg(String msg) &#123; System.out.println(\"MyBean将要说的是：\" + msg); &#125; @After(\"beanPointCut()\") public void applause() &#123; System.out.println(\"鼓掌！鼓掌！\"); &#125;&#125; 现在，我们就需要定义我们的spring配置文件了。我们选择Java配置的方式来配置Spring。 清单3. Spring配置 123456789101112package org.archerie.aop.config;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.EnableAspectJAutoProxy;@Configuration@EnableAspectJAutoProxy@ComponentScan(basePackages = &#123;\"org.archerie.aop\"&#125;)public class AopJavaConfig &#123;&#125; 以上，切面就准备好了，现在就差使用了。下面，使用JUnit来进行测试： 清单4. JUnit测试切面 1234567891011121314151617181920212223242526package org.archerie.aop;import org.archerie.aop.bean.MyBean;import org.archerie.aop.bean.MyOtherBean;import org.archerie.aop.config.AopJavaConfig;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes = AopJavaConfig.class)public class AspectTest &#123; @Autowired MyBean myBean; @Autowired MyOtherBean otherBean; @Test public void testAspect() &#123; myBean.sayHello(\"我要把你做成一个玩偶！\"); &#125;&#125; 以上，就是完成的代码示例。现在运行查看结果： MyBean将要说的是：我要把你做成一个玩偶！手机静音！我要把你做成一个玩偶！鼓掌！鼓掌！ 4. 术语详解Spring AOP主要由连接点、切入点和通知组成切面。而切入点是用来选择某一范围的连接点的，所以我们首先讨论如何定义切入点。这里要说明一点的就是：Spring AOP只支持一种Join point，就是方法的执行。所以，以下切入点（Pointcut）只能选取方法执行的连接点（Join Point）。看我：:happy: 4.1. 切入点（Pointcuts）以下是SpringAOP支持的AspectJ切入点： AspectJ表达式 描述 execution 匹配方法执行的连接点，这是使用Spring AOP时主要使用的切入点 within 匹配特定类型中的连接点（在Spring AOP中则限制为匹配类型中的方法执行） this 匹配Spring AOP代理对象中的连接点（在Spring AOP中为方法的执行），注意匹配的是spring aop代理对象为指定的类型。this表达式必须使用完整的限定类名，不能使用通配符。 target 匹配目标对象中的连接点（在Spring AOP中为方法的执行），但是目标对象得为特定的类型。target表达式必须使用完整的限定类名，不能使用通配符。 args 匹配参数为特定类型实例的连接点（Spring AOP中为方法的执行） @target 匹配特定的连接点（Spring AOP中为方法执行），执行方法的类拥有指定类型的注解 @args 匹配特定的连接点（Spring AOP中为方法的执行），运行时传入的参数必须拥有特定类型的注解 @within 用于匹配拥有特定注解的类型中的连接点 @annotation 用于匹配拥有特定注解的连接点（Spring AOP中为方法的执行） bean Spring AOP扩展的切入点，可以匹配特定的类名中的连接点（方法的执行） 4.1.1 通配符（Wildcards）在使用切入点表达式的时候，有些时候我们可以使用通配符：*、..、+。 符号 含义 .. 在类型匹配时，匹配任何以 .，以 . 结尾的包名。在方法定义时匹配任意数量的参数。 + 匹配给定类型的任意子类型。 * 匹配数量的任意字符，除了*字符。 4.1.2 类型（Type）指示符通过类型来过滤方法，比如接口、类名或者是包名。Spring提供within切入点，使用方式如下。type name可以被替换为package name或者class name。 1within(&lt;type name&gt;) 以下是一些例子： within(com.xyz.web..*)：匹配com.xyz.web包下面的所有类中方法的执行，而且因为使用了 .. 通配符，所以可以匹配com.xyz.web的所有子包。*通配符匹配所有的类名，所以可以匹配所有类中方法的执行。 with(com.xyz.web.*)：匹配com.xyz.web包下面所有类中方法的执行。因为没有使用..通配符，所有只是匹配到web包，不包括子包。*一样匹配所有的类名。 with(com.xyz.service.AccountService)：匹配AccountService类下面所有方法的执行。 with(com.xyz.interface.MyServiceInterface+)：匹配所有实现了MyServiceInterface接口的类中的所有方法的执行。 with(com.xyz.service.MyBaseService+)：匹配MyBaseService类和它的子类。 4.1.3 方法（Method）指示符匹配特定方法的执行，可以使用execution关键字。execution表达式的格式如下： 123execution(modifiers-pattern? ret-type-pattern declaring-type-pattern?name-pattern(param-pattern) throws-pattern?)123 其中，所有的部分除了返回值类型（ret-type-pattern）、方法名（name-pattern）和参数（param-pattern）都是可选的。 修饰符（modifiers-pattern） public、protected或private，也可以使用*匹配所有的修饰符。返回值类型（ret-type-pattern） 匹配特定的返回类型。大多数情况都是使用*通配符匹配所有的返回类型。方法名（name-pattern） 匹配执行方法的名称，可以使用*通配符匹配任意数量够的字符。如果要匹配特定类中方法的执行，就必须指定 类名（declaring-type-pattern） 部分，这部分使用的格式参考 4.1.2 类型指示符。参数列表（param-pattern） 部分，指定方法的参数必须满足的格式。()匹配没有参数的方法，(..)匹配任意数量的参数。当然你也可以使用*匹配任意一个参数的类型，比如(\\*, String)匹配第二个参数为String类型，第一个参数为任意类型的情况。异常列表（throws-pattern） 匹配全限定类名异常类型，如果有多个异常，使用,分割，比如throws java.lang.IllegalArgumentException, java.lang.ArrayIndexOutOfBoundsException。 示例如下： execution(public * *(..))：匹配所有的public方法的执行。 execution(* set*(..))：匹配所有方法名以set开头的方法的执行。 execution(* com.xyz.service.AccountService.*(..))：匹配AccountService接口下所有方法的执行。 execution(* com.xyz.service.*.*(..))：匹配包com.xyz.service下所有类（或接口）下的所有方法的执行。 execution(* com.xyz.service..*.*(..))：匹配包com.xyz.service和其子包中的类（或接口）下的所有方法的执行。 execution(* *(.., String)：匹配所有最后一个参数为String的方法的执行。 execution(* ..Sample+.sampleGenericCollectionMethod(*))：匹配任意以.Sample结尾的包，以及其子包中的sampleGenericCollectionMethod方法的执行，且具有唯一的任意类型的参数。 execution(* *(*, String, ..)：匹配第一个参数为任意类型，第二个参数为String，后面可拥有任意个参数的方法的执行。 4.1.4 其他的切入点指示符 bean(*Service)：所有bean名称以Service结尾的bean。 @annotation(org.springframework.transaction.annotation.Transactional)：匹配所有连接点（Spring AOP中方法的执行）拥有@Transaction注解在方法上。 this(com.xyz.service.AccountService)：匹配实现了AccountService接口的代理类中的所有连接点（Spring AOP中方法的执行） target(com.xyz.service.AccountService)：匹配实现了AccountService接口的目标类的所有连接点（Spring AOP中方法的执行） 4.1.5 组合多个切入点很多时候可能一个切入点并不能满足我们的需求，这时候就需要组合使用切入点来限制匹配的切入点。在Spring AOP中可以使用and(&amp;&amp;)、or(||)和not(!)。既可以使用文字的形式也可以使用符号的形式。比如 execution(* concert.Performance.perform(..)) &amp;&amp; within(concert.*))。 4.2 定义切面（@Aspect）现在，我们可以使用我们学到的来定义切面了。在Spring中可以使用XML和注解的方式来定义切面，本文将只讨论使用注解定义切面的方式。Spring支持使用AspectJ的注解@Aspect来定义切面，就像清单2所使用的那样。但是，如果我们要让Spring知道我们定义了一个切面的话，还必须把这个切面声明为一个Bean。所以我们使用@Component注解，这样Spring就会识别它，并把它当做切面来看待了。 123@Component@Aspectpublic class AdviceExampleAspect &#123;&#125; 4.3 定义切点（@Pointcut）切点（Pointcut）定义使用@Pointcut注解。注解中我们就可以使用4.1 切点中的表达式来选择连接点。定义切点时，可以组合多个切点。 123456789@Pointcut(\"execution(public * *(..))\")private void anyPublicOperation() &#123;&#125;@Pointcut(\"within(com.xyz.someapp.trading..*)\")private void inTrading() &#123;&#125;// 组合切点@Pointcut(\"anyPublicOperation() &amp;&amp; inTrading()\")private void tradingOperation() &#123;&#125; 4.4 定义通知在清单2中我们已经定义了@Before和@After通知，也可以使用其他类型的通知。这里主要介绍如何使用@Around注解，定义 环绕（Around） 通知类型。 1234567891011121314151617181920212223242526package org.archerie.aop.aspect;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.Around;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Pointcut;import org.springframework.stereotype.Component;@Component@Aspectpublic class AdviceAroundAspect &#123; @Pointcut(\"execution(** org.archerie..*Bean.*(..))\") public void beanPointCut() &#123;&#125; @Around(\"beanPointCut()\") public void watchBean(ProceedingJoinPoint jp) &#123; try &#123; System.out.println(\"手机静音！\"); jp.proceed(); System.out.println(\"鼓掌！鼓掌！\"); &#125; catch (Throwable e) &#123; System.out.println(\"投诉！投诉！\"); &#125; &#125;&#125; 在Around通知类型中，我们可以定义具体方法运行前或者后的逻辑。","categories":[{"name":"SSM框架","slug":"SSM框架","permalink":"https://caoler.cn/categories/SSM框架/"},{"name":"Spring","slug":"SSM框架/Spring","permalink":"https://caoler.cn/categories/SSM框架/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://caoler.cn/tags/Spring/"}]},{"title":"SpringBoot配置RestTemplate的代理和超时时间","slug":"SpringBoot配置RestTemplate的代理和超时时间","date":"2018-06-30T07:07:34.000Z","updated":"2018-06-30T07:08:57.574Z","comments":true,"path":"/post/2018/SpringBoot-RestTemplate.html","link":"","permalink":"https://caoler.cn/post/2018/SpringBoot-RestTemplate.html","excerpt":"对于某些特殊需求需要使用代理的时候，使用此方法进行配置","text":"对于某些特殊需求需要使用代理的时候，使用此方法进行配置 application.properties：12345678#代理设置proxy.enabled=falseproxy.host=192.168.18.233proxy.port=8888#REST超时配置rest.ReadTimeout=35000rest.ConnectTimeout=5000 代理配置类：12345678910111213141516171819202122232425262728import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.stereotype.Component;import lombok.Data;/** * 网络代理设置 * * @author yangzhilong * */@Component@ConfigurationProperties(prefix=\"proxy\")@Datapublic class ProxyConfig &#123; /** * 是否启用代理 */ private Boolean enabled; /** * 代理主机地址 */ private String host; /** * 代理端口 */ private Integer port;&#125; SpringBoot的Configuration：123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.net.InetSocketAddress;import java.net.Proxy;import java.net.SocketAddress;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Value;import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.http.client.SimpleClientHttpRequestFactory;import org.springframework.web.client.RestTemplate;import com.yzl.vo.ProxyConfig;@Configuration@ConditionalOnClass(ProxyConfig.class)public class RestConfiguration &#123; @Value(\"$&#123;rest.ReadTimeout&#125;\") private int readTimeout; @Value(\"$&#123;rest.ConnectTimeout&#125;\") private int connectionTimeout; @Autowired private ProxyConfig proxyConfig; @Bean public SimpleClientHttpRequestFactory httpClientFactory() &#123; SimpleClientHttpRequestFactory httpRequestFactory = new SimpleClientHttpRequestFactory(); httpRequestFactory.setReadTimeout(readTimeout); httpRequestFactory.setConnectTimeout(connectionTimeout); if(proxyConfig.getEnabled())&#123; SocketAddress address = new InetSocketAddress(proxyConfig.getHost(), proxyConfig.getPort()); Proxy proxy = new Proxy(Proxy.Type.HTTP, address); httpRequestFactory.setProxy(proxy); &#125; return httpRequestFactory; &#125; @Bean public RestTemplate restTemplate(SimpleClientHttpRequestFactory httpClientFactory) &#123; RestTemplate restTemplate = new RestTemplate(httpClientFactory); return restTemplate; &#125;&#125; 如果不希望这种全局的超时时间污染正常的SpringCloud中restTemplate的时间设置，可以使用如下方法：12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.yzl.autoconfig;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.http.client.HttpComponentsClientHttpRequestFactory;import org.springframework.web.client.RestTemplate;import com.yzl.util.RestClient;/** * 工具类引导装配类 * @author yangzhilong * */@Configurationpublic class RestClientAutoConfiguration &#123; @Value(\"$&#123;rest.config.connectTimeout:10000&#125;\") private int connectTimeout; @Value(\"$&#123;rest.config.readTimeout:30000&#125;\") private int readTimeout; /** * 使用Bootstrap来装配RestClient中的RestTemplate属性， * 避免直接装配RestTemplate来污染了正常的spring Cloud的调用 * @return */ @Bean public RestClientBootstrap bootstrap()&#123; HttpComponentsClientHttpRequestFactory httpRequestFactory = new HttpComponentsClientHttpRequestFactory(); httpRequestFactory.setConnectTimeout(connectTimeout); httpRequestFactory.setReadTimeout(readTimeout); RestTemplate restTemplate = new RestTemplate(httpRequestFactory); RestClient.setRestTemplate(restTemplate); return new RestClientBootstrap(); &#125; /** * 空的引导类 * @author yangzhilong * */ static class RestClientBootstrap &#123; &#125;&#125; RestClient工具类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778package com.yzl.util;import java.util.Map;import org.springframework.http.HttpEntity;import org.springframework.http.HttpHeaders;import org.springframework.http.HttpMethod;import org.springframework.http.MediaType;import org.springframework.util.LinkedMultiValueMap;import org.springframework.util.MultiValueMap;import org.springframework.web.client.RestTemplate;import com.alibaba.fastjson.JSON;/** * HTTP请求帮助类 * @author yangzhilong * */public class RestClient &#123; private static RestTemplate restTemplate; /** * 注入实现类 * @param client */ public static void setRestTemplate(RestTemplate client) &#123; restTemplate = client; &#125; /** * 无参数或者参数附带在url中 * @param url * @return */ public static String get(String url) &#123; return restTemplate.getForObject(url , String.class); &#125; /** * json格式的post提交 * @param obj * @param url * @return */ public static String postJson(String url, Object obj) &#123; HttpHeaders headers = new HttpHeaders(); MediaType type = MediaType.parseMediaType(\"application/json; charset=UTF-8\"); headers.setContentType(type); headers.add(\"Accept\", MediaType.APPLICATION_JSON.toString()); String result = null; if(obj == null)&#123; result = \"&#123;&#125;\"; &#125;else&#123; result = JSON.toJSONString(obj); &#125; HttpEntity&lt;String&gt; formEntity = new HttpEntity&lt;String&gt;(result,headers); return restTemplate.postForObject(url , formEntity, String.class); &#125; /** * form格式的post提交 * @param map * @param url * @return */ public static String postForm(String url, Map&lt;String , String&gt; map)&#123; HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED); MultiValueMap&lt;String, String&gt; params= new LinkedMultiValueMap&lt;&gt;(); for(Map.Entry&lt;String ,String&gt; me : map.entrySet())&#123; params.add(me.getKey() , me.getValue()); &#125; HttpEntity&lt;MultiValueMap&lt;String, String&gt;&gt; requestEntity = new HttpEntity&lt;&gt;(params, headers); return restTemplate.exchange(url, HttpMethod.POST, requestEntity, String.class).getBody(); &#125;&#125; 然后实际发起HTTP请求的时候使用上面的工具类即可！ 参考：https://www.cnblogs.com/yangzhilong/p/6640207.html","categories":[{"name":"SSM框架","slug":"SSM框架","permalink":"https://caoler.cn/categories/SSM框架/"},{"name":"SpringBoot","slug":"SSM框架/SpringBoot","permalink":"https://caoler.cn/categories/SSM框架/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://caoler.cn/tags/SpringBoot/"}]},{"title":"利用maven分环境打包SpringBoot项目","slug":"利用maven按环境打包SpringBoot的不同配置文件","date":"2018-06-11T14:13:22.000Z","updated":"2018-06-11T14:13:34.887Z","comments":true,"path":"/post/2018/SpringBootMavenPackage.html","link":"","permalink":"https://caoler.cn/post/2018/SpringBootMavenPackage.html","excerpt":"一个应用系统需要在不同的阶段以不同的配置文件来进行部署，在开发阶段需要开发时的配置文件启动服务，测试阶段或者生产阶段都是不同的配置，所以我们需要利用maven按照环境来将不同环境的配置文件按环境打包，减少我们的维护成本。","text":"一个应用系统需要在不同的阶段以不同的配置文件来进行部署，在开发阶段需要开发时的配置文件启动服务，测试阶段或者生产阶段都是不同的配置，所以我们需要利用maven按照环境来将不同环境的配置文件按环境打包，减少我们的维护成本。 在pom文件中进行如下配置： 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;profiles&gt; &lt;profile&gt; &lt;id&gt;dev&lt;/id&gt; &lt;properties&gt; &lt;profileActive&gt;dev&lt;/profileActive&gt; &lt;/properties&gt; &lt;activation&gt; &lt;activeByDefault&gt;false&lt;/activeByDefault&gt; &lt;/activation&gt; &lt;/profile&gt; &lt;profile&gt; &lt;id&gt;test&lt;/id&gt; &lt;properties&gt; &lt;profileActive&gt;test&lt;/profileActive&gt; &lt;/properties&gt; &lt;activation&gt; &lt;activeByDefault&gt;false&lt;/activeByDefault&gt; &lt;/activation&gt; &lt;/profile&gt; &lt;/profiles&gt; &lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;application-$&#123;profileActive&#125;.properties&lt;/include&gt; &lt;include&gt;application.properties&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;delimiters&gt; &lt;delimiter&gt;@&lt;/delimiter&gt; &lt;/delimiters&gt; &lt;useDefaultDelimiters&gt;false&lt;/useDefaultDelimiters&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; application.yml中添加如下配置 123spring: profiles: active=@profileActive@ 通过mvn package -P dev进行打包就会只将开发环境的配置文件扔到对应的jar包或者war包中 踩坑经历： 在我按照上述文件配置完成之后，多环境的文件已经生效了，但是！ 我的所有方法都报这样的错误：1invalid bound statement (not found) 网上查阅许久得知 1234567891011&lt;!-- 如果不添加此节点mybatis的mapper.xml文件都会被漏掉。 --&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt;","categories":[{"name":"SSM框架","slug":"SSM框架","permalink":"https://caoler.cn/categories/SSM框架/"},{"name":"SpringBoot","slug":"SSM框架/SpringBoot","permalink":"https://caoler.cn/categories/SSM框架/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://caoler.cn/tags/SpringBoot/"}]},{"title":"《Spring实战》读书笔记2-高级装配","slug":"二、高级装配","date":"2018-06-11T14:12:00.000Z","updated":"2018-06-11T14:12:04.543Z","comments":true,"path":"/post/2018/SpringInAction-2.html","link":"","permalink":"https://caoler.cn/post/2018/SpringInAction-2.html","excerpt":"在Spring装配Bean一文中，我们探讨了Spring的三种管理bean的方式：自动装配、基于JavaConfig、基于XML文件。本篇（对应《Spring实战第三章》）将探讨一些Spring中关于bean的管理的高级知识，这些技能你可能不会每天都用，但是非常重要。","text":"在Spring装配Bean一文中，我们探讨了Spring的三种管理bean的方式：自动装配、基于JavaConfig、基于XML文件。本篇（对应《Spring实战第三章》）将探讨一些Spring中关于bean的管理的高级知识，这些技能你可能不会每天都用，但是非常重要。 环境 and profiles在软件开发中，常常设置不同的运行环境：开发环境、预发环境、性能测试环境和生产环境等等。 不同的环境下，应用程序的配置项也不同，例如数据库配置、远程服务地址等。以数据库配置为例子，在开发环境中你可能使用一个嵌入式的内存数据库，并将测试数据放在一个脚本文件中。例如，在一个Spring的配置类中，可能需要定义如下的bean：1234567@Bean(destroyMethod = \"shutdown\")public DataSource dataSource() &#123; return new EmbeddedDatabaseBuilder() .addScript(\"classpath:schema.sql\") .addScript(\"classpath:test-data.sql\") .build();&#125; 使用EmbeddedDatabaseBuilder这个构建器可以建立一个内存数据库，通过指定路径下的schema.sql文件中的内容可以建立数据库的表定义，通过test-data.sql可以准备好测试数据。 开发环境下可以这么用，但是在生产环境下不可以。在生产环境下，你可能需要从容器中使用JNDI获取DataSource对象，这中情况下，对应的创建代码是：123456789@Beanpublic DataSource dataSource() &#123; JndiObjectFactoryBean jndiObjectFactoryBean = new JndiObjectFactoryBean(); jndiObjectFactoryBean.setJndiName(\"jdbc/myDS\"); jndiObjectFactoryBean.setResourceRef(true); jndiObjectFactoryBean.setProxyInterface(javax.sql.DataSource.class); return (DataSource) jndiObjectFactoryBean.getObject();&#125; 使用JNDI管理DataSource对象，很适合生产环境，但是对于日常开发环境来说太复杂了。 另外，在QA环境下你也可以选择另外一种DataSource配置，可以选择使用普通的DBCP连接池，例如： 1234567891011@Bean(destroyMethod = \"close\")public DataSource dataSource() &#123; BasicDataSource dataSource = new BasicDataSource(); dataSource.setUrl(\"jdbc:h2:tcp://dbserver/~/test\"); dataSource.setDriverClassName(\"org.h2.Driver\"); dataSource.setUsername(\"sa\"); dataSource.setPassword(\"password\"); dataSource.setInitialSize(20); dataSource.setMaxActive(30); return dataSource;&#125; 上述三种办法可以为不同环境创建各自需要的javax.sql.DataSource实例，这个例子很适合介绍不同环境下创建bean，那么有没有一种办法：只需要打包应用一次，然后部署到不同的开发环境下就会自动选择不同的bean创建策略。一种方法是创建三个独立的配置文件，然后利用Maven profiles的预编译命令处理在特定的环境下打包哪个配置文件到最终的应用中。这种解决方法有一个问题，即在切换到不同环境时，需要重新构建应用——从开发环境到测试环境没有问题，但是从测试环境到生产环境也需要重新构建则可能引入一定风险。 Spring提供了对应的方法，使得在环境切换时不需要重新构建整个应用。 配置profile beansSpring提供的方法不是在构件时针对不同的环境决策，而是在运行时，这样，一个应用只需要构建一次，就可以在开发、QA和生产环境运行。 在Spring 3.1之中，可以使用@Profile注解来修饰JavaConfig类，当某个环境对应的profile被激活时，就使用对应环境下的配置类。 在Spring3.2之后，则可以在函数级别使用@Profile注解（是的，跟@Bean注解同时作用在函数上），这样就可以将各个环境的下的bean定义都放在同一个配置类中，还是以之前的例子： 利用注解配置 123456789101112131415161718192021222324252627282930import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Profile;import org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseBuilder;import org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseType;import org.springframework.jndi.JndiObjectFactoryBean;import javax.sql.DataSource;@Configurationpublic class DataSourceConfig &#123; @Bean(destroyMethod = \"shutdown\") @Profile(\"dev\") //为dev peofile装配的bean public DataSource embeddedDataSource() &#123; return new EmbeddedDatabaseBuilder() .setType(EmbeddedDatabaseType.H2) .addScript(\"classpath:schema.sql\") .addScript(\"classpath:test-data.sql\") .build(); &#125; @Bean @Profile(\"prod\") //为prod peofile装配的bean public DataSource dataSource() &#123; JndiObjectFactoryBean jndiObjectFactoryBean = new JndiObjectFactoryBean(); jndiObjectFactoryBean.setJndiName(\"jdbc/myDS\"); jndiObjectFactoryBean.setResourceRef(true); jndiObjectFactoryBean.setProxyInterface(javax.sql.DataSource.class); return (DataSource) jndiObjectFactoryBean.getObject(); &#125;&#125; 除了被@Profile修饰的其他bean，无论在什么开发环境下都会被创建。 利用XML文件配置和在JavaConfig的用法一样，可以从文件级别定义环境信息，也可以将各个环境的bean放在一个XML配置文件中。 1234567891011121314151617181920212223242526272829303132333435&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:jdbc=\"http://www.springframework.org/schema/jdbc\" xmlns:p=\"http://www.springframework.org/schema/p\" xmlns:jee=\"http://www.springframework.org/schema/jee\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc.xsd\"&gt; &lt;beans profile=\"dev\"&gt; &lt;jdbc:embedded-database id=\"dataSource\"&gt; &lt;jdbc:script location=\"classpath:schema.sql\"/&gt; &lt;jdbc:script location=\"classpath:test-data.sql\"/&gt; &lt;/jdbc:embedded-database&gt; &lt;/beans&gt; &lt;beans profile=\"qa\"&gt; &lt;bean id=\"dataSource\" class=\"org.apache.commons.dbcp.BasicDataSource\" destroy-method=\"close\" p:url=\"jdbc:h2:tcp://dbserver/~/test\" p:driverClassName=\"org.h2.Driver\" p:username=\"sa\" p:password=\"password\" p:initialSize=\"20\" p:maxActive=\"30\" /&gt; &lt;/beans&gt; &lt;beans profile=\"prod\"&gt; &lt;jee:jndi-lookup id=\"dataSource\" jndi-name=\"jdbc/MyDatabase\" resource-ref=\"true\" proxy-interface=\"javax.sql.DataSource\"/&gt; &lt;/beans&gt;&lt;/beans&gt; 上述三个javax.sql.DataSource的bean，ID都是dataSource，但是在运行的时候只会创建一个bean。 激活profilesSpring提供了spring.profiles.active和spring.profiles.default这两个配置项定义激活哪个profile。如果应用中设置了spring.profiles.active选项，则Spring根据该配置项的值激活对应的profile，如果没有设置spring.profiles.active，则Spring会再查看spring.profiles.default这个配置项的值，如果这两个变量都没有设置，则Spring只会创建没有被profile修饰的bean。 有下列几种方法设置上述两个变量的值： DispatcherServlet的初始化参数 web应用的上下文参数(context parameters) JNDI项 环境变量 JVM系统属性 在集成测试类上使用@ActiveProfiles注解 开发人员可以按自己的需求设置spring.profiles.active和spring.profiles.default这两个属性的组合。 作者推荐在web应用的web.xml文件中设置spring.profiles.default属性——通过设置DispatcherServlet的初始参数和&lt;context-param&gt;标签。1234567891011121314151617181920212223242526272829303132333435&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd\" version=\"3.1\"&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/spring-mvc-context.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!--为上下文设置的默认profile--&gt; &lt;context-param&gt; &lt;param-name&gt;spring.profiles.default&lt;/param-name&gt; &lt;param-value&gt;dev&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;servlet&gt; &lt;servlet-name&gt;appServletName&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--为servlet设置的默认profile--&gt; &lt;init-param&gt; &lt;param-name&gt;spring.profiles.default&lt;/param-name&gt; &lt;param-value&gt;dev&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;appServletName&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 按照上述方法设置spring.profiles.default属性，任何开发人员只需要下载源码就可以在开发环境中运行程序以及测试。 然后，当应用需要进入QA、生产环境时，负责部署的开发者只需要通过系统属性、环境变量或者JNDI等方法设置spring.profiles.active属性即可，因为spring.profiles.active优先级更高。 TESTING WITH PROFILES在运行集成测试时，可能希望运行跟生产环境下相同的配置；但是，如果配置重需要的beans被profiles修饰的，则需要在跑单元测试之前激活对应的profiles。 Spring提供了@ActiveProfiles注解来激活指定的profiles，用法如下： 12345@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes = SoundSystemConfig.class)@ActiveProfiles(\"dev\")public class SoundSystemTest &#123;&#125; 条件化的bean假设你希望只有在项目中引入特定的依赖库时、或者只有当特定的bean已经被创建时、或者是设置了某个环境变量时，某个bean才被创建。 Spring 4之前很难实现这种需求，不过在Spring 4中提出了一个新的注解——@Conditional，该注解作用于@Bean注解修饰的方法上，通过判断指定的条件是否满足来决定是否创建该bean。 举个例子，工程中有一个MagicBean，你希望只有当magic环境变量被赋值时才创建MagicBean，否则该Bean的创建函数被忽略。12345@Bean@Conditional(MagicExistsCondition.class)public MagicBean magicBean() &#123; return new MagicBean();&#125; 这个例子表示：只有当MagicExistsCondition类已经存在时，才会创建MagicBean。 @Conditional注解的源码列举如下12345678910111213package org.springframework.context.annotation;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;import org.springframework.context.annotation.Condition;@Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)public @interface Conditional &#123; Class&lt;? extends Condition&gt;[] value();&#125; 可以看出，传入@Conditional注解的类一定要实现Condition接口，该接口提供matchs()方法——如果matches()方法返回true，则被@Conditional注解修饰的bean就会创建，否则对应的bean不会创建。 在这个例子中，MagicExistsCondition类应该实现Condition接口，并在matches()方法中实现具体的判断条件，代码如下所示：1234567891011import org.springframework.context.annotation.Condition;import org.springframework.context.annotation.ConditionContext;import org.springframework.core.env.Environment;import org.springframework.core.type.AnnotatedTypeMetadata;public class MagicExistsCondition implements Condition &#123; public boolean matches(ConditionContext conditionContext, AnnotatedTypeMetadata annotatedTypeMetadata) &#123; Environment env = conditionContext.getEnvironment(); return env.containsProperty(\"magic\"); //检查magic环境变量是否被设置 &#125;&#125; 上述代码中的matchs()方法简单且有效：它首先获取Environment变量，然后再判断环境变量中是否存在magic属性。在这个例子中，magic的值是多少并不重要，它只要存在就好。 MagicExistsCondition的matchs()方法是通过ConditionContext获取了Environment实例。matchs()方法的参数有两个：ConditionContext和AnnotatedTypeMetadata，分别看下这两个接口的源码： ConditionContext 1234567public interface ConditionContext &#123; BeanDefinitionRegistry getRegistry(); ConfigurableListableBeanFactory getBeanFactory(); Environment getEnvironment(); ResourceLoader getResourceLoader(); ClassLoader getClassLoader();&#125; 利用ConditionContext接口可做的事情很多，列举如下： 通过getRegistry()方法返回的BeanDefinitionRegistry实例，可以检查bean的定义； 通过getBeanFactory()方法返回的ConfigurableListableBeanFactory实例，- 可以检查某个bean是否存在于应用上下文中，还可以获得该bean的属性； 通过getEnvironment()方法返回的Environment实例，可以检查指定环境变量是否被设置，还可以获得该环境变量的值； 通过getResourceLoader()方法返回的ResourceLoader实例，可以得到应用加载的资源包含的内容； 通过getClassLoader()方法返回的ClassLoader实例，可以检查某个类是否存在。 AnnotatedTypeMetadata 1234567public interface AnnotatedTypeMetadata &#123; boolean isAnnotated(String var1); Map&lt;String, Object&gt; getAnnotationAttributes(String var1); Map&lt;String, Object&gt; getAnnotationAttributes(String var1, boolean var2); MultiValueMap&lt;String, Object&gt; getAllAnnotationAttributes(String var1); MultiValueMap&lt;String, Object&gt; getAllAnnotationAttributes(String var1, boolean var2);&#125; 通过isAnnotated()方法可以检查@Bean方法是否被指定的注解类型修饰；通过其他方法可以获得修饰@Bean方法的注解的属性。 从Spring 4开始，@Profile注解也利用@Conditional注解和Condition接口进行了重构。作为分析@Conditional注解和Condition接口的另一个例子，我们可以看下在Spring 4中@Profile注解的实现。1234567@Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)@Documented@Conditional(&#123;ProfileCondition.class&#125;)public @interface Profile &#123; String[] value();&#125; 可以看出，@Profile注解的实现被@Conditional注解修饰，并且依赖于ProfileCondition类——该类是Condition接口的实现。如下列代码所示，ProfileCondition利用ConditionContext和AnnotatedTypeMetadata两个接口提供的方法进行决策。12345678910111213141516171819202122232425class ProfileCondition implements Condition &#123; ProfileCondition() &#123; &#125; public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) &#123; if(context.getEnvironment() != null) &#123; MultiValueMap attrs = metadata.getAllAnnotationAttributes(Profile.class.getName()); if(attrs != null) &#123; Iterator var4 = ((List)attrs.get(\"value\")).iterator(); Object value; do &#123; if(!var4.hasNext()) &#123; return false; &#125; value = var4.next(); &#125; while(!context.getEnvironment().acceptsProfiles((String[])((String[])value))); return true;//传给@Profile注解的参数对应的环境profiles已激活 &#125; &#125; return true; //默认为true &#125;&#125; 可以看出，这代码写得不太好理解:ProfileCondition通过AnnotatedTypeMetadata实例获取与@Profile注解相关的所有注解属性；然后检查每个属性的值（存放在value实例中），对应的profiles别激活——即context.getEnvironment().acceptsProfiles(((String[]) value))的返回值是true，则matchs()方法返回true。 Environment类提供了可以检查profiles的相关方法，用于检查哪个profile被激活： String[] getActiveProfiles()——返回被激活的profiles数组； String[] getDefaultProfiles()——返回默认的profiles数组； boolean acceptsProfiles(String…profiles)——如果某个profiles被激活，则返回true。 处理自动装配中的歧义性在上文中介绍了如何通过自动装配让Spring自动简历bean之间的依赖关系——自动装配非常有用，通过自动装配可以减少大量显式配置代码。不过，自动装配（autowiring）要求bean的匹配具备唯一性，否则就会产生歧义，从而抛出异常。 举个例子说明自动装配的歧义性，假设你有如下自动装配的代码：1234@Autowiredpublic void setDessert(Dessert dessert) &#123; this.dessert = dessert;&#125; Dessert是一个接口，有三个对应的实现：123456@Componentpublic class Cake implements Dessert &#123; ... &#125;@Componentpublic class Cookies implements Dessert &#123; ... &#125;@Componentpublic class IceCream implements Dessert &#123; ... &#125; 因为上述三个类都被@Component注解修饰，因此都会被component-scanning发现并在应用上下文中创建类型为Dessert的bean；然后，当Spring试图为setDessert()方法装配对应的Dessert参数时，就会面临多个选择；然后Spring就会抛出异常——NoUniqueBeanDefinitionException。 虽然在实际开发中并不会经常遇到这种歧义性，但是它确实是个问题，幸运的是Spring也提供了对应的解决办法。 @Primary指定优先bean在定义bean时，可以通过指定一个优先级高的bean来消除自动装配过程中遇到的歧义问题。 在上述例子中，可以选择一个最重要的Bean，用@Primary注解修饰：123@Component@Primarypublic class IceCream implements Dessert &#123; ... &#125; 如果你没有使用自动扫描，而是使用基于Java的显式配置文件，则如下定义@Bean方法：12345@Bean@Primarypublic Dessert iceCream() &#123; return new IceCream();&#125; 如果使用基于XML文件的显式配置，则如下定义：123&lt;bean id=\"iceCream\" class=\"com.dasserteater.IceCream\" primary=\"true\" /&gt; 不论哪种形式，效果都一样：告诉Spring选择primary bean来消除歧义。不过，当应用中指定多个Primary bean时，Spring又不会选择了，再次遇到歧义。Spring还提供了功能更强大的歧义消除机制——@Qualifiers注解。 @Qualifier指定bean的ID由于在实际开发中，这种情况的出现实在是太罕见了，所以跳过这一小节，当实际遇到了再来回头看吧。 bean的作用域默认情况下，Spring应用上下文中的bean都是单例对象，也就是说，无论给某个bean被多少次装配给其他bean，都是指同一个实例。 大部分情况下，单例bean很好用：如果一个对象没有状态并且可以在应用中重复使用，那么针对该对象的初始化和内存管理开销非常小。 但是，有些情况下你必须使用某中可变对象来维护几种不同的状态，因此形成非线程安全。在这种情况下，把类定义为单例并不是一个好主意——该对象在重入使用的时候可能遇到线程安全问题。 Spring定义了几种bean的作用域，列举如下： (单例)Singleton——在整个应用中只有一个bean的实例； (原型)Prototype——每次某个bean被装配给其他bean时，都会创建一个新的实例； (会话)Session——在web应用中，在每次会话过程中只创建一个bean的实例； (请求)Request——在web应用中，在每次http请求中创建一个bean的实例。 Singleton域是默认的作用域，如前所述，对于可变类型来说并不理想。我们可以使用@Scope注解——和@Component或@Bean注解都可以使用。 例如，如果你依赖component-scanning发现和定义bean，则可以用如下代码定义prototype bean：123@Component@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)public class Notepad&#123; ... &#125; 除了使用SCOPE_PROTOTYPE字符串指定bean的作用域，还可以使用@Scope(“prototype”)，但使用ConfigurableBeanFactory.SCOPE_PROTOTYPE更安全，不容易遇到拼写错误。 另外，如果你使用JavaConfig定义Notepad的bean，也可以给出下列定义：12345@Bean@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)public Notepad notepad() &#123; return new Notepad();&#125; 如果你使用xml文件定义Notepad的bean，则有如下定义：123&lt;bean id=\"notepad\" class=\"com.myapp.Notepad\" scope=\"prototype\" /&gt; 无论你最后采取上述三种定义方式的哪一种定义prototype类型的bean，每次Notepad被装配到其他bean时，都会重新创建一个新的实例。 使用会话和请求作用域在Web应用中，有时需要在某个request或者session的作用域范围内共享同一个bean的实例。举个例子，在一个典型的电子商务应用中，可能会有一个bean代表用户的购物车，如果购物车是单例对象，则所有的用户会把自己要买的商品添加到同一个购物车中；另外，如果购物车bean设置为prototype，则在应用中某个模块中添加的商品在另一个模块中将不能使用。 对于这个例子，使用session scope更合适，因为一个会话（session）唯一对应一个用户，可以通过下列代码使用session scope:1234@Bean@Scope(value=WebApplicationContext.SCOPE_SESSION, proxyMode=ScopedProxyMode.INTERFACES)public ShoppingCart cart() &#123; ... &#125; 在这里你通过value属性设置了WebApplicationContext.SCOPE_SESSION，这告诉Spring为web应用中的每个session创建一个ShoppingCartbean的实例。在整个应用中会有多个ShoppingCart实例，但是在某个会话的作用域中ShoppingCart是单例的。 这里还用proxyMode属性设置了ScopedProxyMode.INTERFACES值，这涉及到另一个问题：把request/session scope的bean装配到singleton scope的bean时会遇到。首先看下这个问题的表现。 假设在应用中需要将ShoppingCartbean装配给单例StoreServicebean的setter方法：123456789@Componentpublic class StoreService &#123; @Autowired public void setShoppingCart(ShoppingCart shoppingCart) &#123; this.shoppingCart = shoppingCart; &#125; ...&#125; 因为StoreService是单例bean，因此在Spring应用上下文加载时该bean就会被创建。在创建这个bean时 ，Spring会试图装配对应的ShoppingCartbean，但是这个bean是session scope的，目前还没有创建——只有在用户访问时并创建session时，才会创建ShoppingCartbean。 而且，之后肯定会有多个ShoppingCartbean：每个用户一个。理想的情景是：在需要StoreService操作购物车时，StoreService能够和ShoppingCartbean正常工作。 针对这种需求，Spring应该给StoreServicebean装配一个ShoppingCartbean的代理，如下图所示。代理类对外暴露的接口和ShoppingCart中的一样，用于告诉StoreService关于ShoppingCart的接口信息——当StoreService调用对应的接口时，代理采取延迟解析策略，并把调用委派给实际的session-scoped ShoppingCartbean。 因为ShoppingCart是一个接口，因此这里工作正常，但是，如果ShoppingCart是具体的类，则Spring不能创建基于接口的代理。这里必须使用CGLib创建class-based的bean，即使用ScopedProxyMode.TARGET_CLASS指示代理类应该基础自目标类。 这里使用session scope作为例子，在request scope中也有同样的问题，当然解决办法也相同。 运行时值注入一般而言，讨论依赖注入和装配时，我们多关注的是如何（how）实现依赖注入（构造函数、setter方法），即如何建立对象之间的联系。 依赖注入的另一个方面是何时（when）将值装配给bean的属性或者构造函数。在上篇（Spring装配Bean）一文中，我们执行了很多值装配的任务，例如有如下代码：123456@Beanpublic CompactDisc sgtPeppers() &#123; return new BlankDisc( \"Sgt. Pepper's Lonely Hearts Club Band\", \"The Beatles\");&#125; 这种硬编码的方式有时可以，有时却需要避免硬编码——在运行时决定需要注入的值。Spring提供以下两种方式实现运行时注入： Property placeholders The Spring Expression Language(SpEL) Property placeholders在Spring中解析外部值的最好方法是定义一个配置文件，然后通过Spring的Environment实例获取配置文件中的配置项的值。例如，下列代码展示如何在Spring 配置文件中使用外部配置项的值。 1234567891011121314151617181920import com.spring.sample.soundsystem.CompactDisc;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.PropertySource;import org.springframework.core.env.Environment;@Configuration@PropertySource(\"classpath:/app.properties\")public class ExpressiveConfig &#123; @Autowired Environment env; @Bean public CompactDisc disc() &#123; return new BlankDisc(env.getProperty(\"disc.title\"), env.getProperty(\"disc.artist\")); &#125;&#125; 这里，@PropertySource注解引用的配置文件内容如下：12disc.title=Sgt. Pepper's Lonely Hearts Club Banddisc.artist=The Beatles 属性文件被加载到Spring的Environment实例中，然后通过getProperty()方法解析对应配置项的值。 DIGGING INTO SPRING’S ENVIRONMENT在Environment类中，getProperty()方法有如下几种重载形式： String getProperty(String var1); String getProperty(String var1, String var2); T getProperty(String var1, Class var2); T getProperty(String var1, Class var2, T var3); 前两个方法都是返回String值，利用第二个参数，可以设置默认值；后两个方法可以指定返回值的类型，举个例子：假设你需要从连接池中获取连接个数，如果你使用前两个方法，则返回的值是String，你需要手动完成类型转换；但是使用后两个方法，可以由Spring自动完成这个转换：1int connection = env.getProperty(\"db.connection.count\", Integer.class, 30) 除了getProperty()方法，还有其他方法可以获得配置项的值，如果不设置默认值参数，则在对应的配置项不存在的情况下对应的属性会配置为null，如果你不希望这种情况发生——即要求每个配置项必须存在，则可以使用getRequiredProperty()方法：123456@Beanpublic CompactDisc disc() &#123; return new BlankDisc( env.getRequiredProperty(\"disc.title\"), env.getRequiredProperty(\"disc.artist\"));&#125; 在上述代码中，如果disc.title或者disc.artist配置项不存在，Spring都会抛出IllegalStateException异常。 如果你希望检查某个配置项是否存在，则可以调用containsProperty()方法：boolean titleExists = env.containsProperty(“disc.title”);。如果你需要将一个属性解析成某个类，则可以使用getPropertyAsClass()方法：Class cdClass = env.getPropertyAsClass(“disc.class”, CompactDisc.class); RESOLVING PROPERTY PLACEHOLDER在Spring中，可以使用${ … }将占位符包裹起来，例如，在XML文件中可以定义如下代码从配置文件中解析对应配置项的值：1234&lt;bean id=\"sgtPeppers\" class=\"soundsystem.BlankDisc\" c:_title=\"$&#123;disc.title&#125;\" c:_artist=\"$&#123;disc.artist&#125;\" /&gt; 如果你使用component-scanning和自动装配创建和初始化应用组件，则可以使用@Value注解获取配置文件中配置项的值，例如BlankDisc的构造函数可以定义如下：123456public BlankDisc( @Value(\"$&#123;disc.title&#125;\") String title, @Value(\"$&#123;disc.artist&#125;\") String artist) &#123; this.title = title; this.artist = artist;&#125; 为了使用占位符的值，需要配置PropertyPlaceholderConfigerbean或者PropertySourcesPlaceholderConfigurerbean。从Spring 3.1之后，更推荐使用PropertySourcesPlaceholderConfigurer，因为这个bean和Spring 的Environment的来源一样，例子代码如下：1234@Beanpublic static PropertySourcesPlaceholderConfigurer placeholderConfigurer() &#123; return new PropertySourcesPlaceholderConfigurer();&#125; 如果使用XML配置文件，则通过元素可以获得PropertySourcesPlaceholderConfigurerbean：123456&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;context:property-placeholder location=\"classpath:/app.properties\" /&gt;&lt;/beans&gt; 使用SpEL装配Spring 3引入了Spring Expression Language（SpEL），这是一种在运行时给bean的属性或者构造函数参数注入值的方法。 SpEL有很多优点，简单列举如下： 可以通过bean的ID引用bean； 可以调用某个对象的方法或者访问它的属性； 支持数学、关系和逻辑操作； 正则表达式匹配； 支持集合操作 在后续的文章中，可以看到SpEL被用到依赖注入的其他方面，例如在Spring Security中，可以使用SpEL表达式定义安全限制；如果在Spring MVC中使用Thymeleaf模板，在模板中可以使用SpEL表达式获取模型数据。 A FEW SpEL EXAMPLESSpEL是一门非常灵活的表达式语言，在这里不准备花大量篇幅来涵盖它的所有方面，可以通过一些例子来感受一下它的强大能力。 首先，SpEL表达式被#{ … }包围，跟placeholders中的${ … }非常像，最简单的SpEL表达式可以写作#{1}。在应用中，你可能回使用更加有实际含义的SpEL表达式，例如#{T(System).currentTimeMillis()}——这个表达式负责获得当前的系统时间，而T()操作符负责将java.lang.System解析成类，以便可以调用currentTimeMillis()方法。 SpEL表达式可以引用指定ID的bean或者某个bean的属性，例如下面这个例子可以获得ID为sgtPeppers的bean的artist属性的值：#{sgtPeppers.artist}；也可以通过#{systemProperties[‘disc.title’]}引用系统属性。 上述这些例子都非常简单，我们接下来看下如何在bean装配中使用SpEL表达式，之前提到过，如果你使用component-scanning和自动装配创建应用组件，则可以使用@Value注解获得配置文件中配置项的值；除了使用placeholder表达式，还可以使用SpEL表达式，例如BlankDisc的构造函数可以按照下面这种方式来写：123456public BlankDisc( @Value(\"#&#123;systemProperties['disc.title']&#125;\") String title, @Value(\"#&#123;systemProperties['disc.artist']&#125;\") String artist) &#123; this.title = title; this.artist = artist;&#125; EXPRESSING LITERAL VALUESSpEL表达式可以表示整数值，也可以表示浮点数、String值和Boolean值。例如可以使用#{3.14159}表式浮点数3.14159，并且还支持科学计数法——#{9.87E4}表示98700；#{‘Hello’}可以表示字符串值、#{false}可以表示Boolean值。 单独使用字面值是乏味的，一般不会使用到只包含有字面值的SpEL表达式，不过在构造更有趣、更复杂的表达式时支持字面值这个特性非常有用。 REFERENCING BEANS, PROPERTIES, AND METHODSSpEL表达式可以通过bean的ID引用bean，例如#{sgtPeppers}；也可以引用指定bean的属性，例如#{sgtPeppers.artist}；还可以调用某个bean的方法，例如#{artistSelector.selectArtist()}表达式可以调用artistSelector这个bean的selectArtist()方法。 SpEL表达式也支持方法的连续调用，例如#{artistSelector.selectArtist().toUpperCase()},为了防止出现NullPointerException异常，最好使用类型安全的操作符，例如#{artistSelector.selectArtist()?.toUpperCase()}。?.操作符在调用右边的函数之前，会确保左边的函数返回的值不为null。 WORKING WITH TYPES IN EXPRESSIONS在SpEL中能够调用类的方法或者常量的关键是T()操作符，例如通过T(java.lang.Math)可以访问Math类中的方法和属性——#{(java.lang.Math).random()}和#{T(java.lang.Math).PI}。 SpEL OPERATORSSpEL提供了不同种类的操作符，如下表所示： EVALUATING REGULAR EXPRESSIONS在操作文本字符串时，最常用的是检查某个文本是否符合某种格式。SpEL通过matches操作符支持正则表达式匹配。例如：#{admin.email matches ‘[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.com’}可以检查admin.email表示的邮件地址是否正确。 EVALUATING COLLECTIONS通过SpEL表达式还可以操作集合和数组，例如#{jukebox.songs[4].title}这个表达式可以访问jukebox的songs数组的第5个元素。 也可以实现更复杂的功能：随机选择一首歌——#{jukebox.songs[T(java.lang.Math).random() * jukebox.songs.size()].title}。 SpEL提供了一个选择操作符——.?[]，可以获得某个集合的子集，举个例子，假设你获得jukebox中所有artist为Aerosmith的歌，则可以使用这个表达式：#{jukebox.songs.?[artist eq ‘Aerosmith’]}。可以看出，.?[]操作符支持在[]中嵌套另一个SpEL表达式。 SpEL还提供了其他两个选择操作符：.^ [ ]用于选择第一个匹配的元素；.$[]用于选择最后一个匹配的元素。 最后，SpEL还提供了一个提取操作符：.![]，可以根据指定的集合新建一个符合某个条件的新集合，例如#{jukebox.songs.![title]}可以将songs的title都提取出来构成一个新的字符串集合。 OK，SpEL的功能非常强大，但是这里需要给开发人员提个醒：别让你的SpEL表达式过于智能。你的表达式越智能，就越难对它们进行单元测试，因此，尽量保证你的SpEL表达式简单易理解。 总结这一章干货十足，我们基于第二章介绍的bean装配技术开始讨论，陆续介绍了关于bean装配的一些进阶知识。 首先我们介绍了通过Spring的profiles解决多环境部署的问题，通过在运行时根据代表指定环境的profile选择性创建某个bean，Spring可以实现无需重新构建就可以在多个环境下部署同一个应用。 Profiles bean是运行时创建bean的一种解决方案，不过Spring 4提供了一个更普遍的解决方案：利用@Conditional注解和Condition接口实现条件性创建bean。 我们还介绍了两种机制来解决自动装配时可能遇到的歧义性问题：primary beans和qualifiers。尽管定义一个primary bean非常简单，但它仍然有局限，因此我们需要利用qualifier缩小自动装配的bean的范围，而且，我们也演示了如何创建自己的qualifiers。 尽管大多数Spring bean是单例对象，但是在某些情况下具备其他作用域的对象更加合适。Spring 应用中可以创建singletons、prototypes、request-scoped或session-scoped。在使用request-scoped或者session-scoped类型的bean时，还需要解决将非单例对象注入到单例对象时遇到的问题——利用代理接口或代理类。 最后，我们也介绍了Spring表达式语言（SpEL），利用SpEL可以实现在运行时给bean注入值。","categories":[{"name":"SSM框架","slug":"SSM框架","permalink":"https://caoler.cn/categories/SSM框架/"},{"name":"Spring","slug":"SSM框架/Spring","permalink":"https://caoler.cn/categories/SSM框架/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://caoler.cn/tags/Spring/"}]},{"title":"《Spring实战》读书笔记1-Spring装配Bean","slug":"一、Spring装配Bean","date":"2018-06-08T16:41:28.000Z","updated":"2018-06-11T14:13:38.446Z","comments":true,"path":"/post/2018/SpringInAction-1.html","link":"","permalink":"https://caoler.cn/post/2018/SpringInAction-1.html","excerpt":"Spring容器负责创建应用程序中的bean并通过DI来协调这些对象之间的关系。但是，作为开发人员，你需要告诉Spring要创建哪些bean并且如何将其装配在一起。当描述bean如何进行装配时，Spring具有非常大的灵活性，它提供了三种主要的装配机制：","text":"Spring容器负责创建应用程序中的bean并通过DI来协调这些对象之间的关系。但是，作为开发人员，你需要告诉Spring要创建哪些bean并且如何将其装配在一起。当描述bean如何进行装配时，Spring具有非常大的灵活性，它提供了三种主要的装配机制： 在XML中进行显式配置。 在Java中进行显式配置。 隐式的bean发现机制和自动装配。 这三种配置方式既可以单独使用也可以根据实际情况组合使用。作者建议：尽可能地使用自动配置的机制。 自动化装配BeanSpring从两个角度来实现自动化装配： 组件扫描（component scanning）：Spring会自动发现应用上下文中所创建的bean。 自动装配（autowiring）：Spring自动满足bean之间的依赖。 创建可被发现的Bean这里举一个例子：CD和播放器，如果你不将CD插入（注入）到CD播放器中，那么CD播放器其实是没有太大用处的。所以，可以这样说，CD播放器依赖于CD才能完成它的使命。 创建接口CompactDisc123public interface CompactDisc&#123; void play();&#125; 然后创建这个接口的实现：123456789@Componentpublic class SgtPeppers implements CompactDisc &#123; private String title = \"Sgt. Perppers' Lonely Hearts Club Band\"; private String artist = \"The Beatles\"; public void play() &#123; System.out.println(\"Playing \" + title + \" by \" + artist); &#125;&#125; 需要注意的就是SgtPeppers类上使用了 @Component注解。这个简单的注解表明该类会作为组件类，并告知Spring要为这个类创建bean。 但是组件扫描默认是不启用的，我们需要手动设置一下：有两种方式 @ComponentScan注解启用扫描 在config包中创建 1234@Configuration@ComponentScan(basePackages = \"cn.caoler.spring.service.impl\")public class CDPlayerConfig &#123;&#125; 在这个Java配置文件中有两个注解值得注意：@Configuration表示这个.java文件是一个配置文件；@ComponentScan表示开启Component扫描，并且可以设置basePackages属性——Spring将会设置该目录以及子目录下所有被@Component注解修饰的类。 通过XML启用组件扫描 1&lt;context:component-scan base-package=\"com.spring.sample.soundsystem\" /&gt; 配置完成之后写一个测试类：1234567891011@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes = CDPlayerConfig.class)public class CDPlayerTest &#123; @Autowired private CompactDisc cd; @Test public void cdShouldNotBeNull() &#123; Assert.assertNotNull(cd); &#125;&#125; 测试通过，说明@Autowired注解起作用了，就意味着Spring能够发现CompactDisc类，自动在Spring上下文中将其创建为bean并将其注入到测试代码之中。 为组件扫描的bean命名Spring应用上下文中所有的bean都会给定一个ID。如果没有指定名字，那么spring会自动为该Bean命名，就是将类名的第一个字母变为小写。 如果需要指定bean名字的话，在@Component(“指定的名字”)即可。 设置组件扫描的基础包如果@ComponentScan没有设置任何属性，那么spring会默认扫描被@ComponentScan标注的类所在包。 如果你想更加清晰地表明你所设置的是基础包，那么你可以通过basePackages属性进行配置：1234@Configuration@ComponentScan(basePackages = &#123;\"cn.caoler.spring.service1\", \"cn.caoler.spring.service2\"&#125;)public class SoundSystemConfig &#123;&#125; 这种字符串形式的表示虽然可以，但是不具备“类型安全”，因此Spring也提供了更加类型安全的机制，即通过类或者接口来设置扫描机制的目标目录，例如：1234@Configuration@ComponentScan(basePackageClasses = &#123;CDPlayer.class, DVDPlayer.class&#125;)public class SoundSystemConfig &#123;&#125; 通过为bean添加注解实现自动装配简单来说，自动装配的意思是让Spring从应用上下文中找到对应的bean的引用，并将它们注入到指定的bean。通过@Autowired注解可以完成自动装配。 例如，考虑下面代码中的CDPlayer类，它的构造函数被@Autowired修饰，表明当Spring创建CDPlayer的bean时，会给这个构造函数传入一个CompactDisc的bean对应的引用。123456789101112@Componentpublic class CDPlayer implements MediaPlayer &#123; private CompactDisc cd; @Autowired public CDPlayer(CompactDisc cd) &#123; this.cd = cd; &#125; public void play() &#123; cd.play(); &#125;&#125; 还有别的实现方法，例如将@Autowired注解作用在setCompactDisc()方法上:1234@Autowiredpublic void setCd(CompactDisc cd) &#123; this.cd = cd;&#125; 或者是其他名字的方法上，例如：1234@Autowiredpublic void insertCD(CompactDisc cd) &#123; this.cd = cd;&#125; 更简单的用法是，可以将@Autowired注解直接作用在成员变量之上，例如：12@Autowiredprivate CompactDisc cd; 只要对应类型的bean有且只有一个，则会自动装配到该属性上。如果没有找到对应的bean，应用会抛出对应的异常，如果想避免抛出这个异常，则需要设置@Autowired(required=false)。不过，在应用程序设计中，应该谨慎设置这个属性，因为这会使得你必须面对NullPointerException的问题。 如果存在多个同一类型的bean，则Spring会抛出异常，表示装配有歧义，解决办法有两个：（1）通过@Qualifier注解指定需要的bean的ID； （2）通过@Resource注解指定注入特定ID的bean； 验证自动配置通过下列代码，可以验证：CompactDisc的bean已经注入到CDPlayer的bean中，同时在测试用例中是将CDPlayer的bean注入到当前测试用例。123456789101112@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes = SoundSystemConfig.class)public class CDPlayerTest &#123; public final Logger log = LoggerFactory.getLogger(CDPlayerTest.class); @Autowired private MediaPlayer player; @Test public void playTest() &#123; player.play(); &#125;&#125; 通过Java代码装配Bean有时候 你想要将第三方库中的组件装配到你的应用中，在这种情况下，是没有办法在它的类上添加@Component和@Autowired注解的，因此就不能使用自动化装配的方案了。 这种情况下就只能通过显示装配的方式去装配，可选方式有两种，先学习通过Java代码去装配。 在进行显式配置时，JavaConfig是更好的方案，因为它更为强大、类型安全并且对重构友好。 JavaConfig不同于其他用于实现业务逻辑的Java代码，因此不能将JavaConfig业务逻辑代码混在一起。一般都会给Java配置文件新建一个单独的package。 创建配置类实际上在之前的例子中我们已经实践过基于Java的配置文件，看如下代码：1234@Configuration@ComponentScan(basePackageClasses = &#123;CDPlayer.class, DVDPlayer.class&#125;)public class SoundSystemConfig &#123;&#125; @Configuration注解表示这个类是配置类，之前我们是通过@ComponentScan注解实现bean的自动扫描和创建，这里我们重点是学习如何显式创建bean，因此首先将@ComponentScan(basePackageClasses = {CDPlayer.class, DVDPlayer.class})这行代码去掉。 让我们看一下如何使用JavaConfig装配CDPlayer和CompactDisc。 声明简单的bean通过@Bean注解创建一个Spring bean，该bean的默认ID和函数的方法名相同，即sgtPeppers。例如：1234@Beanpublic CompactDisc sgtPeppers() &#123; return new SgtPeppers();&#125; 同样，可以指定bean的ID，例如：1234@Bean(name = \"lonelyHeartsClub\")public CompactDisc sgtPeppers() &#123; return new SgtPeppers();&#125; 借助JavaConfig实现注入最简单的办法是将被引用的bean的生成函数传入到构造函数或者set函数中，例如：1234@Beanpublic CDPlayer cdPlayer() &#123; return new CDPlayer(sgtPeppers());&#125; 看起来是函数调用，实际上不是：由于sgtPeppers()方法被@Bean注解修饰，所以Spring会拦截这个函数调用，并返回之前已经创建好的bean——确保该SgtPeppers bean为单例。 假如有下列代码：123456789@Beanpublic CDPlayer cdPlayer() &#123; return new CDPlayer(sgtPeppers());&#125;@Beanpublic CDPlayer anotherCDPlayer() &#123; return new CDPlayer(sgtPeppers());&#125; 如果把sgtPeppers()方法当作普通Java方法对待，则cdPlayerbean和anotherCDPlayerbean会持有不同的SgtPeppers实例——结合CDPlayer的业务场景看：就相当于将一片CD同时装入两个CD播放机中，显然这不可能。 默认情况下，Spring中所有的bean都是单例模式，因此cdPlayer和anotherCDPlayer这俩bean持有相同的SgtPeppers实例。 当然，还有一种更清楚的写法：123456789@Beanpublic CDPlayer cdPlayer(CompactDisc compactDisc) &#123; return new CDPlayer(compactDisc);&#125;@Beanpublic CDPlayer anotherCDPlayer() &#123; return new CDPlayer(sgtPeppers());&#125; 这种情况下，cdPlayer和anotherCDPlayer这俩bean持有相同的SgtPeppers实例，该实例的ID为lonelyHeartsClub。这种方法最值得使用，因为它不要求CompactDisc bean在同一个配置文件中定义——只要在应用上下文容器中即可（不管是基于自动扫描发现还是基于XML配置文件定义）。 通过XML装配bean这里暂时略过 混合使用多种配置方法在JavaConfig中解析XML配置通过@Import注解导入其他的JavaConfig，并且支持同时导入多个配置文件； 1234@Configuration@Import(&#123;CDPlayerConfig.class, CDConfig.class&#125;)public class SoundSystemConfig &#123;&#125; 通过@ImportResource注解导入XML配置文件； 12345@Configuration@Import(CDPlayerConfig.class)@ImportResource(\"classpath: cd-config.xml\")public class SoundSystemConfig &#123;&#125; 在XML配置文件中应用JavaConfig通过&lt;import&gt;标签引入其他的XML配置文件；通过&lt;bean&gt;标签导入Java配置文件到XML配置文件，例如1&lt;bean class=\"soundsystem.CDConfig\" /&gt; 通常的做法是：无论使用JavaConfig或者XML装配，都要创建一个root configuration，即模块化配置定义；并且在这个配置文件中开启自动扫描机制：&lt;context:component-scan&gt;或者@ComponentScan。 小结Spring框架的核心是Spring容器。容器负责管理应用中组件的生命周期，它会创建这些组件并保证它们的依赖能够得到满足，这样的话，组件才能完成预定的任务。 在本章中，我们看到了在Spring中装配bean的三种主要方式：自动化配置、基于Java的显式配置以及基于XML的显式配置。不管你采用什么方式，这些技术都描述了Spring应用中的组件以及这些组件之间的关系。 我同时建议尽可能使用自动化配置，以避免显式配置所带来的维护成本。但是，如果你确实需要显式配置Spring的话，应该优先选择基于Java的配置，它比基于XML的配置更加强大、类型安全并且易于重构。在本书中的例子中，当决定如何装配组件时，我都会遵循这样的指导意见。 因为依赖注入是Spring中非常重要的组成部分，所以本章中介绍的技术在本书中所有的地方都会用到。基于这些基础知识，下一章将会介绍一些更为高级的bean装配技术，这些技术能够让你更加充分地发挥Spring容器的威力。","categories":[{"name":"SSM框架","slug":"SSM框架","permalink":"https://caoler.cn/categories/SSM框架/"},{"name":"Spring","slug":"SSM框架/Spring","permalink":"https://caoler.cn/categories/SSM框架/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://caoler.cn/tags/Spring/"}]},{"title":"SpringBoot整合MyBatis实战总结","slug":"SpringBoot整合MyBatis实战总结","date":"2018-06-02T15:13:53.000Z","updated":"2018-06-02T15:14:32.555Z","comments":true,"path":"/post/2018/SpringBoot-MyBaits-summary.html","link":"","permalink":"https://caoler.cn/post/2018/SpringBoot-MyBaits-summary.html","excerpt":"以下为此次项目中遇到的值得总结的问题","text":"以下为此次项目中遇到的值得总结的问题 1. 表名为关键字的解决方法数据库表明为index与关键字冲突，导致SQL语句执行出错，在改表名上加上’单引号即可避免该情况，举例如下：123456SELECTi.id, i.name, i.source,a.id, a.nameFROM 'index' iLEFT JOIN area aON i.id=a.id 感谢昌炬哥的指导！ 2. 使用collection标签查询时结果仅有一条在进行多表级联查询时，一对多关系（如上述SQL，一条index表数据对应多条area表数据），使用collection标签对两张表进行关联时导致查询结果仅有一条，查阅论坛得知，将互相关联的表的主键字段改为不相同即可，上述两表中主键均为id，修改表结构后，执行SQL如下：123456SELECTi.id, i.name, i.source,a.aid, a.nameFROM 'index' iLEFT JOIN area aON i.id=a.aid 上述方法也是一种解决办法，但是修改数据库表结构代价太大，解决方法如下：123456789&lt;resulrMap id=\"IndexArea\" typr=\"com.myhexin.kiv.model.Index\" extend=\"BaseResultMap\"&gt; //此处BaseResultMap为1-n关系中“1”这一方的resultMap &lt;collection property=\"areaList\" ofType=\"com.myhexin.kiv.model.IndexArea\"&gt; &lt;id column=\"id\" property=\"id\"/&gt; &lt;result column=\"index_id\" property=\"indexId\"/&gt; &lt;result column=\"area\" property=\"area\"/&gt; &lt;/collection&gt;&lt;/resultMap&gt; 扎眼看，上述代码并无任何差错，但是执行的时候对应结果却只有一条 将1&lt;id column=\"id\" property=\"id\"/&gt; 修改为1&lt;result column=\"id\" property=\"id\"/&gt; 即可不用通过修改数据库表结构解决对应问题。 原因是因为被关联表的id和关联表的id（唯一主键）冲突导致，所以将被关联表的id属性设置为属性值即可解决问题 再次感谢昌炬哥！ 3. Mybatis传入参数为多种类型时基本数据类型int,string,long,Date;案例 123456789&lt;sql id=\"Base_Column_List\" &gt; id, car_dept_name, car_maker_name, icon,car_maker_py,hot_type &lt;/sql&gt; &lt;select id=\"selectByPrimaryKey\" resultMap=\"BaseResultMap\" parameterType=\"java.lang.Long\" &gt; select &lt;include refid=\"Base_Column_List\" /&gt; from common_car_make where id = #&#123;id,jdbcType=BIGINT&#125; &lt;/select&gt; 复杂数据类型 class,mapmap类型案例 12345678910111213141516171819&lt;select id=\"queryCarMakerList\" resultMap=\"BaseResultMap\" parameterType=\"java.util.Map\"&gt; select &lt;include refid=\"Base_Column_List\" /&gt; from common_car_make cm where 1=1 &lt;if test=\"id != null\"&gt; and cm.id = #&#123;id,jdbcType=DECIMAL&#125; &lt;/if&gt; &lt;if test=\"carDeptName != null\"&gt; and cm.car_dept_name = #&#123;carDeptName,jdbcType=VARCHAR&#125; &lt;/if&gt; &lt;if test=\"carMakerName != null\"&gt; and cm.car_maker_name = #&#123;carMakerName,jdbcType=VARCHAR&#125; &lt;/if&gt; &lt;if test=\"hotType != null\" &gt; and cm.hot_type = #&#123;hotType,jdbcType=BIGINT&#125; &lt;/if&gt; ORDER BY cm.id &lt;/select&gt; 类类型 123456789101112131415161718192021&lt;update id=\"updateByPrimaryKeySelective\" parameterType=\"com.epeit.api.model.CommonCarMake\" &gt; update common_car_make &lt;set &gt; &lt;if test=\"carDeptName != null\" &gt; car_dept_name = #&#123;carDeptName,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test=\"carMakerName != null\" &gt; car_maker_name = #&#123;carMakerName,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test=\"icon != null\" &gt; icon = #&#123;icon,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test=\"carMakerPy != null\" &gt; car_maker_py = #&#123;carMakerPy,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test=\"hotType != null\" &gt; hot_type = #&#123;hotType,jdbcType=BIGINT&#125;, &lt;/if&gt; &lt;/set&gt; where id = #&#123;id,jdbcType=BIGINT&#125; &lt;/update&gt; map中包含数组的情况 123456789101112&lt;select id=\"selectProOrderByOrderId\" resultType=\"com.epeit.api.model.ProOrder\" parameterType=\"java.util.HashMap\" &gt; select sum(pro_order_num) proOrderNum,product_id productId,promotion_id promotionId from pro_order where 1=1 &lt;if test=\"orderIds != null\"&gt; and &lt;foreach collection=\"orderIds\" item=\"item\" open=\"order_id IN(\" separator=\",\" close=\")\"&gt; #&#123;item,jdbcType=BIGINT&#125; &lt;/foreach&gt; &lt;/if&gt; GROUP BY product_id,promotion_id &lt;/select&gt; 在DAO层，如多有多个参数传入，那么一定要使用@Param注解，List类型也需要使用，否则mapping.xml将无法识别该参数 4. 控制台SQL语句的打印直接application.properties里面定义 1logging.level.com.abc=DEBUG 设置为开发级别即可 5. spring 中自定义工具类需要注入service在SpringMVC框架中，我们经常要使用@Autowired注解注入Service或者Mapper接口，我们也知道，在controller层中注入service接口，在service层中注入其它的service接口或者mapper接口都是可以的，但是如果我们要在我们自己封装的Utils工具类中或者非controller普通类中使用@Autowired注解注入Service或者Mapper接口，直接注入是不可能的，因为Utils使用了静态的方法，我们是无法直接使用非静态接口的，当我们遇到这样的问题，我们就要想办法解决了。 我们有两种方法解决这个问题，第一种是注解方式，第二种是xml配置方式，下面是我们在utils中使用@Autowired注解的方法： 123456789101112131415161718192021@Component public class TestUtils &#123; @Autowired private ItemService itemService; @Autowired private ItemMapper itemMapper; public static TestUtils testUtils; @PostConstruct public void init() &#123; testUtils = this; &#125; //utils工具类中使用service和mapper接口的方法例子，用\"testUtils.xxx.方法\" 就可以了 public static void test(Item record)&#123; testUtils.itemMapper.insert(record); testUtils.itemService.queryAll(); &#125; &#125; 我们在init方法中使用以下注解就可以了，时间上这个init()的方法是可以自己随便定义的，注意：inti()方法里面不用写任何东西，跟我这样的就绝对ok了，不用看网上其他人瞎掰！ 1@PostConstruct 6. 使用clooection标签时报错Cause: org.apache.ibatis.reflection.ReflectionException: Could not set property ‘xx’ of ‘class xx’ with value ‘xx’当时这个问题折磨了我整整半天时间，对应的类，以及设置的值都是完全符合类型的，但是一直报错，总结如下： 出错时collection标签配置如下：123456&lt;collection property=\"orderdetails\" javaType=\"com.luchao.mybatis.first.po.Orderdetail\"&gt; &lt;result column=\"id\" property=\"id\"/&gt; &lt;result column=\"items_id\" property=\"itemsId\"/&gt; &lt;result column=\"items_num\" property=\"itemsNum\"/&gt; &lt;result column=\"orders_id\" property=\"ordersId\"/&gt;&lt;/collection&gt; 通过各种查找资料得知：上面的==javaType==属性的问题，因为这个是一对多，通过反射应该映射为List，但是使用javaType会让MyBatis认为orderdetails属性为Orderdetail，所以出错，将javaType改为ofType，只是指定泛型的类型为Orderdetail。 7. Spring MVC /Boot接收并返回简单JSON 数据（不定义对应pojo情况下）前端json类型如下： 1&#123;\"name\":\"caole\"&#125; 在控制器接受参数时，单个属性没有必要再去创建一个pojo对象来接收，这里可以使用map 举例如下12public String xxxxx(@RequestBody Map map) &#123; List&lt;String&gt; list = (List) map.get(\"xxxxx\"); 且，使用Map接收参数时，注解需为@RequestBody 8. 使用SpringBoot框架PageHelper插件无法启用由于网上有一大半的教程都是有误导性的，在这里重新总结一下 导包，使用springBoot框架时，不能使用pageHelper的基础包，需要使用针对springboot的jar包 网上大多数说法如下： 有两种方式，我们这里只使用原生的PageHelper导入Maven 在这里我们要使用如下JAR： 12345&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt;&lt;/dependency&gt; 具体使用 参考作者的使用方法 pagehelper/Mybatis-PageHelper/HowToUse.md PageHelper integration with Spring Boot 9. 一对多，多对多关联查询的总结在使用pagehelper插件对查询结果进行分页时，对于单表查询效率是极高的，且分页结果会让人很满意，但是进行多表级联查询的时候，效果就不那么理想了。由于开发时间有限，没有太多时间去创建适合开发环境的分页插件，所以就只能对SQL或者resultMap加以改装去使用pagehelper插件了。 分页插件作者的方法介绍如下： Mybatis关联结果查询分页方法 总结： 我们需要达到的目的：对于关联嵌套查询，使用分页的时候，只会对主SQL进行分页查询，嵌套的查询不会被分页。 对于关联结果查询，使用分页得不到正常的结果，因为只有把数据全部查询出来，才能得到最终的结果，对这个结果进行分页才有效。因而如果是这种情况，必然要先全部查询，在对结果处理，这样就体现不出分页的作用了。 对于关联嵌套查询，使用分页的时候，只会对主SQL进行分页查询，嵌套的查询不会被分页。 如何对关联结果进行分页？ 针对这种情况最好的方法就是手写分页，针对主要语句进行分页，对连接的表不进行分页查询 针对主要语句写count查询（不需要管连接的表） 这样一来，对嵌套的结果就没有影响了 举例： 123456&lt;!-- lang: sql --&gt;select * from (select * from (select a.*, rownum rw from sys_role a where rownum &lt;= 4) where rw &gt; 0) a left join sys_role_function b on a.roleid = b.roleid; 关于关联嵌套查询嵌套查询由于都是独立的sql，主sql和分支sql都是分离的，所以使用Mybatis分页插件可以正常分页。如果你还想对关联查询的分支sql进行分页查询，基本上是不可能的，但是通过column={}这种方式传递分页参数也能实现，估计有些人看不懂这里了，就到此为止吧，不需要做这么费力不讨好的事。 然而我们就要使用别人看不懂的这个方法 举例如下： 一对多关系： 有两张表，一张teacher，一张group，一个teacher对应多个group teacher的model中包括List对象 teachermapping.xml 12345678910111213141516&lt;mapper namespace=\"com.oasis.test.mapper.TeacherMapper\"&gt; &lt;resultMap id=\"teacherResultMap\" type=\"com.oasis.test.entity.Teacher\"&gt; &lt;id column=\"id\" property=\"id\"/&gt; &lt;result column=\"teacher_name\" property=\"name\"/&gt; &lt;result column=\"age\" property=\"age\"/&gt; &lt;collection property=\"groupList\" ofType=\"com.oasis.test.entity.Group\" column=\"id\" select=\"com.oasis.test.mapper.GroupMapper.getGroupListByTeacherId\"&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;select id=\"getTeacherList\" parameterType=\"java.lang.Long\" resultMap=\"teacherResultMap\"&gt; SELECT ID,TEACHER_NAME,AGE FROM t_teacher limit 0,5 &lt;/select&gt; GroupMapper.xml 123456789101112131415&lt;mapper namespace=\"com.oasis.test.mapper.GroupMapper\"&gt; &lt;resultMap id=\"groupResultMap\" type=\"com.oasis.test.entity.Group\"&gt; &lt;id column=\"id\" property=\"id\"/&gt; &lt;result column=\"group_name\" property=\"name\"/&gt; &lt;result column=\"number\" property=\"number\"/&gt; &lt;/resultMap&gt; &lt;select id=\"getGroupListByTeacherId\" parameterType=\"java.lang.Long\" resultMap=\"groupResultMap\"&gt; SELECT ID,GROUP_NAME,NUMBER FROM t_group WHERE teacher_id=#&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 对应DAO中书写对应方法即可实现功能。 多对多关系 一个指标组对应多个指标，一个指标也可能属于多个指标组 三张表：index、index_recommend、recommend 其中index_recommend表中仅有两个字段：index_id、recommend_id recommendMapper.xml 1234567891011121314&lt;resultMap id=\"selectAll\" type=\"cn.caoler.model.Recommend\"&gt; &lt;id column=\"id\" property=\"id\"/&gt; &lt;result column=\"name\" property=\"name\"/&gt; &lt;result column=\"number\" property=\"number\"/&gt; &lt;collection property=\"indexList\" ofType=\"cn.caoler.model.Index\" colum=\"id\" select=\"cn.caoler.mapper.IndexMapper.getIndexByRecommend\"&gt; &lt;/collection&gt;&lt;/resultMap&gt;&lt;select id=\"selectAll\" resultMap=\"selectAll\"&gt; SELECT * FROM recommend&lt;/select&gt; indexMapper.xml 1234567891011121314&lt;resultMap id=\"selectAll\" type=\"cn.caoler.model.Index\"&gt; &lt;id column=\"id\" property=\"id\"/&gt; &lt;result column=\"name\" property=\"name\"/&gt; &lt;result column=\"number\" property=\"number\"/&gt;&lt;/resultMap&gt;&lt;select id=\"getIndexByRecommend\" resultMap=\"selectAll\"&gt; SELECT * FROM `index` as i where i.id in( select index_id from index_recommend where recommend_id=#&#123;id&#125; )&lt;/select&gt; 通过上述嵌套查询即可实现功能。 传入参数既有RequestParam，还有RequestBody的处理举例： post 一个json数据到1http://www.google.com?code=1024 RequestParams 就是 code=1024 RequestBody 就是你的json数据(题外话：注意content-type) 参考博客： mybatis一对多返回结果集问题 MyBatis使用Collection查询多对多或一对多结果集bug MyBatis的传入参数parameterType类型 Spring boot＋mybatis 打印sql spring 中自定义工具类 解决@Autowired为null Cause: org.apache.ibatis.reflection.ReflectionException SpringBoot 接收并返回 JSON 数据 关于mybatis中collection一对多关联查询分页出错问题总结 mybatis映射文件selectresultMap关联查询_collection定义关联集合 @RequestBody和@RequestParam区别 Springmvc中@RequestBody和@RequestParam能够同时使用吗","categories":[{"name":"SSM框架","slug":"SSM框架","permalink":"https://caoler.cn/categories/SSM框架/"},{"name":"SpringBoot","slug":"SSM框架/SpringBoot","permalink":"https://caoler.cn/categories/SSM框架/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://caoler.cn/tags/SpringBoot/"}]},{"title":"统一异常处理","slug":"统一异常处理","date":"2018-05-30T15:12:29.000Z","updated":"2018-05-30T15:13:25.316Z","comments":true,"path":"/post/2018/exception.html","link":"","permalink":"https://caoler.cn/post/2018/exception.html","excerpt":"在用spring Boot做web后台时，经常会出现异常，如果每个异常都自己去处理很麻烦，所以我们创建一个全局异常处理类来统一处理异常","text":"在用spring Boot做web后台时，经常会出现异常，如果每个异常都自己去处理很麻烦，所以我们创建一个全局异常处理类来统一处理异常 代码: Result.java 1234567891011121314151617181920212223242526272829303132333435public class Result&lt;T&gt; &#123; /** 错误码. */ private Integer code; /** 提示信息. */ private String msg; /** 具体的内容. */ private T data; public Integer getCode() &#123; return code; &#125; public void setCode(Integer code) &#123; this.code = code; &#125; public String getMsg() &#123; return msg; &#125; public void setMsg(String msg) &#123; this.msg = msg; &#125; public T getData() &#123; return data; &#125; public void setData(T data) &#123; this.data = data; &#125;&#125; ResultUtil .java123456789101112131415161718192021public class ResultUtil &#123; public static Result success(Object object) &#123; Result result = new Result(); result.setCode(0); result.setMsg(\"成功\"); result.setData(object); return result; &#125; public static Result success() &#123; return success(null); &#125; public static Result error(Integer code, String msg) &#123; Result result = new Result(); result.setCode(code); result.setMsg(msg); return result; &#125;&#125; 12345678910111213141516@Entitypublic class Gril &#123; @Id @GeneratedValue @NotNull(message = \"这个id必传\") private Integer id; public Integer getId(Integer id) &#123; return this.id; &#125; public void setId(Integer id) &#123; this.id = id; &#125;&#125; 使用:12345678910111213@RestControllerpublic class GrilController &#123; //添加女生 @PostMapping(value = \"/grils/&#123;id&#125;\") public Result&lt;Gril&gt; grilAdd(@Valid Gril gril, BindingResult bindingResult)&#123; if(bindingResult.hasErrors())&#123; //这个是把gril里面的这个id必传返回给前端 return ResultUtil.error(1,bindingResult.getFieldError().getDefaultMessage()); &#125; return ResultUtil.success(grilpepository.save(gril)); &#125;&#125; 访问http://127.0.0.1:8081/grils 返回12345&#123; \"code\": 1, \"msg\": \"这个id必传\", \"data\": null&#125; 访问http://127.0.0.1:8081/grils/2 返回123&#123; \"id\": 21&#125; 统一异常处理12345678910111213141516public class GrilException extends RuntimeException&#123; private Integer code; public GrilException(Integer code,String message) &#123; super(message); this.code = code(); &#125; public Integer getCode() &#123; return code; &#125; public void setCode(Integer code) &#123; this.code = code; &#125;&#125; 12345678910111213141516171819@ControllerAdvicepublic class ExceptionHandle &#123; private final static Logger logger = LoggerFactory.getLogger(ExceptionHandle.class); @ExceptionHandler(value = Exception.class) @ResponseBody public Result Handle(Exception e)&#123; if (e instanceof GrilException)&#123; GrilException grilException = (GrilException) e; return ResultUtil.error(grilException.getCode(),grilException.getMessage()); &#125;else &#123; //将系统异常以打印出来 logger.info(\"[系统异常]&#123;&#125;\",e); return ResultUtil.error(-1,\"未知错误\"); &#125; &#125;&#125; 使用123456789101112131415@Servicepublic class GirlService &#123; public void getAge(Integer id) throws Exception&#123; Girl girl = girlRepository.findOne(id); Integer age = girl.getAge(); if (age &lt; 10) &#123; //返回\"你还在上小学吧\" code=100 throw new GirlException(100,\"你还在上小学吧\"); &#125;else if (age &gt; 10 &amp;&amp; age &lt; 16) &#123; //返回\"你可能在上初中\" code=101 throw new GirlException(101,\"你可能在上初中\" ); &#125; &#125;&#125; 12345678910@RestControllerpublic class GirlController &#123; @Autowired private GirlService girlService; @GetMapping(value = \"girls/getAge/&#123;id&#125;\") public void getAge(@PathVariable(\"id\") Integer id) throws Exception&#123; girlService.getAge(id); &#125;&#125; 异常是统一维护1234567891011121314151617public class GirlException extends RuntimeException&#123; private Integer code; public GirlException(ResultEnum resultEnum) &#123; super(resultEnum.getMsg()); this.code = resultEnum.getCode(); &#125; public Integer getCode() &#123; return code; &#125; public void setCode(Integer code) &#123; this.code = code; &#125;&#125; 1234567891011121314151617@ControllerAdvicepublic class ExceptionHandle &#123; private final static Logger logger = LoggerFactory.getLogger(ExceptionHandle.class); @ExceptionHandler(value = Exception.class) @ResponseBody public Result handle(Exception e) &#123; if (e instanceof GirlException) &#123; GirlException girlException = (GirlException) e; return ResultUtil.error(girlException.getCode(), girlException.getMessage()); &#125;else &#123; logger.error(\"【系统异常】&#123;&#125;\", e); return ResultUtil.error(-1, \"未知错误\"); &#125; &#125;&#125; 这个就是统一维护的文件,采用枚举12345678910111213141516171819202122232425public enum ResultEnum &#123; UNKONW_ERROR(-1, \"未知错误\"), SUCCESS(0, \"成功\"), PRIMARY_SCHOOL(100, \"我猜你可能还在上小学\"), MIDDLE_SCHOOL(101, \"你可能在上初中\"), ; private Integer code; private String msg; ResultEnum(Integer code, String msg) &#123; this.code = code; this.msg = msg; &#125; public Integer getCode() &#123; return code; &#125; public String getMsg() &#123; return msg; &#125;&#125; 123456789101112131415161718192021@Servicepublic class GirlService &#123; @Autowired private GirlRepository girlRepository; public void getAge(Integer id) throws Exception&#123; Girl girl = girlRepository.findOne(id); Integer age = girl.getAge(); if (age &lt; 10) &#123; //返回\"你还在上小学吧\" code=100 throw new GirlException(ResultEnum.PRIMARY_SCHOOL); &#125;else if (age &gt; 10 &amp;&amp; age &lt; 16) &#123; //返回\"你可能在上初中\" code=101 throw new GirlException(ResultEnum.MIDDLE_SCHOOL); &#125; //如果&gt;16岁,加钱 //... &#125;&#125; 123456789101112@RestControllerpublic class GirlController &#123; @Autowired private GirlService girlService; @GetMapping(value = \"girls/getAge/&#123;id&#125;\") public void getAge(@PathVariable(\"id\") Integer id) throws Exception&#123; girlService.getAge(id); &#125; 后记：在使用枚举类的时候ResultUtil.error(ResultEnum.UNKONW_ERROR)报错，具体原因待总结 参考：springboot统一异常处理及返回数据的处理","categories":[{"name":"SSM框架","slug":"SSM框架","permalink":"https://caoler.cn/categories/SSM框架/"},{"name":"SpringBoot","slug":"SSM框架/SpringBoot","permalink":"https://caoler.cn/categories/SSM框架/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://caoler.cn/tags/SpringBoot/"}]},{"title":"Swagger2-生成RESTful接口文档","slug":"Swagger2-生成RESTful接口文档","date":"2018-05-29T15:11:37.000Z","updated":"2018-05-30T15:13:24.019Z","comments":true,"path":"/post/2018/springboot-swagger2.html","link":"","permalink":"https://caoler.cn/post/2018/springboot-swagger2.html","excerpt":"Swagger 是一个规范和完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务。总体目标是使客户端和文件系统作为服务器以同样的速度来更新。文件的方法，参数和模型紧密集成到服务器端的代码，允许API来始终保持同步。","text":"Swagger 是一个规范和完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务。总体目标是使客户端和文件系统作为服务器以同样的速度来更新。文件的方法，参数和模型紧密集成到服务器端的代码，允许API来始终保持同步。 1. 引入依赖12345678910&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.8.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.8.0&lt;/version&gt;&lt;/dependency&gt; 2.配置Swagger2在 Application.java 同级创建 Swagger2.java（同级创建该文件会导致项目目录结构不整洁，在config目录下创建呢？） 1234567891011121314151617181920212223@Configuration@EnableSwagger2public class Swagger2 &#123; @Bean public Docket createRestApi() &#123; return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .select() .apis(RequestHandlerSelectors.basePackage(\"cn.caoler.kiv.controller\")) .paths(PathSelectors.any()) .build(); &#125; private ApiInfo apiInfo() &#123; return new ApiInfoBuilder() .title(\"Spring Boot添加Swagger2组件\") .description(\"Spring Boot添加Swagger2组件\") .version(\"1.0\") .build(); &#125;&#125; 其中 .apis(RequestHandlerSelectors.basePackage(“cn.caoler.kiv.controller”)) 指定了以扫描包的方式进行，会把cn.caoler.kiv.controller包下的controller都扫描到。 @configration 标识这是一个配置类 @EnableSwagger2开启swagger2 PathSelectors.any()表示路径选择器匹配所有路径 apiInfo() swagger页面上的一些展示信息 3.举例123456789101112@ApiOperation(value = \"新建用户\", notes = \"新建一个用户\")@ApiImplicitParams(&#123; @ApiImplicitParam(name = \"user\", value = \"用户数据\", required = true,dataType = \"User\") @ApiImplicitParam(name = \"page\", value = \"页码\", required = true,dataType = \"Integer\") &#125;)@RequestMapping(value = \"/create\", method = RequestMethod.POST)public Object create(@RequestBody User user @RequsstParam(value = \"page\") Integer page) &#123; System.out.println(\"user : \" + user.getName()); System.out.println(page); return 1;&#125; 4.常用注释@Api() 用于类；表示标识这个类是swagger的资源 tags–表示说明 value–也是说明，可以使用tags替代 @ApiOperation() 用于方法；表示一个http请求的操作 value用于方法描述 notes用于提示内容 @ApiParam() 用于方法，参数，字段说明；表示对参数的添加元数据（说明或是否必填等） name–参数名 value–参数说明 required–是否必填 @ApiModel()用于类 ；表示对类进行说明，用于参数用实体类接收 value–表示对象名 @ApiModelProperty()用于方法，字段； 表示对model属性的说明或者数据操作更改 value–字段说明 name–重写属性名字 dataType–重写属性类型 required–是否必填 example–举例说明 hidden–隐藏 @ApiImplicitParam() 用于方法 表示单独的请求参数 @ApiImplicitParams() 用于方法，包含多个 @ApiImplicitParam name–参数ming value–参数说明 dataType–数据类型 paramType–参数类型 example–举例说明 @ApiIgnore 作用于方法上，使用这个注解swagger将忽略这个接口 5. SwaggerUI访问404错误在按照网上教程配置好Swagger之后，在localhost:8080/swagger-ui.html 访问即可看到swagger页面了。 但是我第一次按照这样的方法配置却提示如下错误： 1234567Whitelabel Error PageThis application has no explicit mapping for /error, so you are seeing this as a fallback.Thu Nov 24 19:57:13 CST 2016There was an unexpected error (type=Not Found, status=404).No message available 出现404不是说文件没有，而是映射出现了问题，特别是静态文件映射。 解决方法： 在WebMvcConfig下添加如下代码：（若没有创建此拦截器，创建并extends WebMvcConfigurerAdapter） 123456789@Overridepublic void addResourceHandlers(ResourceHandlerRegistry registry) &#123; registry.addResourceHandler(\"/**\").addResourceLocations(\"classpath:/static/\"); registry.addResourceHandler(\"swagger-ui.html\") .addResourceLocations(\"classpath:/META-INF/resources/\"); registry.addResourceHandler(\"/webjars/**\") .addResourceLocations(\"classpath:/META-INF/resources/webjars/\"); super.addResourceHandlers(registry);&#125; 6.参考 Spring Boot 系列（七）Swagger2-生成RESTful接口文档 springboot添加swagger2组件 SpringBoot配置SwaggerUI访问404错误","categories":[{"name":"SSM框架","slug":"SSM框架","permalink":"https://caoler.cn/categories/SSM框架/"},{"name":"SpringBoot","slug":"SSM框架/SpringBoot","permalink":"https://caoler.cn/categories/SSM框架/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://caoler.cn/tags/SpringBoot/"}]},{"title":"生活总是那么戏剧","slug":"生活总是那么戏剧","date":"2018-04-26T15:09:28.000Z","updated":"2018-05-27T10:47:18.008Z","comments":true,"path":"/post/2018/10jqka.html","link":"","permalink":"https://caoler.cn/post/2018/10jqka.html","excerpt":"题目来自于找工作时百般焦虑时室友口中的一句话，就直接借用了。","text":"题目来自于找工作时百般焦虑时室友口中的一句话，就直接借用了。 粗略的算起，找工作到今天拿到同花顺offer已经过去了46天，由一开始的兴奋，到自信，再到将就，再到崩溃，再到满心欢喜。实话说46天过的实在煎熬，它不像高考 最终只有两个答案，但是三年的努力让我又不想将就。期间有拿到武汉小公司的offer，但是感觉实在跟自己的实力不太匹配，所以到最终还是放弃了。回到标题，为什么要说生活总是那么戏剧，因为在面试同花顺之前我做了一个特别大的决定：我放弃了学习了近三年的Java 而去转战PHP。其实到今天拿到offer的那一刻 还是心有余悸，有那么一份不舍。我不知道我的决定是否正确，是否会对我的以后产生太大的影响，严重到就像青春的赌注，不说赌赢了，起码我不想输。一回头，努力学了三年的Java就这样突然没了 没了 了。。。 我相信在我的努力之下时间会给我答案，尽管这句话听起来那么的不靠谱。 我为自己感到欣慰，因为2018年的初步目标我已经完成了一半了。 写到这里 我很想感谢几个人。谢谢室友三年的陪伴，谢谢王峻洋平常一起的愉快玩耍和在找工作路上对我的指点和参谋。谢谢9栋508的小伙伴，谢谢梁壮董博和我在项目里的合作，谢谢你们在我找工作时候的指导。谢谢FJY和AYS一年多的陪伴。 同花顺的工作时光我会更加努力，在PHP的道路上勇往直前！ 像迎新系统第一屏说的那样，祝我在同花顺度过开心充实的美好时光！ 有感而发，就写到这里。 2018年4月26日23:07:02 时隔一月，更新一下。 我逐渐适应了在杭州的生活，由一开始的期待到焦躁不安再到现在的无法形容。值得庆幸的是就是回归单身了，还有我赶上组内转型了，我又可以继续写我的JAVA代码了。 昨天终于看了一直想看的肖申克的救赎，满分10分我打9.9分，因为中间上厕所打断了一下，哈 感觉这张图是最符合我现在的处境的一张，待我爬出那根下水道再来更新它。 还有就是希望自己能开心一点，不要太压抑了。 更新于：2018年5月27日18:46:52","categories":[{"name":"CodingLife","slug":"CodingLife","permalink":"https://caoler.cn/categories/CodingLife/"}],"tags":[{"name":"CodingLife","slug":"CodingLife","permalink":"https://caoler.cn/tags/CodingLife/"}]},{"title":"Spring Bean生命周期","slug":"Spring Bean生命周期","date":"2018-04-07T11:13:48.000Z","updated":"2018-04-07T11:15:06.818Z","comments":true,"path":"/post/2018/SpringBeanLife.html","link":"","permalink":"https://caoler.cn/post/2018/SpringBeanLife.html","excerpt":"Spring Bean 生命周期BeanFactory和ApplicationContext是Spring两种很重要的容器,前者提供了最基本的依赖注入的支持，而后者在继承前者的基础进行了功能的拓展，例如增加了事件传播，资源访问和国际化的消息访问等功能。 概括来说主要有四个阶段：实例化，初始化，使用，销毁。","text":"Spring Bean 生命周期BeanFactory和ApplicationContext是Spring两种很重要的容器,前者提供了最基本的依赖注入的支持，而后者在继承前者的基础进行了功能的拓展，例如增加了事件传播，资源访问和国际化的消息访问等功能。 概括来说主要有四个阶段：实例化，初始化，使用，销毁。 Bean 作用范围常用的Bean作用范围：singleton和prototype singleton在默认情况下,Spring的ApplicationContext容器在启动时,自动实例化所有singleton的Bean并缓存于容器中.虽然启动时会花费一些时间,但带来两个好处:首先对Bean提前的实例化操作会及早发现一些潜在的配置问题.其次Bean以缓存的方式保存,当运行时使用到该Bean时就无须再实例化了,加快了运行效率.如果用户不希望在容器启动时提前实例化singleton的Bean,可以通过lazy-init属性进行控制. prototype在默认情况下,Spring容器在启动时不实例化prototype的Bean.此外,Spring容器将prototype的Bean交给调用者后,就不再管理它的生命周期. ApplicationContext Bean生命周期Spring Bean的完整生命周期从创建Spring容器开始，直到最终Spring容器销毁Bean，这其中包含了一系列关键点。 流程图 各种接口方法分类Bean的完整生命周期经历了各种方法调用，这些方法可以划分为以下几类： Bean自身的方法：这个包括了Bean本身调用的方法和通过配置文件中的init-method和destroy-method指定的方法 Bean级生命周期接口方法：这个包括了BeanNameAware、BeanFactoryAware、InitializingBean和DiposableBean这些接口的方法 容器级生命周期接口方法：这个包括了InstantiationAwareBeanPostProcessor和 BeanPostProcessor这两个接口实现，一般称它们的实现类为“后处理器”。容器中每个bean初始化都要经过这一步。 工厂后处理器接口BeanFactoryPostProcessor方法：这个包括了AspectJWeavingEnabler, ConfigurationClassPostProcessor, CustomAutowireConfigurer等等非常有用的工厂后处理器接口的方法。工厂后处理器也是容器级的，在应用上下文装配配置文件之后立即调用。 流程说明ApplicationContext容器中，Bean的生命周期流程如上图所示，流程大致如下： 首先容器启动后，会对scope为singleton且非懒加载的bean进行实例化， 按照Bean定义信息配置信息，注入所有的属性， 如果Bean实现了BeanNameAware接口，会回调该接口的setBeanName()方法，传入该Bean的id，此时该Bean就获得了自己在配置文件中的id， 如果Bean实现了BeanFactoryAware接口,会回调该接口的setBeanFactory()方法，传入该Bean的BeanFactory，这样该Bean就获得了自己所在的BeanFactory， 如果Bean实现了ApplicationContextAware接口,会回调该接口的setApplicationContext()方法，传入该Bean的ApplicationContext，这样该Bean就获得了自己所在的ApplicationContext， 如果有Bean实现了BeanPostProcessor接口，则会回调该接口的postProcessBeforeInitialzation()方法， 如果Bean实现了InitializingBean接口，则会回调该接口的afterPropertiesSet()方法， 如果Bean配置了init-method方法，则会执行init-method配置的方法， 如果有Bean实现了BeanPostProcessor接口，则会回调该接口的postProcessAfterInitialization()方法， 经过流程9之后，就可以正式使用该Bean了,对于scope为singleton的Bean,Spring的ioc容器中会缓存一份该bean的实例，而对于scope为prototype的Bean,每次被调用都会new一个新的对象，期生命周期就交给调用方管理了，不再是Spring容器进行管理了 容器关闭后，如果Bean实现了DisposableBean接口，则会回调该接口的destroy()方法， 如果Bean配置了destroy-method方法，则会执行destroy-method配置的方法，至此，整个Bean的生命周期结束 BeanFactory Bean生命周期BeanFactoty容器中, Bean的生命周期如下图所示，与ApplicationContext相比，有如下几点不同: BeanFactory容器中，不会调用ApplicationContextAware接口的setApplicationContext()方法 BeanPostProcessor接口的postProcessBeforeInitialzation()方法和postProcessAfterInitialization()方法不会自动调用，必须自己通过代码手动注册 BeanFactory容器启动的时候，不会去实例化所有Bean,包括所有scope为singleton且非懒加载的Bean也是一样，而是在调用的时候去实例化。 流程图 流程说明 当调用者通过 getBean(name)向 容器寻找Bean时，如果容器注册了org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessor接口，在实例bean之前，将调用该接口的 postProcessBeforeInstantiation()方法 容器寻找Bean的定义信息，并将其实例化 使用依赖注入，Spring按照Bean定义信息配置Bean的所有属性 如果Bean实现了BeanNameAware接口，工厂调用Bean的setBeanName()方法传递Bean的id 如果实现了BeanFactoryAware接口，工厂调用setBeanFactory()方法传入工厂自身 如果BeanPostProcessor和Bean关联，那么它们的postProcessBeforeInitialization()方法将被调用（需要手动进行注册！） 如果Bean实现了InitializingBean接口，则会回调该接口的afterPropertiesSet()方法 如果Bean指定了init-method方法，就会调用init-method方法 如果BeanPostProcessor和Bean关联，那么它的postProcessAfterInitialization()方法将被调用（需要手动注册！） 现在Bean已经可以使用了 scope为singleton的Bean缓存在Spring IOC容器中 scope为prototype的Bean生命周期交给客户端 销毁 如果Bean实现了DisposableBean接口，destory()方法将会被调用 如果配置了destory-method方法，就调用这个方法 演示用一个简单的Spring Bean来演示一下Spring Bean的生命周期。 1、首先是一个简单的Spring Bean，调用Bean自身的方法和Bean级生命周期接口方法，为了方便演示，它实现了BeanNameAware、ApplicationContextAware、BeanFactoryAware、InitializingBean和DiposableBean这5个接口，同时有2个方法，对应配置文件中的init-method和destroy-method。如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071import org.springframework.beans.BeansException;import org.springframework.beans.factory.BeanFactory;import org.springframework.beans.factory.BeanFactoryAware;import org.springframework.beans.factory.BeanNameAware;import org.springframework.beans.factory.DisposableBean;import org.springframework.beans.factory.InitializingBean;public class Person implements BeanFactoryAware, BeanNameAware, InitializingBean, DisposableBean &#123; private String name; private String address; private int phone; private BeanFactory beanFactory; private String beanName; public Person() &#123; System.out.println(\"【构造器】调用Person的构造器实例化\"); &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; System.out.println(\"【注入属性】注入属性name\"); this.name = name; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; System.out.println(\"【注入属性】注入属性address\"); this.address = address; &#125; public int getPhone() &#123; return phone; &#125; public void setPhone(int phone) &#123; System.out.println(\"【注入属性】注入属性phone\"); this.phone = phone; &#125; @Override public String toString() &#123; return \"Person [address=\" + address + \", name=\" + name + \", phone=\" + phone + \"]\"; &#125; // 这是BeanFactoryAware接口方法 @Override public void setBeanFactory(BeanFactory beanFactory) throws BeansException &#123; System.out.println(\"【BeanFactoryAware接口】调用BeanFactoryAware.setBeanFactory()\"); this.beanFactory = beanFactory; &#125; // 这是BeanNameAware接口方法 @Override public void setBeanName(String name) &#123; System.out.println(\"【BeanNameAware接口】调用BeanNameAware.setBeanName()\"); this.beanName = name; &#125; // 这是InitializingBean接口方法 @Override public void afterPropertiesSet() throws Exception &#123; System.out.println(\"【InitializingBean接口】调用InitializingBean.afterPropertiesSet()\"); &#125; // 这是DiposibleBean接口方法 @Override public void destroy() throws Exception &#123; System.out.println(\"【DiposibleBean接口】调用DiposibleBean.destory()\"); &#125; // 通过&lt;bean&gt;的init-method属性指定的初始化方法 public void myInit() &#123; System.out.println(\"【init-method】调用&lt;bean&gt;的init-method属性指定的初始化方法\"); &#125; // 通过&lt;bean&gt;的destroy-method属性指定的初始化方法 public void myDestory() &#123; System.out.println(\"【destroy-method】调用&lt;bean&gt;的destroy-method属性指定的初始化方法\"); &#125;&#125; 2、接下来是演示BeanPostProcessor接口的方法，如下：1234567891011121314151617import org.springframework.beans.BeansException;import org.springframework.beans.factory.config.BeanPostProcessor;public class MyBeanPostProcessor implements BeanPostProcessor &#123; public MyBeanPostProcessor() &#123; super(); System.out.println(\"这是BeanPostProcessor实现类构造器！！\"); &#125; @Override public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123; System.out.println(\"BeanPostProcessor接口方法postProcessBeforeInitialization对属性进行更改！\"); return bean; &#125; public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123; System.out.println(\"BeanPostProcessor接口方法postProcessAfterInitialization对属性进行更改！\"); return bean; &#125;&#125; 如上，BeanPostProcessor接口包括2个方法postProcessAfterInitialization和postProcessBeforeInitialization，这两个方法的第一个参数都是要处理的Bean对象，第二个参数都是Bean的name。返回值也都是要处理的Bean对象。 3、InstantiationAwareBeanPostProcessor 接口本质是BeanPostProcessor的子接口，一般我们继承Spring为其提供的适配器类InstantiationAwareBeanPostProcessorAdapter来使用它，如下：1234567891011121314151617181920212223242526272829import java.beans.PropertyDescriptor;import org.springframework.beans.BeansException;import org.springframework.beans.PropertyValues;import org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessorAdapter;public class MyInstantiationAwareBeanPostProcessor extends InstantiationAwareBeanPostProcessorAdapter &#123; public MyInstantiationAwareBeanPostProcessor() &#123; super(); System.out.println(\"这是InstantiationAwareBeanPostProcessorAdapter实现类构造器！！\"); &#125; // 接口方法、实例化Bean之前调用 @Override public Object postProcessBeforeInstantiation(Class beanClass, String beanName) throws BeansException &#123; System.out.println(\"InstantiationAwareBeanPostProcessor调用postProcessBeforeInstantiation方法\"); return null; &#125; // 接口方法、实例化Bean之后调用 @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123; System.out.println(\"InstantiationAwareBeanPostProcessor调用postProcessAfterInitialization方法\"); return bean; &#125; // 接口方法、设置某个属性时调用 @Override public PropertyValues postProcessPropertyValues(PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName) throws BeansException &#123; System.out.println(\"InstantiationAwareBeanPostProcessor调用postProcessPropertyValues方法\"); return pvs; &#125;&#125; 这个有3个方法，其中第二个方法postProcessAfterInitialization就是重写了BeanPostProcessor的方法。第三个方法postProcessPropertyValues用来操作属性，返回值也应该是PropertyValues对象。 4、工厂后处理器接口方法，如下：12345678910111213141516import org.springframework.beans.BeansException;import org.springframework.beans.factory.config.BeanDefinition;import org.springframework.beans.factory.config.BeanFactoryPostProcessor;import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;public class MyBeanFactoryPostProcessor implements BeanFactoryPostProcessor &#123; public MyBeanFactoryPostProcessor() &#123; super(); System.out.println(\"这是BeanFactoryPostProcessor实现类构造器！！\"); &#125; @Override public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException &#123; System.out.println(\"BeanFactoryPostProcessor调用postProcessBeanFactory方法\"); BeanDefinition bd = arg0.getBeanDefinition(\"person\"); bd.getPropertyValues().addPropertyValue(\"phone\", \"110\"); &#125;&#125; BeanFactoryPostProcessor 可以修改 bean 的配置信息而 BeanPostProcessor 不能12345678910111213public class MyBeanFactoryPostProcessor implements BeanFactoryPostProcessor &#123; public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException &#123; //BeanFactoryPostProcessor可以修改BEAN的配置信息而BeanPostProcessor不能 //我们在这里修改postProcessorBean的username注入属性 BeanDefinition bd = beanFactory.getBeanDefinition(\"postProcessorBean\"); MutablePropertyValues pv = bd.getPropertyValues(); if(pv.contains(\"username\")) &#123; pv.addPropertyValue(\"username\", \"xiaojun\"); &#125; &#125;&#125; 5、配置文件如下beans.xml，使用ApplicationContext,处理器不用手动注册：123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:p=\"http://www.springframework.org/schema/p\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd\"&gt; &lt;bean id=\"beanPostProcessor\" class=\"springBeanTest.MyBeanPostProcessor\"&gt; &lt;/bean&gt; &lt;bean id=\"instantiationAwareBeanPostProcessor\" class=\"springBeanTest.MyInstantiationAwareBeanPostProcessor\"&gt; &lt;/bean&gt; &lt;bean id=\"beanFactoryPostProcessor\" class=\"springBeanTest.MyBeanFactoryPostProcessor\"&gt; &lt;/bean&gt; &lt;bean id=\"person\" class=\"springBeanTest.Person\" init-method=\"myInit\" destroy-method=\"myDestory\" scope=\"singleton\" p:name=\"张三\" p:address=\"广州\" p:phone=\"15900000000\" /&gt;&lt;/beans&gt; 6、测试1234567891011121314import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class BeanLifeCycleTest &#123; public static void main(String[] args) &#123; System.out.println(\"现在开始初始化容器\"); ApplicationContext factory = new ClassPathXmlApplicationContext(\"beans.xml\"); System.out.println(\"容器初始化成功\"); // 得到Preson，并使用 Person person = factory.getBean(\"person\", Person.class); System.out.println(person); System.out.println(\"现在开始关闭容器！\"); ((ClassPathXmlApplicationContext) factory).registerShutdownHook(); &#125;&#125; 关闭容器使用的是实际是AbstractApplicationContext的钩子方法。 7、结果：12345678910111213141516171819202122232425262728现在开始初始化容器[location]15:15:33 100 INFO (org.springframework.context.support.ClassPathXmlApplicationContext:510) - Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@75a70476: startup date [Mon May 08 15:15:33 CST 2017]; root of context hierarchy[location]15:15:33 194 INFO (org.springframework.beans.factory.xml.XmlBeanDefinitionReader:315) - Loading XML bean definitions from class path resource [beans.xml]这是BeanFactoryPostProcessor实现类构造器！！BeanFactoryPostProcessor调用postProcessBeanFactory方法这是BeanPostProcessor实现类构造器！！这是InstantiationAwareBeanPostProcessorAdapter实现类构造器！！[location]15:15:33 695 INFO (org.springframework.beans.factory.support.DefaultListableBeanFactory:596) - Pre-instantiating singletons in org.springframework.beans.factory.support.DefaultListableBeanFactory@461d434f: defining beans [beanPostProcessor,instantiationAwareBeanPostProcessor,beanFactoryPostProcessor,person]; root of factory hierarchyInstantiationAwareBeanPostProcessor调用postProcessBeforeInstantiation方法【构造器】调用Person的构造器实例化InstantiationAwareBeanPostProcessor调用postProcessPropertyValues方法【注入属性】注入属性address【注入属性】注入属性name【注入属性】注入属性phone【BeanNameAware接口】调用BeanNameAware.setBeanName()【BeanFactoryAware接口】调用BeanFactoryAware.setBeanFactory()BeanPostProcessor接口方法postProcessBeforeInitialization对属性进行更改！【InitializingBean接口】调用InitializingBean.afterPropertiesSet()【init-method】调用&lt;bean&gt;的init-method属性指定的初始化方法BeanPostProcessor接口方法postProcessAfterInitialization对属性进行更改！InstantiationAwareBeanPostProcessor调用postProcessAfterInitialization方法容器初始化成功Person [address=广州, name=张三, phone=110]现在开始关闭容器！[location]15:15:33 752 INFO (org.springframework.context.support.ClassPathXmlApplicationContext:1042) - Closing org.springframework.context.support.ClassPathXmlApplicationContext@75a70476: startup date [Mon May 08 15:15:33 CST 2017]; root of context hierarchy[location]15:15:33 752 INFO (org.springframework.beans.factory.support.DefaultListableBeanFactory:444) - Destroying singletons in org.springframework.beans.factory.support.DefaultListableBeanFactory@461d434f: defining beans [beanPostProcessor,instantiationAwareBeanPostProcessor,beanFactoryPostProcessor,person]; root of factory hierarchy【DiposibleBean接口】调用DiposibleBean.destory()【destroy-method】调用&lt;bean&gt;的destroy-method属性指定的初始化方法 总结Bean的完整生命周期从 spring 容器开始实例化 bean 开始，到销毁。可以从三点来理解 bean自身的方法：包括构造方法、 set 方法、 init-method 指定的方法、 destroy-method 指定的方法 bean级生命周期接口方法：如BeanNameAware 、 BeanFactoryAware 等这些接口方法由 bean类实现 容器级生命周期接口方法：有InstantiationAwareBeanPostProcessor 、 BeanPostProcessor等。一般称为后处理器。他们一般不由bean 本身实现，独立存在，注册到 spring 容器中。 Spring 通过接口反射预先知道，当 spring 容器创建任何 bean 时，这些后处理器都会发生作用。所以他们是全局的，用户可以通过编码对只感兴趣的 bean 进行处理 参考 简书 - SpringBean生命周期 博客园 - Spring Bean的生命周期（非常详细）","categories":[{"name":"SSM框架","slug":"SSM框架","permalink":"https://caoler.cn/categories/SSM框架/"},{"name":"Spring","slug":"SSM框架/Spring","permalink":"https://caoler.cn/categories/SSM框架/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://caoler.cn/tags/Spring/"}]},{"title":"《深入理解Java虚拟机》读书笔记2 - 垃圾收集器与内存分配策略","slug":"垃圾收集器与内存分配策略","date":"2018-03-07T13:17:43.000Z","updated":"2018-03-08T08:33:04.714Z","comments":true,"path":"/post/2018/deep-in-jvm-part2.html","link":"","permalink":"https://caoler.cn/post/2018/deep-in-jvm-part2.html","excerpt":"第三章 垃圾收集器与内存分配策略概述思考GC需要完成的3件事情： 哪些内存需要回收？ 什么时候回收？ 如何回收？再回头看看第二章介绍的Java内存运行时区域的各个部分：","text":"第三章 垃圾收集器与内存分配策略概述思考GC需要完成的3件事情： 哪些内存需要回收？ 什么时候回收？ 如何回收？再回头看看第二章介绍的Java内存运行时区域的各个部分： 程序计时器、虚拟机栈、本地方法栈：随线程而灭，栈帧随方法而进行出栈和入栈，每一个栈帧分配的内存在类结构确定就已知，因此这几个区域不需要考虑回收； 对于Java堆和方法区，只有程序运行期间才知道会创建哪些对象，内存的分配和回收都是动态的，垃圾收集器所关注的是这部分内存；对象已死吗？在垃圾收集器进行回收前，第一件事就是确定这些对象哪些还存活，哪些已经死去。 引用计数算法给对象添加引用计数器，当有地方引用它时就加1，引用失效就减1，为0时就认为对象不再被使用可回收。该算法失效简单，判断高效，但并不被主流虚拟机采用，主要原因是它很难解决对象之间相互循环引用的问题。 可达性分析算法通过一系列的称为“GC Roots”的对象作为起点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），如果一个对象到GC Roots没有引用链相连，则该对象是不可用的。 在Java语言中，可作为GC Roots的对象包括： 虚拟机栈（栈帧中的本地变量表）中引用的对象； 方法区中类静态属性引用的对象； 方法区中常量引用的对象； 本地方法栈中JNI（即一般说的Native方法）引用的对象； 再谈引用在JDK 1.2之后，Java对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用和虚引用，这4种引用强度依次减弱。 生存还是死亡要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize方法（如没有重写finalize方法或者已经被调用过则认为没有必要执行）；如果有必要执行则将该对象放置在F-Queue队列中，并在稍后由一个由虚拟机自己建立的、低优先级的Finalizer线程去执行它；稍后GC将对F-Queue中的对象进行第二次标记，如果对象还是没有被引用，则会被回收。 但是作者不建议通过finalize方法“拯救”对象，因为它运行代价高、不确定性大、无法保证各个对象的调用顺序。 回收方法区永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类。 一个无用的类需要满足以下三个条件： 该类的所有实例都已经被回收； 加载该类的ClassLoader已经被回收； 该类对象的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法； 在大量使用反射、动态代理、CGLib等ByteCode框架、动态生成JSP以及OSGI这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能（HotSpot提供-Xnoclassgc参数控制），以保证永久代不会溢出。 垃圾收集算法 标记-清除算法：首先标记出所有需要回收的对象，然后统一回收所有被标记的对象；缺点是效率不高且容易产生大量不连续的内存碎片； 复制算法：将可用内存分为大小相等的两块，每次只使用其中一块；当这一块用完了，就将还活着的对象复制到另一块上，然后把已使用过的内存清理掉。在HotSpot里，考虑到大部分对象存活时间很短将内存分为Eden和两块Survivor，默认比例为8:1:1。代价是存在部分内存空间浪费，适合在新生代使用； 标记-整理算法：首先标记出所有需要回收的对象，然后让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。适用于老年代。 分代收集算法：一般把Java堆分新生代和老年代，在新生代用复制算法，在老年代用标记-清理或标记-整理算法，是现代虚拟机通常采用的算法。 HotSpot的算法实现枚举根节点由于要确保在一致性的快照中进行可达性分析，从而导致GC进行时必须要停顿所有Java执行线程；在HotSpot里通过一组OopMap数据结构来知道哪些地方存放着对象引用； 安全点HotSpot只在特定的位置记录了OopMap，这些位置称为安全点（SafePoint）；即程序执行时并非在所有地方都能停顿下来开始GC，只有到达安全点时才能暂停；对于安全点基本上是以程序“是否具有让程序长时间执行的特征”（比如方法调用、循环跳转、异常跳转等）为标准进行选定的；另外还需要考虑如果在GC时让所有线程都跑到最近的安全点上，有两种方案：抢先式中断和主动式中断（主流选择）； 安全区域如果程序没有分配CPU时间（如线程处于Sleep或Blocked），此时就需要安全区域（Safe Region），其是指在一段代码片段之中，引用关系不会发生变化；线程执行到安全区域时，首先标识自己已经进入了安全区域，这样JVM在GC时就不管这些线程了； 垃圾收集器垃圾收集算法是内存回收的方法论，垃圾收集器就是内存回收的具体实现。这里讨论JDK 1.7 Update 14之后的HotSpot虚拟机（此时G1仍处于实验状态），包含的虚拟机如下图所示（存在连线的表示可以搭配使用）： Serial收集器 最基本、发展历史最悠久，在JDK 1.3之前是新生代收集的唯一选择； 是一个单线程（并非指一个收集线程，而是会暂停所有工作线程）的收集器，采用的是复制算法； 现在依然是虚拟机运行在Client模式下的默认新生代收集器，主要就是因为它简单而高效（没有线程交互的开销）； ParNew收集器 其实就是Serial收集器的多线程版本； ParNew收集器在单CPU环境中绝对不会有比Serial收集器更好的效果； 是许多运行在Server模式下虚拟机首选的新生代收集器，重要原因就是除了Serial收集器外，只有它能与CMS收集器配合工作； 并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态； 并发（Concurrent）：指用户线程与垃圾收集线程同时执行，用户线程在继续执行而垃圾收集程序运行在另外一个CPU上； Parallel Scavenge收集器 新生代收集器，使用复制算法，并行的多线程收集器； 与其他收集器关注于尽可能缩短垃圾收集时用户线程停顿时间不同，它的目标是达到一个可控制的吞吐量； 高吞吐量可以高效率利用CPU时间，适合在后台运算而不需要太多交互的任务； -XX:MaxGCPauseMillis参数可以设置最大停顿时间，而停顿时间缩短是以牺牲吞吐量和新生代空间来换取的； 另外它还支持GC自适应的调节策略； Serial Old收集器 是Serial收集器的老年代版本，同样是单线程，使用标记-整理算法； 主要是给Client模式下的虚拟机使用的； 在Server模式下主要是给JDK 1.5及之前配合Parallel Scavenge使用或作为CMS收集器的后备预案； Parallel Old收集器 是Parallel Scavenge的老年代版本，使用多线程和标记-整理算法； 是JDK 1.6中才开始提供的； CMS收集器 是一种以获取最短回收停顿时间为目标的收集器，特别适合互联网站或者B/S的服务端； 它是基于标记-清除 算法实现的，主要包括4个步骤：初始标记（STW，只是初始标记一下GC Roots能直接关联到的对象，速度很快）、并发标记（非STW，执行GC RootsTracing，耗时比较长）、重新标记（STW，修正并发标记期间因用户程序继续导致变动的那一部分对象标记）和并发清除（非STW，耗时较长）； 还有3个明显的缺点：CMS收集器对CPU非常敏感（占用部分线程及CPU资源，影响总吞吐量）、无法处理浮动垃圾（默认达到92%就触发垃圾回收）、大量内存碎片产生（可以通过参数启动压缩）； G1收集器 一款面向服务端应用的垃圾收集器，后续会替换掉CMS垃圾收集器； 特点：并行与并发（充分利用多核多CPU缩短Stop-The-World时间）、分代收集（独立管理整个Java堆，但针对不同年龄的对象采取不同的策略）、空间整合（基于标记-整理）、可预测的停顿（将堆分为大小相等的独立区域，避免全区域的垃圾收集）； 关于Region：新生代和老年代不再物理隔离，只是部分Region的集合；G1跟踪各个Region垃圾堆积的价值大小，在后台维护一个优先列表，根据允许的收集时间优先回收价值最大的Region；Region之间的对象引用以及其他收集器中的新生代与老年代之间的对象引用，采用Remembered Set来避免全堆扫描； 分为几个步骤：初始标记（标记一下GC Roots能直接关联的对象并修改TAMS值，需要STW但耗时很短）、并发标记（从GC Root从堆中对象进行可达性分析找存活的对象，耗时较长但可以与用户线程并发执行）、最终标记（为了修正并发标记期间产生变动的那一部分标记记录，这一期间的变化记录在Remembered Set Log里，然后合并到Remembered Set里，该阶段需要STW但是可并行执行）、筛选回收（对各个Region回收价值排序，根据用户期望的GC停顿时间制定回收计划来回收）； 理解GC日志 最前面的数字代表GC发生的时间（虚拟机启动以后的秒杀）； “[GC”和“[Full GC”说明停顿类型，有Full代表的是Stop-The-World的； “[DefNew”、“[Tenured”和“[Perm”表示GC发生的区域； 方括号内部的“3324K -&gt; 152K(3712K)” 含义是 “GC前该内存已使用容量 -&gt; GC后该内存区域已使用容量(该区域总容量)”; 方括号之外的“3324K -&gt; 152K(11904)” 含义是 “GC前Java堆已使用容量 -&gt; GC后Java堆已使用容量(Java堆总容量)”; 再往后“0.0025925 secs”表示该内存区域GC所占用的时间； 垃圾收集器参数总结 内存分配与回收策略 对象优先在新生代分配 大对象直接进入老年代 长期存活的对象将进入老年代 动态对象年龄判断：如果在Survivor空间中相同年龄所有对象大小总和大于Survivor空间的一半，大于或等于该年龄的对象直接进入老年代； 空间分配担保：发生Minor GC前，虚拟机会先检查老年代最大可用连续空间是否大于新生代所有对象总空间，如果不成立，虚拟机会查看HandlePromotionFailure设置值是否允许担保失败，如果允许继续检查老年代最大可用的连续空间是否大于历次晋升到老年代的平均大小，如果大于会尝试进行一次Minor GC；如果小于或者不允许冒险，会进行一次Full GC； 本章小结本章介绍了垃圾回收算法、几款JDK 1.7中提供的垃圾收集器特点以及运作原理。内存回收与垃圾收集器在很多时候都是影响系统性能、并发能力的主要因素之一，然而没有固定收集器和参数组合，也没有最优的调优方法，需要根据实践了解各自的行为、优势和劣势。","categories":[{"name":"JVM","slug":"JVM","permalink":"https://caoler.cn/categories/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://caoler.cn/tags/JVM/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://caoler.cn/tags/读书笔记/"}]},{"title":"一个小程序员的2017年年度总结","slug":"2017总结","date":"2018-01-24T03:03:24.000Z","updated":"2018-01-24T03:22:02.181Z","comments":true,"path":"/post/2018/summary_for_2017.html","link":"","permalink":"https://caoler.cn/post/2018/summary_for_2017.html","excerpt":"一个小程序员2017年的进步、收获与成长。今天是腊八，新历新年已经过去了两个月。在很早之前就打算写一篇年终总结，但是因为考试一直拖延。放假之后愉快的玩♂耍了一周 决定在这个安静的早晨动笔写起。 2017年是上大学以来最有收获的一年，大概学习了一整个JavaWeb的框架部分，而且还通过参加服务外包比赛让自己的学习成功付诸实现，虽然和组里的DB、HJ比起来自己的实力和别人还有不小差距。但是作为一个容易满足的人，我的2017也算是很完美了。","text":"一个小程序员2017年的进步、收获与成长。今天是腊八，新历新年已经过去了两个月。在很早之前就打算写一篇年终总结，但是因为考试一直拖延。放假之后愉快的玩♂耍了一周 决定在这个安静的早晨动笔写起。 2017年是上大学以来最有收获的一年，大概学习了一整个JavaWeb的框架部分，而且还通过参加服务外包比赛让自己的学习成功付诸实现，虽然和组里的DB、HJ比起来自己的实力和别人还有不小差距。但是作为一个容易满足的人，我的2017也算是很完美了。 回顾总结与展望学习部分 学习Spring，刚开学的三月份翻起Spring的教程，从头至尾学习了一遍。 Hibernate初体验，当时学习的目标就是SSH框架，所以在Spring学习结束之后就直接开始学习Hibernate了。了解到了一个很方便很牛逼的技能–IntelliJ IDEA下自动生成Hibernate映射文件以及实体类 遇到了一个国产轻量级的框架——JFinal，一个小提问还得到了框架作者(波总)的回复 点我查看 但是问题到现在都没有解决。头晕 7月，大二的学习生活结束，留校参加了第八届服务外包比赛，用了半个月的时间学习了MyBatis。虽然这个框架学习的时间很短，但是我觉的这个框架是自己吃的最透的一个（其中一部分原因是时间紧迫做项目马上就要用到，逃~）当时用到的几个好工具： 代码生成器Generator MyBatis的分页插件–MyBaits_PageHelper MyBatisPlus 新学期，再学Spring，这次的学习一部分是为了回顾，另一部分是为了之后的SpringMVC做准备。这次的学习时间比较仓促，也只用了不到半个月，对控制反转IOC 依赖注入DI 面向切面编程有了更深入的了解，跟第一次的学习比较起来收获更大。 SpringMVC的学习。一直到9月26日，SSM框架整合完毕。框架部分的学习也算告一段落。 10月，我接触了一部分前端的知识。包括JavaScriptDOM、jQuery，但是这部分的学习学的比较潦草，跟读书一样 只能称作是泛读。 精读《图解HTTP》，插画风格的书阅读起来很轻松，也很容易理解，虽然书的内容很少，但是我了解了网络协议的传输过程，手里还有一本《图解TCP/IP》也打算好好啃一啃。 阅读《Core Java》，大一下对JAVASE部分的学习实在是太粗略了，在学习JAVAWEB部分的时候我甚至不知道泛型、迭代器、集合、map。学习《Core Java》这段时间学习很多，以前似懂非懂的东西那段时间里都得到了解决。对Java集合框架部分的内容进行了深入的研究，用四个字来表达，那就是收获颇多！ JAVA并发编程的学习，这段时间 我一改以前的看视频学习方法，转为看博客，看书。一直通过并发编程网来进行学习，同时也借鉴了不少博客的内容，包括CSDN 博客园。 阅读《JAVA并发编程的艺术》《深入理解JVM》，第五部分的内容也就是之前学的并发部分的内容，我的侧重点是第二章和第三章，还没开始看，希望通过这本书我能够深入的了解JAVA内存模型和它的垃圾回收机制。 做项目之前，学习了Git，项目的过程中和DB同学进行了深入的交♂流。对Git的协作开发有了一定的认识和理解。 升级了自己的IDE，由之前的Eclipse到现在的IntelliJ IDEA，编程环境更舒适了，代码写作的效率也变高了。 学习了通过MAVEN编程，抛弃了之前导包的过程，使开发更加方便轻松。 适应了MarkDown的写作，基本丢弃了以前Word的写作方式，也算是一个进步. emmm..学习部分就这些。想到了再补充。 生活部分 最有成就的就是拿到了驾照，虽然前前后后花了快一年的时间，但是拿到证的那一刻还是非常开心的哈哈哈哈(即使照片其丑无比！！！垃圾摄影师)。下面下面： 认识了我的两个好好好朋友FJY,AYS。 这一年没有经常去外面玩，除了端午节去长沙玩的几天。但是吃了无数次小龙坎 刘一手！最好吃的还算长沙吃的井格。 看了17年所有自己想看的电影，没有遗憾！（照片没拍，我觉得有二三十张） 去夜店蹦迪，去酒吧喝到失去知觉，体验了以前没有体验到的东西。 平时还有不菲的收入，除了必要的生活费没有向父母额外多要一分钱，我很自豪。 和几千人一起跨年！！！ 生活很规律，每天都有吃早饭，除了玩每天12点前睡觉，喝水很多，也很爱喝水。 养了三只小乌龟，其中一个跳楼了。还有三颗富贵竹，希望寒假这段时间不要被冻死。 还有就是以前念想的博客，我也按照自己喜欢的风格搭建好了，每一篇学习记录我也都会在这里坚持写下来！–Caole’s Blog 遗憾 CET-4！！！！！头晕 没有找到女朋友！！ 我自己很感谢这些点点滴滴的积累带来的变化，并且坚信在新的一年会变得更好。为了自拍专门下载的相机哈哈！！ 知乎：https://www.zhihu.com/question/263416941/answer/302598812","categories":[{"name":"CodingLife","slug":"CodingLife","permalink":"https://caoler.cn/categories/CodingLife/"}],"tags":[{"name":"CodingLife","slug":"CodingLife","permalink":"https://caoler.cn/tags/CodingLife/"}]},{"title":"《深入理解Java虚拟机》读书笔记1 - Java技术体系、Java内存区域和内存溢出异常","slug":"Java技术体系、Java内存区域和内存溢出异常","date":"2017-12-01T08:18:22.000Z","updated":"2018-04-09T03:16:40.259Z","comments":true,"path":"/post/2017/deep-in-jvm-part1.html","link":"","permalink":"https://caoler.cn/post/2017/deep-in-jvm-part1.html","excerpt":"世界上并没有完美的程序，但我们并不因此而沮丧，因为写程序本来就是一个不断追求完美的过程。 笔记第一部分对应原书的第一章，主要介绍了Java的技术体系、Java虚拟机的发展历史。第二部分对应原书的第二章，主要介绍了Java运行时区域的划分、对象的创建和访问以及内存溢出的实战。","text":"世界上并没有完美的程序，但我们并不因此而沮丧，因为写程序本来就是一个不断追求完美的过程。 笔记第一部分对应原书的第一章，主要介绍了Java的技术体系、Java虚拟机的发展历史。第二部分对应原书的第二章，主要介绍了Java运行时区域的划分、对象的创建和访问以及内存溢出的实战。 Part 1: 走进Java第一章 走进Java概述Java的优点 结构严谨、面向对象 摆脱平台的束缚，一次编写到处运行 提供了相对安全的内存管理和访问机制 实现了热点代码检测和运行时编译及优化 一套完善的应用程序接口以及无数的第三方类库 Java技术体系Sun官方所定义的Java技术体系包括： Java程序设计语言 各种硬件平台上的Java虚拟机 Class文件格式 Java API类库 来自商业机构和开源社区的第三方Java类库JDK是用于支持Java开发的最小环境，JRE是支持Java程序运行的标准环境，整个Java体系如下所示： Java发展史 JDK 1.0: Java虚拟机、Applet、AWT等； JDK 1.1：JAR文件格式、JDBC、JavaBeans、RMI、内部类、反射； JDK 1.2：拆分为J2SE/J2EE/J2ME、内置JIT编译器、一系列Collections集合类； JDK 1.3：JNDI服务、使用CORBA IIOP实现RMI通信协议、Java 2D改进； JDK 1.4：正则表达式、异常链、NIO、日志类、XML解析器和XSLT转换器； JDK 1.5：自动装箱、泛型、动态注解、枚举、可变参数、遍历循环、改进了Java内存模型、提供了java.util.concurrent并发包； JDK 1.6：提供动态语言支持、提供编译API和微型HTTP服务器API、虚拟机优化（锁与同步、垃圾收集、类加载等）； JDK 1.7：G1收集器、加强对Java语言的调用支持、升级类加载架构； JDK 1.8：Lambda表达式等； Java虚拟机发展史 Sun Classic/Exact VM：Classic VM是第一款商用虚拟机，纯解析器方式来执行Java代码，如果要使用JIT编译器就必须进行外挂，解析器和编译器不能配合工作，编译器执行效率非常差；Exact VM是Sun虚拟机团队曾在Solaris平台发布的虚拟机，支持两级即时编译器、编译器和解释器混合工作、使用准确内存管理（虚拟机可以知道内存中某个位置的数据具体是什么类型），但很快就被HotSpot VM所取代； Sun HotSpot VM：Sun JDK和OpenJDK所带的虚拟机，目前使用范围最广；继承了前两款虚拟机的优点，还支持热点代码探测技术（通过计数器找出最具编译价值的代码）；2006年Sun公司宣布JDK包括HotSpot VM开源，在此基础上建立OpenJDK； Sun Mobile-Embedded VM/Meta-Circular VM：还有一些Sun开发的面对移动和嵌入式发布的和实验性质的虚拟机； BEA JRockit/IBM J9 VM：JRockit VM号称是世界上最快的Java虚拟机，专注于服务器端应用，不包含解析器实现，全部靠即时编译器编译执行；J9 VM定位于HotSpot比较接近，主要目的是作为IBM公司各种Java产品的执行平台； Azul VM/BEA Liquid VM：特定硬件平台专有的高性能虚拟机； Apache Harmony/Google Android Dalvik VM：Apache Harmony包含自己的虚拟机和Java库，但没有通过TCK认证；Dalvik VM是Android平台的核心组成部分，其并没有遵循Java虚拟机规范，不能直接执行Class文件，使用的是寄存器架构而不是JVM常见的栈架构； Microsoft JVM及其他：微软曾经是Java技术的铁杆支持者，开发过Windows下性能最好的Java虚拟机，但后来被Sun起诉终止其发展； 展望Java技术的未来 模块化 混合语言 多核并行 进一步丰富语法 64位虚拟机 本章小结本章介绍了Java技术体系的过去、现在以及未来的一些发展趋势，并独立编译一个OpenJDK 7的版本。 Part 2:自动内存管理机制第二章 Java内存区域与内存溢出异常概述对于JAVA程序员，在虚拟机自动内存管理机制下，不需要为new操作去写配对的delete/free代码，不容易出现内存泄漏。但是如果出现内存泄漏问题，如果不了解虚拟机的机制，便难以定位。 运行时数据区域 程序计数器 一块较小的内存，可以看作是当前线程所执行的字节码的行号指示器； 在虚拟机概念模型（各种虚拟机实现可能不一样）中，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令； 程序计数器是属于线程私有的内存； 如果执行的是Java方法，该计数器记录的是正在执行的虚拟机字节码指令的地址；如果是Native方法则为空； JAVA虚拟机栈 Java虚拟机栈也是线程私有的； 描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机中入栈到出栈的过程； 局部变量表存放了编译器可知的各种基本数据类型(int、double…)、对象引用和returnAddress类型；其所需的内存空间在编辑期完成分配，不会再运行期改变；可能存在两种异常：StackOverflowError（栈深度大于所允许深度）和OutOfMemoryError（无法申请到足够的内存时）； JAVA堆 JAVA堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。 这里的主要目的就是存放对象和实例，几乎所有的对象实例都在这里分配内存。 JAVA堆是垃圾收集器管理的主要区域，而且还可以细分为新生代和老年代。 JAVA堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。 在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutofMemoryError异常。 方法区 是线程共享的区域； 用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据； 该区域对于垃圾收集来说条件比较苛刻，但是还是非常有必要要进行回收处理，回收目标主要是针对常量池的回收和对类型的卸载； 当无法满足内存分配需求时，将抛出OutOfMemoryError异常； 运行时常量池 是方法区的一部分； Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译器生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放； Java虚拟机规范要求较少，通常还会把翻译出来的直接引用也存储在此； 另外一个重要特征是具备动态性，可以在运行期间将新的常量放入池中，如String的intern方法； 可能存在的异常：OutOfMemoryError； 直接内存 并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域； JDK 1.4的NIO引入了基于通道（Channel）和缓冲区（Buffer）的IO方法，可以使用Native函数库直接分配对外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作以提升性能； HotSpot虚拟机对象探秘进一步了解虚拟机内存中数据的其他细节，比如它们是如何创建、如何布局以及如何访问的。下面以虚拟机HotSpot和常用的内存区域Java堆为例，深入探讨HotSpot虚拟机在Java堆中对象分配、布局和访问的全过程。 对象的创建 虚拟机遇到一条new指令时，先检查指令的参数是否能在常量池中定位到一个类的符号，并且检查这个符号引用代码的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程； 接下来虚拟机将为新生对象分配内存。对象所需的内存大小在类加载完成后便完全确定，为对象分配空间等同于把一块确定大小的内存从Java堆中划分出来。在使用Serial、ParNew等带Compact过程的收集器时，系统采用的分配算法是指针碰撞（内存绝对规整，只要通过指针作为分界点标识）；而使用CMS这种基于Mark-Sweep算法收集器时，通常使用空闲列表（内存不规整，通过维护一个列表记录那块内存是可用的）； 另外一个需要考虑的并发下的线程安全问题，有两种方案：一是分配内存空间的动作进行同步处理（实际上虚拟机采用CAS配上失败重试的方式保证更新操作的原子性）；二是为每个线程分配一小块内存（称为本地线程分配缓冲，TLAB），各个线程独立分配，只有TLAB用完需要分配新的才需要同步锁定，虚拟机通过-XX:+/-UseTLAB参数来设定；内存分配完后，虚拟机将分配到的内存空间都初始化为零值（不包括对象头），这保证了对象的实例字段在Java代码中可以不赋值就直接使用，程序能访问到这些字段数据类型对应的零值； 接下来设置对象的对象头（Object Header）信息，包括对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象GC分代年龄等； 接着执行方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来； HotSpot解释器的代码片段：略 对象的内存布局 对象在内存中存储的布局可以分为3块区域：对象头（Object Header）、实例数据（Instance Data）和对齐填充（Padding）；对象头包括两部分信息：第一部分用于存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等；另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例（并不是所有虚拟机都必须在对象数据上保留类型指针）。另外如果对象是一个Java数组，对象头中还必须有一块用于记录数组长度的数据。 实例数据部分是真正存储的有效信息，也是在代码中所定义的各种类型字段内容。无论是父类继承的还是子类中定义的都需要记录下来。这部分存储的顺序会受到虚拟机分配策略参数和字段在Java源码中定义顺序的影响。 对齐填充不是必然存在的，主要是由于HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍。 对象的访问定位 栈上的reference类型在虚拟机规范中只规定了一个指向对象的引用，并没有定义这个引用应该通过何种方式去定位、访问堆栈对象的具体位置，目前主流的方式方式有句柄和直接直接两种。 通过句柄：Java堆中划出一块内存作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。其最大好处就是reference存储的是稳定的句柄地址，在对象被移到（垃圾收集时移到）只改变实例数据指针，而reference不需要修改； 通过直接指针：Java堆对象的布局中必须考虑如果放置访问类型数据的相关信息，而reference中存在的直接就是对象地址。其最大好处在于速度更快，节省了一次指针定位的时机开销。HotSpot采用该方式进行对象访问，但其他语言和框架采用句柄的也非常常见。 实战：OutOfMemoryError异常 通过代码验证Java虚拟机规范中描述各个运行时区域存储的内容； 在实际遇到内存溢出异常时，能根据异常的信息快速判断是哪个区域内存溢出； Java堆溢出解决思路：先通过内存映像分析工具对dump出来的堆转储快照进行分析，先分清楚是内存泄漏还是内存溢出；如果是内存泄漏，进一步查看泄漏对象到GC Roots的引用链，从而确认为什么无法回收；如果是内存溢出，则应当检查虚拟机堆参数（-Xmx与-Xmx）或检查是否存在对象生命周期过长、持有状态时间过长的情况； 虚拟机栈和本地方法栈溢出 HotSpot不区分虚拟机栈和本地方法栈； StackOverflowError和OutOfMemoryError存在互相重叠的地方；栈容量由-Xss参数设定； 虚拟机的默认参数对于通常的方法调用（1000~2000层）完全够用，通常根据异常的堆栈日志就可以很容易定位问题。 方法区和运行时常量池溢出对于这个区域的测试，基本思路是运行时产生大量的类去填满方法区（比如使用反射和动态代理），这里我们借助CGLib直接操作字节码运行时产生大量的动态类（很对主流框架如Spring、Hibernate都会采用类似的字节码技术）。在这里需要特别注意垃圾回收的状况。 本机直接内存溢出 DirectMemory导致的内存溢出，在Heap Dump里不会看见明显的异常。如果发现OouOfMemory之后Dump文件很小，程序又使用了NIO，那就可以检查下是否这方面的原因。","categories":[{"name":"JVM","slug":"JVM","permalink":"https://caoler.cn/categories/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://caoler.cn/tags/JVM/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://caoler.cn/tags/读书笔记/"}]},{"title":"有趣","slug":"有趣","date":"2017-11-29T03:48:43.000Z","updated":"2017-11-29T03:50:32.940Z","comments":true,"path":"/post/2017/goole-birthday.html","link":"","permalink":"https://caoler.cn/post/2017/goole-birthday.html","excerpt":"","text":"","categories":[{"name":"CodingLife","slug":"CodingLife","permalink":"https://caoler.cn/categories/CodingLife/"}],"tags":[{"name":"CodingLife","slug":"CodingLife","permalink":"https://caoler.cn/tags/CodingLife/"}]},{"title":"join()方法和TheadLocal类","slug":"join()方法和TheadLocal类","date":"2017-11-27T05:37:00.000Z","updated":"2017-11-28T05:37:00.000Z","comments":true,"path":"/post/2017/join-and-threadlocal.html","link":"","permalink":"https://caoler.cn/post/2017/join-and-threadlocal.html","excerpt":"Thread.join()使用方式123Thread t = new AThread();t.start();t.join(); 为什么要用join()方法在很多情况下，主线程生成并起动了子线程，如果子线程里要进行大量的耗时的运算，主线程往往将于子线程之前结束，但是如果主线程处理完其他的事务后，需要用到子线程的处理结果，也就是主线程需要等待子线程执行完成之后再结束，这个时候就要用到join()方法了。 join方法的作用JDK中对join方法解释为：“等待该线程终止”，换句话说就是：”当前线程等待子线程的终止“。也就是在子线程调用了join()方法后面的代码，只有等到子线程结束了当前线程才能执行。 用实例来理解 简单了解join()的用法：","text":"Thread.join()使用方式123Thread t = new AThread();t.start();t.join(); 为什么要用join()方法在很多情况下，主线程生成并起动了子线程，如果子线程里要进行大量的耗时的运算，主线程往往将于子线程之前结束，但是如果主线程处理完其他的事务后，需要用到子线程的处理结果，也就是主线程需要等待子线程执行完成之后再结束，这个时候就要用到join()方法了。 join方法的作用JDK中对join方法解释为：“等待该线程终止”，换句话说就是：”当前线程等待子线程的终止“。也就是在子线程调用了join()方法后面的代码，只有等到子线程结束了当前线程才能执行。 用实例来理解 简单了解join()的用法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class BThread extends Thread &#123; public BThread() &#123; super(\"[BThread] Thread\"); &#125;; public void run() &#123; String threadName = Thread.currentThread().getName(); System.out.println(threadName + \" start.\"); try &#123; for (int i = 0; i &lt; 5; i++) &#123; System.out.println(threadName + \" loop at \" + i); Thread.sleep(1000); &#125; System.out.println(threadName + \" end.\"); &#125; catch (Exception e) &#123; System.out.println(\"Exception from \" + threadName + \".run\"); &#125; &#125; &#125; public class AThread extends Thread &#123; BThread bt; public AThread(BThread bt) &#123; super(\"[AThread] Thread\"); this.bt = bt; &#125; public void run() &#123; String threadName = Thread.currentThread().getName(); System.out.println(threadName + \" start.\"); try &#123; bt.join(); System.out.println(threadName + \" end.\"); &#125; catch (Exception e) &#123; System.out.println(\"Exception from \" + threadName + \".run\"); &#125; &#125; &#125; public class TestDemo &#123; public static void main(String[] args) &#123; String threadName = Thread.currentThread().getName(); System.out.println(threadName + \" start.\"); BThread bt = new BThread(); AThread at = new AThread(bt); try &#123; bt.start(); Thread.sleep(2000); at.start(); at.join(); &#125; catch (Exception e) &#123; System.out.println(\"Exception from main\"); &#125; System.out.println(threadName + \" end!\"); &#125; &#125; 运行结果： 1234567891011main start. -- 主线程启动, 因为主线程中调用了at.join(), 所以主线程要等到 AThread线程结束之后才能执行 [BThread] Thread start. [BThread] Thread loop at 0 [BThread] Thread loop at 1 [AThread] Thread start. -- AThread线程启动, 因为AThread线程中调用了bt.join(), 所以AThread线程要等到BThread线程结束之后才能执行 [BThread] Thread loop at 2 [BThread] Thread loop at 3 [BThread] Thread loop at 4 [BThread] Thread end. -- BThread线程结束了, AThread线程执行 [AThread] Thread end. -- AThread线程结束了, 主线程执行 main end! 深入的了解join()的用法： 网上有很多人是这样解释 join()的用法的：”主线程等待子线程的终止“ ，相信有很多人都会这么说，但是这个说法是完全错误的，为什么呢？请看例子，在上边代码的基础上，我们对TestDemo类做一下改动： 123456789101112131415161718public class TestDemo &#123; public static void main(String[] args) &#123; String threadName = Thread.currentThread().getName(); System.out.println(threadName + \" start.\"); BThread bt = new BThread(); AThread at = new AThread(bt); try &#123; bt.start(); Thread.sleep(2000); at.start(); // at.join(); //这里注释掉 &#125; catch (Exception e) &#123; System.out.println(\"Exception from main\"); &#125; System.out.println(threadName + \" end!\"); &#125; &#125; 运行结果： 1234567891011main start. -- 主线程启动 [BThread] Thread start. -- BThread线程启动 [BThread] Thread loop at 0 [BThread] Thread loop at 1 main end! -- 主线程结束，（也就是说AThread线程中调用了bt.join()并不会影响到主线程） [AThread] Thread start. -- AThread线程启动, 因为AThread线程中调用了bt.join(), 所以AThread线程要等到BThread线程结束之后才能执行 [BThread] Thread loop at 2 [BThread] Thread loop at 3 [BThread] Thread loop at 4 [BThread] Thread end. -- BThread线程结束了, AThread线程执行 [AThread] Thread end. 相信聪明的读者已经猜到为什么说 ”主线程等待子线程的终止 “ 的错误原因了吧，正确的说法应该是：”当前线程等待子线程的终止“ 从源码看join()方法在AThread的run方法里，执行了bt.join();，进入看一下它的JDK源码： 123public final void join() throws InterruptedException &#123; join(0L);&#125; 然后进入join(0L)方法：12345678910111213141516171819202122232425public final synchronized void join(long millis)throws InterruptedException &#123; long base = System.currentTimeMillis(); long now = 0; if (millis &lt; 0) &#123; throw new IllegalArgumentException(\"timeout value is negative\"); &#125; if (millis == 0) &#123; // 如果线程被生成了，但还未被起动，isAlive()将返回false，调用它的join()方法是没有作用的，将直接继续向下执行。 while (isAlive()) &#123; wait(0); &#125; &#125; else &#123; while (isAlive()) &#123; long delay = millis - now; if (delay &lt;= 0) &#123; break; &#125; wait(delay); now = System.currentTimeMillis() - base; &#125; &#125;&#125; 单纯从代码上看：在AThread类中的run方法中，bt.join()是判断bt的active状态，如果bt的isActive()方法返回false，在bt.join(),这一点就不用等待BThread线程结束，AThread就可以继续向下进行。 isAlive()方法的签名是：public final native boolean isAlive()，也就是说isAlive()是判断当前线程的状态。 TheadLocalJava中的ThreadLocal类可以让你创建的变量只被同一个线程进行读和写操作。因此，尽管有两个线程同时执行一段相同的代码，而且这段代码又有一个指向同一个ThreadLocal变量的引用，但是这两个线程依然不能看到彼此的ThreadLocal变量域。 创建一个ThreadLocal对象如下所示，创建一个ThreadLocal变量：1private ThreadLocal myThreadLocal = new ThreadLocal(); 你实例化了一个ThreadLocal对象。每个线程仅需要实例化一次即可。虽然不同的线程执行同一段代码时，访问同一个ThreadLocal变量，但是每个线程只能看到私有的ThreadLocal实例。所以不同的线程在给ThreadLocal对象设置不同的值时，他们也不能看到彼此的修改。 访问ThreadLocal对象一旦创建了一个ThreadLocal对象，你就可以通过以下方式来存储此对象的值：1myThreadLocal.set(\"A thread local value\"); 也可以直接读取一个ThreadLocal对象的值：1String threadLocalValue = (String) myThreadLocal.get(); get()方法会返回一个Object对象，而set()方法则依赖一个Object对象参数。 ThreadLocal泛型为了使get()方法返回值不用做强制类型转换，通常可以创建一个泛型化的ThreadLocal对象。以下就是一个泛型化的ThreadLocal示例：1private ThreadLocal myThreadLocal1 = new ThreadLocal&lt;String&gt;(); 现在你可以存储一个字符串到ThreadLocal实例里，此外，当你从此ThreadLocal实例中获取值的时候，就不必要做强制类型转换。123myThreadLocal1.set(\"Hello ThreadLocal\");String threadLocalValues = myThreadLocal.get(); 初始化ThreadLocal由于ThreadLocal对象的set()方法设置的值只对当前线程可见，那有什么方法可以为ThreadLocal对象设置的值对所有线程都可见。 为此，我们可以通过ThreadLocal子类的实现，并覆写initialValue()方法，就可以为ThreadLocal对象指定一个初始化值。如下所示:12345private ThreadLocal myThreadLocal = new ThreadLocal&lt;String&gt;() &#123; @Override protected String initialValue() &#123; return \"This is the initial value\"; &#125;&#125;; 此时，在set()方法调用前，当调用get()方法的时候，所有线程都可以看到同一个初始化值。 Full ThreadLocal Example以下是一个完整的ThreadLocal示例：123456789101112131415161718192021222324252627282930313233package cn.caoler.ThreadTest2;/** * Author: Caole * CreateDateTime: 2017/11/27 13:21 * Description: */public class ThreadLocalExample &#123; public static class MyRunnable implements Runnable &#123; private ThreadLocal&lt;Integer&gt; threadLocal = new ThreadLocal&lt;Integer&gt;(); @Override public void run() &#123; threadLocal.set( (int) (Math.random() * 100D) ); try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; &#125; System.out.println(threadLocal.get()); &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; MyRunnable sharedRunnableInstance = new MyRunnable(); Thread thread1 = new Thread(sharedRunnableInstance); Thread thread2 = new Thread(sharedRunnableInstance); thread1.start(); thread2.start(); thread1.join(); //wait for thread 1 to terminate thread2.join(); //wait for thread 2 to terminate &#125;&#125; 上面创建了两个线程共享一个MyRunnable实例。每个线程执行run()方法的时候，会给同一个ThreadLocal实例设置不同的值。如果调用set()方法的时候用synchronized关键字同步，而不是ThreadLocal对象的实例，那么第二个线程将会覆盖第一个线程所设置的值。 然而，由于是ThreadLocal对象，所以两个线程无法看到彼此的值。因此，可以设置或者获取不同的值。 InheritableThreadLocalInheritableThreadLocal类是ThreadLocal的子类。为了解决ThreadLocal实例内部每个线程都只能看到自己的私有值，所以InheritableThreadLocal允许一个线程创建的所有子线程访问其父线程的值。 参考 CSDN:Java Thread.join详解 并发编程网：《Java并发性和多线程介绍》-Java TheadLocal","categories":[{"name":"并发编程","slug":"并发编程","permalink":"https://caoler.cn/categories/并发编程/"},{"name":"线程通信","slug":"并发编程/线程通信","permalink":"https://caoler.cn/categories/并发编程/线程通信/"}],"tags":[{"name":"并发编程","slug":"并发编程","permalink":"https://caoler.cn/tags/并发编程/"},{"name":"转载","slug":"转载","permalink":"https://caoler.cn/tags/转载/"},{"name":"线程通信","slug":"线程通信","permalink":"https://caoler.cn/tags/线程通信/"}]},{"title":"死锁以及如何避免死锁","slug":"死锁以及如何避免死锁","date":"2017-11-27T02:30:00.000Z","updated":"2017-11-27T12:40:22.311Z","comments":true,"path":"/post/2017/deadlock.html","link":"","permalink":"https://caoler.cn/post/2017/deadlock.html","excerpt":"死锁锁是两个或更多线程阻塞着等待其它处于死锁状态的线程所持有的锁。死锁通常发生在多个线程同时但以不同的顺序请求同一组锁的时候。 例如，如果线程1锁住了A，然后尝试对B进行加锁，同时线程2已经锁住了B，接着尝试对A进行加锁，这时死锁就发生了。线程1永远得不到B，线程2也永远得不到A，并且它们永远也不会知道发生了这样的事情。为了得到彼此的对象（A和B），它们将永远阻塞下去。这种情况就是一个死锁。 该情况如下： Thread 1 locks A, waits for BThread 2 locks B, waits for A 示例","text":"死锁锁是两个或更多线程阻塞着等待其它处于死锁状态的线程所持有的锁。死锁通常发生在多个线程同时但以不同的顺序请求同一组锁的时候。 例如，如果线程1锁住了A，然后尝试对B进行加锁，同时线程2已经锁住了B，接着尝试对A进行加锁，这时死锁就发生了。线程1永远得不到B，线程2也永远得不到A，并且它们永远也不会知道发生了这样的事情。为了得到彼此的对象（A和B），它们将永远阻塞下去。这种情况就是一个死锁。 该情况如下： Thread 1 locks A, waits for BThread 2 locks B, waits for A 示例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package cn.caoler.DeadLockDemo;/** * Author: Caole * CreateDateTime: 2017/11/23 11:56 * Description: */public class DeadLockDemo &#123; private static String A = \"A\"; private static String B = \"B\"; public static void main(String[] args) &#123; new DeadLockDemo().deadLock(); &#125; private void deadLock() &#123; Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; synchronized(A)&#123; try &#123; Thread.currentThread().sleep(20); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized(B)&#123; System.out.println(\"1\"); &#125; &#125; &#125; &#125;); Thread t2 = new Thread(new Runnable() &#123; @Override public void run() &#123; synchronized(B)&#123; synchronized(A)&#123; System.out.println(\"2\"); &#125; &#125; &#125; &#125;); t1.start(); t2.start(); &#125;&#125; 避免死锁常见方法有如下几个： 避免一个线程同时获取多个锁。 避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源。 尝试使用定时锁，使用lock.tryLock(timeout)来代替使用内部锁机制。 对于数据库锁，加锁和解锁必须在同一个数据库连接里，否则会出现解锁异常的情况。 具体解释详见并发编程网-避免死锁","categories":[{"name":"并发编程","slug":"并发编程","permalink":"https://caoler.cn/categories/并发编程/"},{"name":"锁","slug":"并发编程/锁","permalink":"https://caoler.cn/categories/并发编程/锁/"}],"tags":[{"name":"并发编程","slug":"并发编程","permalink":"https://caoler.cn/tags/并发编程/"},{"name":"转载","slug":"转载","permalink":"https://caoler.cn/tags/转载/"},{"name":"死锁","slug":"死锁","permalink":"https://caoler.cn/tags/死锁/"}]},{"title":"线程通信","slug":"线程通信","date":"2017-11-22T10:31:00.000Z","updated":"2017-11-27T12:37:56.861Z","comments":true,"path":"/post/2017/thread-signaling.html","link":"","permalink":"https://caoler.cn/post/2017/thread-signaling.html","excerpt":"概述线程通信的目标是使线程间能够互相发送信号。另一方面，线程通信使线程能够等待其他线程的信号。 例如，线程B可以等待线程A的一个信号，这个信号会通知线程B数据已经准备好了。本文将讲解以下几个JAVA线程间通信的主题： 通过共享对象通信线程间发送信号的一个简单方式是在共享对象的变量里设置信号值。线程A在一个同步块里设置boolean型成员变量hasDataToProcess为true，线程B也在同步块里读取hasDataToProcess这个成员变量。这个简单的例子使用了一个持有信号的对象，并提供了set和check方法:","text":"概述线程通信的目标是使线程间能够互相发送信号。另一方面，线程通信使线程能够等待其他线程的信号。 例如，线程B可以等待线程A的一个信号，这个信号会通知线程B数据已经准备好了。本文将讲解以下几个JAVA线程间通信的主题： 通过共享对象通信线程间发送信号的一个简单方式是在共享对象的变量里设置信号值。线程A在一个同步块里设置boolean型成员变量hasDataToProcess为true，线程B也在同步块里读取hasDataToProcess这个成员变量。这个简单的例子使用了一个持有信号的对象，并提供了set和check方法: 12345678910111213public class MySignal&#123; protected boolean hasDataToProcess = false; public synchronized boolean hasDataToProcess()&#123; return this.hasDataToProcess; &#125; public synchronized void setHasDataToProcess(boolean hasData)&#123; this.hasDataToProcess = hasData; &#125;&#125; 线程A和B必须获得指向一个MySignal共享实例的引用，以便进行通信。如果它们持有的引用指向不同的MySingal实例，那么彼此将不能检测到对方的信号。需要处理的数据可以存放在一个共享缓存区里，它和MySignal实例是分开存放的。 忙等待准备处理数据的线程B正在等待数据变为可用。换句话说，它在等待线程A的一个信号，这个信号使hasDataToProcess()返回true。线程B运行在一个循环里，以等待这个信号： 1234567protected MySignal sharedSignal = ......while(!sharedSignal.hasDataToProcess())&#123; //do nothing... busy waiting&#125; wait(),notify()和notifyAll()忙等待没有对运行等待线程的CPU进行有效的利用，除非平均等待时间非常短。否则，让等待线程进入睡眠或者非运行状态更为明智，直到它接收到它等待的信号。 Java有一个内建的等待机制来允许线程在等待信号的时候变为非运行状态。java.lang.Object 类定义了三个方法，wait()、notify()和notifyAll()来实现这个等待机制。 一个线程一旦调用了任意对象的wait()方法，就会变为非运行状态，直到另一个线程调用了同一个对象 的notify()方法。为了调用wait()或者notify()，线程必须先获得那个对象的锁。也就是说，线程必须在同步块里调用wait()或者notify()。以下是MySingal的修改版本——使用了wait()和notify()的MyWaitNotify： 123456789101112131415161718192021public class MonitorObject&#123;&#125;public class MyWaitNotify&#123; MonitorObject myMonitorObject = new MonitorObject(); public void doWait()&#123; synchronized(myMonitorObject)&#123; try&#123; myMonitorObject.wait(); &#125; catch(InterruptedException e)&#123;...&#125; &#125; &#125; public void doNotify()&#123; synchronized(myMonitorObject)&#123; myMonitorObject.notify(); &#125; &#125;&#125; 等待线程将调用doWait()，而唤醒线程将调用doNotify()。当一个线程调用一个对象的notify()方法，正在等待该对象的所有线程中将有一个线程被唤醒并允许执行 （校注：这个将被唤醒的线程是随机的，不可以指定唤醒哪个线程）。 同时也提供了一个notifyAll()方法来唤醒正在等待一个给定对象的所有线程。 如你所见，不管是等待线程还是唤醒线程都在同步块里调用wait()和notify()。这是强制性的！一个线程如果没有持有对象锁，将不能调用wait()，notify()或者notifyAll()。 否则，会抛出IllegalMonitorStateException异常。 （校注：JVM是这么实现的，当你调用wait时候它首先要检查下当前线程是否是锁的拥有者，不是则抛出IllegalMonitorStateExcept，参考JVM源码的 1422行。） 但是，这怎么可能？等待线程在同步块里面执行的时候，不是一直持有监视器对象（myMonitor对象）的锁吗？等待线程不能阻塞唤醒线程进入doNotify()的同步块吗？答案是：的确不能。一旦线程调用了wait()方法，它就释放了所持有的监视器对象上的锁。这将允许其他线程也可以调用wait()或者notify()。 一旦一个线程被唤醒，不能立刻就退出wait()的方法调用，直到调用notify()的线程退出了它自己的同步块。换句话说：被唤醒的线程必须重新获得监视器对象的锁，才可以退出wait()的方法调用，因为wait方法调用运行在同步块里面。如果多个线程被notifyAll()唤醒，那么在同一时刻将只有一个线程可以退出wait()方法，因为每个线程在退出wait()前必须获得监视器对象的锁。 丢失的信号notify()和notifyAll()方法不会保存调用它们的方法，因为当这两个方法被调用时，有可能没有线程处于等待状态。通知信号过后便丢弃了。因此，如果一个线程先于被通知线程调用wait()前调用了notify()，等待的线程将错过这个信号。这可能是也可能不是个问题。不过，在某些情况下，这可能使等待线程永远在等待，不再醒来，因为线程错过了唤醒信号。 为了避免丢失信号，必须把它们保存在信号类里。在MyWaitNotify的例子中，通知信号应被存储在MyWaitNotify实例的一个成员变量里。以下是MyWaitNotify的修改版本：123456789101112131415161718192021222324public class MyWaitNotify2&#123; MonitorObject myMonitorObject = new MonitorObject(); boolean wasSignalled = false; public void doWait()&#123; synchronized(myMonitorObject)&#123; if(!wasSignalled)&#123; try&#123; myMonitorObject.wait(); &#125; catch(InterruptedException e)&#123;...&#125; &#125; //clear signal and continue running. wasSignalled = false; &#125; &#125; public void doNotify()&#123; synchronized(myMonitorObject)&#123; wasSignalled = true; myMonitorObject.notify(); &#125; &#125;&#125; 留意doNotify()方法在调用notify()前把wasSignalled变量设为true。同时，留意doWait()方法在调用wait()前会检查wasSignalled变量。事实上，如果没有信号在前一次doWait()调用和这次doWait()调用之间的时间段里被接收到，它将只调用wait()。 （校注：为了避免信号丢失， 用一个变量来保存是否被通知过。在notify前，设置自己已经被通知过。在wait后，设置自己没有被通知过，需要等待通知。） 自己的理解，wasSignalled标注的功能就是限制Wait和Notify的顺序 假唤醒由于莫名其妙的原因，线程有可能在没有调用过notify()和notifyAll()的情况下醒来。这就是所谓的假唤醒（spurious wakeups）。无端端地醒过来了。 如果在MyWaitNotify2的doWait()方法里发生了假唤醒，等待线程即使没有收到正确的信号，也能够执行后续的操作。这可能导致你的应用程序出现严重问题。 为了防止假唤醒，保存信号的成员变量将在一个while循环里接受检查，而不是在if表达式里。这样的一个while循环叫做自旋锁 （校注：这种做法要慎重，目前的JVM实现自旋会消耗CPU，如果长时间不调用doNotify方法，doWait方法会一直自旋，CPU会消耗太大）。 被唤醒的线程会自旋直到自旋锁(while循环)里的条件变为false。以下MyWaitNotify2的修改版本展示了这点：123456789101112131415161718192021222324public class MyWaitNotify3&#123; MonitorObject myMonitorObject = new MonitorObject(); boolean wasSignalled = false; public void doWait()&#123; synchronized(myMonitorObject)&#123; while(!wasSignalled)&#123; try&#123; myMonitorObject.wait(); &#125; catch(InterruptedException e)&#123;...&#125; &#125; //clear signal and continue running. wasSignalled = false; &#125; &#125; public void doNotify()&#123; synchronized(myMonitorObject)&#123; wasSignalled = true; myMonitorObject.notify(); &#125; &#125;&#125; 留意wait()方法是在while循环里，而不在if表达式里。如果等待线程没有收到信号就唤醒，wasSignalled变量将变为false,while循环会再执行一次，促使醒来的线程回到等待状态。 多线程等待相同信号如果你有多个线程在等待，被notifyAll()唤醒，但只有一个被允许继续执行，使用while循环也是个好方法。每次只有一个线程可以获得监视器对象锁，意味着只有一个线程可以退出wait()调用并清除wasSignalled标志（设为false）。一旦这个线程退出doWait()的同步块，其他线程退出wait()调用，并在while循环里检查wasSignalled变量值。但是，这个标志已经被第一个唤醒的线程清除了，所以其余醒来的线程将回到等待状态，直到下次信号到来。 不要对常量字符串或全局对象调用wait()（校注：本章说的字符串常量指的是值为常量的变量） 本文早期的一个版本在MyWaitNotify例子里使用字符串常量（””）作为管程对象。以下是那个例子：123456789101112131415161718192021222324public class MyWaitNotify3&#123; String myMonitorObject = \"\"; boolean wasSignalled = false; public void doWait()&#123; synchronized(myMonitorObject)&#123; while(!wasSignalled)&#123; try&#123; myMonitorObject.wait(); &#125; catch(InterruptedException e)&#123;...&#125; &#125; //clear signal and continue running. wasSignalled = false; &#125; &#125; public void doNotify()&#123; synchronized(myMonitorObject)&#123; wasSignalled = true; myMonitorObject.notify(); &#125; &#125;&#125; 在空字符串作为锁的同步块(或者其他常量字符串)里调用wait()和notify()产生的问题是，JVM/编译器内部会把常量字符串转换成同一个对象。这意味着，即使你有2个不同的MyWaitNotify实例，它们都引用了相同的空字符串实例。同时也意味着存在这样的风险：在第一个MyWaitNotify实例上调用doWait()的线程会被在第二个MyWaitNotify实例上调用doNotify()的线程唤醒。这种情况可以画成以下这张图： 等待/通知机制 总结相关方法 方法名称 描述 notify() 通知一个在对象上等待的线程，由WAITING状态变为BLOCKING状态，从等待队列移动到同步队列，等待CPU调度获取该对象的锁，当该线程获取到了对象的锁后，该线程从wait()方法返回 notifyAll() 通知所有等待在该对象上的线程，由WAITING状态变为BLOCKING状态，等待CPU调度获取该对象的锁 wait() 调用该方法的线程进入WAITING状态，并将当前线程放置到对象的等待队列，只有等待另外线程的通知或被中断才会返回，需要注意，调用wait()方法后，会释放对象的锁 wait(long) 超时等待一段时间，这里的参数时间是毫秒，也就是等待长达n毫秒，如果没有通知就超时返回 wait(long，int) 对于超时时间更细力度的控制，可以达到纳秒 代码清单如下代码本人觉得更加清晰123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package cn.caoler.WaitNotify;import java.text.SimpleDateFormat;import java.util.Date;import java.util.concurrent.TimeUnit;/** * Author: Caole * CreateDateTime: 2017/11/23 12:43 * Description: */public class WaitNotify &#123; static boolean flag = true; static Object lock = new Object(); public static void main(String[] args) throws InterruptedException &#123; Thread waitThread = new Thread(new Wait(), \"WaitThread\"); waitThread.start(); TimeUnit.SECONDS.sleep(1); Thread notifyThread = new Thread(new Notify(), \"NotifyThread\"); notifyThread.start(); &#125; static class Wait implements Runnable &#123; @Override public void run() &#123; //加锁，拥有lock的Monitor synchronized(lock)&#123; //当条件不满足时继续wait，同时释放了lock的锁 while (flag)&#123; try &#123; System.out.println(Thread.currentThread() + \"flag is true .wait@\" + new SimpleDateFormat(\"HH:mm:ss\").format(new Date())); lock.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; //条件满足时，完成工作 System.out.println(Thread.currentThread() + \"flag is false .running@\" + new SimpleDateFormat(\"HH:mm:ss\").format(new Date())); &#125; &#125; &#125; static class Notify implements Runnable&#123; @Override public void run() &#123; //加锁，拥有lock的Monitor synchronized(lock)&#123; //获取lock的锁，然后进行通知，通知时不会释放lock的锁 //直到当前线程释放了lock锁之后，WaitThread才能从wait方法中返回 System.out.println(Thread.currentThread() + \"hold lock .notify @\" + new SimpleDateFormat(\"HH:mm:ss\").format(new Date())); lock.notifyAll(); flag = false; SleepUtils.second(5); &#125; //再次加锁 synchronized(lock)&#123; System.out.println(Thread.currentThread() + \"hold lock again .sleep @\" + new SimpleDateFormat(\"HH:mm:ss\").format(new Date())); SleepUtils.second(5); &#125; &#125; &#125;&#125; 输出如下： 1234Thread[WaitThread,5,main]flag is true .wait@15:54:24Thread[NotifyThread,5,main]hold lock .notify @15:54:24Thread[NotifyThread,5,main]hold lock again .sleep @15:54:30Thread[WaitThread,5,main]flag is false .running@15:54:35 使用wait/notify注意事项和问题 执行完wait后会释放锁， 在执行notify()方法后，当前线程不会立刻释放该对象锁。呈wait状态的线程并不能马上获取该对象锁，要等执行notify()方法的线程将程序执行完，也就是退出synchronized代码块后，当前线程才会释放锁。 在调用wait()或notify()方法之前，必须获得该对象的对象级别锁，即只能在同步方法或者同步块中调用wait()方法，在执行wait()方法之后，当前线程释放锁。 在调用notify通知某线程后，该线程不会立即进入Running状态，而是先进入Runnable状态。 notify每次仅通知一个线程，多次调用可将wait线程全部唤醒。 当线程呈wait状态时，调用线程对象的interrupt方法会抛出InterruptedException异常。 通知过早: 如果通知过早，会打乱程序正常运行逻辑。 等待/通知的经典范式从前断示例中可以提炼出等待/通知经典范式，该范式分为两部分，分别为等待方(消费者)和通知方（生产者）。 等待方遵循如下原则。 获取对象的锁 如果条件不满足，那么调用对象的wait()方法，被通知后仍要检查条件。 条件满足则执行对应的逻辑。 对应的伪代码如下 123456synchronized(对象)&#123; while(不满足)&#123; 对象.wait(); &#125; 对应的处理逻辑&#125; 通知方遵循如下原则 获得对象的锁 改变条件 通知所有等待在对象上的线程 对应的伪代码如下： 1234synchronized(对象)&#123; 改变条件 对象.notifyAll();&#125; 参考 自并发编程网 – ifeve.com本文链接地址: strings-wait-notify JAVA并发编程的艺术（方腾飞） 4.3.2节","categories":[{"name":"并发编程","slug":"并发编程","permalink":"https://caoler.cn/categories/并发编程/"},{"name":"线程通信","slug":"并发编程/线程通信","permalink":"https://caoler.cn/categories/并发编程/线程通信/"}],"tags":[{"name":"并发编程","slug":"并发编程","permalink":"https://caoler.cn/tags/并发编程/"},{"name":"转载","slug":"转载","permalink":"https://caoler.cn/tags/转载/"}]},{"title":"线程安全及其实现方法","slug":"线程安全及其实现方法","date":"2017-11-22T10:28:00.000Z","updated":"2017-11-27T12:39:29.112Z","comments":true,"path":"/post/2017/thread-safety-realize.html","link":"","permalink":"https://caoler.cn/post/2017/thread-safety-realize.html","excerpt":"线程安全线程安全：当多个对象访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方法进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那么这个对象是线程安全的。 互斥同步互斥同步是常见的一种并发正确性保障手段。同步是指多个线程并发访问共享数据时，保障数据在同一时刻只被一个（或者是一些，使用信号量的时候）线程使用。 而互斥是实现同步的一种手段，临界区、互斥量、信号量都是主要的互斥实现方式、因此在这4个字里面，互斥是因、同步是果；互斥是方法，同步是目的。 synchronied关键字","text":"线程安全线程安全：当多个对象访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方法进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那么这个对象是线程安全的。 互斥同步互斥同步是常见的一种并发正确性保障手段。同步是指多个线程并发访问共享数据时，保障数据在同一时刻只被一个（或者是一些，使用信号量的时候）线程使用。 而互斥是实现同步的一种手段，临界区、互斥量、信号量都是主要的互斥实现方式、因此在这4个字里面，互斥是因、同步是果；互斥是方法，同步是目的。 synchronied关键字 synchronized是java中最基本的同步手段，他在经过编译之后，会在同步前后分别形成monitorenter和monitorexit这两个字节码，这两个字节码都需要一个reference类型的参数来指明要锁定和解锁的对象。如果java程序中的synchronized明确指定了对象参数，那就是这个对象的reference；如果没有明确指定，那就根据synchronized修饰的是实例还是类方法去取对应的对象实例或class对象来作为锁对象。 在虚拟机规范对monitorenter和monitorexit的行为描述中有2点是特别要注意的。 synchronized同步块对同一条线程来说是可重入的，不会出现自己把自己锁死的问题。 同步块在已进入的线程执行完之前，会阻塞后面其他线程的进入。 java线程是映射到操作系统的原生线程之上的，如果要阻塞或者唤醒一个线程都需要操作系统来帮忙完成，这就需要从用户态转到核心态中，因此状态转换需要耗费很多的处理时间。对于代码简单的同步块（如被synchronized修饰的set和get方法），状态转换消耗的时间比用户代码执行的时间还要长，所以synchronized是java语言中一个重量级的操作。 ReentrantLock重入锁基本用法上重入锁和synchronized很相似，他们都具备一样的线程重入特性，只是在代码写法上有点区别，一个表现为API层面的互斥锁，另一个表现在语法层面的互斥锁。不过相比较synchronized，ReetrantLock增加了一些高级功能，主要有以下3项：等待可中断、可实现公平锁，以及锁可以绑定多个条件。 等待可中断是指当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情，可中断特性对处理执行时间非常长的同步块很有帮助。 公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁；而非公平锁则不保证这一点，在锁被释放时，任何一个等待锁的线程都有机会获得锁。synchronized中的锁是非公平的，ReentrantLock默认情况下也是非公平的，但可以通过带布尔值的构造函数要求使用公平锁。 锁绑定多个条件是指一个ReentrantLock对象可以同时绑定多个Condition对象，而在synchronized中，锁对象的wait（）和notify（）或notifyAll（）方法可以实现一个隐含的条件，如果要和多于一个的条件关联的时候，就不得不额外地添加一个锁，而ReentrantLock则无需这样做，只需要多次调用newCondition()方法即可。 通过对比两种锁的吞吐量可知： 1.6中加入了很多针对锁的优化措施，JDK 1.6发布之后，人们就发现synchronized与ReentrantLock的性能基本上是完全持平了。因此，如果读者的程序是使用JDK 1.6或以上部署的话，性能因素就不再是选择ReentrantLock的理由了，虚拟机在未来的性能改进中肯定也会更加偏向于原生的synchronized，所以还是提倡在synchronized能实现需求的情况下，优先考虑使用synchronized来进行同步。 非阻塞同步互斥同步最主要的问题就是进行线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步（Blocking Synchronization）。从处理问题的方式上说，互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施（例如加锁），那就肯定会出现问题，无论共享数据是否真的会出现竞争，它都要进行加锁（这里讨论的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁）、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。随着硬件指令集的发展，我们有了另外一个选择：基于冲突检测的乐观并发策略，通俗地说，就是先进行操作，如果没有其他线程争用共享数据，那操作就成功了；如果共享数据有争用，产生了冲突，那就再采取其他的补偿措施（最常见的补偿措施就是不断地重试，直到成功为止），这种乐观的并发策略的许多实现都不需要把线程挂起，因此这种同步操作称为非阻塞同步（Non-Blocking Synchronization）。 无同步方案要保证线程安全，并不是一定就要进行同步，两者没有因果关系。同步只是保证共享数据争用时的正确性的手段，如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性，因此会有一些代码天生就是线程安全的，笔者简单地介绍其中的两类。 可重入代码（Reentrant Code）这种代码也叫做纯代码（Pure Code），可以在代码执行的任何时刻中断它，转而去执行另外一段代码（包括递归调用它本身），而在控制权返回后，原来的程序不会出现任何错误。相对线程安全来说，可重入性是更基本的特性，它可以保证线程安全，即所有的可重入的代码都是线程安全的，但是并非所有的线程安全的代码都是可重入的。 可重入代码有一些共同的特征，例如不依赖存储在堆上的数据和公用的系统资源、用到的状态量都由参数中传入、不调用非可重入的方法等。我们可以通过一个简单的原则来判断代码是否具备可重入性：如果一个方法，它的返回结果是可以预测的，只要输入了相同的数据，就都能返回相同的结果，那它就满足可重入性的要求，当然也就是线程安全的。 线程本地存储（Thread Local Storage）如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行？如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。符合这种特点的应用并不少见，大部分使用消费队列的架构模式（如“生产者-消费者”模式）都会将产品的消费过程尽量在一个线程中消费完，其中最重要的一个应用实例就是经典Web交互模型中的“一个请求对应一个服务器线程”（Thread-per-Request）的处理方式，这种处理方式的广泛应用使得很多Web服务端应用都可以使用线程本地存储来解决线程安全问题。Java语言中，如果一个变量要被多线程访问，可以使用volatile关键字声明它为“易变的”；如果一个变量要被某个线程独享，Java中就没有类似C++中__declspec（thread）[3]这样的关键字，不过还是可以通过java.lang.ThreadLocal类来实现线程本地存储的功能。每一个线程的Thread对象中都有一个ThreadLocalMap对象，这个对象存储了一组以ThreadLocal.threadLocalHashCode为键，以本地线程变量为值的K-V值对，ThreadLocal对象就是当前线程的ThreadLocalMap的访问入口，每一个ThreadLocal对象都包含了一个独一无二的threadLocalHashCode值，使用这个值就可以在线程K-V值对中找回对应的本地线程变量。 参考本文内容摘自周志明老师的深入理解Java虚拟机第十三章线程安全与锁优化。","categories":[{"name":"并发编程","slug":"并发编程","permalink":"https://caoler.cn/categories/并发编程/"},{"name":"线程安全","slug":"并发编程/线程安全","permalink":"https://caoler.cn/categories/并发编程/线程安全/"}],"tags":[{"name":"并发编程","slug":"并发编程","permalink":"https://caoler.cn/tags/并发编程/"},{"name":"转载","slug":"转载","permalink":"https://caoler.cn/tags/转载/"}]},{"title":"使用WMITool解决浏览器主页被hao123劫持问题","slug":"使用WMITool解决浏览器主页被hao123劫持问题","date":"2017-11-21T06:50:00.000Z","updated":"2017-11-27T12:40:43.002Z","comments":true,"path":"/post/2017/wmitools.html","link":"","permalink":"https://caoler.cn/post/2017/wmitools.html","excerpt":"最近一段时间发现，无论Chrome 还是 Firefox 主页都被流氓(hao123)劫持了。 一些具体症状： 删掉原先的快捷方式以后再重新创建一个，问题依然存在； 快捷方式属性没有问题，没有后缀网址； 直接启动exe文件没有异常； chrome主页设置也没有问题，但是如果重新设置一遍主页，从快捷方式就可以正常启动chrome，但再次启动电脑又会恢复原样； 改exe文件名可解决但我不想用这种回避的方式。 本人又没有安装360，电脑管家等流氓软件的习惯，于是通过Google找到了解决办法，具体如下：","text":"最近一段时间发现，无论Chrome 还是 Firefox 主页都被流氓(hao123)劫持了。 一些具体症状： 删掉原先的快捷方式以后再重新创建一个，问题依然存在； 快捷方式属性没有问题，没有后缀网址； 直接启动exe文件没有异常； chrome主页设置也没有问题，但是如果重新设置一遍主页，从快捷方式就可以正常启动chrome，但再次启动电脑又会恢复原样； 改exe文件名可解决但我不想用这种回避的方式。 本人又没有安装360，电脑管家等流氓软件的习惯，于是通过Google找到了解决办法，具体如下： 一、下载 WIM Tools官网连接：https://www.adremsoft.com/wmitools/ 软件体积较大(不推荐) 百度云链接: https://pan.baidu.com/s/1slJU2Rz 密码: o400 二、安装完成之后按照如下操作 在右侧选中后右击——&gt;选择view instant properties 至此查看ScriptText项可知，这是一段VBScript调用系统服务间隔30分钟执行一次，将所有浏览器调用加上如下糟糕链接 解决办法选中左侧选项，点击上面的X按钮。 删不掉？ 到WMITool安装路径（例如：C:\\Program Files (x86)\\WMI Tools）下，右键点击wbemeventviewer.exe，选择以管理员身份运行！删之！ 还没完，还要手动将快速启动栏中，将各个浏览器快捷命令中的http://hk.jtsh123.com/?r=b&amp;m=10去掉！ 大功告成！","categories":[{"name":"实用教程","slug":"实用教程","permalink":"https://caoler.cn/categories/实用教程/"},{"name":"浏览器","slug":"实用教程/浏览器","permalink":"https://caoler.cn/categories/实用教程/浏览器/"}],"tags":[{"name":"原创","slug":"原创","permalink":"https://caoler.cn/tags/原创/"},{"name":"实用教程","slug":"实用教程","permalink":"https://caoler.cn/tags/实用教程/"}]},{"title":"Java同步块","slug":"JAVA同步块","date":"2017-11-20T10:44:00.000Z","updated":"2017-11-27T12:42:51.970Z","comments":true,"path":"/post/2017/synchronized-blocks.html","link":"","permalink":"https://caoler.cn/post/2017/synchronized-blocks.html","excerpt":"概述Java 同步块（synchronized block）用来标记方法或者代码块是同步的。Java同步块用来避免竞争。 Java 同步关键字（synchronized）Java中的同步块用synchronized标记。同步块在Java中是同步在某个对象上。所有同步在一个对象上的同步块在同时只能被一个线程进入并执行操作。所有其他等待进入该同步块的线程将被阻塞，直到执行该同步块中的线程退出。 有四种不同的同步块： 实例方法 静态方法 实例方法中的同步块 静态方法中的同步块 上述同步块都同步在不同对象上。实际需要那种同步块视具体情况而定。","text":"概述Java 同步块（synchronized block）用来标记方法或者代码块是同步的。Java同步块用来避免竞争。 Java 同步关键字（synchronized）Java中的同步块用synchronized标记。同步块在Java中是同步在某个对象上。所有同步在一个对象上的同步块在同时只能被一个线程进入并执行操作。所有其他等待进入该同步块的线程将被阻塞，直到执行该同步块中的线程退出。 有四种不同的同步块： 实例方法 静态方法 实例方法中的同步块 静态方法中的同步块 上述同步块都同步在不同对象上。实际需要那种同步块视具体情况而定。 实例方法同步下面是一个同步的实例方法：123public synchronized void add(int value)&#123; this.count += value;&#125; 注意在方法声明中同步（synchronized ）关键字。这告诉Java该方法是同步的。 Java实例方法同步是同步在拥有该方法的对象上。 这样，每个实例其方法同步都同步在不同的对象上，即该方法所属的实例。只有一个线程能够在实例方法同步块中运行。如果有多个实例存在，那么一个线程一次可以在一个实例同步块中执行操作。一个实例一个线程。 静态方法同步静态方法同步和实例方法同步方法一样，也使用synchronized 关键字。Java静态方法同步如下示例：123public static synchronized void add(int value)&#123; count += value;&#125; 同样，这里synchronized 关键字告诉Java这个方法是同步的。 静态方法的同步是指同步在该方法所在的类对象上。 因为在Java虚拟机中一个类只能对应一个类对象，所以同时只允许一个线程执行同一个类中的静态同步方法。 对于不同类中的静态同步方法，一个线程可以执行每个类中的静态同步方法而无需等待。不管类中的那个静态同步方法被调用，一个类只能由一个线程同时执行。 实例方法中的同步块有时你不需要同步整个方法，而是同步方法中的一部分。Java可以对方法的一部分进行同步。 在非同步的Java方法中的同步块的例子如下所示：123456public void add(int value)&#123; synchronized(this)&#123; this.count += value; &#125;&#125; 示例使用Java同步块构造器来标记一块代码是同步的。该代码在执行时和同步方法一样。 注意Java同步块构造器用括号将对象括起来。在上例中，使用了“this”，即为调用add方法的实例本身。在同步构造器中用括号括起来的对象叫做监视器对象。上述代码使用监视器对象同步，同步实例方法使用调用方法本身的实例作为监视器对象。 一次只有一个线程能够在同步于同一个监视器对象的Java方法内执行。 下面两个例子都同步他们所调用的实例对象上，因此他们在同步的执行效果上是等效的。1234567891011121314public class MyClass &#123; public synchronized void log1(String msg1, String msg2)&#123; log.writeln(msg1); log.writeln(msg2); &#125; public void log2(String msg1, String msg2)&#123; synchronized(this)&#123; log.writeln(msg1); log.writeln(msg2); &#125; &#125;&#125; 在上例中，每次只有一个线程能够在两个同步块中任意一个方法内执行。 如果第二个同步块不是同步在this实例对象上，那么两个方法可以被线程同时执行。 静态方法中的同步块和上面类似，下面是两个静态方法同步的例子。这些方法同步在该方法所属的类对象上。12345678910111213public class MyClass &#123; public static synchronized void log1(String msg1, String msg2)&#123; log.writeln(msg1); log.writeln(msg2); &#125; public static void log2(String msg1, String msg2)&#123; synchronized(MyClass.class)&#123; log.writeln(msg1); log.writeln(msg2); &#125; &#125;&#125; 这两个方法不允许同时被线程访问。 如果第二个同步块不是同步在MyClass.class这个对象上。那么这两个方法可以同时被线程访问。 Java同步实例在下面例子中，启动了两个线程，都调用Counter类同一个实例的add方法。因为同步在该方法所属的实例上，所以同时只能有一个线程访问该方法。1234567891011121314151617181920212223242526272829303132public class Counter&#123; long count = 0; public synchronized void add(long value)&#123; this.count += value; &#125; &#125; public class CounterThread extends Thread&#123; protected Counter counter = null; public CounterThread(Counter counter)&#123; this.counter = counter; &#125; public void run() &#123; for(int i=0; i&lt;10; i++)&#123; counter.add(i); &#125; &#125; &#125; public class Example &#123; public static void main(String[] args)&#123; Counter counter = new Counter(); Thread threadA = new CounterThread(counter); Thread threadB = new CounterThread(counter); threadA.start(); threadB.start(); &#125;&#125; 创建了两个线程。他们的构造器引用同一个Counter实例。Counter.add方法是同步在实例上，是因为add方法是实例方法并且被标记上synchronized关键字。因此每次只允许一个线程调用该方法。另外一个线程必须要等到第一个线程退出add()方法时，才能继续执行方法。 如果两个线程引用了两个不同的Counter实例，那么他们可以同时调用add()方法。这些方法调用了不同的对象，因此这些方法也就同步在不同的对象上。这些方法调用将不会被阻塞。如下面这个例子所示：123456789101112public class Example &#123; public static void main(String[] args)&#123; Counter counterA = new Counter(); Counter counterB = new Counter(); Thread threadA = new CounterThread(counterA); Thread threadB = new CounterThread(counterB); threadA.start(); threadB.start(); &#125;&#125; 注意这两个线程，threadA和threadB，不再引用同一个counter实例。CounterA和counterB的add方法同步在他们所属的对象上。调用counterA的add方法将不会阻塞调用counterB的add方法。 参考本文转载于并发编程网","categories":[{"name":"并发编程","slug":"并发编程","permalink":"https://caoler.cn/categories/并发编程/"},{"name":"线程安全","slug":"并发编程/线程安全","permalink":"https://caoler.cn/categories/并发编程/线程安全/"}],"tags":[{"name":"并发编程","slug":"并发编程","permalink":"https://caoler.cn/tags/并发编程/"},{"name":"转载","slug":"转载","permalink":"https://caoler.cn/tags/转载/"}]},{"title":"JAVA与线程","slug":"JAVA与线程","date":"2017-11-19T07:30:00.000Z","updated":"2017-11-27T12:42:37.446Z","comments":true,"path":"/post/2017/java-and-thread.html","link":"","permalink":"https://caoler.cn/post/2017/java-and-thread.html","excerpt":"线程的实现方式概述在传统的操作系统中，拥有资源和独立调度的基本单位都是进程。在引入线程的操作系统中，线程是独立调度的基本单位，进程是资源拥有的基本单位。在同一进程中，线程的切换不会引起进程切换。在不同进程中进行线程切换,如从一个进程内的线程切换到另一个进程中的线程时，会引起进程切换 根据操作系统内核是否对线程可感知，可以把线程分为内核线程和用户线程 名称 描述 用户级线程(User-LevelThread, ULT) 由应用程序所支持的线程实现, 内核意识不到用户级线程的实现 内核级线程(Kemel-LevelThread, KLT) 内核级线程又称为内核支持的线程 实现线程主要有3种方式：使用内核线程、使用用户级线程和使用用户线程加轻量级进程混合实现。","text":"线程的实现方式概述在传统的操作系统中，拥有资源和独立调度的基本单位都是进程。在引入线程的操作系统中，线程是独立调度的基本单位，进程是资源拥有的基本单位。在同一进程中，线程的切换不会引起进程切换。在不同进程中进行线程切换,如从一个进程内的线程切换到另一个进程中的线程时，会引起进程切换 根据操作系统内核是否对线程可感知，可以把线程分为内核线程和用户线程 名称 描述 用户级线程(User-LevelThread, ULT) 由应用程序所支持的线程实现, 内核意识不到用户级线程的实现 内核级线程(Kemel-LevelThread, KLT) 内核级线程又称为内核支持的线程 实现线程主要有3种方式：使用内核线程、使用用户级线程和使用用户线程加轻量级进程混合实现。 使用内核线程实现内核线程就是直接由操作系统内核支持的线程，这种线程有内核来完成线程切换，内核通过调度器(Scheduler) 对线程进行调度，并负责将线程的任务映射到各个处理器上。 轻量级进程(LWP)程序一般不会直接使用内核线程，而是去使用内核线程的一种高级接口———轻量级进程（LWP），轻量级进程就是我们通常意义上所讲的线程，轻量级进程(LWP)是一种由内核支持的用户线程。它是基于内核线程的高级抽象，因此只有先支持内核线程，才能有LWP。 优点 多处理器系统中，内核能够并行执行同一进程内的多个线程 如果进程中的一个线程被阻塞，能够切换同一进程内的其他线程继续执行（用户级线程的一个缺点） 所有能够阻塞线程的调用都以系统调用的形式实现，代价可观 当一个线程阻塞时，内核根据选择可以运行另一个进程的线程，而用户空间实现的线程中，运行时系统始终运行自己进程中的线程 信号是发给进程而不是线程的，当一个信号到达时，应该由哪一个线程处理它？线程可以“注册”它们感兴趣的信号 缺点对于用户的线程切换而言，其模式切换到饿开销较大，在同一个进程中，从一个线程切换到另一个线程时，需要从用户态转到核心态进行，这是因为用户的线程在用户态运行，而线程调度和管理实在内核中实现的，系统开销较大。 使用用户线程实现LWP虽然本质上属于用户线程，但LWP线程库是建立在内核之上的，LWP的许多操作都要进行系统调用，因此效率不高。而这里的用户线程指的是完全建立在用户空间的线程库，用户线程的建立，同步，销毁，调度完全在用户空间完成，不需要内核的帮助。因此这种线程的操作是极其快速的且低消耗的。 从中可以看出，进程中包含线程，用户线程在用户空间中实现，内核并没有直接对用户线程进程调度，内核的调度对象和传统进程一样，还是进程本身，内核并不知道用户线程的存在。用户线程之间的调度由在用户空间实现的线程库实现。 优点 可以在不支持线程的操作系统中实现。 创建和销毁线程、线程切换代价等线程管理的代价比内核线程少得多, 因为保存线程状态的过程和调用程序都只是本地过程 允许每个进程定制自己的调度算法，线程管理比较灵活。这就是必须自己写管理程序，与内核线程的区别 线程能够利用的表空间和堆栈空间比内核级线程多 不需要陷阱，不需要上下文切换，也不需要对内存高速缓存进行刷新，使得线程调用非常快捷 线程的调度不需要内核直接参与，控制简单。 缺点 线程发生I/O或页面故障引起的阻塞时，如果调用阻塞系统调用则内核由于不知道有多线程的存在，而会阻塞整个进程从而阻塞所有线程, 因此同一进程中只能同时有一个线程在运行 页面失效也会产生类似的问题。 一个单独的进程内部，没有时钟中断，所以不可能用轮转调度的方式调度线程 资源调度按照进程进行，多个处理机下，同一个进程中的线程只能在同一个处理机下分时复用 补充在用户级线程中，每个进程里的线程表由运行时系统管理。当一个线程转换到就绪状态或阻塞状态时，在该线程表中存放重新启动该线程所需的信息，与内核在进程表中存放的进程的信息完全一样 使用用户线程加轻量级进程混合实现这种模型对应着恐龙书中多对多模型。用户线程库还是完全建立在用户空间中，因此用户线程的操作还是很廉价，因此可以建立任意多需要的用户线程。操作系统提供了 LWP 作为用户线程和内核线程之间的桥梁。 LWP 还是和前面提到的一样，具有内核线程支持，是内核的调度单元，并且用户线程的系统调用要通过 LWP ，因此进程中某个用户线程的阻塞不会影响整个进程的执行。用户线程库将建立的用户线程关联到 LWP 上， LWP 与用户线程的数量不一定一致。当内核调度到某个 LWP 上时，此时与该 LWP 关联的用户线程就被执行。 JAVA线程调度进程调度属于低级调度，用来决定就绪队列中的那个进程获取处理器，然后有分派程序将执行把处理器分派给该进程的具体操作。进程调度的方式有两个非抢占式调度和抢占式调度 非抢占方式(Non-preemptive Mode)概念: 当某一进程正在处理机上执行时，即使有某个更为重要或紧迫的进程进入就绪队列，该进程仍继续执行，直到其完成或发生某种事件而进入完成或阻 塞状态时，才把处理机分配给更为重要或紧迫的进程 引起进程调度的因素: 正在执行的进程执行完毕， 或因发生某事件而不能再继续执行 执行中的进程因提出I/O请求而暂停执行； 在进程通信或同步过程中执行了某种原语操作，如wait、Block、Wakeup原语 优点: 算法简单，系统开销小 缺点: 紧急任务不能及时响应；短进程到达要等待长进程运行结束适用于大多数批处理系统环境 抢占方式(Preemptive Mode)概念: 当某一进程正在处理机上执行时，若有某个更为重要或紧迫的进程进入就绪队列，则立即暂停正在执行的进程，将处理机分配给这个更为重要或紧迫的进程 抢占式调度主要有以下原则 优先权原则 允许高优先权的新到进程抢占当前进程的处理机 短作业(进程)优先原则允许执行时间短的新到进程抢占当前进程的处理机 时间片原则 时间片用完后停止执行，重新进行调度，适用于分时系统 优点： 适于时间要求严格的实时系统 缺点： 调度算法复杂，系统开销大 状态转换 线程间的状态转换： 新建(new)：新创建了一个线程对象。 可运行(runnable)：线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取cpu 的使用权 。 运行(running)：可运行状态(runnable)的线程获得了cpu 时间片（timeslice） ，执行程序代码。 阻塞(block)：阻塞状态是指线程因为某种原因放弃了cpu 使用权，也即让出了cpu timeslice，暂时停止运行。直到线程进入可运行(runnable)状态，才有机会再次获得cpu timeslice 转到运行(running)状态。阻塞的情况分三种： 等待阻塞：运行(running)的线程执行o.wait()方法，JVM会把该线程放入等待队列(waitting queue)中。 同步阻塞：运行(running)的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池(lock pool)中。 其他阻塞：运行(running)的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。 死亡(dead)：线程run()、main() 方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。 参考 CSDN: linux内核线程、轻量级进程和用户进程 CSDN: 线程的3种实现方式–内核级线程, 用户级线程和混合型线程 计算机操作系统（第四版）2.8.1/3.3.1 深入理解Java虚拟机：JVM高级特性与最佳实践（第二版） CSDN ：进程调度方式 OSChina：一张图让你看懂JAVA线程间的状态转换 今日头条：Java线程状态转换","categories":[{"name":"并发编程","slug":"并发编程","permalink":"https://caoler.cn/categories/并发编程/"},{"name":"JAVA与线程","slug":"并发编程/JAVA与线程","permalink":"https://caoler.cn/categories/并发编程/JAVA与线程/"}],"tags":[{"name":"原创","slug":"原创","permalink":"https://caoler.cn/tags/原创/"},{"name":"并发编程","slug":"并发编程","permalink":"https://caoler.cn/tags/并发编程/"},{"name":"操作系统","slug":"操作系统","permalink":"https://caoler.cn/tags/操作系统/"}]},{"title":"先行并发原则","slug":"先行发生原则（Happens-before）","date":"2017-11-18T06:26:00.000Z","updated":"2017-11-27T12:39:53.469Z","comments":true,"path":"/post/2017/Happens-Before.html","link":"","permalink":"https://caoler.cn/post/2017/Happens-Before.html","excerpt":"先行发生原则（Happens-Before）是判断数据是否存在竞争、线程是否安全的主要依据。 先行发生是Java内存，模型中定义的两项操作之间的偏序关系，如果操作A先行发生于操作B，那么操作A产生的影响能够被操作B观察到,”影响”包括修改了内存中共享变量的值、发送了消息、调用了方法等。 Java内存模型中存在的天然的先行发生关系：","text":"先行发生原则（Happens-Before）是判断数据是否存在竞争、线程是否安全的主要依据。 先行发生是Java内存，模型中定义的两项操作之间的偏序关系，如果操作A先行发生于操作B，那么操作A产生的影响能够被操作B观察到,”影响”包括修改了内存中共享变量的值、发送了消息、调用了方法等。 Java内存模型中存在的天然的先行发生关系： 程序次序规则：同一个线程内，按照代码出现的顺序，前面的代码先行于后面的代码，准确的说是控制流顺序，因为要考虑到分支和循环结构。 管程锁定规则：一个unlock操作先行发生于后面（时间上）对同一个锁的lock操作。 volatile变量规则：对一个volatile变量的写操作先行发生于后面（时间上）对这个变量的读操作。 线程启动规则：Thread的start( )方法先行发生于这个线程的每一个操作。 线程终止规则：线程的所有操作都先行于此线程的终止检测。可以通过Thread.join( )方法结束、Thread.isAlive( )的返回值等手段检测线程的终止。 线程中断规则：对线程interrupt( )方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupt( )方法检测线程是否中断 对象终结规则：一个对象的初始化完成先行于发生它的finalize（）方法的开始。 传递性：如果操作A先行于操作B，操作B先行于操作C，那么操作A先行于操作C。 总结：一个操作“时间上的先发生”不代表这个操作先行发生；一个操作先行发生也不代表这个操作在时间上是先发生的（重排序的出现）。时间上的先后顺序对先行发生没有太大的关系，所以衡量并发安全问题的时候不要受到时间顺序的影响，一切以先行发生原则为准。","categories":[{"name":"并发编程","slug":"并发编程","permalink":"https://caoler.cn/categories/并发编程/"},{"name":"内存模型","slug":"并发编程/内存模型","permalink":"https://caoler.cn/categories/并发编程/内存模型/"}],"tags":[{"name":"原创","slug":"原创","permalink":"https://caoler.cn/tags/原创/"},{"name":"并发编程","slug":"并发编程","permalink":"https://caoler.cn/tags/并发编程/"}]},{"title":"JAVA的原子性、可见性、有序性","slug":"原子性、可见性、有序性","date":"2017-11-16T09:26:00.000Z","updated":"2017-11-27T12:37:27.074Z","comments":true,"path":"/post/2017/javasanxin.html","link":"","permalink":"https://caoler.cn/post/2017/javasanxin.html","excerpt":"原子性定义是指一个操作或多个操作要么全部执行，且执行的过程不会被任何因素打断，要么都不执行。 原子操作原理（处理器是如何实现原子操作的）处理器实现原子操作有3种方式： 处理器自动保证基本内存操作的原子性 使用总线锁保证原子性 使用缓存锁保证原子性","text":"原子性定义是指一个操作或多个操作要么全部执行，且执行的过程不会被任何因素打断，要么都不执行。 原子操作原理（处理器是如何实现原子操作的）处理器实现原子操作有3种方式： 处理器自动保证基本内存操作的原子性 使用总线锁保证原子性 使用缓存锁保证原子性 可见性定义可见性是指：当一个线程修改了线程共享变量的值，其它线程能够立即得知这个修改。 Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方法来实现可见性的，无论是普通变量还是volatile变量都是如此。 普通变量与volatile变量的区别是volatile的特殊规则保证了新值能立即同步到主内存，以及每使用前立即从内存刷新。因为我们可以说volatile保证了线程操作时变量的可见性，而普通变量则不能保证这一点。 有序性定义有序性：即程序执行的顺序按照代码的先后顺序执行。 Java内存模型中的程序天然有序性可以总结为一句话：如果在本线程内观察，所有操作都是有序的；如果在一个线程中观察另一个线程，所有操作都是无序的。 前半句是指“线程内表现为串行语义”，后半句是指“指令重排序”现象和“工作内存主主内存同步延迟”现象。 有序性的语意有几层， 最常见的就是保证多线程运行的串行顺序 防止重排序引起的问题 程序运行的先后顺序。比方JMM定义的一些Happens-before规则 实例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495public class MyClass &#123; private static volatile int count = 0; private static AtomicInteger atomicCount = new AtomicInteger(0); private static int synchronizedCount = 0; public static void main(String[] args) &#123; // 分别调用，打印结果 // volatileCount(); // atomicCount(); synchronizedCount(); &#125; private static void volatileCount() &#123; for (int i = 0; i &lt; 10; i++) &#123; Executors.newFixedThreadPool(3).execute(new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; // 虽然使用volatile关键字修饰int变量，但是对于多线程的环境下，也很难保证没问题，所以一般用来修饰标志位 System.out.println(\"volatile count: \" + ++count); &#125; &#125;); &#125; &#125; // 打印结果：有重复数据，且顺序错乱。表示数据操作不是原子的，线程之间也不是有序的 // volatile count: 1 // volatile count: 5 // volatile count: 4 // volatile count: 3 // volatile count: 1 // volatile count: 2 // volatile count: 6 // volatile count: 7 // volatile count: 8 // volatile count: 9 private static void atomicCount() &#123; for (int i = 0; i &lt; 10; i++) &#123; Executors.newFixedThreadPool(3).execute(new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; // 通过使用Atomic包中的原子类保证数据操作是原子的（数据没有重复，表示是原子操作），但是不能保障有序性 System.out.println(\"atomic count: \" + atomicCount.incrementAndGet()); &#125; &#125;); &#125; &#125; // 打印结果：虽然顺序错乱，但是数据没有重复，也就说明保障了数据的操作是原子的，但是线程间不是有序的 // atomic count: 1 // atomic count: 2 // atomic count: 3 // atomic count: 5 // atomic count: 8 // atomic count: 9 // atomic count: 10 // atomic count: 4 // atomic count: 7 // atomic count: 6 private static void synchronizedCount() &#123; for (int i = 0; i &lt; 10; i++) &#123; Executors.newFixedThreadPool(3).execute(new Runnable() &#123; @Override public void run() &#123; synchronized (MyClass.class) &#123; // 通过synchronized关键字来保证线程之间的有序性 System.out.println(\"synchronized count: \" + ++synchronizedCount); &#125; &#125; &#125;); &#125; &#125; // 打印结果：没有重复数据，也没有错乱现象，说明数据操作是原子的，同时线程操作也是顺序的。同时也说明，有序性可以保障数据操作的原子性 // synchronized count: 1 // synchronized count: 2 // synchronized count: 3 // synchronized count: 4 // synchronized count: 5 // synchronized count: 6 // synchronized count: 7 // synchronized count: 8 // synchronized count: 9 // synchronized count: 10&#125; 参考： CSDN: Java的原子性&amp;&amp;可见性&amp;&amp;有序性 深入理解Java虚拟机：JVM高级特性与最佳实践（第二版）","categories":[{"name":"并发编程","slug":"并发编程","permalink":"https://caoler.cn/categories/并发编程/"},{"name":"内存模型","slug":"并发编程/内存模型","permalink":"https://caoler.cn/categories/并发编程/内存模型/"}],"tags":[{"name":"原创","slug":"原创","permalink":"https://caoler.cn/tags/原创/"},{"name":"并发编程","slug":"并发编程","permalink":"https://caoler.cn/tags/并发编程/"}]},{"title":"Volatile型变量的语义解释","slug":"Volatile型变量的语义解释","date":"2017-11-16T08:41:00.000Z","updated":"2017-11-27T12:41:44.751Z","comments":true,"path":"/post/2017/volatile.html","link":"","permalink":"https://caoler.cn/post/2017/volatile.html","excerpt":"关键字volatile可以说是Java虚拟机提供的最轻量级的同步机制，但是它并不容易完全被正确、 完整地理解，以至于许多程序员都习惯不去使用它，遇到需要处理多线程数据竞争问题的时候一律使用synchronized来进行同步。 了解volatile变量的语义对后面了解多线程操作的其他特性很有意义，在这里我们将多花费一些时间去弄清楚volatile的语义到底是什么。 Java内存模型对volatile专门定义了一些特殊的访问规则，在介绍这些比较拗口的规则定义之前，笔者先用不那么正式但通俗易懂的语言来介绍一下这个关键字的作用。","text":"关键字volatile可以说是Java虚拟机提供的最轻量级的同步机制，但是它并不容易完全被正确、 完整地理解，以至于许多程序员都习惯不去使用它，遇到需要处理多线程数据竞争问题的时候一律使用synchronized来进行同步。 了解volatile变量的语义对后面了解多线程操作的其他特性很有意义，在这里我们将多花费一些时间去弄清楚volatile的语义到底是什么。 Java内存模型对volatile专门定义了一些特殊的访问规则，在介绍这些比较拗口的规则定义之前，笔者先用不那么正式但通俗易懂的语言来介绍一下这个关键字的作用。 可见性当一个变量定义为volatile之后，它将具备两种特性，第一是保证此变量对所有线程的可见性，这里的“可见性”是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。 而普通变量不能做到这一点，普通变量的值在线程间传递均需要通过主内存来完成，例如，线程A修改一个普通变量的值，然后向主内存进行回写，另外一条线程B在线程A回写完成了之后再从主内存进行读取操作，新变量值才会对线程B可见。 volatile变量在各个线程的工作内存中不存在一致性问题（在各个线程的工作内存中，volatile变量也可以存在不一致的情况，但由于每次使用之前都要先刷新，执行引擎看不到不一致的情况，因此可以认为不存在一致性问题），但是Java里面的运算并非原子操作，导致volatile变量的运算在并发下一样是不安全的. 禁止指令重排序优化使用volatile变量的第二个语义是禁止指令重排序优化，普通的变量仅仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。 因为在一个线程的方法执行过程中无法感知到这点，这也就是Java内存模型中描述的所谓的“线程内表现为串行的语义”（Within-Thread As-If-SerialSemantics）。 总结解决了volatile的语义问题，再来看看在众多保障并发安全的工具中选用volatile的意义——它能让我们的代码比使用其他的同步工具更快吗？在某些情况下，volatile的同步机制的性能确实要优于锁（使用synchronized关键字或java.util.concurrent包里面的锁），但是由于虚拟机对锁实行的许多消除和优化，使得我们很难量化地认为volatile就会比synchronized快多少。 如果让volatile自己与自己比较，那可以确定一个原则：volatile变量读操作的性能消耗与普通变量几乎没有什么差别，但是写操作则可能会慢一些，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行。 不过即便如此，大多数场景下volatile的总开销仍然要比锁低，我们在volatile与锁之中选择的唯一依据仅仅是volatile的语义能否满足使用场景的需求。 需要注意两点 load、read动作相关联，必须连续一起出现。 store、writer动作相关联，必须连续一起出现。","categories":[{"name":"并发编程","slug":"并发编程","permalink":"https://caoler.cn/categories/并发编程/"},{"name":"内存模型","slug":"并发编程/内存模型","permalink":"https://caoler.cn/categories/并发编程/内存模型/"}],"tags":[{"name":"原创","slug":"原创","permalink":"https://caoler.cn/tags/原创/"},{"name":"并发编程","slug":"并发编程","permalink":"https://caoler.cn/tags/并发编程/"}]},{"title":"Java内存模型","slug":"JAVA内存模型","date":"2017-11-16T08:38:00.000Z","updated":"2017-11-27T12:43:11.796Z","comments":true,"path":"/post/2017/java-memory-model-1.html","link":"","permalink":"https://caoler.cn/post/2017/java-memory-model-1.html","excerpt":"并发处理的广泛应用是使得Amdahl定律代替摩尔定律成为计算机性能发展源动力的根本原因，也是人类“压榨”计算机运算能力的最有力武器。 概述Java内存模型规范了Java虚拟机与计算机内存是如何协同工作的。Java虚拟机是一个完整的计算机的一个模型，因此这个模型自然也包含一个内存模型——又称为Java内存模型。 如果你想设计表现良好的并发程序，理解Java内存模型是非常重要的。Java内存模型规定了如何和何时可以看到由其他线程修改过后的共享变量的值，以及在必须时如何同步的访问共享变量。","text":"并发处理的广泛应用是使得Amdahl定律代替摩尔定律成为计算机性能发展源动力的根本原因，也是人类“压榨”计算机运算能力的最有力武器。 概述Java内存模型规范了Java虚拟机与计算机内存是如何协同工作的。Java虚拟机是一个完整的计算机的一个模型，因此这个模型自然也包含一个内存模型——又称为Java内存模型。 如果你想设计表现良好的并发程序，理解Java内存模型是非常重要的。Java内存模型规定了如何和何时可以看到由其他线程修改过后的共享变量的值，以及在必须时如何同步的访问共享变量。 原始的Java内存模型存在一些不足，因此Java内存模型在Java1.5时被重新修订。这个版本的Java内存模型在Java8中仍在使用。 硬件的效率与一致性现代计算机在执行并发任务的时候，为了更充分的利用计算机处理器的效能，所以不得不加入一层读写速度尽可能接近处理器运算速度的高速缓存（Cache） 来作为内存与处理器之间的缓冲：将运算与要用到的数据复制到缓存中，让运算能够快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无须等待缓慢的内存读写了。 每个CPU可能还有一个CPU缓存层。实际上，绝大多数的现代CPU都有一定大小的缓存层。CPU访问缓存层的速度快于访问主存的速度，但通常比访问内部寄存器的速度还要慢一点。一些CPU还有多层缓存，但这些对理解Java内存模型如何和内存交互不是那么重要。只要知道CPU中可以有一个缓存层就可以了。 通常情况下，当一个CPU需要读取主存时，它会将主存的部分读到CPU缓存中。它甚至可能将缓存中的部分内容读到它的内部寄存器中，然后在寄存器中执行操作。当CPU需要将结果写回到主存中去时，它会将内部寄存器的值刷新到缓存中，然后在某个时间点将值刷新回主存。 当CPU需要在缓存层存放一些东西的时候，存放在缓存中的内容通常会被刷新回主存。CPU缓存可以在某一时刻将数据局部写到它的内存中，和在某一时刻局部刷新它的内存。它不会再某一时刻读/写整个缓存。通常，在一个被称作“cache lines”的更小的内存块中缓存被更新。一个或者多个缓存行可能被读到缓存，一个或者多个缓存行可能再被刷新回主存。 “内存模型”一词可以理解为在特定的操作协议下，对特定的内存或者高速缓存进行读写访问的过程抽象。 JAVA内存模型JAVA虚拟机规范中视图定义一种JAVA内存模型(JMM)来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让JAVA程序在各种平台下都能够达到一致的内存访问效果。Java1.5发布后，Java内存模型已经成熟和完善起来了。 JVM内部存储结构—堆、线程栈Java内存模型把Java虚拟机内部划分为线程栈和堆。如下图所示： 栈是运行时的单位，而堆是存储的单位。在Java中每一个运行在Java虚拟机里的线程都拥有自己的线程栈。一个线程仅能访问自己的线程栈。一个线程创建的本地变量对其它线程不可见，即使两个线程执行的是同一段代码，它们也会在各自的线程栈中创建各自的本地变量。 所有的基本类型的本地变量和对象引用都存放在栈中，因此对其它线程不可见。一个线程可能向另一个线程传递一个基本类型变量的拷贝，但是它不能共享这个基本类型变量自身。 对象都存放在堆中，包括基本类型的对象版本。如果一个对象被创建然后赋值给一个局部变量，或者用来作为另一个对象的成员变量，这个对象任然是存放在堆上。 一个本地变量也可能是指向一个对象的一个引用。在这种情况下，引用（这个本地变量）存放在线程栈上，但是对象本身存放在堆上。 一个对象可能包含方法，这些方法可能包含本地变量。这些本地变量任然存放在线程栈上，即使这些方法所属的对象存放在堆上。 一个对象的成员变量可能随着这个对象自身存放在堆上。不管这个成员变量是原始类型还是引用类型。 静态成员变量跟随着类定义一起也存放在堆上。 存放在堆上的对象可以被所有持有对这个对象引用的线程访问。当多个线程通过调用同一个对象的相同方法访问其成员变量的时候，每个线程都将拥有该成员变量的拷贝而不是其自身。 主内存和工作内存Java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存中取出变量这样的底层细节。此处的变量(Variables) 与Java编程中所说的变量有所区别，它包括了实例字段、静态字段和构成数组对象的元素，但不包括局部变量与方法参数，因为后者不是私有的，不会被共享，自然就不会存在竞争问题。 JAVA内存模型规定了所有的变量都存储在主内存中。每条线程还有自己的工作内存(与计算机的高速缓冲类比),线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取、赋值）都必须在工作内存中进行，而不能直接读写主内存中的变量。不同的线程之间也无法访问对方工作内存中的变量，线程间变量值的传递云需要通过主内存来完成。 Java内存模型与硬件内存架构之间存在差异。硬件内存架构没有区分线程栈和堆。对于硬件，所有的线程栈和堆都分布在主内中。部分线程栈和堆可能有时候会出现在CPU缓存中和CPU内部的寄存器中。这种交叉对应关系如下图所示： 当对象和变量被存放在计算机中各种不同的内存区域中时，就可能会出现一些具体的问题。主要包括如下两个方面： 线程对共享变量修改的可见性 当读，写和检查共享变量时出现race conditions 内存间交互操作交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存之间的细节操作。虚拟机保证下列操作都是原子的、不可再分的。 状态 作用内存 功能 lock（锁定） 主 将变量标识为线程独占状态 unlock（解锁） 主 释放锁定的变量，释放后的变量才可以被锁定 read（读取） 主 将变量的值从主内存传输到线程的工作内存中 load（载入） 工作 把read到的变量放入工作内存的变量副本中 use（使用） 工作 将工作内存中的变量值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时会执行这个操作 assign（赋值） 工作 将执行引擎中的变量值传递给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时会执行这个操作 store（存储） 工作 将工作内存中的一个变量的值传递到主内存中 write（写入） 主 将得到的变量的值放入主内存的变量中 线程、工作内存、主内存三者的交互关系如下图所示： JAVA内存模型规定上述操作必须按顺序执行，但是没有保证是连续执行，也就说其中某连续两个操作之间可以插入其他指令，除此之外JAVA内存模型还规定执行上述操作时需要满足较多规则，规则详情查看 这里不做详细说明。 8种内存访问操作以及上述规定以及完全确定了JAVA程序中那些内存访问操作在并发下是安全的。由于过于严谨，实践起来很麻烦，所以 此篇文章 将介绍这种定义的一个等效判断原则————先行发生原则，来确认一个访问在并发环境下是否安全。 参考 并发编程网：Java内存模型 iteye：Java内存模型JMM之一内存交互操作 深入理解Java虚拟机：JVM高级特性与最佳实践（第二版）","categories":[{"name":"并发编程","slug":"并发编程","permalink":"https://caoler.cn/categories/并发编程/"},{"name":"内存模型","slug":"并发编程/内存模型","permalink":"https://caoler.cn/categories/并发编程/内存模型/"}],"tags":[{"name":"原创","slug":"原创","permalink":"https://caoler.cn/tags/原创/"},{"name":"并发编程","slug":"并发编程","permalink":"https://caoler.cn/tags/并发编程/"}]},{"title":"全站开启HTTPS加密模式访问","slug":"全站开启HTTPS加密模式访问","date":"2017-11-14T09:17:00.000Z","updated":"2017-11-27T12:41:05.485Z","comments":true,"path":"/post/2017/ssl-https.html","link":"","permalink":"https://caoler.cn/post/2017/ssl-https.html","excerpt":"前言最近发现，各大网站好像已经开始全站使用HTTPS，看着浏览器地址栏左边有着一把绿色的小锁，好像是一件很酷的事情。国内的网络环境好像越来越差，除了学会科学上网之外，好像也难免会遇到通讯服务商在网站上加上小广告的问题。随着不断了解计算机的知识，安全概念也越来越重。看着某某网站又被脱裤，一不小心自己的隐私可能就泄露出去了。在社工库上一查，还真能发现自己小学时候使用过的密码。不过，现在当然已经学会了各种措施，每个网站独立密码，能双重保护地就进行双重保护。1password也是我经常使用的一个密码管理软件……啊，好像扯远了。今天，天气很好，也想给自己的博客加上把绿色的小锁HTTPS。 什么是HTTPS","text":"前言最近发现，各大网站好像已经开始全站使用HTTPS，看着浏览器地址栏左边有着一把绿色的小锁，好像是一件很酷的事情。国内的网络环境好像越来越差，除了学会科学上网之外，好像也难免会遇到通讯服务商在网站上加上小广告的问题。随着不断了解计算机的知识，安全概念也越来越重。看着某某网站又被脱裤，一不小心自己的隐私可能就泄露出去了。在社工库上一查，还真能发现自己小学时候使用过的密码。不过，现在当然已经学会了各种措施，每个网站独立密码，能双重保护地就进行双重保护。1password也是我经常使用的一个密码管理软件……啊，好像扯远了。今天，天气很好，也想给自己的博客加上把绿色的小锁HTTPS。 什么是HTTPS HTTPS全称Hypertext Transfer Protocol Secure 超文本安全协议。也就是HTTP加上安全传输层协议TSL/SSL。介于HTTP层与TCP层之间的一层安全协议。通过安全认证，可以避免HTTP中间人攻击，信息污染，信息劫持等问题。详细信息的话腾讯Bugly的文章全站HTTPS来了介绍得很详细。HTTPS基础原理，通信过程，在这篇文章里都有详细地讲到。 直接进入主题，为博客加上HTTPS吧。 给博客加上HTTPS数字证书通过上述的HTTPS介绍，可以知道如果我们要给让博客的协议变成HTTPS，就需要有CA认可的证书才可以，一般这样子的证书是需要自己进行购买和申请认证的。简单RSA非对称性的加密算法是无法避免中间人攻击的。存在着中间人攻击和信息抵赖的风险。所以我这里所采用的方法是用，Cloudflare所提供的CDN来作为HTTPS的接入口。 CDN什么是CDN? CDN的全称就是Content Delivery Network，内容分发网络。其最基本的思路就是，用户在访问一个网站的时候，不直接访问这个网站的服务器，CDN系统会根据地理位置，将用户重新导向离其最近的CDN服务器。网站的内容在这个CDN服务器上会有相应的缓存，从而使用户更快地访问到所需要的内容，可以减少网络拥堵的情况，也可以减轻网站的服务器承受太大的访问量，以及带宽不足的情况。 主要步骤 注册Cloudflare，添加个人网站 获取Cloudflare的Domain Name Server 在域名提供商处修改自己域名的Domain Name Server为2所获取的DNS 开启SSL加密，选择flexible 开启强制跳转，使http自动跳转到https 步骤1，2在注册cloudflare的过程中，跟着流程一步一步做就好了。步骤3的话我们要先取消掉原有的DNS的解析服务，修改为cloudflare的DNS的地址。然后在Cloudflare的DNS中添加相应的DNS记录即可。可能会用到的DNS record大概有下面几种 A记录: 将一个域名指向一个ipv4的地址AAAA记录: 将一个域名指向一个ipv6的地址CNAME记录: 将一个域名指向另一个域名 步骤4中，我们所使用的是flexible的SSL加密方式。这种加密方式根据cloudflare的解释如下： Flexible SSL: There is an encrypted connection between your website visitors and Cloudflare, but not from Cloudflare to your server.You do not need an SSL certificate on your serverVisitors will see the SSL lock icon in their browser 也就是说这其实不是一种安全的加密方式，因为其实服务器与CDN在通信过程中的信息是没有加密的。但是因为我使用的git page 以及没有购买相应的证书，所以没法再服务器上部署SSL。所以CDN与服务器之间的通信就不是加密的通信。 步骤5共有两种方法 第一种：在cloudflare上的Page Rules设置中，添加上一条规则使得通过http协议的访问也会强制跳转到https上。 第二种：在网站head标签中加入如下代码：12345&lt;script type=\"text/javascript\"&gt; var host = \"caoler.cn\"; if ((host == window.location.host) &amp;&amp; (window.location.protocol != \"https:\")) window.location.protocol = \"https\";&lt;/script&gt; 防跳坑： 上述两种方式只能使用其中一种，不然浏览器会报出循环重定向错误，导致网站无法正常访问。别问我为什么知道~ （逃 全站HTTPS要做到成功让这个博客满足https的要求，在博客所使用所有的图片自然也是要使用https的链接才行的，只要网站上所使用的资源不是全部通过https的就存在着安全的风险。且网站会被chrome等浏览器认为是不安全的。(放弃七牛云作为图床) 这里所使用的是新浪微博的图床，在chrome商店可以找到对应的插件。在左下角有的https的选项，只要勾选上了就可以默认生成https的图片链接了。谷歌商店地址 总结虽然这里所使用的方法，不是安全的一种方法。网站仍然会面临中间人攻击等一系列问题。因为服务器与CDN之间的通信未加密。但是至少用户在访问网站的时候，不会被通信服务商再拦截再什么广告了。刚好在学习计算机网络的过程中，了解了一些https、cdn、dns、ssl的知识。随着chrome,firefox等浏览器和苹果的大力推进。HTTPS肯定是接下去的发展趋势了，而且证书的费用也在下降。所以，各个网站都是很有必要，向这里过渡的。还有，看着自己浏览的网站，有一个绿色的小锁，就是一件很酷的事情啊，哈哈。","categories":[{"name":"博客相关","slug":"博客相关","permalink":"https://caoler.cn/categories/博客相关/"}],"tags":[{"name":"博客相关","slug":"博客相关","permalink":"https://caoler.cn/tags/博客相关/"}]},{"title":"线程安全","slug":"线程安全","date":"2017-11-13T10:48:00.000Z","updated":"2017-11-27T12:39:34.673Z","comments":true,"path":"/post/2017/thread-safety.html","link":"","permalink":"https://caoler.cn/post/2017/thread-safety.html","excerpt":"竞态条件与临界区在同一程序中运行多个线程本身不会导致问题，问题在于多个线程访问了相同的资源。如，同一内存区（变量，数组，或对象）、系统（数据库，web services等）或文件。实际上，这些问题只有在一或多个线程向这些资源做了写操作时才有可能发生，只要资源没有发生变化,多个线程读取相同的资源就是安全的。 多线程同时执行下面的代码可能会出错：123456public class Counter &#123; protected long count = 0; public void add(long value)&#123; this.count = this.count + value; &#125;&#125;","text":"竞态条件与临界区在同一程序中运行多个线程本身不会导致问题，问题在于多个线程访问了相同的资源。如，同一内存区（变量，数组，或对象）、系统（数据库，web services等）或文件。实际上，这些问题只有在一或多个线程向这些资源做了写操作时才有可能发生，只要资源没有发生变化,多个线程读取相同的资源就是安全的。 多线程同时执行下面的代码可能会出错：123456public class Counter &#123; protected long count = 0; public void add(long value)&#123; this.count = this.count + value; &#125;&#125; 想象下线程A和B同时执行同一个Counter对象的add()方法，我们无法知道操作系统何时会在两个线程之间切换。JVM并不是将这段代码视为单条指令来执行的，而是按照下面的顺序： 从内存获取 this.count 的值放到寄存器将寄存器中的值增加value将寄存器中的值写回内存 观察线程A和B交错执行会发生什么： this.count = 0; A: 读取 this.count 到一个寄存器 (0) B: 读取 this.count 到一个寄存器 (0) B: 将寄存器的值加2 B: 回写寄存器值(2)到内存. this.count 现在等于 2 A: 将寄存器的值加3 A: 回写寄存器值(3)到内存. this.count 现在等于 3 两个线程分别加了2和3到count变量上，两个线程执行结束后count变量的值应该等于5。然而由于两个线程是交叉执行的，两个线程从内存中读出的初始值都是0。然后各自加了2和3，并分别写回内存。最终的值并不是期望的5，而是最后写回内存的那个线程的值，上面例子中最后写回内存的是线程A，但实际中也可能是线程B。如果没有采用合适的同步机制，线程间的交叉执行情况就无法预料。 竞态条件 &amp; 临界区当两个线程竞争同一资源时，如果对资源的访问顺序敏感，就称存在竞态条件。导致竞态条件发生的代码区称作临界区。上例中add()方法就是一个临界区,它会产生竞态条件。在临界区中使用适当的同步就可以避免竞态条件。 线程安全与共享资源允许被多个线程同时执行的代码称作线程安全的代码。线程安全的代码不包含竞态条件。当多个线程同时更新共享资源时会引发竞态条件。因此，了解Java线程执行时共享了什么资源很重要。 局部变量局部变量存储在线程自己的栈中。也就是说，局部变量永远也不会被多个线程共享。所以，基础类型的局部变量是线程安全的。下面是基础类型的局部变量的一个例子：123456public void someMethod()&#123; long threadSafeInt = 0; threadSafeInt++;&#125; 局部的对象引用对象的局部引用和基础类型的局部变量不太一样。尽管引用本身没有被共享，但引用所指的对象并没有存储在线程的栈内。所有的对象都存在共享堆中。如果在某个方法中创建的对象不会逃逸出（译者注：即该对象不会被其它方法获得，也不会被非局部变量引用到）该方法，那么它就是线程安全的。实际上，哪怕将这个对象作为参数传给其它方法，只要别的线程获取不到这个对象，那它仍是线程安全的。下面是一个线程安全的局部引用样例： 1234567891011public void someMethod()&#123; LocalObject localObject = new LocalObject(); localObject.callMethod(); method2(localObject);&#125;public void method2(LocalObject localObject)&#123; localObject.setValue(\"value\");&#125; 样例中LocalObject对象没有被方法返回，也没有被传递给someMethod()方法外的对象。每个执行someMethod()的线程都会创建自己的LocalObject对象，并赋值给localObject引用。因此，这里的LocalObject是线程安全的。事实上，整个someMethod()都是线程安全的。即使将LocalObject作为参数传给同一个类的其它方法或其它类的方法时，它仍然是线程安全的。当然，如果LocalObject通过某些方法被传给了别的线程，那它就不再是线程安全的了。 对象成员对象成员存储在堆上。如果两个线程同时更新同一个对象的同一个成员，那这个代码就不是线程安全的。下面是一个样例：1234567public class NotThreadSafe&#123; StringBuilder builder = new StringBuilder(); public add(String text)&#123; this.builder.append(text); &#125; &#125; 如果两个线程同时调用同一个NotThreadSafe实例上的add()方法，就会有竞态条件问题。例如：12345678910111213141516NotThreadSafe sharedInstance = new NotThreadSafe();new Thread(new MyRunnable(sharedInstance)).start();new Thread(new MyRunnable(sharedInstance)).start(); public class MyRunnable implements Runnable&#123; NotThreadSafe instance = null; public MyRunnable(NotThreadSafe instance)&#123; this.instance = instance; &#125; public void run()&#123; this.instance.add(\"some text\"); &#125;&#125; 注意两个MyRunnable共享了同一个NotThreadSafe对象。因此，当它们调用add()方法时会造成竞态条件。 当然，如果这两个线程在不同的NotThreadSafe实例上调用call()方法，就不会导致竞态条件。下面是稍微修改后的例子：12new Thread(new MyRunnable(new NotThreadSafe())).start();new Thread(new MyRunnable(new NotThreadSafe())).start(); 现在两个线程都有自己单独的NotThreadSafe对象，调用add()方法时就会互不干扰，再也不会有竞态条件问题了。所以非线程安全的对象仍可以通过某种方式来消除竞态条件。 线程控制逃逸规则线程控制逃逸规则可以帮助你判断代码中对某些资源的访问是否是线程安全的。 如果一个资源的创建，使用，销毁都在同一个线程内完成，且永远不会脱离该线程的控制，则该资源的使用就是线程安全的。 资源可以是对象，数组，文件，数据库连接，套接字等等。Java中你无需主动销毁对象，所以“销毁”指不再有引用指向对象。 即使对象本身线程安全，但如果该对象中包含其他资源（文件，数据库连接），整个应用也许就不再是线程安全的了。比如2个线程都创建了各自的数据库连接，每个连接自身是线程安全的，但它们所连接到的同一个数据库也许不是线程安全的。比如，2个线程执行如下代码： 检查记录X是否存在，如果不存在，插入X 如果两个线程同时执行，而且碰巧检查的是同一个记录，那么两个线程最终可能都插入了记录： 线程1检查记录X是否存在。检查结果：不存在线程2检查记录X是否存在。检查结果：不存在线程1插入记录X线程2插入记录X 同样的问题也会发生在文件或其他共享资源上。因此，区分某个线程控制的对象是资源本身，还是仅仅到某个资源的引用很重要。 线程安全及不可变性当多个线程同时访问同一个资源，并且其中的一个或者多个线程对这个资源进行了写操作，才会产生竞态条件。多个线程同时读同一个资源不会产生竞态条件。 我们可以通过创建不可变的共享对象来保证对象在线程间共享时不会被修改，从而实现线程安全。如下示例： 1234567891011public class ImmutableValue&#123; private int value = 0; public ImmutableValue(int value)&#123; this.value = value; &#125; public int getValue()&#123; return this.value; &#125;&#125; 请注意ImmutableValue类的成员变量value是通过构造函数赋值的，并且在类中没有set方法。这意味着一旦ImmutableValue实例被创建，value变量就不能再被修改，这就是不可变性。但你可以通过getValue()方法读取这个变量的值。 （译者注：注意，“不变”（Immutable）和“只读”（Read Only）是不同的。当一个变量是“只读”时，变量的值不能直接改变，但是可以在其它变量发生改变的时候发生改变。比如，一个人的出生年月日是“不变”属性，而一个人的年龄便是“只读”属性，但是不是“不变”属性。随着时间的变化，一个人的年龄会随之发生变化，而一个人的出生年月日则不会变化。这就是“不变”和“只读”的区别。（摘自《Java与模式》第34章）） 如果你需要对ImmutableValue类的实例进行操作，可以通过得到value变量后创建一个新的实例来实现，下面是一个对value变量进行加法操作的示例： 123456789101112131415public class ImmutableValue&#123; private int value = 0; public ImmutableValue(int value)&#123; this.value = value; &#125; public int getValue()&#123; return this.value; &#125; public ImmutableValue add(int valueToAdd)&#123; return new ImmutableValue(this.value + valueToAdd); &#125;&#125; 请注意add()方法以加法操作的结果作为一个新的ImmutableValue类实例返回，而不是直接对它自己的value变量进行操作。 引用不是线程安全的！ 重要的是要记住，即使一个对象是线程安全的不可变对象，指向这个对象的引用也可能不是线程安全的。看这个例子：12345678910111213141516public void Calculator&#123; private ImmutableValue currentValue = null; public ImmutableValue getValue()&#123; return currentValue; &#125; public void setValue(ImmutableValue newValue)&#123; this.currentValue = newValue; &#125; public void add(int newValue)&#123; this.currentValue = this.currentValue.add(newValue); &#125;&#125; Calculator类持有一个指向ImmutableValue实例的引用。注意，通过setValue()方法和add()方法可能会改变这个引用。因此，即使Calculator类内部使用了一个不可变对象，但Calculator类本身还是可变的，因此Calculator类不是线程安全的。换句话说：ImmutableValue类是线程安全的，但使用它的类不是。当尝试通过不可变性去获得线程安全时，这点是需要牢记的。 要使Calculator类实现线程安全，将getValue()、setValue()和add()方法都声明为同步方法即可。 本文转载于并发编程网来源：http://ifeve.com/java-concurrency-thread-directory/","categories":[{"name":"并发编程","slug":"并发编程","permalink":"https://caoler.cn/categories/并发编程/"},{"name":"多线程","slug":"并发编程/多线程","permalink":"https://caoler.cn/categories/并发编程/多线程/"}],"tags":[{"name":"并发编程","slug":"并发编程","permalink":"https://caoler.cn/tags/并发编程/"},{"name":"转载","slug":"转载","permalink":"https://caoler.cn/tags/转载/"}]},{"title":"并发性和多线程介绍","slug":"并发性和多线程的介绍","date":"2017-11-12T09:48:00.000Z","updated":"2017-11-27T12:41:27.176Z","comments":true,"path":"/post/2017/java-concurrency-thread.html","link":"","permalink":"https://caoler.cn/post/2017/java-concurrency-thread.html","excerpt":"介绍在过去单CPU时代，单任务在一个时间点只能执行单一程序。之后发展到多任务阶段，计算机能在同一时间点并行执行多任务或多进程。虽然并不是真正意义上的“同一时间点”，而是多个任务或进程共享一个CPU，并交由操作系统来完成多任务间对CPU的运行切换，以使得每个任务都有机会获得一定的时间片运行。 随着多任务对软件开发者带来的新挑战，程序不在能假设独占所有的CPU时间、所有的内存和其他计算机资源。一个好的程序榜样是在其不再使用这些资源时对其进行释放，以使得其他程序能有机会使用这些资源。","text":"介绍在过去单CPU时代，单任务在一个时间点只能执行单一程序。之后发展到多任务阶段，计算机能在同一时间点并行执行多任务或多进程。虽然并不是真正意义上的“同一时间点”，而是多个任务或进程共享一个CPU，并交由操作系统来完成多任务间对CPU的运行切换，以使得每个任务都有机会获得一定的时间片运行。 随着多任务对软件开发者带来的新挑战，程序不在能假设独占所有的CPU时间、所有的内存和其他计算机资源。一个好的程序榜样是在其不再使用这些资源时对其进行释放，以使得其他程序能有机会使用这些资源。 再后来发展到多线程技术，使得在一个程序内部能拥有多个线程并行执行。一个线程的执行可以被认为是一个CPU在执行该程序。当一个程序运行在多线程下，就好像有多个CPU在同时执行该程序。 多线程比多任务更加有挑战。多线程是在同一个程序内部并行执行，因此会对相同的内存空间进行并发读写操作。这可能是在单线程程序中从来不会遇到的问题。其中的一些错误也未必会在单CPU机器上出现，因为两个线程从来不会得到真正的并行执行。然而，更现代的计算机伴随着多核CPU的出现，也就意味着不同的线程能被不同的CPU核得到真正意义的并行执行。 如果一个线程在读一个内存时，另一个线程正向该内存进行写操作，那进行读操作的那个线程将获得什么结果呢？是写操作之前旧的值？还是写操作成功之后的新值？或是一半新一半旧的值？或者，如果是两个线程同时写同一个内存，在操作完成后将会是什么结果呢？是第一个线程写入的值？还是第二个线程写入的值？还是两个线程写入的一个混合值？因此如没有合适的预防措施，任何结果都是可能的。而且这种行为的发生甚至不能预测，所以结果也是不确定性的。 多线程的优点尽管面临很多挑战，多线程有一些优点使得它一直被使用。这些优点是： 资源利用率更好 程序设计在某些情况下更简单 程序响应更快 资源利用率更好想象一下，一个应用程序需要从本地文件系统中读取和处理文件的情景。比方说，从磁盘读取一个文件需要5秒，处理一个文件需要2秒。处理两个文件则需要： 12345675秒读取文件A2秒处理文件A5秒读取文件B2秒处理文件B--------------总共需要14秒 从磁盘中读取文件的时候，大部分的CPU时间用于等待磁盘去读取数据。在这段时间里，CPU非常的空闲。它可以做一些别的事情。通过改变操作的顺序，就能够更好的使用CPU资源。看下面的顺序：1234565秒读取文件A5秒读取文件B + 2秒处理文件A2秒处理文件B--------------总共需要12秒 CPU等待第一个文件被读取完。然后开始读取第二个文件。当第二文件在被读取的时候，CPU会去处理第一个文件。记住，在等待磁盘读取文件的时候，CPU大部分时间是空闲的。 总的说来，CPU能够在等待IO的时候做一些其他的事情。这个不一定就是磁盘IO。它也可以是网络的IO，或者用户输入。通常情况下，网络和磁盘的IO比CPU和内存的IO慢的多。 程序设计更简单在单线程应用程序中，如果你想编写程序手动处理上面所提到的读取和处理的顺序，你必须记录每个文件读取和处理的状态。相反，你可以启动两个线程，每个线程处理一个文件的读取和操作。线程会在等待磁盘读取文件的过程中被阻塞。在等待的时候，其他的线程能够使用CPU去处理已经读取完的文件。其结果就是，磁盘总是在繁忙地读取不同的文件到内存中。这会带来磁盘和CPU利用率的提升。而且每个线程只需要记录一个文件，因此这种方式也很容易编程实现。 程序响应更快将一个单线程应用程序变成多线程应用程序的另一个常见的目的是实现一个响应更快的应用程序。设想一个服务器应用，它在某一个端口监听进来的请求。当一个请求到来时，它去处理这个请求，然后再返回去监听。 服务器的流程如下所述：1234while(server is active)&#123; listen for request process request&#125; 如果一个请求需要占用大量的时间来处理，在这段时间内新的客户端就无法发送请求给服务端。只有服务器在监听的时候，请求才能被接收。另一种设计是，监听线程把请求传递给工作者线程(worker thread)，然后立刻返回去监听。而工作者线程则能够处理这个请求并发送一个回复给客户端。这种设计如下所述：12345while(server is active)&#123; listen for request hand request to worker thread&#125; 这种方式，服务端线程迅速地返回去监听。因此，更多的客户端能够发送请求给服务端。这个服务也变得响应更快。 桌面应用也是同样如此。如果你点击一个按钮开始运行一个耗时的任务，这个线程既要执行任务又要更新窗口和按钮，那么在任务执行的过程中，这个应用程序看起来好像没有反应一样。相反，任务可以传递给工作者线程（word thread)。当工作者线程在繁忙地处理任务的时候，窗口线程可以自由地响应其他用户的请求。当工作者线程完成任务的时候，它发送信号给窗口线程。窗口线程便可以更新应用程序窗口，并显示任务的结果。对用户而言，这种具有工作者线程设计的程序显得响应速度更快。 多线程的代价从一个单线程的应用到一个多线程的应用并不仅仅带来好处，它也会有一些代价。不要仅仅为了使用多线程而使用多线程。而应该明确在使用多线程时能多来的好处比所付出的代价大的时候，才使用多线程。如果存在疑问，应该尝试测量一下应用程序的性能和响应能力，而不只是猜测。 设计更复杂虽然有一些多线程应用程序比单线程的应用程序要简单，但其他的一般都更复杂。在多线程访问共享数据的时候，这部分代码需要特别的注意。线程之间的交互往往非常复杂。不正确的线程同步产生的错误非常难以被发现，并且重现以修复。 上下文切换的开销当CPU从执行一个线程切换到执行另外一个线程的时候，它需要先存储当前线程的本地的数据，程序指针等，然后载入另一个线程的本地数据，程序指针等，最后才开始执行。这种切换称为“上下文切换”(“context switch”)。CPU会在一个上下文中执行一个线程，然后切换到另外一个上下文中执行另外一个线程。 上下文切换并不廉价。如果没有必要，应该减少上下文切换的发生。 你可以通过维基百科阅读更多的关于上下文切换相关的内容： http://en.wikipedia.org/wiki/Context_switch 增加资源消耗线程在运行的时候需要从计算机里面得到一些资源。除了CPU，线程还需要一些内存来维持它本地的堆栈。它也需要占用操作系统中一些资源来管理线程。我们可以尝试编写一个程序，让它创建100个线程，这些线程什么事情都不做，只是在等待，然后看看这个程序在运行的时候占用了多少内存。 并发编程模型并发系统可以采用多种并发编程模型来实现。并发模型指定了系统中的线程如何通过协作来完成分配给它们的作业。不同的并发模型采用不同的方式拆分作业，同时线程间的协作和交互方式也不相同。这篇并发模型教程将会较深入地介绍目前（2015年，本文撰写时间）比较流行的几种并发模型。 并发模型与分布式系统之间的相似性本文所描述的并发模型类似于分布式系统中使用的很多体系结构。在并发系统中线程之间可以相互通信。在分布式系统中进程之间也可以相互通信（进程有可能在不同的机器中）。线程和进程之间具有很多相似的特性。这也就是为什么很多并发模型通常类似于各种分布式系统架构。 当然，分布式系统在处理网络失效、远程主机或进程宕掉等方面也面临着额外的挑战。但是运行在巨型服务器上的并发系统也可能遇到类似的问题，比如一块CPU失效、一块网卡失效或一个磁盘损坏等情况。虽然出现失效的概率可能很低，但是在理论上仍然有可能发生。 由于并发模型类似于分布式系统架构，因此它们通常可以互相借鉴思想。例如，为工作者们（线程）分配作业的模型一般与分布式系统中的负载均衡系统比较相似。同样，它们在日志记录、失效转移、幂等性等错误处理技术上也具有相似性。【注：幂等性，一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同】 并行工作者第一种并发模型就是我所说的并行工作者模型。传入的作业会被分配到不同的工作者上。下图展示了并行工作者模型： 在并行工作者模型中，委派者（Delegator）将传入的作业分配给不同的工作者。每个工作者完成整个任务。工作者们并行运作在不同的线程上，甚至可能在不同的CPU上。 如果在某个汽车厂里实现了并行工作者模型，每台车都会由一个工人来生产。工人们将拿到汽车的生产规格，并且从头到尾负责所有工作。 在Java应用系统中，并行工作者模型是最常见的并发模型（即使正在转变）。java.util.concurrent包中的许多并发实用工具都是设计用于这个模型的。你也可以在Java企业级（J2EE）应用服务器的设计中看到这个模型的踪迹。 并行工作者模型的优点并行工作者模式的优点是，它很容易理解。你只需添加更多的工作者来提高系统的并行度。 例如，如果你正在做一个网络爬虫，可以试试使用不同数量的工作者抓取到一定数量的页面，然后看看多少数量的工作者消耗的时间最短（意味着性能最高）。由于网络爬虫是一个IO密集型工作，最终结果很有可能是你电脑中的每个CPU或核心分配了几个线程。每个CPU若只分配一个线程可能有点少，因为在等待数据下载的过程中CPU将会空闲大量时间。 并行工作者模型的缺点并行工作者模型虽然看起来简单，却隐藏着一些缺点。接下来的章节中我会分析一些最明显的弱点。 共享状态可能会很复杂在实际应用中，并行工作者模型可能比前面所描述的情况要复杂得多。共享的工作者经常需要访问一些共享数据，无论是内存中的或者共享的数据库中的。下图展示了并行工作者模型是如何变得复杂的： 有些共享状态是在像作业队列这样的通信机制下。但也有一些共享状态是业务数据，数据缓存，数据库连接池等。 一旦共享状态潜入到并行工作者模型中，将会使情况变得复杂起来。线程需要以某种方式存取共享数据，以确保某个线程的修改能够对其他线程可见（数据修改需要同步到主存中，不仅仅将数据保存在执行这个线程的CPU的缓存中）。线程需要避免竟态，死锁以及很多其他共享状态的并发性问题。 此外，在等待访问共享数据结构时，线程之间的互相等待将会丢失部分并行性。许多并发数据结构是阻塞的，意味着在任何一个时间只有一个或者很少的线程能够访问。这样会导致在这些共享数据结构上出现竞争状态。在执行需要访问共享数据结构部分的代码时，高竞争基本上会导致执行时出现一定程度的串行化。 现在的非阻塞并发算法也许可以降低竞争并提升性能，但是非阻塞算法的实现比较困难。 可持久化的数据结构是另一种选择。在修改的时候，可持久化的数据结构总是保护它的前一个版本不受影响。因此，如果多个线程指向同一个可持久化的数据结构，并且其中一个线程进行了修改，进行修改的线程会获得一个指向新结构的引用。所有其他线程保持对旧结构的引用，旧结构没有被修改并且因此保证一致性。Scala编程包含几个持久化数据结构。【注：这里的可持久化数据结构不是指持久化存储，而是一种数据结构，比如Java中的String类，以及CopyOnWriteArrayList类，具体可参考】 虽然可持久化的数据结构在解决共享数据结构的并发修改时显得很优雅，但是可持久化的数据结构的表现往往不尽人意。 比如说，一个可持久化的链表需要在头部插入一个新的节点，并且返回指向这个新加入的节点的一个引用（这个节点指向了链表的剩余部分）。所有其他现场仍然保留了这个链表之前的第一个节点，对于这些线程来说链表仍然是为改变的。它们无法看到新加入的元素。 这种可持久化的列表采用链表来实现。不幸的是链表在现代硬件上表现的不太好。链表中得每个元素都是一个独立的对象，这些对象可以遍布在整个计算机内存中。现代CPU能够更快的进行顺序访问，所以你可以在现代的硬件上用数组实现的列表，以获得更高的性能。数组可以顺序的保存数据。CPU缓存能够一次加载数组的一大块进行缓存，一旦加载完成CPU就可以直接访问缓存中的数据。这对于元素散落在RAM中的链表来说，不太可能做得到。 无状态的工作者共享状态能够被系统中得其他线程修改。所以工作者在每次需要的时候必须重读状态，以确保每次都能访问到最新的副本，不管共享状态是保存在内存中的还是在外部数据库中。工作者无法在内部保存这个状态（但是每次需要的时候可以重读）称为无状态的。 每次都重读需要的数据，将会导致速度变慢，特别是状态保存在外部数据库中的时候。 任务顺序是不确定的并行工作者模式的另一个缺点是，作业执行顺序是不确定的。无法保证哪个作业最先或者最后被执行。作业A可能在作业B之前就被分配工作者了，但是作业B反而有可能在作业A之前执行。 并行工作者模式的这种非确定性的特性，使得很难在任何特定的时间点推断系统的状态。这也使得它也更难（如果不是不可能的话）保证一个作业在其他作业之前被执行。 流水线模式第二种并发模型我们称之为流水线并发模型。我之所以选用这个名字，只是为了配合“并行工作者”的隐喻。其他开发者可能会根据平台或社区选择其他称呼（比如说反应器系统，或事件驱动系统）。下图表示一个流水线并发模型： 类似于工厂中生产线上的工人们那样组织工作者。每个工作者只负责作业中的部分工作。当完成了自己的这部分工作时工作者会将作业转发给下一个工作者。每个工作者在自己的线程中运行，并且不会和其他工作者共享状态。有时也被成为无共享并行模型。 通常使用非阻塞的IO来设计使用流水线并发模型的系统。非阻塞IO意味着，一旦某个工作者开始一个IO操作的时候（比如读取文件或从网络连接中读取数据），这个工作者不会一直等待IO操作的结束。IO操作速度很慢，所以等待IO操作结束很浪费CPU时间。此时CPU可以做一些其他事情。当IO操作完成的时候，IO操作的结果（比如读出的数据或者数据写完的状态）被传递给下一个工作者。 有了非阻塞IO，就可以使用IO操作确定工作者之间的边界。工作者会尽可能多运行直到遇到并启动一个IO操作。然后交出作业的控制权。当IO操作完成的时候，在流水线上的下一个工作者继续进行操作，直到它也遇到并启动一个IO操作。 在实际应用中，作业有可能不会沿着单一流水线进行。由于大多数系统可以执行多个作业，作业从一个工作者流向另一个工作者取决于作业需要做的工作。在实际中可能会有多个不同的虚拟流水线同时运行。这是现实当中作业在流水线系统中可能的移动情况： 作业甚至也有可能被转发到超过一个工作者上并发处理。比如说，作业有可能被同时转发到作业执行器和作业日志器。下图说明了三条流水线是如何通过将作业转发给同一个工作者（中间流水线的最后一个工作者）来完成作业: 流水线有时候比这个情况更加复杂。 反应器，事件驱动系统采用流水线并发模型的系统有时候也称为反应器系统或事件驱动系统。系统内的工作者对系统内出现的事件做出反应，这些事件也有可能来自于外部世界或者发自其他工作者。事件可以是传入的HTTP请求，也可以是某个文件成功加载到内存中等。在写这篇文章的时候，已经有很多有趣的反应器/事件驱动平台可以使用了，并且不久的将来会有更多。比较流行的似乎是这几个： Vert.x AKKa Node.JS(JavaScript)我个人觉得Vert.x是相当有趣的（特别是对于我这样使用Java/JVM的人来说） Actors 和 ChannelsActors 和 channels 是两种比较类似的流水线（或反应器/事件驱动）模型。 在Actor模型中每个工作者被称为actor。Actor之间可以直接异步地发送和处理消息。Actor可以被用来实现一个或多个像前文描述的那样的作业处理流水线。下图给出了Actor模型：而在Channel模型中，工作者之间不直接进行通信。相反，它们在不同的通道中发布自己的消息（事件）。其他工作者们可以在这些通道上监听消息，发送者无需知道谁在监听。下图给出了Channel模型： 在写这篇文章的时候，channel模型对于我来说似乎更加灵活。一个工作者无需知道谁在后面的流水线上处理作业。只需知道作业（或消息等）需要转发给哪个通道。通道上的监听者可以随意订阅或者取消订阅，并不会影响向这个通道发送消息的工作者。这使得工作者之间具有松散的耦合。 流水线模型的优点相比并行工作者模型，流水线并发模型具有几个优点，在接下来的章节中我会介绍几个最大的优点。 无需共享的状态工作者之间无需共享状态，意味着实现的时候无需考虑所有因并发访问共享对象而产生的并发性问题。这使得在实现工作者的时候变得非常容易。在实现工作者的时候就好像是单个线程在处理工作-基本上是一个单线程的实现。 有状态的工作者当工作者知道了没有其他线程可以修改它们的数据，工作者可以变成有状态的。对于有状态，我是指，它们可以在内存中保存它们需要操作的数据，只需在最后将更改写回到外部存储系统。因此，有状态的工作者通常比无状态的工作者具有更高的性能。 较好的硬件整合（Hardware Conformity）单线程代码在整合底层硬件的时候往往具有更好的优势。首先，当能确定代码只在单线程模式下执行的时候，通常能够创建更优化的数据结构和算法。 其次，像前文描述的那样，单线程有状态的工作者能够在内存中缓存数据。在内存中缓存数据的同时，也意味着数据很有可能也缓存在执行这个线程的CPU的缓存中。这使得访问缓存的数据变得更快。 我说的硬件整合是指，以某种方式编写的代码，使得能够自然地受益于底层硬件的工作原理。有些开发者称之为mechanical sympathy。我更倾向于硬件整合这个术语，因为计算机只有很少的机械部件，并且能够隐喻“更好的匹配（match better）”，相比“同情（sympathy）”这个词在上下文中的意思，我觉得“conform”这个词表达的非常好。当然了，这里有点吹毛求疵了，用自己喜欢的术语就行。 合理的作业顺序基于流水线并发模型实现的并发系统，在某种程度上是有可能保证作业的顺序的。作业的有序性使得它更容易地推出系统在某个特定时间点的状态。更进一步，你可以将所有到达的作业写入到日志中去。一旦这个系统的某一部分挂掉了，该日志就可以用来重头开始重建系统当时的状态。按照特定的顺序将作业写入日志，并按这个顺序作为有保障的作业顺序。下图展示了一种可能的设计： 实现一个有保障的作业顺序是不容易的，但往往是可行的。如果可以，它将大大简化一些任务，例如备份、数据恢复、数据复制等，这些都可以通过日志文件来完成。 流水线模型的缺点流水线并发模型最大的缺点是作业的执行往往分布到多个工作者上，并因此分布到项目中的多个类上。这样导致在追踪某个作业到底被什么代码执行时变得困难。 同样，这也加大了代码编写的难度。有时会将工作者的代码写成回调处理的形式。若在代码中嵌入过多的回调处理，往往会出现所谓的回调地狱（callback hell）现象。所谓回调地狱，就是意味着在追踪代码在回调过程中到底做了什么，以及确保每个回调只访问它需要的数据的时候，变得非常困难 使用并行工作者模型可以简化这个问题。你可以打开工作者的代码，从头到尾优美的阅读被执行的代码。当然并行工作者模式的代码也可能同样分布在不同的类中，但往往也能够很容易的从代码中分析执行的顺序。 函数式并行（Functional Parallelism）第三种并发模型是函数式并行模型，这是也最近（2015）讨论的比较多的一种模型。函数式并行的基本思想是采用函数调用实现程序。函数可以看作是”代理人（agents）“或者”actor“，函数之间可以像流水线模型（AKA 反应器或者事件驱动系统）那样互相发送消息。某个函数调用另一个函数，这个过程类似于消息发送。 函数都是通过拷贝来传递参数的，所以除了接收函数外没有实体可以操作数据。这对于避免共享数据的竞态来说是很有必要的。同样也使得函数的执行类似于原子操作。每个函数调用的执行独立于任何其他函数的调用。 一旦每个函数调用都可以独立的执行，它们就可以分散在不同的CPU上执行了。这也就意味着能够在多处理器上并行的执行使用函数式实现的算法。 Java7中的java.util.concurrent包里包含的ForkAndJoinPool能够帮助我们实现类似于函数式并行的一些东西。而Java8中并行streams能够用来帮助我们并行的迭代大型集合。记住有些开发者对ForkAndJoinPool进行了批判（你可以在我的ForkAndJoinPool教程里面看到批评的链接）。 函数式并行里面最难的是确定需要并行的那个函数调用。跨CPU协调函数调用需要一定的开销。某个函数完成的工作单元需要达到某个大小以弥补这个开销。如果函数调用作用非常小，将它并行化可能比单线程、单CPU执行还慢。 我个人认为（可能不太正确），你可以使用反应器或者事件驱动模型实现一个算法，像函数式并行那样的方法实现工作的分解。使用事件驱动模型可以更精确的控制如何实现并行化（我的观点）。 此外，将任务拆分给多个CPU时协调造成的开销，仅仅在该任务是程序当前执行的唯一任务时才有意义。但是，如果当前系统正在执行多个其他的任务时（比如web服务器，数据库服务器或者很多其他类似的系统），将单个任务进行并行化是没有意义的。不管怎样计算机中的其他CPU们都在忙于处理其他任务，没有理由用一个慢的、函数式并行的任务去扰乱它们。使用流水线（反应器）并发模型可能会更好一点，因为它开销更小（在单线程模式下顺序执行）同时能更好的与底层硬件整合。 使用那种并发模型最好？所以，用哪种并发模型更好呢? 通常情况下，这个答案取决于你的系统打算做什么。如果你的作业本身就是并行的、独立的并且没有必要共享状态，你可能会使用并行工作者模型去实现你的系统。虽然许多作业都不是自然并行和独立的。对于这种类型的系统，我相信使用流水线并发模型能够更好的发挥它的优势，而且比并行工作者模型更有优势。 你甚至不用亲自编写所有流水线模型的基础结构。像Vert.x这种现代化的平台已经为你实现了很多。我也会去为探索如何设计我的下一个项目，使它运行在像Vert.x这样的优秀平台上。我感觉Java EE已经没有任何优势了。 注：本文转载于并发编程网来源：Java并发性和多线程介绍","categories":[{"name":"并发编程","slug":"并发编程","permalink":"https://caoler.cn/categories/并发编程/"},{"name":"多线程","slug":"并发编程/多线程","permalink":"https://caoler.cn/categories/并发编程/多线程/"}],"tags":[{"name":"并发编程","slug":"并发编程","permalink":"https://caoler.cn/tags/并发编程/"},{"name":"转载","slug":"转载","permalink":"https://caoler.cn/tags/转载/"}]},{"title":"Java 8系列之重新认识HashMap","slug":"Java 8系列之重新认识HashMap","date":"2017-11-07T10:40:00.000Z","updated":"2017-11-27T12:44:58.868Z","comments":true,"path":"/post/2017/java-8-hashmap.html","link":"","permalink":"https://caoler.cn/post/2017/java-8-hashmap.html","excerpt":"摘要HashMap是Java程序员使用频率最高的用于映射(键值对)处理的数据类型。随着JDK（Java Developmet Kit）版本的更新，JDK1.8对HashMap底层的实现进行了优化，例如引入红黑树的数据结构和扩容的优化等。本文结合JDK1.7和JDK1.8的区别，深入探讨HashMap的结构实现和功能原理。 简介Java为数据结构中的映射定义了一个接口java.util.Map，此接口主要有四个常用的实现类，分别是HashMap、Hashtable、LinkedHashMap和TreeMap，类继承关系如下图所示：","text":"摘要HashMap是Java程序员使用频率最高的用于映射(键值对)处理的数据类型。随着JDK（Java Developmet Kit）版本的更新，JDK1.8对HashMap底层的实现进行了优化，例如引入红黑树的数据结构和扩容的优化等。本文结合JDK1.7和JDK1.8的区别，深入探讨HashMap的结构实现和功能原理。 简介Java为数据结构中的映射定义了一个接口java.util.Map，此接口主要有四个常用的实现类，分别是HashMap、Hashtable、LinkedHashMap和TreeMap，类继承关系如下图所示： 下面针对各个实现类的特点做一些说明： (1) HashMap：它根据键的hashCode值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。 HashMap最多只允许一条记录的键为null，允许多条记录的值为null。 HashMap 非线程安全，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用 Collections的synchronizedMap方法使HashMap具有线程安全的能力，或者使用ConcurrentHashMap。 (2) Hashtable：Hashtable是遗留类，很多映射的常用功能与HashMap类似，不同的是它承自Dictionary类，并且是线程安全的，任一时间只有一个线程能写Hashtable，并发性不如ConcurrentHashMap，因为ConcurrentHashMap引入了分段锁。Hashtable不建议在新代码中使用，不需要线程安全的场合可以用HashMap替换，需要线程安全的场合可以用ConcurrentHashMap替换。 (3) LinkedHashMap：LinkedHashMap是HashMap的一个子类，保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。 (4) TreeMap：TreeMap实现SortedMap接口，能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。如果使用排序的映射，建议使用TreeMap。在使用TreeMap时，key必须实现Comparable接口或者在构造TreeMap传入自定义的Comparator，否则会在运行时抛出java.lang.ClassCastException类型的异常。 对于上述四种Map类型的类，要求映射中的key是不可变对象。不可变对象是该对象在创建后它的哈希值不会被改变。如果对象的哈希值发生变化，Map对象很可能就定位不到映射的位置了。 通过上面的比较，我们知道了HashMap是Java的Map家族中一个普通成员，鉴于它可以满足大多数场景的使用条件，所以是使用频度最高的一个。下文我们主要结合源码，从存储结构、常用方法分析、扩容以及安全性等方面深入讲解HashMap的工作原理。 内部实现搞清楚HashMap，首先需要知道HashMap是什么，即它的存储结构-字段；其次弄明白它能干什么，即它的功能实现-方法。下面我们针对这两个方面详细展开讲解。 一、存储结构-字段从结构实现来讲，HashMap是数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的，如下如所示。 这里需要讲明白两个问题：数据底层具体存储的是什么？这样的存储方式有什么优点呢？ (1) 从源码可知，HashMap类中有一个非常重要的字段，就是 Node[] table，即哈希桶数组，明显它是一个Node的数组。我们来看Node[JDK1.8]是何物。 1234567891011121314static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; //用来定位数组索引位置 final K key; V value; Node&lt;K,V&gt; next; //链表的下一个node Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; ... &#125; public final K getKey()&#123; ... &#125; public final V getValue() &#123; ... &#125; public final String toString() &#123; ... &#125; public final int hashCode() &#123; ... &#125; public final V setValue(V newValue) &#123; ... &#125; public final boolean equals(Object o) &#123; ... &#125;&#125; Node是HashMap的一个内部类，实现了Map.Entry接口，本质是就是一个映射(键值对)。上图中的每个黑色圆点就是一个Node对象。 (2) HashMap就是使用哈希表来存储的。哈希表为解决冲突，可以采用开放地址法和链地址法等来解决问题，Java中HashMap采用了链地址法。链地址法，简单来说，就是数组加链表的结合。在每个数组元素上都一个链表结构，当数据被Hash后，得到数组下标，把数据放在对应下标元素的链表上。例如程序执行下面代码： map.put(“美团”,”小美”); 系统将调用”美团”这个key的hashCode()方法得到其hashCode 值（该方法适用于每个Java对象），然后再通过Hash算法的后两步运算（高位运算和取模运算，下文有介绍）来定位该键值对的存储位置，有时两个key会定位到相同的位置，表示发生了Hash碰撞。当然Hash算法计算结果越分散均匀，Hash碰撞的概率就越小，map的存取效率就会越高。 如果哈希桶数组很大，即使较差的Hash算法也会比较分散，如果哈希桶数组数组很小，即使好的Hash算法也会出现较多碰撞，所以就需要在空间成本和时间成本之间权衡，其实就是在根据实际情况确定哈希桶数组的大小，并在此基础上设计好的hash算法减少Hash碰撞。那么通过什么方式来控制map使得Hash碰撞的概率又小，哈希桶数组（Node[] table）占用空间又少呢？答案就是好的Hash算法和扩容机制。 在理解Hash和扩容流程之前，我们得先了解下HashMap的几个字段。从HashMap的默认构造函数源码可知，构造函数就是对下面几个字段进行初始化，源码如下： int threshold; // 所能容纳的key-value对极限 final float loadFactor; // 负载因子 int modCount; int size; 首先，Node[] table的初始化长度length(默认值是16)，Load factor为负载因子(默认值是0.75)，threshold是HashMap所能容纳的最大数据量的Node(键值对)个数。threshold = length * Load factor。也就是说，在数组定义好长度之后，负载因子越大，所能容纳的键值对个数越多。 结合负载因子的定义公式可知，threshold就是在此Load factor和length(数组长度)对应下允许的最大元素数目，超过这个数目就重新resize(扩容)，扩容后的HashMap容量是之前容量的两倍。默认的负载因子0.75是对空间和时间效率的一个平衡选择，建议大家不要修改，除非在时间和空间比较特殊的情况下，如果内存空间很多而又对时间效率要求很高，可以降低负载因子Load factor的值；相反，如果内存空间紧张而对时间效率要求不高，可以增加负载因子loadFactor的值，这个值可以大于1。 size这个字段其实很好理解，就是HashMap中实际存在的键值对数量。注意和table的长度length、容纳最大键值对数量threshold的区别。而modCount字段主要用来记录HashMap内部结构发生变化的次数，主要用于迭代的快速失败。强调一点，内部结构发生变化指的是结构发生变化，例如put新键值对，但是某个key对应的value值被覆盖不属于结构变化。 在HashMap中，哈希桶数组table的长度length大小必须为2的n次方(一定是合数)，这是一种非常规的设计，常规的设计是把桶的大小设计为素数。相对来说素数导致冲突的概率要小于合数，具体证明可以参考http://blog.csdn.net/liuqiyao_01/…/，Hashtable初始化桶大小为11，就是桶大小设计为素数的应用（Hashtable扩容后不能保证还是素数）。HashMap采用这种非常规设计，主要是为了在取模和扩容时做优化，同时为了减少冲突，HashMap定位哈希桶索引位置时，也加入了高位参与运算的过程。 这里存在一个问题，即使负载因子和Hash算法设计的再合理，也免不了会出现拉链过长的情况，一旦出现拉链过长，则会严重影响HashMap的性能。于是，在JDK1.8版本中，对数据结构做了进一步的优化，引入了红黑树。而当链表长度太长（默认超过8）时，链表就转换为红黑树，利用红黑树快速增删改查的特点提高HashMap的性能，其中会用到红黑树的插入、删除、查找等算法。本文不再对红黑树展开讨论，想了解更多红黑树数据结构的工作原理可以参考。http://blog.csdn.net/v_july_v/…/ 二、功能实现-方法HashMap的内部功能实现很多，本文主要从根据key获取哈希桶数组索引位置、put方法的详细执行、扩容过程三个具有代表性的点深入展开讲解。 1. 确定哈希桶数组索引位置不管增加、删除、查找键值对，定位到哈希桶数组的位置都是很关键的第一步。前面说过HashMap的数据结构是数组和链表的结合，所以我们当然希望这个HashMap里面的元素位置尽量分布均匀些，尽量使得每个位置上的元素数量只有一个，那么当我们用hash算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，不用遍历链表，大大优化了查询的效率。HashMap定位数组索引位置，直接决定了hash方法的离散性能。先看看源码的实现(方法一+方法二): 方法一： 123456static final int hash(Object key) &#123; //jdk1.8 &amp; jdk1.7 int h; // h = key.hashCode() 为第一步 取hashCode值 // h ^ (h &gt;&gt;&gt; 16) 为第二步 高位参与运算 return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125; 方法二： 123static int indexFor(int h, int length) &#123; //jdk1.7的源码，jdk1.8没有这个方法，但是实现原理一样的 return h &amp; (length-1); //第三步 取模运算&#125; 这里的Hash算法本质上就是三步：取key的hashCode值、高位运算、取模运算。 对于任意给定的对象，只要它的hashCode()返回值相同，那么程序调用方法一所计算得到的Hash码值总是相同的。我们首先想到的就是把hash值对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，模运算的消耗还是比较大的，在HashMap中是这样做的：调用方法二来计算该对象应该保存在table数组的哪个索引处。 这个方法非常巧妙，它通过h &amp; (table.length -1)来得到该对象的保存位，而HashMap底层数组的长度总是2的n次方，这是HashMap在速度上的优化。当length总是2的n次方时，h&amp; (length-1)运算等价于对length取模，也就是h%length，但是&amp;比%具有更高的效率。 在JDK1.8的实现中，优化了高位运算的算法，通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的，这么做可以在数组table的length比较小的时候，也能保证考虑到高低Bit都参与到Hash的计算中，同时不会有太大的开销。 下面举例说明下，n为table的长度。 2. 分析HashMap的put方法HashMap的put方法执行过程可以通过下图来理解，自己有兴趣可以去对比源码更清楚地研究学习。 判断键值对数组table[i]是否为空或为null，否则执行resize()进行扩容； 根据键值key计算hash值得到插入的数组索引i，如果table[i]==null，直接新建节点添加，转向⑥，如果table[i]不为空，转向③； 判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，否则转向④，这里的相同指的是hashCode以及equals； 判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向⑤； 遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可； 插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩容。 JDK1.8HashMap的put方法源码如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true);&#125;final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else &#123; Node&lt;K,V&gt; e; K k; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else &#123; for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null;&#125; 3. 扩容机制扩容(resize)就是重新计算容量，向HashMap对象里不停的添加元素，而HashMap对象内部的数组无法装载更多的元素时，对象就需要扩大数组的长度，以便能装入更多的元素。当然Java里的数组是无法自动扩容的，方法是使用一个新的数组代替已有的容量小的数组，就像我们用一个小桶装水，如果想装更多的水，就得换大水桶。 我们分析下resize的源码，鉴于JDK1.8融入了红黑树，较复杂，为了便于理解我们仍然使用JDK1.7的代码，好理解一些，本质上区别不大，具体区别后文再说。 12345678910111213void resize(int newCapacity) &#123; //传入新的容量 Entry[] oldTable = table; //引用扩容前的Entry数组 int oldCapacity = oldTable.length; if (oldCapacity == MAXIMUM_CAPACITY) &#123; //扩容前的数组大小如果已经达到最大(2^30)了 threshold = Integer.MAX_VALUE; //修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了 return; &#125; Entry[] newTable = new Entry[newCapacity]; //初始化一个新的Entry数组 transfer(newTable); //！！将数据转移到新的Entry数组里 table = newTable; //HashMap的table属性引用新的Entry数组 threshold = (int)(newCapacity * loadFactor);//修改阈值 &#125; 这里就是使用一个容量更大的数组来代替已有的容量小的数组，transfer()方法将原有Entry数组的元素拷贝到新的Entry数组里。1234567891011121314151617void transfer(Entry[] newTable) &#123; Entry[] src = table; //src引用了旧的Entry数组 int newCapacity = newTable.length; for (int j = 0; j &lt; src.length; j++) &#123; //遍历旧的Entry数组 Entry&lt;K,V&gt; e = src[j]; //取得旧Entry数组的每个元素 if (e != null) &#123; src[j] = null;//释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象） do &#123; Entry&lt;K,V&gt; next = e.next; int i = indexFor(e.hash, newCapacity); //！！重新计算每个元素在数组中的位置 e.next = newTable[i]; //标记[1] newTable[i] = e; //将元素放在数组上 e = next; //访问下一个Entry链上的元素 &#125; while (e != null); &#125; &#125;&#125; newTable[i]的引用赋给了e.next，也就是使用了单链表的头插入方式，同一位置上新元素总会被放在链表的头部位置；这样先放在一个索引上的元素终会被放到Entry链的尾部(如果发生了hash冲突的话），这一点和Jdk1.8有区别，下文详解。在旧数组中同一条Entry链上的元素，通过重新计算索引位置后，有可能被放到了新数组的不同位置上。 下面举个例子说明下扩容过程。假设了我们的hash算法就是简单的用key mod 一下表的大小（也就是数组的长度）。其中的哈希桶数组table的size=2， 所以key = 3、7、5，put顺序依次为 5、7、3。在mod 2以后都冲突在table[1]这里了。这里假设负载因子 loadFactor=1，即当键值对的实际大小size 大于 table的实际大小时进行扩容。接下来的三个步骤是哈希桶数组 resize成4，然后所有的Node重新rehash的过程。下面我们讲解下JDK1.8做了哪些优化。经过观测可以发现，我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。看下图可以明白这句话的意思，n为table的长度，图（a）表示扩容前的key1和key2两种key确定索引位置的示例，图（b）表示扩容后key1和key2两种key确定索引位置的示例，其中hash1是key1对应的哈希与高位运算结果。元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化：因此，我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”，可以看看下图为16扩充为32的resize示意图：这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。这一块就是JDK1.8新增的优化点。有一点注意区别，JDK1.7中rehash的时候，旧链表迁移新链表的时候，如果在新表的数组索引位置相同，则链表元素会倒置，但是从上图可以看出，JDK1.8不会倒置。有兴趣的同学可以研究下JDK1.8的resize源码，写的很赞，如下: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) &#123; if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold &#125; else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; else &#123; // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; @SuppressWarnings(&#123;\"rawtypes\",\"unchecked\"&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; if (oldTab != null) &#123; for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; // preserve order Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab;&#125; 线程安全性在多线程使用场景中，应该尽量避免使用线程不安全的HashMap，而使用线程安全的ConcurrentHashMap。那么为什么说HashMap是线程不安全的，下面举例子说明在并发的多线程使用场景中使用HashMap可能造成死循环。代码例子如下(便于理解，仍然使用JDK1.7的环境)： 1234567891011121314151617181920public class HashMapInfiniteLoop &#123; private static HashMap&lt;Integer,String&gt; map = new HashMap&lt;Integer,String&gt;(2，0.75f); public static void main(String[] args) &#123; map.put(5， \"C\"); new Thread(\"Thread1\") &#123; public void run() &#123; map.put(7, \"B\"); System.out.println(map); &#125;; &#125;.start(); new Thread(\"Thread2\") &#123; public void run() &#123; map.put(3, \"A); System.out.println(map); &#125;; &#125;.start(); &#125; &#125; 其中，map初始化为一个长度为2的数组，loadFactor=0.75，threshold=2*0.75=1，也就是说当put第二个key的时候，map就需要进行resize。 通过设置断点让线程1和线程2同时debug到transfer方法(3.3小节代码块)的首行。注意此时两个线程已经成功添加数据。放开thread1的断点至transfer方法的“Entry next = e.next;” 这一行；然后放开线程2的的断点，让线程2进行resize。结果如下图。注意，Thread1的 e 指向了key(3)，而next指向了key(7)，其在线程二rehash后，指向了线程二重组后的链表。 线程一被调度回来执行，先是执行 newTalbe[i] = e， 然后是e = next，导致了e指向了key(7)，而下一次循环的next = e.next导致了next指向了key(3)。e.next = newTable[i] 导致 key(3).next 指向了 key(7)。注意：此时的key(7).next 已经指向了key(3)， 环形链表就这样出现了。于是，当我们用线程一调用map.get(11)时，悲剧就出现了——Infinite Loop。 JDK1.8与JDK1.7的性能对比HashMap中，如果key经过hash算法得出的数组索引位置全部不相同，即Hash算法非常好，那样的话，getKey方法的时间复杂度就是O(1)，如果Hash算法技术的结果碰撞非常多，假如Hash算极其差，所有的Hash算法结果得出的索引位置一样，那样所有的键值对都集中到一个桶中，或者在一个链表中，或者在一个红黑树中，时间复杂度分别为O(n)和O(lgn)。 鉴于JDK1.8做了多方面的优化，总体性能优于JDK1.7，下面我们从两个方面用例子证明这一点。 Hash较均匀的情况为了便于测试，我们先写一个类Key，如下： 123456789101112131415161718192021222324252627class Key implements Comparable&lt;Key&gt; &#123; private final int value; Key(int value) &#123; this.value = value; &#125; @Override public int compareTo(Key o) &#123; return Integer.compare(this.value, o.value); &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Key key = (Key) o; return value == key.value; &#125; @Override public int hashCode() &#123; return value; &#125;&#125; 这个类复写了equals方法，并且提供了相当好的hashCode函数，任何一个值的hashCode都不会相同，因为直接使用value当做hashcode。为了避免频繁的GC，我将不变的Key实例缓存了起来，而不是一遍一遍的创建它们。代码如下：123456789101112131415public class Keys &#123; public static final int MAX_KEY = 10_000_000; private static final Key[] KEYS_CACHE = new Key[MAX_KEY]; static &#123; for (int i = 0; i &lt; MAX_KEY; ++i) &#123; KEYS_CACHE[i] = new Key(i); &#125; &#125; public static Key of(int value) &#123; return KEYS_CACHE[value]; &#125;&#125; 现在开始我们的试验，测试需要做的仅仅是，创建不同size的HashMap（1、10、100、……10000000），屏蔽了扩容的情况，代码如下：1234567891011121314151617181920static void test(int mapSize) &#123; HashMap&lt;Key, Integer&gt; map = new HashMap&lt;Key,Integer&gt;(mapSize); for (int i = 0; i &lt; mapSize; ++i) &#123; map.put(Keys.of(i), i); &#125; long beginTime = System.nanoTime(); //获取纳秒 for (int i = 0; i &lt; mapSize; i++) &#123; map.get(Keys.of(i)); &#125; long endTime = System.nanoTime(); System.out.println(endTime - beginTime);&#125;public static void main(String[] args) &#123; for(int i=10;i&lt;= 1000 0000;i*= 10)&#123; test(i); &#125;&#125; 在测试中会查找不同的值，然后度量花费的时间，为了计算getKey的平均时间，我们遍历所有的get方法，计算总的时间，除以key的数量，计算一个平均值，主要用来比较，绝对值可能会受很多环境因素的影响。结果如下：通过观测测试结果可知，JDK1.8的性能要高于JDK1.7 15%以上，在某些size的区域上，甚至高于100%。由于Hash算法较均匀，JDK1.8引入的红黑树效果不明显，下面我们看看Hash不均匀的的情况。 Hash极不均匀的情况假设我们又一个非常差的Key，它们所有的实例都返回相同的hashCode值。这是使用HashMap最坏的情况。代码修改如下：123456789class Key implements Comparable&lt;Key&gt; &#123; //... @Override public int hashCode() &#123; return 1; &#125;&#125; 仍然执行main方法，得出的结果如下表所示：从表中结果中可知，随着size的变大，JDK1.7的花费时间是增长的趋势，而JDK1.8是明显的降低趋势，并且呈现对数增长稳定。当一个链表太长的时候，HashMap会动态的将它替换成一个红黑树，这话的话会将时间复杂度从O(n)降为O(logn)。hash算法均匀和不均匀所花费的时间明显也不相同，这两种情况的相对比较，可以说明一个好的hash算法的重要性。 测试环境：处理器为2.2 GHz Intel Core i7，内存为16 GB 1600 MHz DDR3，SSD硬盘，使用默认的JVM参数，运行在64位的OS X 10.10.1上。 小结(1) 扩容是一个特别耗性能的操作，所以当程序员在使用HashMap的时候，估算map的大小，初始化的时候给一个大致的数值，避免map进行频繁的扩容。 (2) 负载因子是可以修改的，也可以大于1，但是建议不要轻易修改，除非情况非常特殊。 (3) HashMap是线程不安全的，不要在并发的环境中同时操作HashMap，建议使用ConcurrentHashMap。 (4) JDK1.8引入红黑树大程度优化了HashMap的性能。 (5) 还没升级JDK1.8的，现在开始升级吧。HashMap的性能提升仅仅是JDK1.8的冰山一角。 参考 JDK1.7&amp;JDK1.8 源码。 CSDN博客频道，HashMap多线程死循环问题，2014。 红黑联盟，Java类集框架之HashMap(JDK1.8)源码剖析，2015。 CSDN博客频道， 教你初步了解红黑树，2010。 Java Code Geeks，HashMap performance improvements in Java 8，2014。 Importnew，危险！在HashMap中将可变对象用作Key，2014。 CSDN博客频道，为什么一般hashtable的桶数会取一个素数，2013。 注：本文转载于美团点评技术团队 知乎：https://zhuanlan.zhihu.com/p/21673805 源: https://tech.meituan.com/java-hashmap.html","categories":[{"name":"JAVASE","slug":"JAVASE","permalink":"https://caoler.cn/categories/JAVASE/"},{"name":"集合框架","slug":"JAVASE/集合框架","permalink":"https://caoler.cn/categories/JAVASE/集合框架/"}],"tags":[{"name":"转载","slug":"转载","permalink":"https://caoler.cn/tags/转载/"},{"name":"HashMap","slug":"HashMap","permalink":"https://caoler.cn/tags/HashMap/"}]},{"title":"442. Find All Duplicates in an Array","slug":"442. Find All Duplicates in an Array","date":"2017-11-06T11:57:00.000Z","updated":"2017-11-27T12:46:03.350Z","comments":true,"path":"/post/2017/Find-All-Duplicates-in-an-Array.html","link":"","permalink":"https://caoler.cn/post/2017/Find-All-Duplicates-in-an-Array.html","excerpt":"Given an array of integers, 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once. Find all the elements that appear twice in this array. Could you do it without extra space and in O(n) runtime?12345Example:Input:[4,3,2,7,8,2,3,1]Output:[2,3]","text":"Given an array of integers, 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once. Find all the elements that appear twice in this array. Could you do it without extra space and in O(n) runtime?12345Example:Input:[4,3,2,7,8,2,3,1]Output:[2,3] 题目大意：给定一个整数数组，1 &lt;= a[i] &lt;= n (n = 数组长度)，某些元素出现两次，某些出现一次。寻找数组中所有出现两次的元素。你可以不使用额外空间并且在O(n)运行时间内完成题目吗？ 思路：解法一（自己的想法）：首先对数组进行排列，例如[4,3,3,2,1] 排列后变为[1,2,3,3,4]，遍历nums，当nums[i] - nums[i + 1] == 0时，也就是当前数字等于下一个数字，再将当前数字存入数组中。 代码： 1234567891011public static List&lt;Integer&gt; findDuplicates1(int[] nums) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); Arrays.sort(nums); for (int i = 0; i &lt; nums.length - 1; i++) &#123; if (nums[i] - nums[ i+1 ] == 0)&#123; res.add(nums[i]); i++; &#125; &#125; return res;&#125; 解法二：正负号标记法（一趟遍历） 遍历nums，记当前数字为n（取绝对值），将数字n视为下标（因为a[i]∈[1, n]） 当n首次出现时，nums[n - 1]-1 当n再次出现时，则nums[n - 1]一定＜0，将n加入答案 参考：https://discuss.leetcode.com/topic/64735/java-simple-solution代码： 123456789101112131415public class Solution &#123; // when find a number i, flip the number at position i-1 to negative. // if the number at position i-1 is already negative, i is the number that occurs twice. public List&lt;Integer&gt; findDuplicates(int[] nums) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; nums.length; ++i) &#123; int index = Math.abs(nums[i])-1; if (nums[index] &lt; 0) res.add(Math.abs(index+1)); nums[index] = -nums[index]; &#125; return res; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://caoler.cn/categories/leetcode/"},{"name":"Array","slug":"leetcode/Array","permalink":"https://caoler.cn/categories/leetcode/Array/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://caoler.cn/tags/leetcode/"}]},{"title":"561. Array Partition I","slug":"561. Array Partition I","date":"2017-11-06T11:56:00.000Z","updated":"2017-11-27T12:45:40.699Z","comments":true,"path":"/post/2017/Array-Partition-I.html","link":"","permalink":"https://caoler.cn/post/2017/Array-Partition-I.html","excerpt":"Given an array of 2n integers, your task is to group these integers into n pairs of integer, say (a1, b1), (a2, b2), …, (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible. Example 1: 123Input: [1,4,3,2]Output: 4Explanation: n is 2, and the maximum sum of pairs is 4 = min(1, 2) + min(3, 4).","text":"Given an array of 2n integers, your task is to group these integers into n pairs of integer, say (a1, b1), (a2, b2), …, (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible. Example 1: 123Input: [1,4,3,2]Output: 4Explanation: n is 2, and the maximum sum of pairs is 4 = min(1, 2) + min(3, 4). Note: n is a positive integer, which is in the range of [1, 10000]. All the integers in the array will be in the range of [-10000, 10000]. 题目大意： 给定一个长度为2n(偶数)的数组，分成n个小组，返回每组中较小值的和sum，使sum尽量大 思路：先将数组从大到小进行排列，将相邻两个数分为一组，每组较小数都在左边，求和即可。 代码如下： 1234567891011121314151617181920212223package cn.caoler.Array.No561;import java.util.Arrays;/** * Author: Caole * CreateDateTime: 2017/10/11 15:46 * Description: */public class main &#123; public static int arrayPairSum(int[] nums) &#123; Arrays.sort(nums); int sum = 0; for (int i = 0; i &lt; nums.length; i += 2) &#123; sum += nums[i]; &#125; return sum; &#125; public static void main(String[] args) &#123; int[] num = &#123;1,2,3,4,5,6,7,8&#125;; System.out.println(arrayPairSum(num)); &#125;&#125; 其中使用了Arrays.sort()函数，其功能参照API文档如下： 1static void sort(byte[] a) 按照数字顺序排列指定的数组。 且 for循环时直接使用 i += 2 提升效率。","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://caoler.cn/categories/leetcode/"},{"name":"Array","slug":"leetcode/Array","permalink":"https://caoler.cn/categories/leetcode/Array/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://caoler.cn/tags/leetcode/"}]},{"title":"JAVA迭代器（Interator）详解","slug":"JAVA迭代器（Interator）详解","date":"2017-11-04T03:40:12.000Z","updated":"2017-11-27T12:44:08.332Z","comments":true,"path":"/post/2017/java-interator.html","link":"","permalink":"https://caoler.cn/post/2017/java-interator.html","excerpt":"一、迭代器概述1、什么是迭代器？在Java中，有很多的数据容器，对于这些的操作有很多的共性。Java采用了迭代器来为各种容器提供了公共的操作接口。这样使得对容器的遍历操作与其具体的底层实现相隔离，达到解耦的效果。 在Iterator接口中定义了四个方法： 方法 功能 default void forEachRemaining(Consumer&lt;? super E&gt; action) 对每个剩余元素执行给定的操作，直到所有元素都被处理或动作引发异常。 boolean hasNext() 如果迭代具有更多元素，则返回 true 。 E next() 返回迭代中的下一个元素。 default void remove() 从底层集合中删除此迭代器返回的最后一个元素（可选操作）。","text":"一、迭代器概述1、什么是迭代器？在Java中，有很多的数据容器，对于这些的操作有很多的共性。Java采用了迭代器来为各种容器提供了公共的操作接口。这样使得对容器的遍历操作与其具体的底层实现相隔离，达到解耦的效果。 在Iterator接口中定义了四个方法： 方法 功能 default void forEachRemaining(Consumer&lt;? super E&gt; action) 对每个剩余元素执行给定的操作，直到所有元素都被处理或动作引发异常。 boolean hasNext() 如果迭代具有更多元素，则返回 true 。 E next() 返回迭代中的下一个元素。 default void remove() 从底层集合中删除此迭代器返回的最后一个元素（可选操作）。 2、迭代器使用12345678910111213public void testIterator() &#123; Collection collection = new ArrayList(); collection.add(123); collection.add(\"AA\"); collection.add(new Date()); collection.add(\"BB\"); collection.add(new Employee(\"Caole\",23)); Iterator iterator = collection.iterator(); while (iterator.hasNext())&#123; System.out.println(iterator.next()); &#125;&#125; 执行结果： 12345123AAWed Nov 01 17:53:43 CST 2017BBEmployee&#123;id=598, name='Caole', salary=23.0&#125; 二、ArrayList的Iterator实现前段代码的输出结果不用多说，这里的iterator更像是“游标”，不过这游标具体做了啥，我们还得通过list.iterator()好好看看。通过源码了解到该方法产生了一个实现Iterator接口的对象。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364private class Itr implements Iterator&lt;E&gt; &#123; int cursor; // index of next element to return int lastRet = -1; // index of last element returned; -1 if no such int expectedModCount = modCount; public boolean hasNext() &#123; return cursor != size; &#125; @SuppressWarnings(\"unchecked\") public E next() &#123; checkForComodification(); int i = cursor; if (i &gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i]; &#125; public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; ArrayList.this.remove(lastRet); cursor = lastRet; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; @Override @SuppressWarnings(\"unchecked\") public void forEachRemaining(Consumer&lt;? super E&gt; consumer) &#123; Objects.requireNonNull(consumer); final int size = ArrayList.this.size; int i = cursor; if (i &gt;= size) &#123; return; &#125; final Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) &#123; throw new ConcurrentModificationException(); &#125; while (i != size &amp;&amp; modCount == expectedModCount) &#123; consumer.accept((E) elementData[i++]); &#125; // update once at end of iteration to reduce heap write traffic cursor = i; lastRet = i - 1; checkForComodification(); &#125; final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125;&#125; 其中： 123456private class Itr implements Iterator&lt;E&gt; &#123; int cursor; // index of next element to return int lastRet = -1; // index of last element returned; -1 if no such int expectedModCount = modCount; ...&#125; 在ArrayList内部定义了一个内部类Itr，该类实现了Iterator接口。 在Itr中，有三个变量分别是 cursor：表示下一个元素的索引位置 lastRet：表示上一个元素的索引位置 expectModCount：预期被修改的次数 下面看一下Itr类实现了Iterator接口的三个方法： 123public boolean hasNext() &#123; return cursor != size;//当cursor不等于size时，表示仍有索引元素&#125; 1234567891011public E next() //返回下一个元素&#123; checkForComodification(); int i = cursor; if (i &gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i];&#125; 在next()方法中有一个checkForComodification()方法，其实现为： 1234final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException();&#125; 可以看到，该函数是用来判断集合的修改次数是否合法。 在集合内部维护一个字段modCount用于记录集合被修改的次数，每当集合内部结构发生变化(add,remove，set)时，modCount+1。 在迭代器内部也维护一个字段expectedModCount，同样记录当前集合修改的次数，初始化为集合的modCount值。当我们在调用Iterator进行遍历操作时，如果有其他线程修改list会出现modCount!=expectedModCount的情况，就会报并发修改异常java.util.ConcurrentModificationException。下面为示例代码： 12345678910111213141516171819public static void main(String[] args)&#123; ArrayList&lt;String&gt; aList=new ArrayList&lt;String&gt;(); aList.add(\"bbc\"); aList.add(\"abc\"); aList.add(\"ysc\"); aList.add(\"saa\"); System.out.println(\"移除前：\"+aList); Iterator&lt;String&gt; it=aList.iterator(); while(it.hasNext()) &#123; if(\"abc\".equals(it.next())) &#123; aList.remove(\"abc\"); &#125; &#125; System.out.println(\"移除后：\"+aList);&#125; 12345移除前：[bbc, abc, ysc, saa]java.util.ConcurrentModificationException at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:901) at java.util.ArrayList$Itr.next(ArrayList.java:851) 上面的代码中，如果我们只使用迭代器来进行删除，则不会出现并发修改异常错误。12345678910111213141516171819public static void main(String[] args)&#123; ArrayList&lt;String&gt; aList=new ArrayList&lt;String&gt;(); aList.add(\"bbc\"); aList.add(\"abc\"); aList.add(\"ysc\"); aList.add(\"saa\"); System.out.println(\"移除前：\"+aList); Iterator&lt;String&gt; it=aList.iterator(); while(it.hasNext()) &#123; if(\"abc\".equals(it.next())) &#123; it.remove(); &#125; &#125; System.out.println(\"移除后：\"+aList);&#125; 12移除前：[bbc, abc, ysc, saa]移除后：[bbc, ysc, saa] 1234567891011121314public void remove()&#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; ArrayList.this.remove(lastRet); cursor = lastRet; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125;&#125; 在执行remove操作时，同样先执行checkForComodification()，然后会执行ArrayList的remove()方法，该方法会将modCount值加1，这里我们将expectedModCount=modCount，使之保持统一。 三、ListIterator上面可以看到，Iterator只提供了删除元素的方法remove，如果我们想要在遍历的时候添加元素怎么办？ ListIterator接口继承了Iterator接口，它允许程序员按照任一方向遍历列表，迭代期间修改列表，并获得迭代器在列表中的当前位置。 ListIterator接口定义了下面几个方法： 方法 说明 void add(E e) 将指定的元素插入列表（可选操作）。 boolean hasNext() 返回 true如果遍历正向列表，列表迭代器有多个元素。 boolean hasPrevious() 返回 true如果遍历反向列表，列表迭代器有多个元素。 E next() 返回列表中的下一个元素，并且前进光标位置。 int nextIndex() 返回随后调用 next()返回的元素的索引。 E previous() 返回列表中的上一个元素，并向后移动光标位置。 int previousIndex() 返回由后续调用 previous()返回的元素的索引。 void remove() 从列表中删除由 next()或 previous()返回的最后一个元素（可选操作）。 void set(E e) 用 指定的元素替换由 next()或 previous()返回的最后一个元素（可选操作）。 下面使用ListIterator来对list进行边遍历边添加元素操作：123456789101112131415161718public static void main(String[] args)&#123; ArrayList&lt;String&gt; aList = new ArrayList&lt;String&gt;(); aList.add(\"bbc\"); aList.add(\"abc\"); aList.add(\"ysc\"); aList.add(\"saa\"); System.out.println(\"移除前：\" + aList); ListIterator&lt;String&gt; listIt = aList.listIterator(); while (listIt.hasNext()) &#123; if (\"abc\".equals(listIt.next())) &#123; listIt.add(\"haha\"); &#125; &#125; System.out.println(\"移除后：\" + aList);&#125; 12移除前：[bbc, abc, ysc, saa]移除后：[bbc, abc, haha, ysc, saa]","categories":[{"name":"JAVASE","slug":"JAVASE","permalink":"https://caoler.cn/categories/JAVASE/"},{"name":"集合框架","slug":"JAVASE/集合框架","permalink":"https://caoler.cn/categories/JAVASE/集合框架/"}],"tags":[{"name":"迭代器","slug":"迭代器","permalink":"https://caoler.cn/tags/迭代器/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-11-03T05:33:33.000Z","updated":"2017-11-27T12:45:17.066Z","comments":true,"path":"/post/2017/Hello-World.html","link":"","permalink":"https://caoler.cn/post/2017/Hello-World.html","excerpt":"","text":"HelloWorld！","categories":[],"tags":[]}]}