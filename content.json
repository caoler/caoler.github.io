{"meta":{"title":"Caole's blog","subtitle":"Caole的个人博客","description":"个人博客","author":"Caole","url":"https://caoler.cn"},"pages":[{"title":"向我留言","date":"2017-11-14T08:42:22.701Z","updated":"2017-11-14T08:42:22.701Z","comments":true,"path":"about/index.html","permalink":"https://caoler.cn/about/index.html","excerpt":"","text":"邮箱：caoler.cn@Gmail.com"},{"title":"Categories","date":"2017-11-08T04:53:21.565Z","updated":"2017-11-08T04:53:21.565Z","comments":true,"path":"categories/index.html","permalink":"https://caoler.cn/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2017-11-08T04:53:21.566Z","updated":"2017-11-08T04:53:21.566Z","comments":true,"path":"tags/index.html","permalink":"https://caoler.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"多线程笔记 - 线程安全","slug":"线程安全","date":"2017-11-13T10:48:00.000Z","updated":"2017-11-13T10:56:46.747Z","comments":true,"path":"/blog/2017/线程安全.html","link":"","permalink":"https://caoler.cn/blog/2017/线程安全.html","excerpt":"竞态条件与临界区在同一程序中运行多个线程本身不会导致问题，问题在于多个线程访问了相同的资源。如，同一内存区（变量，数组，或对象）、系统（数据库，web services等）或文件。实际上，这些问题只有在一或多个线程向这些资源做了写操作时才有可能发生，只要资源没有发生变化,多个线程读取相同的资源就是安全的。 多线程同时执行下面的代码可能会出错：123456public class Counter &#123; protected long count = 0; public void add(long value)&#123; this.count = this.count + value; &#125;&#125;","text":"竞态条件与临界区在同一程序中运行多个线程本身不会导致问题，问题在于多个线程访问了相同的资源。如，同一内存区（变量，数组，或对象）、系统（数据库，web services等）或文件。实际上，这些问题只有在一或多个线程向这些资源做了写操作时才有可能发生，只要资源没有发生变化,多个线程读取相同的资源就是安全的。 多线程同时执行下面的代码可能会出错：123456public class Counter &#123; protected long count = 0; public void add(long value)&#123; this.count = this.count + value; &#125;&#125; 想象下线程A和B同时执行同一个Counter对象的add()方法，我们无法知道操作系统何时会在两个线程之间切换。JVM并不是将这段代码视为单条指令来执行的，而是按照下面的顺序： 从内存获取 this.count 的值放到寄存器将寄存器中的值增加value将寄存器中的值写回内存 观察线程A和B交错执行会发生什么： this.count = 0; A: 读取 this.count 到一个寄存器 (0) B: 读取 this.count 到一个寄存器 (0) B: 将寄存器的值加2 B: 回写寄存器值(2)到内存. this.count 现在等于 2 A: 将寄存器的值加3 A: 回写寄存器值(3)到内存. this.count 现在等于 3 两个线程分别加了2和3到count变量上，两个线程执行结束后count变量的值应该等于5。然而由于两个线程是交叉执行的，两个线程从内存中读出的初始值都是0。然后各自加了2和3，并分别写回内存。最终的值并不是期望的5，而是最后写回内存的那个线程的值，上面例子中最后写回内存的是线程A，但实际中也可能是线程B。如果没有采用合适的同步机制，线程间的交叉执行情况就无法预料。 竞态条件 &amp; 临界区当两个线程竞争同一资源时，如果对资源的访问顺序敏感，就称存在竞态条件。导致竞态条件发生的代码区称作临界区。上例中add()方法就是一个临界区,它会产生竞态条件。在临界区中使用适当的同步就可以避免竞态条件。 线程安全与共享资源允许被多个线程同时执行的代码称作线程安全的代码。线程安全的代码不包含竞态条件。当多个线程同时更新共享资源时会引发竞态条件。因此，了解Java线程执行时共享了什么资源很重要。 局部变量局部变量存储在线程自己的栈中。也就是说，局部变量永远也不会被多个线程共享。所以，基础类型的局部变量是线程安全的。下面是基础类型的局部变量的一个例子：123456public void someMethod()&#123; long threadSafeInt = 0; threadSafeInt++;&#125; 局部的对象引用对象的局部引用和基础类型的局部变量不太一样。尽管引用本身没有被共享，但引用所指的对象并没有存储在线程的栈内。所有的对象都存在共享堆中。如果在某个方法中创建的对象不会逃逸出（译者注：即该对象不会被其它方法获得，也不会被非局部变量引用到）该方法，那么它就是线程安全的。实际上，哪怕将这个对象作为参数传给其它方法，只要别的线程获取不到这个对象，那它仍是线程安全的。下面是一个线程安全的局部引用样例： 1234567891011public void someMethod()&#123; LocalObject localObject = new LocalObject(); localObject.callMethod(); method2(localObject);&#125;public void method2(LocalObject localObject)&#123; localObject.setValue(\"value\");&#125; 样例中LocalObject对象没有被方法返回，也没有被传递给someMethod()方法外的对象。每个执行someMethod()的线程都会创建自己的LocalObject对象，并赋值给localObject引用。因此，这里的LocalObject是线程安全的。事实上，整个someMethod()都是线程安全的。即使将LocalObject作为参数传给同一个类的其它方法或其它类的方法时，它仍然是线程安全的。当然，如果LocalObject通过某些方法被传给了别的线程，那它就不再是线程安全的了。 对象成员对象成员存储在堆上。如果两个线程同时更新同一个对象的同一个成员，那这个代码就不是线程安全的。下面是一个样例：1234567public class NotThreadSafe&#123; StringBuilder builder = new StringBuilder(); public add(String text)&#123; this.builder.append(text); &#125; &#125; 如果两个线程同时调用同一个NotThreadSafe实例上的add()方法，就会有竞态条件问题。例如：12345678910111213141516NotThreadSafe sharedInstance = new NotThreadSafe();new Thread(new MyRunnable(sharedInstance)).start();new Thread(new MyRunnable(sharedInstance)).start(); public class MyRunnable implements Runnable&#123; NotThreadSafe instance = null; public MyRunnable(NotThreadSafe instance)&#123; this.instance = instance; &#125; public void run()&#123; this.instance.add(\"some text\"); &#125;&#125; 注意两个MyRunnable共享了同一个NotThreadSafe对象。因此，当它们调用add()方法时会造成竞态条件。 当然，如果这两个线程在不同的NotThreadSafe实例上调用call()方法，就不会导致竞态条件。下面是稍微修改后的例子：12new Thread(new MyRunnable(new NotThreadSafe())).start();new Thread(new MyRunnable(new NotThreadSafe())).start(); 现在两个线程都有自己单独的NotThreadSafe对象，调用add()方法时就会互不干扰，再也不会有竞态条件问题了。所以非线程安全的对象仍可以通过某种方式来消除竞态条件。 线程控制逃逸规则线程控制逃逸规则可以帮助你判断代码中对某些资源的访问是否是线程安全的。 如果一个资源的创建，使用，销毁都在同一个线程内完成，且永远不会脱离该线程的控制，则该资源的使用就是线程安全的。 资源可以是对象，数组，文件，数据库连接，套接字等等。Java中你无需主动销毁对象，所以“销毁”指不再有引用指向对象。 即使对象本身线程安全，但如果该对象中包含其他资源（文件，数据库连接），整个应用也许就不再是线程安全的了。比如2个线程都创建了各自的数据库连接，每个连接自身是线程安全的，但它们所连接到的同一个数据库也许不是线程安全的。比如，2个线程执行如下代码： 检查记录X是否存在，如果不存在，插入X 如果两个线程同时执行，而且碰巧检查的是同一个记录，那么两个线程最终可能都插入了记录： 线程1检查记录X是否存在。检查结果：不存在线程2检查记录X是否存在。检查结果：不存在线程1插入记录X线程2插入记录X 同样的问题也会发生在文件或其他共享资源上。因此，区分某个线程控制的对象是资源本身，还是仅仅到某个资源的引用很重要。 线程安全及不可变性当多个线程同时访问同一个资源，并且其中的一个或者多个线程对这个资源进行了写操作，才会产生竞态条件。多个线程同时读同一个资源不会产生竞态条件。 我们可以通过创建不可变的共享对象来保证对象在线程间共享时不会被修改，从而实现线程安全。如下示例： 1234567891011public class ImmutableValue&#123; private int value = 0; public ImmutableValue(int value)&#123; this.value = value; &#125; public int getValue()&#123; return this.value; &#125;&#125; 请注意ImmutableValue类的成员变量value是通过构造函数赋值的，并且在类中没有set方法。这意味着一旦ImmutableValue实例被创建，value变量就不能再被修改，这就是不可变性。但你可以通过getValue()方法读取这个变量的值。 （译者注：注意，“不变”（Immutable）和“只读”（Read Only）是不同的。当一个变量是“只读”时，变量的值不能直接改变，但是可以在其它变量发生改变的时候发生改变。比如，一个人的出生年月日是“不变”属性，而一个人的年龄便是“只读”属性，但是不是“不变”属性。随着时间的变化，一个人的年龄会随之发生变化，而一个人的出生年月日则不会变化。这就是“不变”和“只读”的区别。（摘自《Java与模式》第34章）） 如果你需要对ImmutableValue类的实例进行操作，可以通过得到value变量后创建一个新的实例来实现，下面是一个对value变量进行加法操作的示例： 123456789101112131415public class ImmutableValue&#123; private int value = 0; public ImmutableValue(int value)&#123; this.value = value; &#125; public int getValue()&#123; return this.value; &#125; public ImmutableValue add(int valueToAdd)&#123; return new ImmutableValue(this.value + valueToAdd); &#125;&#125; 请注意add()方法以加法操作的结果作为一个新的ImmutableValue类实例返回，而不是直接对它自己的value变量进行操作。 引用不是线程安全的！ 重要的是要记住，即使一个对象是线程安全的不可变对象，指向这个对象的引用也可能不是线程安全的。看这个例子：12345678910111213141516public void Calculator&#123; private ImmutableValue currentValue = null; public ImmutableValue getValue()&#123; return currentValue; &#125; public void setValue(ImmutableValue newValue)&#123; this.currentValue = newValue; &#125; public void add(int newValue)&#123; this.currentValue = this.currentValue.add(newValue); &#125;&#125; Calculator类持有一个指向ImmutableValue实例的引用。注意，通过setValue()方法和add()方法可能会改变这个引用。因此，即使Calculator类内部使用了一个不可变对象，但Calculator类本身还是可变的，因此Calculator类不是线程安全的。换句话说：ImmutableValue类是线程安全的，但使用它的类不是。当尝试通过不可变性去获得线程安全时，这点是需要牢记的。 要使Calculator类实现线程安全，将getValue()、setValue()和add()方法都声明为同步方法即可。 本文转载于并发编程网来源：http://ifeve.com/java-concurrency-thread-directory/","categories":[{"name":"JAVASE","slug":"JAVASE","permalink":"https://caoler.cn/categories/JAVASE/"},{"name":"多线程","slug":"JAVASE/多线程","permalink":"https://caoler.cn/categories/JAVASE/多线程/"}],"tags":[{"name":"转载","slug":"转载","permalink":"https://caoler.cn/tags/转载/"}]},{"title":"442. Find All Duplicates in an Array","slug":"442. Find All Duplicates in an Array","date":"2017-11-06T11:57:00.000Z","updated":"2017-11-14T08:45:50.914Z","comments":true,"path":"/blog/2017/442. Find All Duplicates in an Array.html","link":"","permalink":"https://caoler.cn/blog/2017/442. Find All Duplicates in an Array.html","excerpt":"Given an array of integers, 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once. Find all the elements that appear twice in this array. Could you do it without extra space and in O(n) runtime?12345Example:Input:[4,3,2,7,8,2,3,1]Output:[2,3]","text":"Given an array of integers, 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once. Find all the elements that appear twice in this array. Could you do it without extra space and in O(n) runtime?12345Example:Input:[4,3,2,7,8,2,3,1]Output:[2,3] 题目大意：给定一个整数数组，1 &lt;= a[i] &lt;= n (n = 数组长度)，某些元素出现两次，某些出现一次。寻找数组中所有出现两次的元素。你可以不使用额外空间并且在O(n)运行时间内完成题目吗？ 思路：解法一（自己的想法）：首先对数组进行排列，例如[4,3,3,2,1] 排列后变为[1,2,3,3,4]，遍历nums，当nums[i] - nums[i + 1] == 0时，也就是当前数字等于下一个数字，再将当前数字存入数组中。 代码： 1234567891011public static List&lt;Integer&gt; findDuplicates1(int[] nums) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); Arrays.sort(nums); for (int i = 0; i &lt; nums.length - 1; i++) &#123; if (nums[i] - nums[ i+1 ] == 0)&#123; res.add(nums[i]); i++; &#125; &#125; return res;&#125; 解法二：正负号标记法（一趟遍历） 遍历nums，记当前数字为n（取绝对值），将数字n视为下标（因为a[i]∈[1, n]） 当n首次出现时，nums[n - 1]-1 当n再次出现时，则nums[n - 1]一定＜0，将n加入答案 参考：https://discuss.leetcode.com/topic/64735/java-simple-solution代码： 123456789101112131415public class Solution &#123; // when find a number i, flip the number at position i-1 to negative. // if the number at position i-1 is already negative, i is the number that occurs twice. public List&lt;Integer&gt; findDuplicates(int[] nums) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; nums.length; ++i) &#123; int index = Math.abs(nums[i])-1; if (nums[index] &lt; 0) res.add(Math.abs(index+1)); nums[index] = -nums[index]; &#125; return res; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://caoler.cn/categories/leetcode/"},{"name":"Array","slug":"leetcode/Array","permalink":"https://caoler.cn/categories/leetcode/Array/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://caoler.cn/tags/leetcode/"}]},{"title":"561. Array Partition I","slug":"561. Array Partition I","date":"2017-11-06T11:56:00.000Z","updated":"2017-11-14T08:46:01.216Z","comments":true,"path":"/blog/2017/561. Array Partition I.html","link":"","permalink":"https://caoler.cn/blog/2017/561. Array Partition I.html","excerpt":"Given an array of 2n integers, your task is to group these integers into n pairs of integer, say (a1, b1), (a2, b2), …, (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible. Example 1: 123Input: [1,4,3,2]Output: 4Explanation: n is 2, and the maximum sum of pairs is 4 = min(1, 2) + min(3, 4).","text":"Given an array of 2n integers, your task is to group these integers into n pairs of integer, say (a1, b1), (a2, b2), …, (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible. Example 1: 123Input: [1,4,3,2]Output: 4Explanation: n is 2, and the maximum sum of pairs is 4 = min(1, 2) + min(3, 4). Note: n is a positive integer, which is in the range of [1, 10000]. All the integers in the array will be in the range of [-10000, 10000]. 题目大意： 给定一个长度为2n(偶数)的数组，分成n个小组，返回每组中较小值的和sum，使sum尽量大 思路：先将数组从大到小进行排列，将相邻两个数分为一组，每组较小数都在左边，求和即可。 代码如下： 1234567891011121314151617181920212223package cn.caoler.Array.No561;import java.util.Arrays;/** * Author: Caole * CreateDateTime: 2017/10/11 15:46 * Description: */public class main &#123; public static int arrayPairSum(int[] nums) &#123; Arrays.sort(nums); int sum = 0; for (int i = 0; i &lt; nums.length; i += 2) &#123; sum += nums[i]; &#125; return sum; &#125; public static void main(String[] args) &#123; int[] num = &#123;1,2,3,4,5,6,7,8&#125;; System.out.println(arrayPairSum(num)); &#125;&#125; 其中使用了Arrays.sort()函数，其功能参照API文档如下： 1static void sort(byte[] a) 按照数字顺序排列指定的数组。 且 for循环时直接使用 i += 2 提升效率。","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://caoler.cn/categories/leetcode/"},{"name":"Array","slug":"leetcode/Array","permalink":"https://caoler.cn/categories/leetcode/Array/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://caoler.cn/tags/leetcode/"}]},{"title":"JAVA迭代器（Interator）详解","slug":"JAVA迭代器（Interator）详解","date":"2017-11-04T03:40:12.000Z","updated":"2017-11-07T12:15:37.217Z","comments":true,"path":"/blog/2017/JAVA迭代器（Interator）详解.html","link":"","permalink":"https://caoler.cn/blog/2017/JAVA迭代器（Interator）详解.html","excerpt":"一、迭代器概述1、什么是迭代器？在Java中，有很多的数据容器，对于这些的操作有很多的共性。Java采用了迭代器来为各种容器提供了公共的操作接口。这样使得对容器的遍历操作与其具体的底层实现相隔离，达到解耦的效果。 在Iterator接口中定义了四个方法： 方法 功能 default void forEachRemaining(Consumer&lt;? super E&gt; action) 对每个剩余元素执行给定的操作，直到所有元素都被处理或动作引发异常。 boolean hasNext() 如果迭代具有更多元素，则返回 true 。 E next() 返回迭代中的下一个元素。 default void remove() 从底层集合中删除此迭代器返回的最后一个元素（可选操作）。","text":"一、迭代器概述1、什么是迭代器？在Java中，有很多的数据容器，对于这些的操作有很多的共性。Java采用了迭代器来为各种容器提供了公共的操作接口。这样使得对容器的遍历操作与其具体的底层实现相隔离，达到解耦的效果。 在Iterator接口中定义了四个方法： 方法 功能 default void forEachRemaining(Consumer&lt;? super E&gt; action) 对每个剩余元素执行给定的操作，直到所有元素都被处理或动作引发异常。 boolean hasNext() 如果迭代具有更多元素，则返回 true 。 E next() 返回迭代中的下一个元素。 default void remove() 从底层集合中删除此迭代器返回的最后一个元素（可选操作）。 2、迭代器使用12345678910111213public void testIterator() &#123; Collection collection = new ArrayList(); collection.add(123); collection.add(\"AA\"); collection.add(new Date()); collection.add(\"BB\"); collection.add(new Employee(\"Caole\",23)); Iterator iterator = collection.iterator(); while (iterator.hasNext())&#123; System.out.println(iterator.next()); &#125;&#125; 执行结果： 12345123AAWed Nov 01 17:53:43 CST 2017BBEmployee&#123;id=598, name='Caole', salary=23.0&#125; 二、ArrayList的Iterator实现前段代码的输出结果不用多说，这里的iterator更像是“游标”，不过这游标具体做了啥，我们还得通过list.iterator()好好看看。通过源码了解到该方法产生了一个实现Iterator接口的对象。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364private class Itr implements Iterator&lt;E&gt; &#123; int cursor; // index of next element to return int lastRet = -1; // index of last element returned; -1 if no such int expectedModCount = modCount; public boolean hasNext() &#123; return cursor != size; &#125; @SuppressWarnings(\"unchecked\") public E next() &#123; checkForComodification(); int i = cursor; if (i &gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i]; &#125; public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; ArrayList.this.remove(lastRet); cursor = lastRet; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; @Override @SuppressWarnings(\"unchecked\") public void forEachRemaining(Consumer&lt;? super E&gt; consumer) &#123; Objects.requireNonNull(consumer); final int size = ArrayList.this.size; int i = cursor; if (i &gt;= size) &#123; return; &#125; final Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) &#123; throw new ConcurrentModificationException(); &#125; while (i != size &amp;&amp; modCount == expectedModCount) &#123; consumer.accept((E) elementData[i++]); &#125; // update once at end of iteration to reduce heap write traffic cursor = i; lastRet = i - 1; checkForComodification(); &#125; final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125;&#125; 其中： 123456private class Itr implements Iterator&lt;E&gt; &#123; int cursor; // index of next element to return int lastRet = -1; // index of last element returned; -1 if no such int expectedModCount = modCount; ...&#125; 在ArrayList内部定义了一个内部类Itr，该类实现了Iterator接口。 在Itr中，有三个变量分别是 cursor：表示下一个元素的索引位置 lastRet：表示上一个元素的索引位置 expectModCount：预期被修改的次数 下面看一下Itr类实现了Iterator接口的三个方法： 123public boolean hasNext() &#123; return cursor != size;//当cursor不等于size时，表示仍有索引元素&#125; 1234567891011public E next() //返回下一个元素&#123; checkForComodification(); int i = cursor; if (i &gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i];&#125; 在next()方法中有一个checkForComodification()方法，其实现为： 1234final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException();&#125; 可以看到，该函数是用来判断集合的修改次数是否合法。 在集合内部维护一个字段modCount用于记录集合被修改的次数，每当集合内部结构发生变化(add,remove，set)时，modCount+1。 在迭代器内部也维护一个字段expectedModCount，同样记录当前集合修改的次数，初始化为集合的modCount值。当我们在调用Iterator进行遍历操作时，如果有其他线程修改list会出现modCount!=expectedModCount的情况，就会报并发修改异常java.util.ConcurrentModificationException。下面为示例代码： 12345678910111213141516171819public static void main(String[] args)&#123; ArrayList&lt;String&gt; aList=new ArrayList&lt;String&gt;(); aList.add(\"bbc\"); aList.add(\"abc\"); aList.add(\"ysc\"); aList.add(\"saa\"); System.out.println(\"移除前：\"+aList); Iterator&lt;String&gt; it=aList.iterator(); while(it.hasNext()) &#123; if(\"abc\".equals(it.next())) &#123; aList.remove(\"abc\"); &#125; &#125; System.out.println(\"移除后：\"+aList);&#125; 12345移除前：[bbc, abc, ysc, saa]java.util.ConcurrentModificationException at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:901) at java.util.ArrayList$Itr.next(ArrayList.java:851) 上面的代码中，如果我们只使用迭代器来进行删除，则不会出现并发修改异常错误。12345678910111213141516171819public static void main(String[] args)&#123; ArrayList&lt;String&gt; aList=new ArrayList&lt;String&gt;(); aList.add(\"bbc\"); aList.add(\"abc\"); aList.add(\"ysc\"); aList.add(\"saa\"); System.out.println(\"移除前：\"+aList); Iterator&lt;String&gt; it=aList.iterator(); while(it.hasNext()) &#123; if(\"abc\".equals(it.next())) &#123; it.remove(); &#125; &#125; System.out.println(\"移除后：\"+aList);&#125; 12移除前：[bbc, abc, ysc, saa]移除后：[bbc, ysc, saa] 1234567891011121314public void remove()&#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; ArrayList.this.remove(lastRet); cursor = lastRet; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125;&#125; 在执行remove操作时，同样先执行checkForComodification()，然后会执行ArrayList的remove()方法，该方法会将modCount值加1，这里我们将expectedModCount=modCount，使之保持统一。 三、ListIterator上面可以看到，Iterator只提供了删除元素的方法remove，如果我们想要在遍历的时候添加元素怎么办？ ListIterator接口继承了Iterator接口，它允许程序员按照任一方向遍历列表，迭代期间修改列表，并获得迭代器在列表中的当前位置。 ListIterator接口定义了下面几个方法： 方法 说明 void add(E e) 将指定的元素插入列表（可选操作）。 boolean hasNext() 返回 true如果遍历正向列表，列表迭代器有多个元素。 boolean hasPrevious() 返回 true如果遍历反向列表，列表迭代器有多个元素。 E next() 返回列表中的下一个元素，并且前进光标位置。 int nextIndex() 返回随后调用 next()返回的元素的索引。 E previous() 返回列表中的上一个元素，并向后移动光标位置。 int previousIndex() 返回由后续调用 previous()返回的元素的索引。 void remove() 从列表中删除由 next()或 previous()返回的最后一个元素（可选操作）。 void set(E e) 用 指定的元素替换由 next()或 previous()返回的最后一个元素（可选操作）。 下面使用ListIterator来对list进行边遍历边添加元素操作：123456789101112131415161718public static void main(String[] args)&#123; ArrayList&lt;String&gt; aList = new ArrayList&lt;String&gt;(); aList.add(\"bbc\"); aList.add(\"abc\"); aList.add(\"ysc\"); aList.add(\"saa\"); System.out.println(\"移除前：\" + aList); ListIterator&lt;String&gt; listIt = aList.listIterator(); while (listIt.hasNext()) &#123; if (\"abc\".equals(listIt.next())) &#123; listIt.add(\"haha\"); &#125; &#125; System.out.println(\"移除后：\" + aList);&#125; 12移除前：[bbc, abc, ysc, saa]移除后：[bbc, abc, haha, ysc, saa]","categories":[{"name":"JAVASE","slug":"JAVASE","permalink":"https://caoler.cn/categories/JAVASE/"},{"name":"集合框架","slug":"JAVASE/集合框架","permalink":"https://caoler.cn/categories/JAVASE/集合框架/"}],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2017-11-03T05:33:33.000Z","updated":"2017-11-14T08:46:12.458Z","comments":true,"path":"/blog/2017/hello-world.html","link":"","permalink":"https://caoler.cn/blog/2017/hello-world.html","excerpt":"","text":"HelloWorld！","categories":[],"tags":[]}]}