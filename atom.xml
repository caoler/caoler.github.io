<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Caole&#39;s blog</title>
  
  <subtitle>Caole的个人博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://caoler.cn/"/>
  <updated>2018-10-14T12:55:47.391Z</updated>
  <id>https://caoler.cn/</id>
  
  <author>
    <name>Caole</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spring Boot + Mybatis 多数据源配置</title>
    <link href="https://caoler.cn//post/2018/spring-mybatis-more-db.html"/>
    <id>https://caoler.cn//post/2018/spring-mybatis-more-db.html</id>
    <published>2018-10-11T08:38:00.000Z</published>
    <updated>2018-10-14T12:55:47.391Z</updated>
    
    <content type="html"><![CDATA[<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>项目需要同时连接两个不同的数据库poi、pos，暂未涉及到主从，仅仅是因为两个数据库相互独立。</p><a id="more"></a><h2 id="多数据源"><a href="#多数据源" class="headerlink" title="多数据源"></a>多数据源</h2><p>首先要将spring boot自带的<code>DataSourceAutoConfiguration</code>禁掉，因为它会读取<code>application.properties</code>文件的<code>spring.datasource.*</code>属性并自动配置单数据源。在<code>@SpringBootApplication</code>注解中添加<code>exclude</code>属性即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span>(exclude = &#123;</span><br><span class="line">        DataSourceAutoConfiguration.class</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(WebApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在<code>application.yml</code>中配置多数据源连接信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    type: com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">    poi:</span><br><span class="line">      driverClassName: com.mysql.cj.jdbc.Driver</span><br><span class="line">      url: jdbc:mysql:<span class="comment">//127.0.0.1:3306/poi</span></span><br><span class="line">      username: root</span><br><span class="line">      password: root</span><br><span class="line">    pos:</span><br><span class="line">      driverClassName: com.mysql.cj.jdbc.Driver</span><br><span class="line">      url: jdbc:mysql:<span class="comment">//127.0.0.1:3306/pos</span></span><br><span class="line">      username: root</span><br><span class="line">      password: root</span><br></pre></td></tr></table></figure><p>由于我们禁掉了自动数据源配置，因些下一步就需要手动将这些数据源创建出来：</p><h3 id="poi数据源配置"><a href="#poi数据源配置" class="headerlink" title="poi数据源配置"></a>poi数据源配置</h3><p>注意，配置类需要对<code>DataSource</code>、<code>DataSourceTransactionManager</code>、<code>SqlSessionFactory</code> 、<code>SqlSessionTemplate</code>四个数据项进行配置；<code>DataSource</code>类型需要引入<code>javax.sql.DataSource</code></p><p><code>@MapperScan</code>对指定dao包建立映射，确保在多个数据源下，自动选择合适的数据源，而在service层里不需要做特殊说明.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@MapperScan</span>(basePackages = <span class="string">"cn.caoler.poi.mapper"</span>, sqlSessionTemplateRef = <span class="string">"poiSqlSessionTemplate"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseDataSourceConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"poiDataSource"</span>)</span><br><span class="line">    <span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.datasource.poi"</span>)</span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">setDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DataSourceBuilder.create().build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"poiTransactionManager"</span>)</span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSourceTransactionManager <span class="title">setTransactionManager1</span><span class="params">(@Qualifier(<span class="string">"poiDataSource"</span>)</span> DataSource dataSource) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"poiSqlSessionFactory"</span>)</span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">setSqlSessionFactory</span><span class="params">(@Qualifier(<span class="string">"poiDataSource"</span>)</span> DataSource dataSource) <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SqlSessionFactoryBean bean = <span class="keyword">new</span> SqlSessionFactoryBean();</span><br><span class="line">        bean.setDataSource(dataSource);</span><br><span class="line">        bean.setMapperLocations(<span class="keyword">new</span> PathMatchingResourcePatternResolver().getResources(<span class="string">"classpath:mapper/poi/*.xml"</span>));</span><br><span class="line">        <span class="keyword">return</span> bean.getObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"poiSqlSessionTemplate"</span>)</span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SqlSessionTemplate <span class="title">setSqlSessionTemplate</span><span class="params">(@Qualifier(<span class="string">"poiSqlSessionFactory"</span>)</span> SqlSessionFactory sqlSessionFactory) <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SqlSessionTemplate(sqlSessionFactory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过如上配置，<code>cn.caoler.poi.mapper</code>包下的Mapper接口，都会使用poi数据源。同理可配第二个</p><h3 id="pos数据源配置"><a href="#pos数据源配置" class="headerlink" title="pos数据源配置"></a>pos数据源配置</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@MapperScan</span>(basePackages = <span class="string">"cn.caoler.pos.mapper"</span>, sqlSessionTemplateRef = <span class="string">"poiSqlSessionTemplate"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseDataSourceConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"posDataSource"</span>)</span><br><span class="line">    <span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.datasource.pos"</span>)</span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">setDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DataSourceBuilder.create().build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"posTransactionManager"</span>)</span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSourceTransactionManager <span class="title">setTransactionManager2</span><span class="params">(@Qualifier(<span class="string">"posDataSource"</span>)</span> DataSource dataSource) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"posSqlSessionFactory"</span>)</span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">setSqlSessionFactory</span><span class="params">(@Qualifier(<span class="string">"posDataSource"</span>)</span> DataSource dataSource) <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SqlSessionFactoryBean bean = <span class="keyword">new</span> SqlSessionFactoryBean();</span><br><span class="line">        bean.setDataSource(dataSource);</span><br><span class="line">        bean.setMapperLocations(<span class="keyword">new</span> PathMatchingResourcePatternResolver().getResources(<span class="string">"classpath:mapper/pos/*.xml"</span>));</span><br><span class="line">        <span class="keyword">return</span> bean.getObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"posSqlSessionTemplate"</span>)</span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SqlSessionTemplate <span class="title">setSqlSessionTemplate</span><span class="params">(@Qualifier(<span class="string">"posSqlSessionFactory"</span>)</span> SqlSessionFactory sqlSessionFactory) <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SqlSessionTemplate(sqlSessionFactory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完成这些配置后，假设有2个Mapper <code>poi.mapper.UserMapper</code>和<code>pos.mapper.RoleMapper</code>，使用前者时会自动连接poi库，后者连接pos库。</p><h2 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h2><h3 id="1-jdbcUrl-is-required-with-driverClassName报错"><a href="#1-jdbcUrl-is-required-with-driverClassName报错" class="headerlink" title="1. jdbcUrl is required with driverClassName报错"></a>1. jdbcUrl is required with driverClassName报错</h3><p>解决方法：在配置文件中使用spring.datasource.jdbcUrl，而不是通常使用的spring.datasource.url。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">datasource:</span><br><span class="line">  type: com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">  poi:</span><br><span class="line">    driverClassName: com.mysql.cj.jdbc.Driver</span><br><span class="line">    jdbcUrl: jdbc:mysql:<span class="comment">//127.0.0.1:3306/poi         #此处必须使用jdbcUrl而不是url</span></span><br><span class="line">    username: root</span><br><span class="line">    password: root</span><br></pre></td></tr></table></figure><h3 id="2-访问-接口时提示：DataSourceTransactionManager-重复"><a href="#2-访问-接口时提示：DataSourceTransactionManager-重复" class="headerlink" title="2. 访问 接口时提示：DataSourceTransactionManager  重复"></a>2. 访问 接口时提示：DataSourceTransactionManager  重复</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span>(name = <span class="string">"posTransactionManager"</span>)</span><br><span class="line"><span class="meta">@Primary</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSourceTransactionManager <span class="title">setTransactionManager2</span><span class="params">(@Qualifier(<span class="string">"posDataSource"</span>)</span> DataSource dataSource) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在配置DataSourceTransactionManager时，Bean命名为posTransactionManager和poiTransactionManager，已经做了区分，但是调用时还会提示有两个TransactionManager，产生原因暂不明确，但是解决方法为： <strong>修改函数名，保证函数名之间有严格区分即可（例：<code>setTransactionManager1</code>、<code>setTransactionManager2</code>）</strong></p><h3 id="3-提示mapper-xxx-xml未找到"><a href="#3-提示mapper-xxx-xml未找到" class="headerlink" title="3. 提示mapper/xxx/*.xml未找到"></a>3. 提示mapper/xxx/*.xml未找到</h3><p>只要保证程序运行之前，上述位置生成好对应的mapping.xml文件即可，若该位置无xml文件，则会报上述错误。</p><p>至此，大功告成。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://blog.csdn.net/acquaintanceship/article/details/75350653" target="_blank" rel="external">https://blog.csdn.net/acquaintanceship/article/details/75350653</a></li><li><a href="https://blog.csdn.net/newhanzhe/article/details/80763581" target="_blank" rel="external">https://blog.csdn.net/newhanzhe/article/details/80763581</a></li><li><a href="https://blog.csdn.net/neosmith/article/details/61202084" target="_blank" rel="external">https://blog.csdn.net/neosmith/article/details/61202084</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;应用场景&quot;&gt;&lt;a href=&quot;#应用场景&quot; class=&quot;headerlink&quot; title=&quot;应用场景&quot;&gt;&lt;/a&gt;应用场景&lt;/h2&gt;&lt;p&gt;项目需要同时连接两个不同的数据库poi、pos，暂未涉及到主从，仅仅是因为两个数据库相互独立。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring" scheme="https://caoler.cn/categories/Spring/"/>
    
    
      <category term="springboot" scheme="https://caoler.cn/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>Java RestTemplate post请求传递参数</title>
    <link href="https://caoler.cn//post/2018/Java-RestTemplate.html"/>
    <id>https://caoler.cn//post/2018/Java-RestTemplate.html</id>
    <published>2018-10-10T08:38:00.000Z</published>
    <updated>2018-10-14T12:54:44.487Z</updated>
    
    <content type="html"><![CDATA[<p>最近使用Spring 的 RestTemplate 工具类请求接口的时候发现参数传递的一个坑，也就是当我们把参数封装在Map里面的时候，Map 的类型选择。 使用RestTemplate post请求的时候主要可以通过三种方式实现</p><ol><li>调用postForObject方法 </li><li>使用postForEntity方法 </li><li>调用exchange方法 </li></ol><a id="more"></a><p>postForObject和postForEntity方法的区别主要在于可以在postForEntity方法中设置header的属性，当需要指定header的属性值的时候，使用postForEntity方法。exchange方法和postForEntity类似，但是更灵活，exchange还可以调用get请求。使用这三种方法传递参数，Map不能定义为以下两种类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; paramMap = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; paramMap = <span class="keyword">new</span> LinkedHashMap&lt;String, Object&gt;();</span><br></pre></td></tr></table></figure><p>经过测试，我发现这两种map里面的参数都不能被后台接收到，这个问题困扰我两天，终于，当我把Map类型换成LinkedMultiValueMap后，参数成功传递到后台</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MultiValueMap&lt;String, Object&gt; paramMap = new LinkedMultiValueMap&lt;String, Object&gt;();</span><br></pre></td></tr></table></figure><p>经过测试，正确的传参方式如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RestTemplate template = <span class="keyword">new</span> RestTemplate();</span><br><span class="line">        String url = <span class="string">"http://192.168.2.40:8081/channel/channelHourData/getHourNewUserData"</span>;</span><br><span class="line">        <span class="comment">// 封装参数，千万不要替换为Map与HashMap，否则参数无法传递</span></span><br><span class="line">        MultiValueMap&lt;String, Object&gt; paramMap = <span class="keyword">new</span> LinkedMultiValueMap&lt;String, Object&gt;();</span><br><span class="line">        paramMap.add(<span class="string">"dt"</span>, <span class="string">"20180416"</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 1、使用postForObject请求接口</span></span><br><span class="line">        String result = template.postForObject(url, paramMap, String.class);</span><br><span class="line">        System.out.println(<span class="string">"result1=================="</span> + result);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 2、使用postForEntity请求接口</span></span><br><span class="line">        HttpHeaders headers = <span class="keyword">new</span> HttpHeaders();</span><br><span class="line">        HttpEntity&lt;MultiValueMap&lt;String, Object&gt;&gt; httpEntity = <span class="keyword">new</span> HttpEntity&lt;MultiValueMap&lt;String, Object&gt;&gt;(paramMap,headers);</span><br><span class="line">        ResponseEntity&lt;String&gt; response2 = template.postForEntity(url, httpEntity, String.class);</span><br><span class="line">        System.out.println(<span class="string">"result2===================="</span> + response2.getBody());</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 3、使用exchange请求接口</span></span><br><span class="line">        ResponseEntity&lt;String&gt; response3 = template.exchange(url, HttpMethod.POST, httpEntity, String.class);</span><br><span class="line">        System.out.println(<span class="string">"result3===================="</span> + response3.getBody());</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近使用Spring 的 RestTemplate 工具类请求接口的时候发现参数传递的一个坑，也就是当我们把参数封装在Map里面的时候，Map 的类型选择。 使用RestTemplate post请求的时候主要可以通过三种方式实现&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;调用postForObject方法 &lt;/li&gt;
&lt;li&gt;使用postForEntity方法 &lt;/li&gt;
&lt;li&gt;调用exchange方法 &lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="JAVASE" scheme="https://caoler.cn/categories/JAVASE/"/>
    
    
      <category term="JAVASE" scheme="https://caoler.cn/tags/JAVASE/"/>
    
      <category term="请求发送" scheme="https://caoler.cn/tags/%E8%AF%B7%E6%B1%82%E5%8F%91%E9%80%81/"/>
    
  </entry>
  
  <entry>
    <title>KafKa存储结构详解</title>
    <link href="https://caoler.cn//post/2018/kafka-storage.html"/>
    <id>https://caoler.cn//post/2018/kafka-storage.html</id>
    <published>2018-09-29T11:38:00.000Z</published>
    <updated>2018-10-14T12:55:19.255Z</updated>
    
    <content type="html"><![CDATA[<h2 id="整体存储结构"><a href="#整体存储结构" class="headerlink" title="整体存储结构"></a>整体存储结构</h2><p>Kafka中的Message是以topic为基本单位组织的，不同的topic之间是相互独立的。每个topic又可以分成几个不同的partition(每个topic有几个partition是在创建topic时指定的)，每个partition存储一部分Message。借用官方的一张图，可以直观地看到topic和partition的关系。</p><a id="more"></a><p><img src="http://kafka.apache.org/images/log_anatomy.png" alt="img"></p><p>partition是以文件的形式存储在文件系统中，比如，创建了一个名为page_visits的topic，其有5个partition，那么在Kafka的数据目录中(由配置文件中的log.dirs指定的)中就有这样5个目录: page_visits-0， page_visits-1，page_visits-2，page_visits-3，page_visits-4，其命名规则为<code>&lt;topic_name&gt;-&lt;partition_id&gt;</code>，里面存储的分别就是这5个partition的数据。</p><p>接下来，本文将分析partition目录中的文件的存储格式和相关的代码所在的位置。</p><h2 id="Partition的数据文件"><a href="#Partition的数据文件" class="headerlink" title="Partition的数据文件"></a>Partition的数据文件</h2><p>Partition中的每条Message由offset来表示它在这个partition中的偏移量，这个offset不是该Message在partition数据文件中的实际存储位置，而是逻辑上一个值，它唯一确定了partition中的一条Message。因此，可以认为offset是partition中Message的id。partition中的每条Message包含了以下三个属性：</p><ul><li>offset</li><li>MessageSize</li><li>data</li></ul><p>其中offset为long型，MessageSize为int32，表示data有多大，data为message的具体内容。它的格式和<a href="http://blog.csdn.net/jewes/article/details/42744855" target="_blank" rel="external">Kafka通讯协议</a>中介绍的MessageSet格式是一致。</p><p>我们来思考一下，如果一个partition只有一个数据文件会怎么样？</p><ol><li>新数据是添加在文件末尾（调用FileMessageSet的append方法），不论文件数据文件有多大，这个操作永远都是O(1)的。</li><li>查找某个offset的Message（调用FileMessageSet的searchFor方法）是顺序查找的。因此，如果数据文件很大的话，查找的效率就低。</li></ol><p>那Kafka是如何解决查找效率的的问题呢？有两大法宝：1) 分段 2) 索引。</p><h3 id="数据文件的分段"><a href="#数据文件的分段" class="headerlink" title="数据文件的分段"></a>数据文件的分段</h3><p>Kafka解决查询效率的手段之一是将数据文件分段，比如有100条Message，它们的offset是从0到99。假设将数据文件分成5段，第一段为0-19，第二段为20-39，以此类推，每段放在一个单独的数据文件里面，数据文件以该段中最小的offset命名。这样在查找指定offset的Message的时候，用二分查找就可以定位到该Message在哪个段中。</p><h3 id="为数据文件创建索引"><a href="#为数据文件创建索引" class="headerlink" title="为数据文件创建索引"></a>为数据文件创建索引</h3><p>数据文件分段使得可以在一个较小的数据文件中查找对应offset的Message了，但是这依然需要顺序扫描才能找到对应offset的Message。为了进一步提高查找的效率，Kafka为每个分段后的数据文件建立了索引文件，文件名与数据文件的名字是一样的，只是文件扩展名为.index。<br>索引文件中包含若干个索引条目，每个条目表示数据文件中一条Message的索引。索引包含两个部分（均为4个字节的数字），分别为相对offset和position。</p><ul><li>相对offset：因为数据文件分段以后，每个数据文件的起始offset不为0，相对offset表示这条Message相对于其所属数据文件中最小的offset的大小。举例，分段后的一个数据文件的offset是从20开始，那么offset为25的Message在index文件中的相对offset就是25-20 = 5。存储相对offset可以减小索引文件占用的空间。</li><li>position，表示该条Message在数据文件中的绝对位置。只要打开文件并移动文件指针到这个position就可以读取对应的Message了。</li></ul><p>index文件中并没有为数据文件中的每条Message建立索引，而是采用了稀疏存储的方式，每隔一定字节的数据建立一条索引。这样避免了索引文件占用过多的空间，从而可以将索引文件保留在内存中。但缺点是没有建立索引的Message也不能一次定位到其在数据文件的位置，从而需要做一次顺序扫描，但是这次顺序扫描的范围就很小了。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>我们以几张图来总结一下Message是如何在Kafka中存储的，以及如何查找指定offset的Message的。</p><p>Message是按照topic来组织，每个topic可以分成多个的partition，比如：有5个partition的名为为page_visits的topic的目录结构为：<br><img src="https://ws1.sinaimg.cn/large/005DnJLEgy1fvqinrzk7cj30gs02x0t1.jpg" alt=""></p><p>partition是分段的，每个段叫LogSegment，包括了一个数据文件和一个索引文件，下图是某个partition目录下的文件：<br><img src="https://ws1.sinaimg.cn/large/005DnJLEgy1fvqioajihej306e064wef.jpg" alt=""><br>可以看到，这个partition有4个LogSegment。</p><p>展示是如何查找Message的。<br><img src="https://ws1.sinaimg.cn/large/005DnJLEly1fvqip60oy0j311j0pb0wj.jpg" alt=""><br>比如：要查找绝对offset为7的Message：</p><ol><li>首先是用二分查找确定它是在哪个LogSegment中，自然是在第一个Segment中。</li><li>打开这个Segment的index文件，也是用二分查找找到offset小于或者等于指定offset的索引条目中最大的那个offset。自然offset为6的那个索引是我们要找的，通过索引文件我们知道offset为6的Message在数据文件中的位置为9807。</li><li>打开数据文件，从位置为9807的那个地方开始顺序扫描直到找到offset为7的那条Message。</li></ol><p>这套机制是建立在offset是有序的。索引文件被映射到内存中，所以查找的速度还是很快的。</p><p>一句话，Kafka的Message存储采用了分区(partition)，分段(LogSegment)和稀疏索引这几个手段来达到了高效性。</p><p>本文转自CSDN,原文链接：<a href="https://blog.csdn.net/gongxinju/article/details/72672375" target="_blank" rel="external">https://blog.csdn.net/gongxinju/article/details/72672375</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;整体存储结构&quot;&gt;&lt;a href=&quot;#整体存储结构&quot; class=&quot;headerlink&quot; title=&quot;整体存储结构&quot;&gt;&lt;/a&gt;整体存储结构&lt;/h2&gt;&lt;p&gt;Kafka中的Message是以topic为基本单位组织的，不同的topic之间是相互独立的。每个topic又可以分成几个不同的partition(每个topic有几个partition是在创建topic时指定的)，每个partition存储一部分Message。借用官方的一张图，可以直观地看到topic和partition的关系。&lt;/p&gt;
    
    </summary>
    
      <category term="KafKa" scheme="https://caoler.cn/categories/KafKa/"/>
    
    
      <category term="kafka" scheme="https://caoler.cn/tags/kafka/"/>
    
      <category term="消息队列" scheme="https://caoler.cn/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>生产者消费者模型</title>
    <link href="https://caoler.cn//post/2018/producer-consumer.html"/>
    <id>https://caoler.cn//post/2018/producer-consumer.html</id>
    <published>2018-09-29T08:38:00.000Z</published>
    <updated>2018-10-14T12:55:59.620Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是生产者消费者"><a href="#什么是生产者消费者" class="headerlink" title="什么是生产者消费者"></a>什么是生产者消费者</h3><p>用一个不是特别恰当的例子做比喻：鸡下蛋，人吃鸡蛋，鸡每天下10个蛋，但是人每天只能吃2个蛋，吃不及蛋就会造成阻塞。生产者消费者模型呢，给中间放了个篮子，鸡下蛋放进篮子，人吃蛋从篮子里拿，将人与鸡的强耦合解开，变成了弱耦合。</p><a id="more"></a><p>生产者消费者模型需要关注的几个点：</p><ul><li>生产者生产的时候消费者不能消费</li><li>消费者消费的时候生产者不能生产</li><li>缓冲区空时消费者不能消费</li><li>缓冲区满时生产者不能生产</li></ul><h4 id="为什么要用生产者消费者模型？优点在哪里？"><a href="#为什么要用生产者消费者模型？优点在哪里？" class="headerlink" title="为什么要用生产者消费者模型？优点在哪里？"></a>为什么要用生产者消费者模型？优点在哪里？</h4><ul><li><strong>解耦</strong> 。因为多了一个缓冲区，所以生产者和消费者并不直接相互调用，这一点很容易想到，这样生产者和消费者的代码发生变化，都不会对对方产生影响，这样其实就把生产者和消费者之间的强耦合解开，变为了生产者和缓冲区/消费者和缓冲区之间的弱耦合</li><li><strong>通过平衡生产者和消费者的处理能力来提高整体处理数据的速度</strong>，这是生产者/消费者模型最重要的一个优点。如果消费者直接从生产者这里拿数据，如果生产者生产的速度很慢，但消费者消费的速度很快，那消费者就得占用CPU的时间片白白等在那边。有了生产者/消费者模型，生产者和消费者就是两个独立的并发体，生产者把生产出来的数据往缓冲区一丢就好了，不必管消费者；消费者也是，从缓冲区去拿数据就好了，也不必管生产者，缓冲区满了就不生产，缓冲区空了就不消费，使生产者/消费者的处理能力达到一个动态的平衡</li></ul><h3 id="实现生产者消费者模型的两个简单Demo"><a href="#实现生产者消费者模型的两个简单Demo" class="headerlink" title="实现生产者消费者模型的两个简单Demo"></a>实现生产者消费者模型的两个简单Demo</h3><hr><p><strong>利用wait()/notify()实现生产者/消费者模型</strong></p><p>既然生产者/消费者模型有一个缓冲区，那么我们就自己做一个缓冲区，生产者和消费者的通信都是通过这个缓冲区的。value为””表示缓冲区空，value不为””表示缓冲区满：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueObject</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String value = <span class="string">""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就是一个生产者了，如果缓冲区满了的，那么就wait()，不再生产了，等待消费者消费完通知；如果缓冲区是空的，那么就生产数据到缓冲区中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.myhexin.ioc.producerConsumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object lock;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(Object lock)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lock = lock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">                <span class="keyword">if</span> (!ValueObject.value.equals(<span class="string">""</span>))&#123;</span><br><span class="line">                    lock.wait();</span><br><span class="line">                &#125;</span><br><span class="line">                String value = System.currentTimeMillis() + <span class="string">"_"</span> + System.nanoTime();</span><br><span class="line">                System.out.println(<span class="string">"Set的值为："</span> + value);</span><br><span class="line">                ValueObject.value = value;</span><br><span class="line">                lock.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费者类似，如果缓冲区是空的，那么就不再消费，wait()等待，等待生产者生产完通知；如果缓冲区不是空的，那么就去拿数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.myhexin.ioc.producerConsumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object lock;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Customer</span><span class="params">(Object lock)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lock = lock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">                <span class="keyword">if</span> (ValueObject.value.equals(<span class="string">""</span>))&#123;</span><br><span class="line">                    lock.wait();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"Get的值为："</span> + ValueObject.value);</span><br><span class="line">                ValueObject.value = <span class="string">""</span>;</span><br><span class="line">                lock.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写个主函数，开两个线程调用Producer里面的getValue()方法和Customer()里面的setValue()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.myhexin.ioc.producerConsumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">        <span class="keyword">final</span> Producer producer = <span class="keyword">new</span> Producer(lock);</span><br><span class="line">        <span class="keyword">final</span> Customer customer = <span class="keyword">new</span> Customer(lock);</span><br><span class="line"></span><br><span class="line">        Runnable producerRunnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                    producer.setValue();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Runnable customerRunnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                    customer.getValue();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Thread p = <span class="keyword">new</span> Thread(producerRunnable);</span><br><span class="line">        Thread c = <span class="keyword">new</span> Thread(customerRunnable);</span><br><span class="line">        p.start();</span><br><span class="line">        c.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一下运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">Set的值是：1444025677743_162366875965845</span><br><span class="line">Get的值是：1444025677743_162366875965845</span><br><span class="line">Set的值是：1444025677743_162366875983541</span><br><span class="line">Get的值是：1444025677743_162366875983541</span><br><span class="line">Set的值是：1444025677743_162366876004776</span><br><span class="line">Get的值是：1444025677743_162366876004776</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>生产数据和消费数据一定是成对出现的，生产一个消费一个，满了不生产，空了不消费，生产者不能无限生产，消费者也不能无限消费，符合生产者/消费者模型。生产者速度快，就不占用CPU时间片，等着消费者消费完通知它继续生产，这块时间片可以用来给其他线程用。</p><hr><p><strong>利用await()/signal()实现生产者和消费者模型</strong></p><p>一样，先定义一个缓冲区：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueObject</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String value = <span class="string">""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>换种写法，生产和消费方法放在一个类里面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.myhexin.ioc.pc2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDomain</span> <span class="keyword">extends</span> <span class="title">ReentrantLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Condition condition = newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock();</span><br><span class="line">            <span class="keyword">while</span> (!<span class="string">""</span>.equals(ValueObject.value))</span><br><span class="line">                condition.await();</span><br><span class="line">            ValueObject.value = <span class="string">"123"</span>;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"生产了："</span> + ValueObject.value);</span><br><span class="line">            condition.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock();</span><br><span class="line">            <span class="keyword">while</span> (<span class="string">""</span>.equals(ValueObject.value))</span><br><span class="line">                condition.await();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"消费了："</span> + ValueObject.value);</span><br><span class="line">            ValueObject.value = <span class="string">""</span>;</span><br><span class="line">            condition.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的，开两个线程，一个线程调用set()方法生产，另一个线程调用get()方法消费：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.myhexin.ioc.pc2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ThreadDomain td = <span class="keyword">new</span> ThreadDomain();</span><br><span class="line">        Runnable pRunnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">                    td.set();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Runnable cRunnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">                    td.get();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Thread p = <span class="keyword">new</span> Thread(pRunnable);</span><br><span class="line">        p.setName(<span class="string">"P"</span>);</span><br><span class="line">        Thread c = <span class="keyword">new</span> Thread(cRunnable);</span><br><span class="line">        c.setName(<span class="string">"C"</span>);</span><br><span class="line">        p.start();</span><br><span class="line">        c.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和wait()/notify()机制的实现效果一样，同样符合生产者/消费者模型.</p><h3 id="小心假死"><a href="#小心假死" class="headerlink" title="小心假死"></a>小心假死</h3><p>生产者/消费者模型最终达到的目的是<strong>平衡生产者和消费者的处理能力</strong>，达到这个目的的过程中，并不要求只有一个生产者和一个消费者。可以多个生产者对应多个消费者，可以一个生产者对应一个消费者，可以多个生产者对应一个消费者。</p><p>假死就发生在上面三种场景下。理论分析就能说明问题，所以就不写代码了。代码要写也很简单，上面的两个例子随便修改一个，开一个生产者线程/多个消费者线程、开多个生产者线程/消费者线程、开多个生产者线程/多个消费者线程都可以。假死指的是全部线程都进入了WAITING状态，那么程序就不再执行任何业务功能了，整个项目呈现停滞状态。</p><p><strong>比方说有生产者A和生产者B，缓冲区由于空了，消费者处于WAITING。生产者B处于WAITING，生产者A被消费者通知生产，生产者A生产出来的产品本应该通知消费者，结果通知了生产者B，生产者B被唤醒，发现缓冲区满了，于是继续WAITING。至此，两个生产者线程处于WAITING，消费者处于WAITING，系统假死。</strong></p><p>上面的分析可以看出，假死出现的原因是因为notify的是同类，所以非单生产者/单消费者的场景，可以采取两种方法<strong>解决</strong> 这个问题：</p><p>1、synchronized用notifyAll()唤醒所有线程、ReentrantLock用signalAll()唤醒所有线程</p><p>2、用ReentrantLock定义两个Condition，一个表示生产者的Condition，一个表示消费者的Condition，唤醒的时候调用相应的Condition的signal()方法就可以了</p><p>本文转自五月的仓颉大神，原文链接：<a href="https://www.cnblogs.com/xrq730/p/4855663.html" target="_blank" rel="external">https://www.cnblogs.com/xrq730/p/4855663.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;什么是生产者消费者&quot;&gt;&lt;a href=&quot;#什么是生产者消费者&quot; class=&quot;headerlink&quot; title=&quot;什么是生产者消费者&quot;&gt;&lt;/a&gt;什么是生产者消费者&lt;/h3&gt;&lt;p&gt;用一个不是特别恰当的例子做比喻：鸡下蛋，人吃鸡蛋，鸡每天下10个蛋，但是人每天只能吃2个蛋，吃不及蛋就会造成阻塞。生产者消费者模型呢，给中间放了个篮子，鸡下蛋放进篮子，人吃蛋从篮子里拿，将人与鸡的强耦合解开，变成了弱耦合。&lt;/p&gt;
    
    </summary>
    
      <category term="并发编程" scheme="https://caoler.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="生产者消费者" scheme="https://caoler.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85/"/>
    
    
      <category term="生产者消费者" scheme="https://caoler.cn/tags/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85/"/>
    
  </entry>
  
  <entry>
    <title>Queue、BlockingQueue以及利用BlockingQueue实现生产者消费者模型</title>
    <link href="https://caoler.cn//post/2018/BlockingQueue.html"/>
    <id>https://caoler.cn//post/2018/BlockingQueue.html</id>
    <published>2018-09-28T08:38:00.000Z</published>
    <updated>2018-10-14T12:55:41.464Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Queue是什么</strong></p><p>队列，是一种数据结构。除了优先级队列和LIFO队列外，队列都是以FIFO（先进先出）的方式对各个元素进行排序的。无论使用哪种排序方式，队列的头都是调用remove()或poll()移除元素的。在FIFO队列中，所有新元素都插入队列的末尾。</p> <a id="more"></a><p><strong>Queue中的方法</strong></p><p>Queue中的方法不难理解，6个，每2对是一个也就是总共3对。看一下JDK API就知道了：</p><p><img src="https://images2015.cnblogs.com/blog/801753/201510/801753-20151005151001299-1024347662.png" alt="img"></p><p>注意一点就好，<strong>Queue通常不允许插入Null</strong>，尽管某些实现（比如LinkedList）是允许的，但是也不建议。</p><p><strong>BlockingQueue</strong></p><p><strong>1、BlockingQueue概述</strong></p><p>只讲BlockingQueue，因为BlockingQueue是Queue中的一个重点，并且通过BlockingQueue我们再次加深对于生产者/消费者模型的理解。其他的Queue都不难，通过查看JDK API和简单阅读源码完全可以理解他们的作用。</p><p>BlockingQueue，顾名思义，<strong>阻塞队列</strong>。BlockingQueue是在java.util.concurrent下的，因此不难理解，BlockingQueue是为了解决多线程中数据高效安全传输而提出的。</p><p>多线程中，很多场景都可以使用队列实现，比如经典的生产者/消费者模型，通过队列可以便利地实现两者之间数据的共享，定义一个生产者线程，定义一个消费者线程，通过队列共享数据就可以了。</p><p>当然现实不可能都是理想的，比如消费者消费速度比生产者生产的速度要快，那么消费者消费到 一定程度上的时候，必须要暂停等待一下了（使消费者线程处于WAITING状态）。BlockingQueue的提出，就是为了解决这个问题的，他不用程序员去控制这些细节，同时还要兼顾效率和线程安全。</p><p>阻塞队列所谓的”阻塞”，指的是<strong>某些情况下线程会挂起（即阻塞），一旦条件满足，被挂起的线程又会自动唤醒</strong>。使用BlockingQueue，不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程，这些内容BlockingQueue都已经做好了</p><p><strong>2、BlockingQueue中的方法</strong></p><p>BlockingQueue既然是Queue的子接口，必然有Queue中的方法，上面已经列了。看一下BlockingQueue中特有的方法：</p><p>（1）void put(E e) throws InterruptedException</p><p>把e添加进BlockingQueue中，如果BlockingQueue中没有空间，则调用线程被阻塞，进入等待状态，直到BlockingQueue中有空间再继续</p><p>（2）void take() throws InterruptedException</p><p>取走BlockingQueue里面排在首位的对象，如果BlockingQueue为空，则调用线程被阻塞，进入等待状态，直到BlockingQueue有新的数据被加入</p><p>（3）int drainTo(Collection&lt;? super E&gt; c, int maxElements)</p><p>一次性取走BlockingQueue中的数据到c中，可以指定取的个数。通过该方法可以提升获取数据效率，不需要多次分批加锁或释放锁</p><p><strong>3、ArrayBlockingQueue</strong></p><p>基于数组的阻塞队列，<strong>必须指定队列大小</strong>。比较简单。ArrayBlockingQueue中只有一个ReentrantLock对象，这意味着生产者和消费者无法并行运行（见下面的代码）。另外，创建ArrayBlockingQueue时，可以指定ReentrantLock是否为公平锁，默认采用非公平锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Main lock guarding all access */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line"><span class="comment">/** Condition for waiting takes */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line"><span class="comment">/** Condition for waiting puts */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</span><br></pre></td></tr></table></figure><p><strong>4、LinkedBlockingQueue</strong></p><p>基于链表的阻塞队列，和ArrayBlockingQueue差不多。不过LinkedBlockingQueue如果不指定队列容量大小，会默认一个类似无限大小的容量，之所以说是类似是因为这个无限大小是Integer.MAX_VALUE，这么说就好理解ArrayBlockingQueue为什么必须要制定大小了，如果ArrayBlockingQueue不指定大小的话就用Integer.MAX_VALUE，那将造成大量的空间浪费，但是基于链表实现就不一样的，一个一个节点连起来而已。另外，LinkedBlockingQueue生产者和消费者都有自己的锁（见下面的代码），这意味着生产者和消费者可以”同时”运行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Lock held by take, poll, etc */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Wait queue for waiting takes */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = takeLock.newCondition();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Lock held by put, offer, etc */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Wait queue for waiting puts */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull = putLock.newCondition();</span><br></pre></td></tr></table></figure><p><strong>5、SynchronousQueue</strong></p><p>比较特殊，一种没有缓冲的等待队列。什么叫做没有缓冲区，ArrayBlocking中有：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** The queued items  */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> E[] items;</span><br></pre></td></tr></table></figure><p>数组用以存储队列。LinkedBlockingQueue中有：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Linked list node class</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** The item, volatile to ensure barrier separating write and read */</span></span><br><span class="line">    <span class="keyword">volatile</span> E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node(E x) &#123; item = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将队列以链表形式连接。</p><p>生产者/消费者操作数据实际上都是通过这两个”中介”来操作数据的，但是SynchronousQueue则是生产者直接把数据给消费者（消费者直接从生产者这里拿数据），好像又回到了没有生产者/消费者模型的老办法了。换句话说，<strong>每一个插入操作必须等待一个线程对应的移除操作</strong>。SynchronousQueue又有两种模式：</p><p>1、公平模式</p><p>采用公平锁，并配合一个FIFO队列（Queue）来管理多余的生产者和消费者</p><p>2、非公平模式</p><p>采用非公平锁，并配合一个LIFO栈（Stack）来管理多余的生产者和消费者，这也是SynchronousQueue默认的模式</p><p><strong>利用BlockingQueue实现生产者消费者模型</strong></p><p>上一篇我们写的生产者消费者模型有局限，局限体现在：</p><ul><li>缓冲区内只能存放一个数据，实际生产者/消费者模型中的缓冲区内可以存放大量生产者生产出来的数据</li><li>生产者和消费者处理数据的速度几乎一样</li></ul><p>OK，我们就用BlockingQueue来简单写一个例子，并且让生产者、消费者处理数据速度不同。子类选择的是ArrayBlockingQueue，大小定为10：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> BlockingQueue&lt;String&gt; bq = <span class="keyword">new</span> ArrayBlockingQueue&lt;String&gt;(<span class="number">10</span>);</span><br><span class="line">    Runnable producerRunnable = <span class="keyword">new</span> Runnable()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span></span><br><span class="line">                &#123;</span><br><span class="line">                    System.out.println(<span class="string">"我生产了一个"</span> + i++);</span><br><span class="line">                    bq.put(i + <span class="string">""</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">                &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    Runnable customerRunnable = <span class="keyword">new</span> Runnable()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span></span><br><span class="line">                &#123;</span><br><span class="line">                    System.out.println(<span class="string">"我消费了一个"</span> + bq.take());</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">                &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    Thread producerThread = <span class="keyword">new</span> Thread(producerRunnable);</span><br><span class="line">    Thread customerThread = <span class="keyword">new</span> Thread(customerRunnable);</span><br><span class="line">    producerThread.start();</span><br><span class="line">    customerThread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码的做法是让生产者生产速度快于消费者消费速度的，看一下运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> 我生产了一个<span class="number">0</span></span><br><span class="line"> <span class="number">2</span> 我消费了一个<span class="number">1</span></span><br><span class="line"> <span class="number">3</span> 我生产了一个<span class="number">1</span></span><br><span class="line"> <span class="number">4</span> 我生产了一个<span class="number">2</span></span><br><span class="line"> <span class="number">5</span> 我消费了一个<span class="number">2</span></span><br><span class="line"> <span class="number">6</span> 我生产了一个<span class="number">3</span></span><br><span class="line"> <span class="number">7</span> 我生产了一个<span class="number">4</span></span><br><span class="line"> <span class="number">8</span> 我生产了一个<span class="number">5</span></span><br><span class="line"> <span class="number">9</span> 我消费了一个<span class="number">3</span></span><br><span class="line"><span class="number">10</span> 我生产了一个<span class="number">6</span></span><br><span class="line"><span class="number">11</span> 我生产了一个<span class="number">7</span></span><br><span class="line"><span class="number">12</span> 我生产了一个<span class="number">8</span></span><br><span class="line"><span class="number">13</span> 我消费了一个<span class="number">4</span></span><br><span class="line"><span class="number">14</span> 我生产了一个<span class="number">9</span></span><br><span class="line"><span class="number">15</span> 我生产了一个<span class="number">10</span></span><br><span class="line"><span class="number">16</span> 我生产了一个<span class="number">11</span></span><br><span class="line"><span class="number">17</span> 我消费了一个<span class="number">5</span></span><br><span class="line"><span class="number">18</span> 我生产了一个<span class="number">12</span></span><br><span class="line"><span class="number">19</span> 我生产了一个<span class="number">13</span></span><br><span class="line"><span class="number">20</span> 我生产了一个<span class="number">14</span></span><br><span class="line"><span class="number">21</span> 我消费了一个<span class="number">6</span></span><br><span class="line"><span class="number">22</span> 我生产了一个<span class="number">15</span></span><br><span class="line"><span class="number">23</span> 我生产了一个<span class="number">16</span></span><br><span class="line"><span class="number">24</span> 我消费了一个<span class="number">7</span></span><br><span class="line"><span class="number">25</span> 我生产了一个<span class="number">17</span></span><br><span class="line"><span class="number">26</span> 我消费了一个<span class="number">8</span></span><br><span class="line"><span class="number">27</span> 我生产了一个<span class="number">18</span></span><br></pre></td></tr></table></figure><p>分两部分来看输出结果：</p><p>1、第1行~第23行。这块BlockingQueue未满，所以生产者随便生产，消费者随便消费，基本上都是生产3个消费1个，消费者消费速度慢</p><p>2、第24行~第27行，从前面我们可以看出，生产到16，消费到6，说明到了ArrayBlockingQueue的极限10了，这时候没办法，生产者生产一个ArrayBlockingQueue就满了，所以不能继续生产了，只有等到消费者消费完才可以继续生产。所以之后的打印内容一定是一个生产者、一个消费者</p><p>这就是前面一章开头说的”<strong>通过平衡生产者和消费者的处理能力来提高整体处理数据的速度</strong>“，这给例子应该体现得很明显。另外，也不要担心非单一生产者/消费者场景下的系统假死问题，缓冲区空、缓冲区满的场景BlockingQueue都是定义了不同的Condition，所以不会唤醒自己的同类。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Queue是什么&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;队列，是一种数据结构。除了优先级队列和LIFO队列外，队列都是以FIFO（先进先出）的方式对各个元素进行排序的。无论使用哪种排序方式，队列的头都是调用remove()或poll()移除元素的。在FIFO队列中，所有新元素都插入队列的末尾。&lt;/p&gt;
    
    </summary>
    
      <category term="并发编程" scheme="https://caoler.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="阻塞队列" scheme="https://caoler.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/"/>
    
    
      <category term="阻塞队列" scheme="https://caoler.cn/tags/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>梦想破灭</title>
    <link href="https://caoler.cn//post/2018/over.html"/>
    <id>https://caoler.cn//post/2018/over.html</id>
    <published>2018-09-26T13:48:57.000Z</published>
    <updated>2018-09-26T13:49:20.907Z</updated>
    
    <content type="html"><![CDATA[<p>梦想破灭</p><p>2018年9月26日21:48:48</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;梦想破灭&lt;/p&gt;
&lt;p&gt;2018年9月26日21:48:48&lt;/p&gt;

      
    
    </summary>
    
      <category term="CodingLife" scheme="https://caoler.cn/categories/CodingLife/"/>
    
    
      <category term="CodingLife" scheme="https://caoler.cn/tags/CodingLife/"/>
    
  </entry>
  
  <entry>
    <title>JAVA获取当前函数名</title>
    <link href="https://caoler.cn//post/2018/getFileLineMethod.html"/>
    <id>https://caoler.cn//post/2018/getFileLineMethod.html</id>
    <published>2018-09-20T08:38:00.000Z</published>
    <updated>2018-10-14T12:55:06.311Z</updated>
    
    <content type="html"><![CDATA[<p>无具体描述</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat; </span><br><span class="line"><span class="keyword">import</span> java.util.Date; </span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">* Java实现类似C/C++中的__FILE__、__FUNC__、__LINE__等,主要用于日志等功能中。 </span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* <span class="doctag">@version</span> 1.0 2011-07-13 </span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonFunction</span> </span>&#123; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">    * 打印日志时获取当前的程序文件名、行号、方法名 输出格式为：[FileName | LineNumber | MethodName] </span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> </span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getFileLineMethod</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        StackTraceElement traceElement = ((<span class="keyword">new</span> Exception()).getStackTrace())[<span class="number">1</span>]; </span><br><span class="line">        StringBuffer toStringBuffer = <span class="keyword">new</span> StringBuffer(<span class="string">"["</span>).append( </span><br><span class="line">        traceElement.getFileName()).append(<span class="string">" | "</span>).append( </span><br><span class="line">        traceElement.getLineNumber()).append(<span class="string">" | "</span>).append( </span><br><span class="line">        traceElement.getMethodName()).append(<span class="string">"]"</span>); </span><br><span class="line">        <span class="keyword">return</span> toStringBuffer.toString(); </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当前文件名 </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">_FILE_</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        StackTraceElement traceElement = ((<span class="keyword">new</span> Exception()).getStackTrace())[<span class="number">1</span>]; </span><br><span class="line">        <span class="keyword">return</span> traceElement.getFileName(); </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当前方法名 </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">_FUNC_</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        StackTraceElement traceElement = ((<span class="keyword">new</span> Exception()).getStackTrace())[<span class="number">1</span>]; </span><br><span class="line">        <span class="keyword">return</span> traceElement.getMethodName(); </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当前行号 </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">_LINE_</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        StackTraceElement traceElement = ((<span class="keyword">new</span> Exception()).getStackTrace())[<span class="number">1</span>]; </span><br><span class="line">        <span class="keyword">return</span> traceElement.getLineNumber(); </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当前时间 </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">_TIME_</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        Date now = <span class="keyword">new</span> Date(); </span><br><span class="line">        SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss.SSS"</span>); </span><br><span class="line">        <span class="keyword">return</span> sdf.format(now); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;无具体描述&lt;/p&gt;
    
    </summary>
    
      <category term="JAVASE" scheme="https://caoler.cn/categories/JAVASE/"/>
    
    
      <category term="JAVASE" scheme="https://caoler.cn/tags/JAVASE/"/>
    
  </entry>
  
  <entry>
    <title>如何“做成”个人计划</title>
    <link href="https://caoler.cn//post/2018/how-to-plan.html"/>
    <id>https://caoler.cn//post/2018/how-to-plan.html</id>
    <published>2018-08-21T08:38:00.000Z</published>
    <updated>2018-10-14T12:55:56.800Z</updated>
    
    <content type="html"><![CDATA[<p>老大的一篇好笔记，偷走</p><h2 id="做成个人计划能给你带来什么"><a href="#做成个人计划能给你带来什么" class="headerlink" title="做成个人计划能给你带来什么"></a>做成个人计划能给你带来什么</h2><p>个人计划是一个让你走向优秀的途径。</p><p>能够给你带来能力上的提升，能够让你更加自信，能够让你拥有更多的机会。</p><p>上述文字绝非喊口号，而是根据亲身观察身边同事得出的结论。</p><a id="more"></a><h2 id="为什么大家的个人计划完成度都很低"><a href="#为什么大家的个人计划完成度都很低" class="headerlink" title="为什么大家的个人计划完成度都很低"></a>为什么大家的个人计划完成度都很低</h2><p>真的是因为<code>没有时间</code>么？还是说定的个人计划，其实并不是你真正<code>想做</code>的？亦或者是你确实想做成某个计划，但是却苦于不知道该怎么有效的去实施？</p><p>我们需要先找准自己的问题，才能针对性的加以改进。</p><h2 id="什么样才算做成个人计划"><a href="#什么样才算做成个人计划" class="headerlink" title="什么样才算做成个人计划"></a>什么样才算做成个人计划</h2><p><code>做成</code>和<code>完成</code>，在标准和意义上，是完全不一样的。这个不只是对个人计划而言，对你工作、生活中的任何事情，都是通用的。</p><p><code>完成</code>，仅仅只是完成既定的、可见的工作，比如完成某个工具的编码工作之类的。这部分工作很容易，但是这并不能帮助你真正实现目标。</p><p><code>做成</code>，则是从<code>结果</code>角度去衡量，有没有真正解决问题。</p><blockquote><p>我们公司的行为做事准则是：<code>以终为始</code>，<code>以结果为导向</code>。这也是程序员十大素养中的两条。</p></blockquote><p>这里举个例子，比如你感觉目前内网开发，跨部门合作因为数据问题很麻烦，想做一个mock工具来解决这个问题。那么：</p><blockquote><p>这个mock工具的编码开发，就属于<code>完成</code>，但是完成这个工作，并不能解决问题</p><p>完成工具的开发，并推广给所有人使用，让大家都接受这个工具和流程机制，从而让数据不再是内网开发的瓶颈，这才是<code>做成</code>这个事情</p></blockquote><p>还有<code>追女朋友</code>的例子，不管过程中你送了多少礼物，发了多少信息，最终没追到，就是没有达到目标，你还是不能脱离单身汪的行列。</p><h2 id="如何制定个人计划"><a href="#如何制定个人计划" class="headerlink" title="如何制定个人计划"></a>如何制定个人计划</h2><p>先思考一个问题：<code>你想成为什么样的人？</code></p><p>然后带着这个问题的答案，去制定你的个人计划。</p><p>个人感觉，一个优秀的个人计划，必须包含如下几个要素：</p><blockquote><p>0、有自我提升的意愿(可以理解为上进心。如果你不想让自己变得更好，那么是不可能克服提升过程中的痛苦的)</p><p>1、一定是你自己想做的(包括发自内心想做的事情，以及你面临的必须解决的困难)</p><p>2、具有持续性，周期比较长(想短短几天就给自己带来很大的提升，不现实；半年完成一个核心计划即可，做成一个比完成多个更好)</p><p>3、一定是对你个人有用的，能够帮你解决某个问题；如果能够同时帮助公司解决问题，那就更好了</p><p>4、具备可行性(成功率；比如你的计划是一个产品相关的计划，那么要考虑能否打败竞争对手、能否抢占市场和先机)</p><p>5、你认可这个计划，觉得它是有价值的</p></blockquote><p>当心里有一个想法后，你可以思考下：<code>做成这个计划，能给我带来什么？</code>借此来帮助自己判断该计划的价值。</p><p>当计划的方向确定后，具体制定细节内容时，可以参考<a href="https://baike.baidu.com/item/smart/2230883" target="_blank" rel="external">SMART原则</a>。</p><p>假如你是一个刚进入大学的新生，你想提升个人的英语水平，准备制定一个计划：</p><h3 id="具体的-Specific"><a href="#具体的-Specific" class="headerlink" title="具体的(Specific)"></a>具体的(Specific)</h3><p>提高英语水平(模糊) VS 通过英语四级(具体)</p><h3 id="可衡量的-Measurable"><a href="#可衡量的-Measurable" class="headerlink" title="可衡量的(Measurable)"></a>可衡量的(Measurable)</h3><p>四级考试分数</p><h3 id="可达到的-Attainable"><a href="#可达到的-Attainable" class="headerlink" title="可达到的(Attainable)"></a>可达到的(Attainable)</h3><p>英语四级(可达到) VS 英语八级(不可达到)</p><h3 id="相关性-Relevant"><a href="#相关性-Relevant" class="headerlink" title="相关性(Relevant)"></a>相关性(Relevant)</h3><p>课程相关，且过不了就没法毕业</p><h3 id="截止期限-Time-bound"><a href="#截止期限-Time-bound" class="headerlink" title="截止期限(Time-bound)"></a>截止期限(Time-bound)</h3><p>同考试日期</p><h2 id="如何做成个人计划"><a href="#如何做成个人计划" class="headerlink" title="如何做成个人计划"></a>如何做成个人计划</h2><p>这个可以参考身边的同事，看看他们是怎么做的。通过成功失败的案例来分析，是最直观的。</p><h3 id="成功案例"><a href="#成功案例" class="headerlink" title="成功案例"></a>成功案例</h3><h4 id="李晓栋的健身-这个案例比较特殊，不是公司内的个人计划"><a href="#李晓栋的健身-这个案例比较特殊，不是公司内的个人计划" class="headerlink" title="李晓栋的健身(这个案例比较特殊，不是公司内的个人计划)"></a>李晓栋的健身(这个案例比较特殊，不是公司内的个人计划)</h4><h4 id="焦生康的订餐系统"><a href="#焦生康的订餐系统" class="headerlink" title="焦生康的订餐系统"></a>焦生康的订餐系统</h4><h4 id="余庆的用户反馈流程"><a href="#余庆的用户反馈流程" class="headerlink" title="余庆的用户反馈流程"></a>余庆的用户反馈流程</h4><h4 id="淼哥的新人培训、重构版、虚拟桌面、运维系统、CRM"><a href="#淼哥的新人培训、重构版、虚拟桌面、运维系统、CRM" class="headerlink" title="淼哥的新人培训、重构版、虚拟桌面、运维系统、CRM"></a>淼哥的新人培训、重构版、虚拟桌面、运维系统、CRM</h4><h4 id="王海波的Docker容器化"><a href="#王海波的Docker容器化" class="headerlink" title="王海波的Docker容器化"></a>王海波的Docker容器化</h4><h3 id="失败案例"><a href="#失败案例" class="headerlink" title="失败案例"></a>失败案例</h3><h4 id="小组的API平台"><a href="#小组的API平台" class="headerlink" title="小组的API平台"></a>小组的API平台</h4><h4 id="我的周会主题机制"><a href="#我的周会主题机制" class="headerlink" title="我的周会主题机制"></a>我的周会主题机制</h4><h4 id="问答助手"><a href="#问答助手" class="headerlink" title="问答助手"></a>问答助手</h4><p>建议大家都去了解下上述案例(可以通过询问你的导师来了解)，然后自己思考下：上面的案例为什么成功/失败？决定成功与否的关键因素有哪些？</p><h2 id="组长在组员的个人计划中，应该承担哪些角色"><a href="#组长在组员的个人计划中，应该承担哪些角色" class="headerlink" title="组长在组员的个人计划中，应该承担哪些角色"></a>组长在组员的个人计划中，应该承担哪些角色</h2><p>在制定计划阶段，组长起到的，是一个引导者和审核者的角色；在计划执行过程中，则起到一个激励者的作用。</p><p>这是目前我们做得很差的地方。</p><h2 id="常见误区"><a href="#常见误区" class="headerlink" title="常见误区"></a>常见误区</h2><h3 id="没有思考过个人规划，目标不明确"><a href="#没有思考过个人规划，目标不明确" class="headerlink" title="没有思考过个人规划，目标不明确"></a>没有思考过个人规划，目标不明确</h3><p>具体的表现，就是定的个人计划很散乱。因为自己也不清楚自己将来想要成为什么样的人、当前欠缺什么，因此定计划就会很迷茫。经常是每个月都定好几个计划，然后每个月的计划都没什么关联，上个月还计划搞Node，下个月又去计划搞Java，最终什么也没做成。</p><p>好的计划，一定是具有持续性的，而不是短短一个月，做完就扔。</p><p>如果你对个人规划感到迷茫，建议你先通过身边的同事，或者你的导师，先对我们团队有一个清晰的了解，知道我们团队的现状、在团队中的发展机会(包括技术和非技术的)，然后让导师帮助你明确好自己的规划。</p><h3 id="计划内容脱离实际工作范围"><a href="#计划内容脱离实际工作范围" class="headerlink" title="计划内容脱离实际工作范围"></a>计划内容脱离实际工作范围</h3><p>能力的提升，必须要有一个环境，能够让你不断将学习到的东西进行实践，强化练习。否则你的知识都只会停留在理论层面。就像学校读书，为什么要有课后练习题？这是同样的道理。</p><p>所以计划最好能够和你的工作环境相结合。注意这里的结合，不是说将计划定成具体的工作内容，而是指你的计划能够在这个工作环境中加以运用、体现价值。</p><blockquote><p>只有在战场上才会诞生将军。</p></blockquote><p>举个例子：你在一个软件公司工作，然后你给自己定的计划是成为一个职业篮球运动员，那这个计划就是脱离实际工作范围的：一方面软件公司不具备让你成为职业篮球运动员的环境；另一方面即使你成为了职业篮球运动员，在这个公司也无法体现你在这方面的价值。</p><p>另外还有同事经常将个人计划定位<code>学习XX技术</code>，但是近期的工作内容根本不涉及这个技术，你学了之后，没有实际工作内容来给你锻炼和强化这个技术，这也是不合适的。</p><h3 id="将目标和要做的事情弄反了"><a href="#将目标和要做的事情弄反了" class="headerlink" title="将目标和要做的事情弄反了"></a>将目标和要做的事情弄反了</h3><p>做某件事情，是为了帮助我们达成某个目标；而我们很容易将两者弄反，最后只着眼于做某件事，至于能不能达成目标，反而被忽视了。</p><p>具体的体现就是，很多同事定的个人计划，都是“做XX工具”、“学习XX技术”，深入思考下，这些内容都只是做某件事，你真正想达到的目标，并不是这些表面上的事情。</p><h3 id="通过分配任务的方式给组员制定计划"><a href="#通过分配任务的方式给组员制定计划" class="headerlink" title="通过分配任务的方式给组员制定计划"></a>通过分配任务的方式给组员制定计划</h3><p>计划应该通过<code>激励</code>来促进大家执行，而不应该通过任务的形式来督促大家执行。</p><h3 id="舒适的执行计划"><a href="#舒适的执行计划" class="headerlink" title="舒适的执行计划"></a>舒适的执行计划</h3><p>个人计划的执行过程，是自我提升的过程，这肯定不是一个舒适的过程，如果你一直处于舒适区，那你肯定是没有什么提升的。我们可以通过自我激励，来度过这段非舒适的区域，最终享受成功带来的喜悦。</p><h3 id="将自己的个人计划，弄成了别人的个人计划"><a href="#将自己的个人计划，弄成了别人的个人计划" class="headerlink" title="将自己的个人计划，弄成了别人的个人计划"></a>将自己的个人计划，弄成了别人的个人计划</h3><p>计划的内容不是自己想做的，只是简单的参与别人的计划，或者完成别人给的任务，没有自己去主导计划。</p><blockquote><p>好的计划都是自下而上的，只有坏的计划才是自上而下。</p></blockquote><h3 id="计划都拖到月末才处理"><a href="#计划都拖到月末才处理" class="headerlink" title="计划都拖到月末才处理"></a>计划都拖到月末才处理</h3><p>都拖到月末了，说明你肯定是不重视这个计划的。发现这种问题，要及时调整：要么想办法让自己真正理解这个计划的重要性；要么更换你的计划，改为一个你自己想做的。</p><blockquote><p>好的计划是灯塔，坏的计划是束缚。</p></blockquote><h3 id="个人计划是为了帮助你，而不是为了打击你"><a href="#个人计划是为了帮助你，而不是为了打击你" class="headerlink" title="个人计划是为了帮助你，而不是为了打击你"></a>个人计划是为了帮助你，而不是为了打击你</h3><p>如果每个月的计划都不重视，都完成得很差，那么久而久之就会让你形成惰性；然后每次月末过总结，这些计划都会成给你的自信造成打击。我们一定要避免这种情况，让计划形成一个良性循环。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;老大的一篇好笔记，偷走&lt;/p&gt;
&lt;h2 id=&quot;做成个人计划能给你带来什么&quot;&gt;&lt;a href=&quot;#做成个人计划能给你带来什么&quot; class=&quot;headerlink&quot; title=&quot;做成个人计划能给你带来什么&quot;&gt;&lt;/a&gt;做成个人计划能给你带来什么&lt;/h2&gt;&lt;p&gt;个人计划是一个让你走向优秀的途径。&lt;/p&gt;
&lt;p&gt;能够给你带来能力上的提升，能够让你更加自信，能够让你拥有更多的机会。&lt;/p&gt;
&lt;p&gt;上述文字绝非喊口号，而是根据亲身观察身边同事得出的结论。&lt;/p&gt;
    
    </summary>
    
      <category term="计划" scheme="https://caoler.cn/categories/%E8%AE%A1%E5%88%92/"/>
    
    
      <category term="计划" scheme="https://caoler.cn/tags/%E8%AE%A1%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>Java并发之AQS详解</title>
    <link href="https://caoler.cn//post/2018/aqs.html"/>
    <id>https://caoler.cn//post/2018/aqs.html</id>
    <published>2018-08-20T08:38:00.000Z</published>
    <updated>2018-10-14T12:55:15.530Z</updated>
    
    <content type="html"><![CDATA[<p>人老了就有个习惯，看到好文就想保存下来。就担心一不留神哪天文章被删除了，可谓：楼主写的很好 可下一秒 这篇文章就是我的了。但是本着尊重作者劳动成果的前提，在知道来源的情况下，每篇转载的文章我都会注明原作者，且仅用作个人学习，若您看到这篇文章是你写的或者不允许转载，那还请您联系一下我，我会立刻删除，还望见谅！</p><p>多线程，并发编程一直是我能力最薄弱的地方，所以最近一直在补自己的短板，秋招也好，工作也好，对自己能力的提升还是很有帮助了，故转此下文。</p><a id="more"></a><p>本文来自cnblogs的大神<a href="http://www.cnblogs.com/waterystone/" target="_blank" rel="external">水岩</a>，原文链接：<a href="https://www.cnblogs.com/waterystone/p/4920797.html" target="_blank" rel="external">Java并发之AQS详解</a></p><p>[TOC]</p><h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>　　谈到并发，不得不谈ReentrantLock；而谈到ReentrantLock，不得不谈AbstractQueuedSynchronizer（AQS）！</p><p>　　类如其名，抽象的队列式的同步器，AQS定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它，如常用的ReentrantLock/Semaphore/CountDownLatch…。</p><p>　　以下是本文的目录大纲：</p><ol><li>概述</li><li>框架</li><li>源码详解</li><li>简单应用</li></ol><p>若有不正之处，请谅解和批评指正，不胜感激。</p><p>请尊重作者劳动成果，转载请标明原文链接：<a href="http://www.cnblogs.com/waterystone/p/4920797.html" target="_blank" rel="external">http://www.cnblogs.com/waterystone/p/4920797.html</a></p><p>手机版可访问：<a href="https://mp.weixin.qq.com/s/eyZyzk8ZzjwzZYN4a4H5YA" target="_blank" rel="external">https://mp.weixin.qq.com/s/eyZyzk8ZzjwzZYN4a4H5YA</a>　　</p><h1 id="二、框架"><a href="#二、框架" class="headerlink" title="二、框架"></a>二、框架</h1><p><img src="https://images2015.cnblogs.com/blog/721070/201705/721070-20170504110246211-10684485.png" alt="img"></p><p>　　它维护了一个volatile int state（代表共享资源）和一个FIFO线程等待队列（多线程争用资源被阻塞时会进入此队列）。这里volatile是核心关键词，具体volatile的语义，在此不述。state的访问方式有三种:</p><ul><li>getState()</li><li>setState()</li><li>compareAndSetState()</li></ul><p>　　AQS定义两种资源共享方式：Exclusive（独占，只有一个线程能执行，如ReentrantLock）和Share（共享，多个线程可同时执行，如Semaphore/CountDownLatch）。</p><p>　　不同的自定义同步器争用共享资源的方式也不同。<strong>自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可</strong>，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法：</p><ul><li>isHeldExclusively()：该线程是否正在独占资源。只有用到condition才需要去实现它。</li><li>tryAcquire(int)：独占方式。尝试获取资源，成功则返回true，失败则返回false。</li><li>tryRelease(int)：独占方式。尝试释放资源，成功则返回true，失败则返回false。</li><li>tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</li><li>tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。</li></ul><p>　　以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。</p><p>　　再以CountDownLatch以例，任务分为N个子线程去执行，state也初始化为N（注意N要与线程个数一致）。这N个子线程是并行执行的，每个子线程执行完后countDown()一次，state会CAS减1。等到所有子线程都执行完后(即state=0)，会unpark()主调用线程，然后主调用线程就会从await()函数返回，继续后余动作。</p><p>　　一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。但AQS也支持自定义同步器同时实现独占和共享两种方式，如ReentrantReadWriteLock。</p><h1 id="三、源码详解"><a href="#三、源码详解" class="headerlink" title="三、源码详解"></a>三、源码详解</h1><p>　　本节开始讲解AQS的源码实现。依照acquire-release、acquireShared-releaseShared的次序来。</p><h2 id="3-1-acquire-int"><a href="#3-1-acquire-int" class="headerlink" title="3.1 acquire(int)"></a>3.1 acquire(int)</h2><p>　　此方法是独占模式下线程获取共享资源的顶层入口。如果获取到资源，线程直接返回，否则进入等待队列，直到获取到资源为止，<strong>且整个过程忽略中断的影响</strong>。这也正是lock()的语义，当然不仅仅只限于lock()。获取到资源后，线程就可以去执行其临界区代码了。下面是acquire()的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　函数流程如下：    </p><ol><li>tryAcquire()尝试直接去获取资源，如果成功则直接返回；</li><li>addWaiter()将该线程加入等待队列的尾部，并标记为独占模式；</li><li>acquireQueued()使线程在等待队列中获取资源，一直获取到资源后才返回。如果在整个等待过程中被中断过，则返回true，否则返回false。</li><li>如果线程在等待过程中被中断过，它是不响应的。只是获取资源后才再进行自我中断selfInterrupt()，将中断补上。</li></ol><p>　　这时单凭这4个抽象的函数来看流程还有点朦胧，不要紧，看完接下来的分析后，你就会明白了。就像《大话西游》里唐僧说的：<strong>等你明白了舍生取义的道理，你自然会回来和我唱这首歌的</strong>。</p><h3 id="3-1-1-tryAcquire-int"><a href="#3-1-1-tryAcquire-int" class="headerlink" title="3.1.1 tryAcquire(int)"></a>3.1.1 tryAcquire(int)</h3><p>　　此方法尝试去获取独占资源。如果获取成功，则直接返回true，否则直接返回false。这也正是tryLock()的语义，还是那句话，当然不仅仅只限于tryLock()。如下是tryAcquire()的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　什么？直接throw异常？说好的功能呢？好吧，<strong>还记得概述里讲的AQS只是一个框架，具体资源的获取/释放方式交由自定义同步器去实现吗？</strong>就是这里了！！！AQS这里只定义了一个接口，具体资源的获取交由自定义同步器去实现了（通过state的get/set/CAS）！！！至于能不能重入，能不能加塞，那就看具体的自定义同步器怎么去设计了！！！当然，自定义同步器在进行资源访问时要考虑线程安全的影响。</p><p>　　这里之所以没有定义成abstract，是因为独占模式下只用实现tryAcquire-tryRelease，而共享模式下只用实现tryAcquireShared-tryReleaseShared。如果都定义成abstract，那么每个模式也要去实现另一模式下的接口。说到底，Doug Lea还是站在咱们开发者的角度，尽量减少不必要的工作量。</p><h3 id="3-1-2-addWaiter-Node"><a href="#3-1-2-addWaiter-Node" class="headerlink" title="3.1.2 addWaiter(Node)"></a>3.1.2 addWaiter(Node)</h3><p>　　此方法用于将当前线程加入到等待队列的队尾，并返回当前线程所在的结点。还是上源码吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//以给定模式构造结点。mode有两种：EXCLUSIVE（独占）和SHARED（共享）</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//尝试快速方式直接放到队尾。</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//上一步失败则通过enq入队。</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 不用再说了，直接看注释吧。这里我们说下Node。Node结点是对每一个访问同步代码的线程的封装，其包含了需要同步的线程本身以及线程的状态，如是否被阻塞，是否等待唤醒，是否已经被取消等。变量waitStatus则表示当前被封装成Node结点的等待状态，共有4种取值CANCELLED、SIGNAL、CONDITION、PROPAGATE。</p><ul><li><em>CANCELLED</em>：值为1，在同步队列中等待的线程等待超时或被中断，需要从同步队列中取消该Node的结点，其结点的waitStatus为CANCELLED，即结束状态，进入该状态后的结点将不会再变化。</li><li><em>SIGNAL</em>：值为-1，被标识为该等待唤醒状态的后继结点，当其前继结点的线程释放了同步锁或被取消，将会通知该后继结点的线程执行。说白了，就是处于唤醒状态，只要前继结点释放锁，就会通知标识为SIGNAL状态的后继结点的线程执行。</li><li><em>CONDITION</em>：值为-2，与Condition相关，该标识的结点处于<strong>等待队列</strong>中，结点的线程等待在Condition上，当其他线程调用了Condition的signal()方法后，CONDITION状态的结点将<strong>从等待队列转移到同步队列中</strong>，等待获取同步锁。</li><li><em>PROPAGATE</em>：值为-3，与共享模式相关，在共享模式中，该状态标识结点的线程处于可运行状态。</li><li><em>0状态</em>：值为0，代表初始化状态。</li></ul><p>AQS在判断状态时，通过用waitStatus&gt;0表示取消状态，而waitStatus&lt;0表示有效状态。</p><h4 id="3-1-2-1-enq-Node"><a href="#3-1-2-1-enq-Node" class="headerlink" title="3.1.2.1 enq(Node)"></a>3.1.2.1 enq(Node)</h4><p> 　　此方法用于将node加入队尾。源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//CAS"自旋"，直到成功加入队尾</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// 队列为空，创建一个空的标志结点作为head结点，并将tail也指向它。</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//正常流程，放入队尾</span></span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你看过AtomicInteger.getAndIncrement()函数源码，那么相信你一眼便看出这段代码的精华。<strong>CAS自旋volatile变量</strong>，是一种很经典的用法。还不太了解的，自己去百度一下吧。</p><h3 id="3-1-3-acquireQueued-Node-int"><a href="#3-1-3-acquireQueued-Node-int" class="headerlink" title="3.1.3 acquireQueued(Node, int)"></a>3.1.3 acquireQueued(Node, int)</h3><p>　　OK，通过tryAcquire()和addWaiter()，该线程获取资源失败，已经被放入等待队列尾部了。聪明的你立刻应该能想到该线程下一部该干什么了吧：<strong>进入等待状态休息，直到其他线程彻底释放资源后唤醒自己，自己再拿到资源，然后就可以去干自己想干的事了</strong>。没错，就是这样！是不是跟医院排队拿号有点相似~~acquireQueued()就是干这件事：<strong>在等待队列中排队拿号（中间没其它事干可以休息），直到拿到号后再返回</strong>。这个函数非常关键，还是上源码吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;<span class="comment">//标记是否成功拿到资源</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;<span class="comment">//标记等待过程中是否被中断过</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//又是一个“自旋”！</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();<span class="comment">//拿到前驱</span></span><br><span class="line">            <span class="comment">//如果前驱是head，即该结点已成老二，那么便有资格去尝试获取资源（可能是老大释放完资源唤醒自己的，当然也可能被interrupt了）。</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);<span class="comment">//拿到资源后，将head指向该结点。所以head所指的标杆结点，就是当前获取到资源的那个结点或null。</span></span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// setHead中node.prev已置为null，此处再将head.next置为null，就是为了方便GC回收以前的head结点。也就意味着之前拿完资源的结点出队了！</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;<span class="comment">//返回等待过程中是否被中断过</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//如果自己可以休息了，就进入waiting状态，直到被unpark()</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;<span class="comment">//如果等待过程中被中断过，哪怕只有那么一次，就将interrupted标记为true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里了，我们先不急着总结acquireQueued()的函数流程，先看看shouldParkAfterFailedAcquire()和parkAndCheckInterrupt()具体干些什么。</p><h4 id="3-1-3-1-shouldParkAfterFailedAcquire-Node-Node"><a href="#3-1-3-1-shouldParkAfterFailedAcquire-Node-Node" class="headerlink" title="3.1.3.1 shouldParkAfterFailedAcquire(Node, Node)"></a>3.1.3.1 shouldParkAfterFailedAcquire(Node, Node)</h4><p>　　此方法主要用于检查状态，看看自己是否真的可以去休息了（进入waiting状态，如果线程状态转换不熟，可以参考本人上一篇写的<a href="http://www.cnblogs.com/waterystone/p/4920007.html" target="_blank" rel="external">Thread详解</a>），万一队列前边的线程都放弃了只是瞎站着，那也说不定，对吧！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;<span class="comment">//拿到前驱的状态</span></span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="comment">//如果已经告诉前驱拿完号后通知自己一下，那就可以安心休息了</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 如果前驱放弃了，那就一直往前找，直到找到最近一个正常等待的状态，并排在它的后边。</span></span><br><span class="line"><span class="comment">         * 注意：那些放弃的结点，由于被自己“加塞”到它们前边，它们相当于形成一个无引用链，稍后就会被保安大叔赶走了(GC回收)！</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">//如果前驱正常，那就把前驱的状态设置成SIGNAL，告诉它拿完号后通知自己一下。有可能失败，人家说不定刚刚释放完呢！</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个流程中，如果前驱结点的状态不是SIGNAL，那么自己就不能安心去休息，需要去找个安心的休息点，同时可以再尝试下看有没有机会轮到自己拿号。</p><h4 id="3-1-3-2-parkAndCheckInterrupt"><a href="#3-1-3-2-parkAndCheckInterrupt" class="headerlink" title="3.1.3.2 parkAndCheckInterrupt()"></a>3.1.3.2 parkAndCheckInterrupt()</h4><p>　　如果线程找好安全休息点后，那就可以安心去休息了。此方法就是让线程去休息，真正进入等待状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);<span class="comment">//调用park()使线程进入waiting状态</span></span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();<span class="comment">//如果被唤醒，查看自己是不是被中断的。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 　　park()会让当前线程进入waiting状态。在此状态下，有两种途径可以唤醒该线程：1）被unpark()；2）被interrupt()。（再说一句，如果线程状态转换不熟，可以参考本人写的<a href="http://www.cnblogs.com/waterystone/p/4920007.html" target="_blank" rel="external">Thread详解</a>）。需要注意的是，Thread.interrupted()会清除当前线程的中断标记位。 </p><h4 id="3-1-3-3-小结"><a href="#3-1-3-3-小结" class="headerlink" title="3.1.3.3 小结"></a>3.1.3.3 小结</h4><p>　　OK，看了shouldParkAfterFailedAcquire()和parkAndCheckInterrupt()，现在让我们再回到acquireQueued()，总结下该函数的具体流程：</p><ol><li>结点进入队尾后，检查状态，找到安全休息点；</li><li>调用park()进入waiting状态，等待unpark()或interrupt()唤醒自己；</li><li>被唤醒后，看自己是不是有资格能拿到号。如果拿到，head指向当前结点，并返回从入队到拿到号的整个过程中是否被中断过；如果没拿到，继续流程1。</li></ol><h3 id="3-1-4-小结"><a href="#3-1-4-小结" class="headerlink" title="3.1.4 小结"></a>3.1.4 小结</h3><p>　　OKOK，acquireQueued()分析完之后，我们接下来再回到acquire()！再贴上它的源码吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来总结下它的流程吧：</p><ol><li>调用自定义同步器的tryAcquire()尝试直接去获取资源，如果成功则直接返回；</li><li>没成功，则addWaiter()将该线程加入等待队列的尾部，并标记为独占模式；</li><li>acquireQueued()使线程在等待队列中休息，有机会时（轮到自己，会被unpark()）会去尝试获取资源。获取到资源后才返回。如果在整个等待过程中被中断过，则返回true，否则返回false。</li><li>如果线程在等待过程中被中断过，它是不响应的。只是获取资源后才再进行自我中断selfInterrupt()，将中断补上。</li></ol><p>由于此函数是重中之重，我再用流程图总结一下：</p><p><img src="https://images2015.cnblogs.com/blog/721070/201511/721070-20151102145743461-623794326.png" alt="img"></p><p>至此，acquire()的流程终于算是告一段落了。这也就是ReentrantLock.lock()的流程，不信你去看其lock()源码吧，整个函数就是一条acquire(1)！！！</p><h2 id="3-2-release-int"><a href="#3-2-release-int" class="headerlink" title="3.2 release(int)"></a>3.2 release(int)</h2><p> 　　上一小节已经把acquire()说完了，这一小节就来讲讲它的反操作release()吧。此方法是独占模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果彻底释放了（即state=0）,它会唤醒等待队列里的其他线程来获取资源。这也正是unlock()的语义，当然不仅仅只限于unlock()。下面是release()的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;<span class="comment">//找到头结点</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);<span class="comment">//唤醒等待队列里的下一个线程</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　逻辑并不复杂。它调用tryRelease()来释放资源。有一点需要注意的是，<strong>它是根据tryRelease()的返回值来判断该线程是否已经完成释放掉资源了！所以自定义同步器在设计tryRelease()的时候要明确这一点！！</strong></p><h3 id="3-2-1-tryRelease-int"><a href="#3-2-1-tryRelease-int" class="headerlink" title="3.2.1 tryRelease(int)"></a>3.2.1 tryRelease(int)</h3><p>　　此方法尝试去释放指定量的资源。下面是tryRelease()的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　跟tryAcquire()一样，这个方法是需要独占模式的自定义同步器去实现的。正常来说，tryRelease()都会成功的，因为这是独占模式，该线程来释放资源，那么它肯定已经拿到独占资源了，直接减掉相应量的资源即可(state-=arg)，也不需要考虑线程安全的问题。但要注意它的返回值，上面已经提到了，<strong>release()是根据tryRelease()的返回值来判断该线程是否已经完成释放掉资源了！</strong>所以自义定同步器在实现时，如果已经彻底释放资源(state=0)，要返回true，否则返回false。</p><h3 id="3-2-2-unparkSuccessor-Node"><a href="#3-2-2-unparkSuccessor-Node" class="headerlink" title="3.2.2 unparkSuccessor(Node)"></a>3.2.2 unparkSuccessor(Node)</h3><p>　　此方法用于唤醒等待队列中下一个线程。下面是源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这里，node一般为当前线程所在的结点。</span></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)<span class="comment">//置零当前线程所在的结点状态，允许失败。</span></span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    Node s = node.next;<span class="comment">//找到下一个需要唤醒的结点s</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;<span class="comment">//如果为空或已取消</span></span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)<span class="comment">//从这里可以看出，&lt;=0的结点，都是还有效的结点。</span></span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);<span class="comment">//唤醒</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个函数并不复杂。一句话概括：<strong>用unpark()唤醒等待队列中最前边的那个未放弃线程</strong>，这里我们也用s来表示吧。此时，再和acquireQueued()联系起来，s被唤醒后，进入if (p == head &amp;&amp; tryAcquire(arg))的判断（即使p!=head也没关系，它会再进入shouldParkAfterFailedAcquire()寻找一个安全点。这里既然s已经是等待队列中最前边的那个未放弃线程了，那么通过shouldParkAfterFailedAcquire()的调整，s也必然会跑到head的next结点，下一次自旋p==head就成立啦），然后s把自己设置成head标杆结点，表示自己已经获取到资源了，acquire()也返回了！！And then, DO what you WANT!</p><h3 id="3-2-3-小结"><a href="#3-2-3-小结" class="headerlink" title="3.2.3 小结"></a>3.2.3 小结</h3><p>　　release()是独占模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果彻底释放了（即state=0）,它会唤醒等待队列里的其他线程来获取资源。</p><h2 id="3-3-acquireShared-int"><a href="#3-3-acquireShared-int" class="headerlink" title="3.3 acquireShared(int)"></a>3.3 acquireShared(int)</h2><p>　　此方法是共享模式下线程获取共享资源的顶层入口。它会获取指定量的资源，获取成功则直接返回，获取失败则进入等待队列，直到获取到资源为止，整个过程忽略中断。下面是acquireShared()的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">  doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这里tryAcquireShared()依然需要自定义同步器去实现。但是AQS已经把其返回值的语义定义好了：负值代表获取失败；0代表获取成功，但没有剩余资源；正数表示获取成功，还有剩余资源，其他线程还可以去获取。所以这里acquireShared()的流程就是：</p><ol><li>tryAcquireShared()尝试获取资源，成功则直接返回；</li><li>失败则通过doAcquireShared()进入等待队列，直到获取到资源为止才返回。</li></ol><h3 id="3-3-1-doAcquireShared-int"><a href="#3-3-1-doAcquireShared-int" class="headerlink" title="3.3.1 doAcquireShared(int)"></a>3.3.1 doAcquireShared(int)</h3><p>　　此方法用于将当前线程加入等待队列尾部休息，直到其他线程释放资源唤醒自己，自己成功拿到相应量的资源后才返回。下面是doAcquireShared()的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);<span class="comment">//加入队列尾部</span></span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;<span class="comment">//是否成功标志</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;<span class="comment">//等待过程中是否被中断过的标志</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();<span class="comment">//前驱</span></span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;<span class="comment">//如果到head的下一个，因为head是拿到资源的线程，此时node被唤醒，很可能是head用完资源来唤醒自己的</span></span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);<span class="comment">//尝试获取资源</span></span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;<span class="comment">//成功</span></span><br><span class="line">                    setHeadAndPropagate(node, r);<span class="comment">//将head指向自己，还有剩余资源可以再唤醒之后的线程</span></span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    <span class="keyword">if</span> (interrupted)<span class="comment">//如果等待过程中被打断过，此时将中断补上。</span></span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//判断状态，寻找安全点，进入waiting状态，等着被unpark()或interrupt()</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　有木有觉得跟acquireQueued()很相似？对，其实流程并没有太大区别。只不过这里将补中断的selfInterrupt()放到doAcquireShared()里了，而独占模式是放到acquireQueued()之外，其实都一样，不知道Doug Lea是怎么想的。</p><p>　　跟独占模式比，还有一点需要注意的是，这里只有线程是head.next时（“老二”），才会去尝试获取资源，有剩余的话还会唤醒之后的队友。那么问题就来了，假如老大用完后释放了5个资源，而老二需要6个，老三需要1个，老四需要2个。老大先唤醒老二，老二一看资源不够，他是把资源让给老三呢，还是不让？答案是否定的！老二会继续park()等待其他线程释放资源，也更不会去唤醒老三和老四了。独占模式，同一时刻只有一个线程去执行，这样做未尝不可；但共享模式下，多个线程是可以同时执行的，现在因为老二的资源需求量大，而把后面量小的老三和老四也都卡住了。当然，这并不是问题，只是AQS保证严格按照入队顺序唤醒罢了（保证公平，但降低了并发）。</p><h4 id="3-3-1-1-setHeadAndPropagate-Node-int"><a href="#3-3-1-1-setHeadAndPropagate-Node-int" class="headerlink" title="3.3.1.1 setHeadAndPropagate(Node, int)"></a>3.3.1.1 setHeadAndPropagate(Node, int)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">    Node h = head; </span><br><span class="line">    setHead(node);<span class="comment">//head指向自己</span></span><br><span class="line">     <span class="comment">//如果还有剩余量，继续唤醒下一个邻居线程</span></span><br><span class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        Node s = node.next;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())</span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　此方法在setHead()的基础上多了一步，就是自己苏醒的同时，如果条件符合（比如还有剩余资源），还会去唤醒后继结点，毕竟是共享模式！</p><p>　　doReleaseShared()我们留着下一小节的releaseShared()里来讲。</p><h3 id="3-3-2-小结"><a href="#3-3-2-小结" class="headerlink" title="3.3.2 小结"></a>3.3.2 小结</h3><p>　　OK，至此，acquireShared()也要告一段落了。让我们再梳理一下它的流程：</p><ol><li><ol><li>tryAcquireShared()尝试获取资源，成功则直接返回；</li><li>失败则通过doAcquireShared()进入等待队列park()，直到被unpark()/interrupt()并成功获取到资源才返回。整个等待过程也是忽略中断的。</li></ol></li></ol><p>　　其实跟acquire()的流程大同小异，只不过多了个<strong>自己拿到资源后，还会去唤醒后继队友的操作（这才是共享嘛）</strong>。</p><h2 id="3-4-releaseShared"><a href="#3-4-releaseShared" class="headerlink" title="3.4 releaseShared()"></a>3.4 releaseShared()</h2><p>　　上一小节已经把acquireShared()说完了，这一小节就来讲讲它的反操作releaseShared()吧。此方法是共享模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果成功释放且允许唤醒等待线程，它会唤醒等待队列里的其他线程来获取资源。下面是releaseShared()的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;<span class="comment">//尝试释放资源</span></span><br><span class="line">        doReleaseShared();<span class="comment">//唤醒后继结点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　此方法的流程也比较简单，一句话：<strong>释放掉资源后，唤醒后继</strong>。跟独占模式下的release()相似，但有一点稍微需要注意：独占模式下的tryRelease()在完全释放掉资源（state=0）后，才会返回true去唤醒其他线程，这主要是基于独占下可重入的考量；而共享模式下的releaseShared()则没有这种要求，共享模式实质就是控制一定量的线程并发执行，那么拥有资源的线程在释放掉部分资源时就可以唤醒后继等待结点。例如，资源总量是13，A（5）和B（7）分别获取到资源并发运行，C（4）来时只剩1个资源就需要等待。A在运行过程中释放掉2个资源量，然后tryReleaseShared(2)返回true唤醒C，C一看只有3个仍不够继续等待；随后B又释放2个，tryReleaseShared(2)返回true唤醒C，C一看有5个够自己用了，然后C就可以跟A和B一起运行。而ReentrantReadWriteLock读锁的tryReleaseShared()只有在完全释放掉资源（state=0）才返回true，所以自定义同步器可以根据需要决定tryReleaseShared()的返回值。</p><h3 id="3-4-1-doReleaseShared"><a href="#3-4-1-doReleaseShared" class="headerlink" title="3.4.1 doReleaseShared()"></a>3.4.1 doReleaseShared()</h3><p>　　此方法主要用于唤醒后继。下面是它的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                unparkSuccessor(h);<span class="comment">//唤醒后继</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head)<span class="comment">// head发生变化</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-5-小结"><a href="#3-5-小结" class="headerlink" title="3.5 小结"></a>3.5 小结</h2><p>　　本节我们详解了独占和共享两种模式下获取-释放资源(acquire-release、acquireShared-releaseShared)的源码，相信大家都有一定认识了。值得注意的是，acquire()和acquireSahred()两种方法下，线程在等待队列中都是忽略中断的。AQS也支持响应中断的，acquireInterruptibly()/acquireSharedInterruptibly()即是，这里相应的源码跟acquire()和acquireSahred()差不多，这里就不再详解了。</p><h1 id="四、简单应用"><a href="#四、简单应用" class="headerlink" title="四、简单应用"></a>四、简单应用</h1><p>　　通过前边几个章节的学习，相信大家已经基本理解AQS的原理了。这里再将“框架”一节中的一段话复制过来：</p><p>　　不同的自定义同步器争用共享资源的方式也不同。<strong>自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可</strong>，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法：</p><ul><li><em>isHeldExclusively()</em>：该线程是否正在独占资源。只有用到condition才需要去实现它。</li><li><em>tryAcquire(int)</em>：独占方式。尝试获取资源，成功则返回true，失败则返回false。</li><li><em>tryRelease(int)</em>：独占方式。尝试释放资源，成功则返回true，失败则返回false。</li><li><em>tryAcquireShared(int)</em>：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</li><li><em>tryReleaseShared(int)</em>：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。</li></ul><p>　　OK，下面我们就以AQS源码里的Mutex为例，讲一下AQS的简单应用。</p><h2 id="4-1-Mutex（互斥锁）"><a href="#4-1-Mutex（互斥锁）" class="headerlink" title="4.1 Mutex（互斥锁）"></a>4.1 Mutex（互斥锁）</h2><p>　　Mutex是一个不可重入的互斥锁实现。锁资源（AQS里的state）只有两种状态：0表示未锁定，1表示锁定。下边是Mutex的核心源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mutex</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 自定义同步器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断是否锁定状态</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getState() == <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试获取资源，立即返回。成功则返回true，否则false。</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">assert</span> acquires == <span class="number">1</span>; <span class="comment">// 这里限定只能为1个量</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;<span class="comment">//state为0才设置为1，不可重入！</span></span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());<span class="comment">//设置为当前线程独占资源</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试释放资源，立即返回。成功则为true，否则false。</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">assert</span> releases == <span class="number">1</span>; <span class="comment">// 限定为1个量</span></span><br><span class="line">            <span class="keyword">if</span> (getState() == <span class="number">0</span>)<span class="comment">//既然来释放，那肯定就是已占有状态了。只是为了保险，多层判断！</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">            setState(<span class="number">0</span>);<span class="comment">//释放资源，放弃占有状态</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 真正同步类的实现都依赖继承于AQS的自定义同步器！</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync = <span class="keyword">new</span> Sync();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//lock&lt;--&gt;acquire。两者语义一样：获取资源，即便等待，直到成功才返回。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//tryLock&lt;--&gt;tryAcquire。两者语义一样：尝试获取资源，要求立即返回。成功则为true，失败则为false。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//unlock&lt;--&gt;release。两者语文一样：释放资源。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//锁是否占有状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.isHeldExclusively();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　同步类在实现时一般都将自定义同步器（sync）定义为内部类，供自己使用；而同步类自己（Mutex）则实现某个接口，对外服务。当然，接口的实现要直接依赖sync，它们在语义上也存在某种对应关系！！而sync只用实现资源state的获取-释放方式tryAcquire-tryRelelase，至于线程的排队、等待、唤醒等，上层的AQS都已经实现好了，我们不用关心。</p><p>　　除了Mutex，ReentrantLock/CountDownLatch/Semphore这些同步类的实现方式都差不多，不同的地方就在获取-释放资源的方式tryAcquire-tryRelelase。掌握了这点，AQS的核心便被攻破了！</p><p>　　OK，至此，整个AQS的讲解也要落下帷幕了。希望本文能够对学习Java并发编程的同学有所借鉴，中间写的有不对的地方，也欢迎讨论和指正~</p><p>作者：<a href="http://www.cnblogs.com/waterystone/" target="_blank" rel="external">水岩</a></p><p>出处：<a href="http://www.cnblogs.com/waterystone/" target="_blank" rel="external">http://www.cnblogs.com/waterystone/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;人老了就有个习惯，看到好文就想保存下来。就担心一不留神哪天文章被删除了，可谓：楼主写的很好 可下一秒 这篇文章就是我的了。但是本着尊重作者劳动成果的前提，在知道来源的情况下，每篇转载的文章我都会注明原作者，且仅用作个人学习，若您看到这篇文章是你写的或者不允许转载，那还请您联系一下我，我会立刻删除，还望见谅！&lt;/p&gt;
&lt;p&gt;多线程，并发编程一直是我能力最薄弱的地方，所以最近一直在补自己的短板，秋招也好，工作也好，对自己能力的提升还是很有帮助了，故转此下文。&lt;/p&gt;
    
    </summary>
    
      <category term="并发编程" scheme="https://caoler.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="锁" scheme="https://caoler.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E9%94%81/"/>
    
    
      <category term="AQS" scheme="https://caoler.cn/tags/AQS/"/>
    
  </entry>
  
  <entry>
    <title>logrotate解决Tomcat catalina.out日志过大的问题</title>
    <link href="https://caoler.cn//post/2018/logrotate.html"/>
    <id>https://caoler.cn//post/2018/logrotate.html</id>
    <published>2018-08-18T08:38:00.000Z</published>
    <updated>2018-10-14T12:55:23.579Z</updated>
    
    <content type="html"><![CDATA[<p>由于tomcat不能按照日志的大小、保存日期进行自动切割，导致日志文件过大，查找分析日志的效率变低。所以利用linux的一个工具进行管理。</p><a id="more"></a><h3 id="一、介绍日志切割logrotate"><a href="#一、介绍日志切割logrotate" class="headerlink" title="一、介绍日志切割logrotate"></a>一、介绍日志切割logrotate</h3><p>　　对于Linux系统安全来说，日志文件是极其重要的工具。不知为何，我发现很多运维同学的服务器上都运行着一些诸如每天切分Nginx日志之类的CRON脚本，大家似乎遗忘了Logrotate，争相发明自己的轮子，这真是让人沮丧啊！就好比明明身边躺着现成的性感美女，大家却忙着自娱自乐，罪过！</p><p>　　logrotate程序是一个日志文件管理工具。用于<strong>分割日志文件，删除旧的日志文件，并创建新的日志文件，起到”转储”作用。可以节省磁盘空间</strong>。例如，你可以设置logrotate，让/var/log/logfile日志文件每30天轮循，并删除超过6个月的日志。配置完后，logrotate的运作完全自动化，不必进行任何进一步的人为干预。</p><h3 id="二、安装配置"><a href="#二、安装配置" class="headerlink" title="二、安装配置"></a>二、安装配置</h3><p>这里安装和配置过程省略。</p><h3 id="三、配置tomcat"><a href="#三、配置tomcat" class="headerlink" title="三、配置tomcat"></a>三、配置tomcat</h3><p>首先创建tomcat.conf(需要在logrotate的安装目录对应位置)</p><p>include <code>tomcat.out</code> 到 <code>catalina.out</code></p><p>tomcat.conf的配置如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/logrotate.d/config/tomcat/catalina.out &#123;</span><br><span class="line">daily         </span><br><span class="line">rotate 15</span><br><span class="line">missingok</span><br><span class="line">notifempty</span><br><span class="line">dateext</span><br><span class="line">compress</span><br><span class="line">create 644 root root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置解释：</p><table><thead><tr><th><strong>配置参数</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>monthly</strong></td><td>日志文件将按月轮循。其它可用值为’daily’，’weekly’或者’yearly’。</td></tr><tr><td><strong>rotate 5</strong></td><td>一次将存储5个归档日志。对于第六个归档，时间最久的归档将被删除。</td></tr><tr><td><strong>compress</strong></td><td>在轮循任务完成后，已轮循的归档将使用gzip进行压缩。</td></tr><tr><td><strong>delaycompress</strong></td><td>总是与compress选项一起用，delaycompress选项指示logrotate不要将最近的归档压缩，压缩将在下一次轮循周期进行。这在你或任何软件仍然需要读取最新归档时很有用。</td></tr><tr><td><strong>missingok</strong></td><td>在日志轮循期间，任何错误将被忽略，例如“文件无法找到”之类的错误。</td></tr><tr><td><strong>notifempty</strong></td><td>如果日志文件为空，轮循不会进行。</td></tr><tr><td><strong>dateext</strong></td><td>切换后的日志文件会附加上一个短横线和YYYYMMDD格式的日期，没有这个配置项会附加一个小数点加一个数字序号</td></tr><tr><td><strong>sharedscripts</strong></td><td>在所有其它指令完成后，postrotate和endscript里面指定的命令将被执行。在这种情况下，rsyslogd 进程将立即再次读取其配置并继续运行。</td></tr><tr><td><strong>create 644 root root</strong></td><td>以指定的权限创建全新的日志文件，同时logrotate也会重命名原始日志文件。</td></tr><tr><td><strong>postrotate/endscript</strong></td><td>在所有其它指令完成后，postrotate和endscript里面指定的命令将被执行。在这种情况下，rsyslogd 进程将立即再次读取其配置并继续运行。</td></tr></tbody></table><p>这里只列举了一部分。可按需进行配置。</p><h3 id="四、参考"><a href="#四、参考" class="headerlink" title="四、参考"></a>四、参考</h3><ul><li><a href="https://www.imooc.com/article/37104?block_id=tuijian_wz" target="_blank" rel="external">https://www.imooc.com/article/37104?block_id=tuijian_wz</a></li><li><a href="http://blog.51cto.com/5iqiong/790908" target="_blank" rel="external">http://blog.51cto.com/5iqiong/790908</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于tomcat不能按照日志的大小、保存日期进行自动切割，导致日志文件过大，查找分析日志的效率变低。所以利用linux的一个工具进行管理。&lt;/p&gt;
    
    </summary>
    
      <category term="实用教程" scheme="https://caoler.cn/categories/%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B/"/>
    
      <category term="日志分割" scheme="https://caoler.cn/categories/%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B/%E6%97%A5%E5%BF%97%E5%88%86%E5%89%B2/"/>
    
    
      <category term="logrotate" scheme="https://caoler.cn/tags/logrotate/"/>
    
  </entry>
  
  <entry>
    <title>全面理解Java内存模型</title>
    <link href="https://caoler.cn//post/2018/jmm.html"/>
    <id>https://caoler.cn//post/2018/jmm.html</id>
    <published>2018-08-13T08:38:00.000Z</published>
    <updated>2018-10-14T12:55:51.630Z</updated>
    
    <content type="html"><![CDATA[<p>转载自CSDN-<a href="https://blog.csdn.net/javazejian/article/details/72772461" target="_blank" rel="external">全面理解Java内存模型(JMM)及volatile关键字</a></p><h1 id="理解Java内存区域与Java内存模型"><a href="#理解Java内存区域与Java内存模型" class="headerlink" title="理解Java内存区域与Java内存模型"></a>理解Java内存区域与Java内存模型</h1><h2 id="Java内存区域"><a href="#Java内存区域" class="headerlink" title="Java内存区域"></a>Java内存区域</h2><p><img src="https://ws1.sinaimg.cn/large/005DnJLEly1fu8x1lpjxrj30jx097goo.jpg" alt=""></p><p>Java虚拟机在运行程序时会把其自动管理的内存划分为以上几个区域，每个区域都有的用途以及创建销毁的时机，其中蓝色部分代表的是所有线程共享的数据区域，而绿色部分代表的是每个线程的私有数据区域。</p><a id="more"></a><ul><li><p>方法区（Method Area）：</p><p>方法区属于线程共享的内存区域，又称Non-Heap（非堆），主要用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据，根据Java 虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError 异常。值得注意的是在方法区中存在一个叫运行时常量池(Runtime Constant Pool）的区域，它主要用于存放编译器生成的各种字面量和符号引用，这些内容将在类加载后存放到运行时常量池中，以便后续使用。</p></li><li><p>JVM堆（Java Heap）：</p><p>Java 堆也是属于线程共享的内存区域，它在虚拟机启动时创建，是Java 虚拟机所管理的内存中最大的一块，主要用于存放对象实例，几乎所有的对象实例都在这里分配内存，注意Java 堆是垃圾收集器管理的主要区域，因此很多时候也被称做GC 堆，如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError 异常。</p></li><li><p>程序计数器(Program Counter Register)：</p><p>属于线程私有的数据区域，是一小块内存空间，主要代表当前线程所执行的字节码行号指示器。字节码解释器工作时，通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p></li><li><p>虚拟机栈(Java Virtual Machine Stacks)：</p><p>属于线程私有的数据区域，与线程同时创建，总数与线程关联，代表Java方法执行的内存模型。每个方法执行时都会创建一个栈桢来存储方法的的变量表、操作数栈、动态链接方法、返回值、返回地址等信息。每个方法从调用直结束就对于一个栈桢在虚拟机栈中的入栈和出栈过程，如下（图有误，应该为栈桢）：</p><p><img src="https://ws1.sinaimg.cn/large/005DnJLEly1fu8x2lbckcj30iu0a1whq.jpg" alt=""></p></li><li><p>本地方法栈(Native Method Stacks)：</p><p>本地方法栈属于线程私有的数据区域，这部分主要与虚拟机用到的 Native 方法相关，一般情况下，我们无需关心此区域。</p></li></ul><p>这里之所以简要说明这部分内容，注意是为了区别Java内存模型与Java内存区域的划分，毕竟这两种划分是属于不同层次的概念。</p><h2 id="Java内存模型概述"><a href="#Java内存模型概述" class="headerlink" title="Java内存模型概述"></a>Java内存模型概述</h2><p>Java内存模型(即Java Memory Model，简称JMM)本身是一种抽象的概念，并不真实存在，它描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式。由于JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存(有些地方称为栈空间)，用于存储线程私有的数据，而Java内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问，但线程对变量的操作(读取赋值等)必须在工作内存中进行，首先要将变量从主内存拷贝的自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量，工作内存中存储着主内存中的变量副本拷贝，前面说过，工作内存是每个线程的私有数据区域，因此不同的线程间无法访问对方的工作内存，线程间的通信(传值)必须通过主内存来完成，其简要访问过程如下图</p><p><img src="https://ws1.sinaimg.cn/large/005DnJLEly1fu8x6zlm3hj30lp0dywjg.jpg" alt=""></p><p>需要注意的是，JMM与Java内存区域的划分是不同的概念层次，更恰当说JMM描述的是一组规则，通过这组规则控制程序中各个变量在共享数据区域和私有数据区域的访问方式，JMM是围绕原子性，有序性、可见性展开的(稍后会分析)。JMM与Java内存区域唯一相似点，都存在共享数据区域和私有数据区域，在JMM中主内存属于共享数据区域，从某个程度上讲应该包括了堆和方法区，而工作内存数据线程私有数据区域，从某个程度上讲则应该包括程序计数器、虚拟机栈以及本地方法栈。或许在某些地方，我们可能会看见主内存被描述为堆内存，工作内存被称为线程栈，实际上他们表达的都是同一个含义。关于JMM中的主内存和工作内存说明如下</p><ul><li><p>主内存</p><p>主要存储的是Java实例对象，所有线程创建的实例对象都存放在主内存中，不管该<strong>实例对象是成员变量还是方法中的本地变量(也称局部变量)</strong>，当然也包括了共享的类信息、常量、静态变量。由于是共享数据区域，多条线程对同一个变量进行访问可能会发现线程安全问题。</p></li><li><p>工作内存</p><p>主要存储当前方法的所有本地变量信息(工作内存中存储着主内存中的变量副本拷贝)，每个线程只能访问自己的工作内存，即线程中的本地变量对其它线程是不可见的，就算是两个线程执行的是同一段代码，它们也会各自在自己的工作内存中创建属于当前线程的本地变量，当然也包括了字节码行号指示器、相关Native方法的信息。注意由于工作内存是每个线程的私有数据，线程间无法相互访问工作内存，因此存储在工作内存的数据不存在线程安全问题。</p></li></ul><p>弄清楚主内存和工作内存后，接了解一下主内存与工作内存的数据存储类型以及操作方式，根据虚拟机规范，对于一个实例对象中的成员方法而言，<strong>如果方法中包含本地变量是基本数据类型（boolean,byte,short,char,int,long,float,double），将直接存储在工作内存的帧栈结构中，但倘若本地变量是引用类型，那么该变量的引用会存储在功能内存的帧栈中，而对象实例将存储在主内存(共享数据区域，堆)中。但对于实例对象的成员变量，不管它是基本数据类型或者包装类型(Integer、Double等)还是引用类型，都会被存储到堆区。至于static变量以及类本身相关信息将会存储在主内存中。</strong>需要注意的是，在主内存中的实例对象可以被多线程共享，倘若两个线程同时调用了同一个对象的同一个方法，那么两条线程会将要操作的数据拷贝一份到自己的工作内存中，执行完成操作后才刷新到主内存，简单示意图如下所示：</p><p><img src="https://ws1.sinaimg.cn/large/005DnJLEly1fu8xcssxq6j30jx0h478w.jpg" alt=""></p><h1 id="硬件内存架构与Java内存模型"><a href="#硬件内存架构与Java内存模型" class="headerlink" title="硬件内存架构与Java内存模型"></a>硬件内存架构与Java内存模型</h1><h2 id="硬件内存架构"><a href="#硬件内存架构" class="headerlink" title="硬件内存架构"></a>硬件内存架构</h2><p><img src="https://ws1.sinaimg.cn/large/005DnJLEly1fu8xdzggexj30hi0an40a.jpg" alt=""></p><p>正如上图所示，经过简化CPU与内存操作的简易图，实际上没有这么简单，这里为了理解方便，我们省去了南北桥并将三级缓存统一为CPU缓存(有些CPU只有二级缓存，有些CPU有三级缓存)。就目前计算机而言，一般拥有多个CPU并且每个CPU可能存在多个核心，多核是指在一枚处理器(CPU)中集成两个或多个完整的计算引擎(内核),这样就可以支持多任务并行执行，从多线程的调度来说，每个线程都会映射到各个CPU核心中并行运行。在CPU内部有一组CPU寄存器，寄存器是cpu直接访问和处理的数据，是一个临时放数据的空间。一般CPU都会从内存取数据到寄存器，然后进行处理，但由于内存的处理速度远远低于CPU，导致CPU在处理指令时往往花费很多时间在等待内存做准备工作，于是在寄存器和主内存间添加了CPU缓存，CPU缓存比较小，但访问速度比主内存快得多，如果CPU总是操作主内存中的同一址地的数据，很容易影响CPU执行速度，此时CPU缓存就可以把从内存提取的数据暂时保存起来，如果寄存器要取内存中同一位置的数据，直接从缓存中提取，无需直接从主内存取。需要注意的是，寄存器并不每次数据都可以从缓存中取得数据，万一不是同一个内存地址中的数据，那寄存器还必须直接绕过缓存从内存中取数据。所以并不每次都得到缓存中取数据，这种现象有个专业的名称叫做缓存的命中率，从缓存中取就命中，不从缓存中取从内存中取，就没命中，可见缓存命中率的高低也会影响CPU执行性能，这就是CPU、缓存以及主内存间的简要交互过程，总而言之当一个CPU需要访问主存时，会先读取一部分主存数据到CPU缓存(当然如果CPU缓存中存在需要的数据就会直接从缓存获取)，进而在读取CPU缓存到寄存器，当CPU需要写数据到主存时，同样会先刷新寄存器中的数据到CPU缓存，然后再把数据刷新到主内存中。</p><h2 id="Java线程与硬件处理器"><a href="#Java线程与硬件处理器" class="headerlink" title="Java线程与硬件处理器"></a>Java线程与硬件处理器</h2><p>了解完硬件的内存架构后，接着了解JVM中线程的实现原理，理解线程的实现原理，有助于我们了解Java内存模型与硬件内存架构的关系，在Window系统和Linux系统上，Java线程的实现是基于一对一的线程模型，所谓的一对一模型，实际上就是通过语言级别层面程序去间接调用系统内核的线程模型，即我们在使用Java线程时，Java虚拟机内部是转而调用当前操作系统的内核线程来完成当前任务。这里需要了解一个术语，内核线程(Kernel-Level Thread，KLT)，它是由操作系统内核(Kernel)支持的线程，这种线程是由操作系统内核来完成线程切换，内核通过操作调度器进而对线程执行调度，并将线程的任务映射到各个处理器上。每个内核线程可以视为内核的一个分身,这也就是操作系统可以同时处理多任务的原因。由于我们编写的多线程程序属于语言层面的，程序一般不会直接去调用内核线程，取而代之的是一种轻量级的进程(Light Weight Process)，也是通常意义上的线程，由于每个轻量级进程都会映射到一个内核线程，因此我们可以通过轻量级进程调用内核线程，进而由操作系统内核将任务映射到各个处理器，这种轻量级进程与内核线程间1对1的关系就称为一对一的线程模型。如下图</p><p><img src="https://ws1.sinaimg.cn/large/005DnJLEly1fu8xg3momej30i60i2n2w.jpg" alt=""></p><p>如图所示，每个线程最终都会映射到CPU中进行处理，如果CPU存在多核，那么一个CPU将可以并行执行多个线程任务。</p><h2 id="Java内存模型与硬件内存架构的关系"><a href="#Java内存模型与硬件内存架构的关系" class="headerlink" title="Java内存模型与硬件内存架构的关系"></a>Java内存模型与硬件内存架构的关系</h2><p>通过对前面的硬件内存架构、Java内存模型以及Java多线程的实现原理的了解，我们应该已经意识到，多线程的执行最终都会映射到硬件处理器上进行执行，但Java内存模型和硬件内存架构并不完全一致。对于硬件内存来说只有寄存器、缓存内存、主内存的概念，并没有工作内存(线程私有数据区域)和主内存(堆内存)之分，也就是说Java内存模型对内存的划分对硬件内存并没有任何影响，因为JMM只是一种抽象的概念，是一组规则，并不实际存在，不管是工作内存的数据还是主内存的数据，对于计算机硬件来说都会存储在计算机主内存中，当然也有可能存储到CPU缓存或者寄存器中，因此总体上来说，Java内存模型和计算机硬件内存架构是一个相互交叉的关系，是一种抽象概念划分与真实物理硬件的交叉。(注意对于Java内存区域划分也是同样的道理)</p><p><img src="https://ws1.sinaimg.cn/large/005DnJLEly1fu8xhz9poaj30p30cojvp.jpg" alt=""></p><h1 id="JMM存在的必要性"><a href="#JMM存在的必要性" class="headerlink" title="JMM存在的必要性"></a>JMM存在的必要性</h1><p>在明白了Java内存区域划分、硬件内存架构、Java多线程的实现原理与Java内存模型的具体关系后，接着来谈谈Java内存模型存在的必要性。由于JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存(有些地方称为栈空间)，用于存储线程私有的数据，线程与主内存中的变量操作必须通过工作内存间接完成，主要过程是将变量从主内存拷贝的每个线程各自的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，如果存在两个线程同时对一个主内存中的实例对象的变量进行操作就有可能诱发线程安全问题。如下图，主内存中存在一个共享变量x，现在有A和B两条线程分别对该变量x=1进行操作，A/B线程各自的工作内存中存在共享变量副本x。假设现在A线程想要修改x的值为2，而B线程却想要读取x的值，那么B线程读取到的值是A线程更新后的值2还是更新前的值1呢？答案是，不确定，即B线程有可能读取到A线程更新前的值1，也有可能读取到A线程更新后的值2，这是因为工作内存是每个线程私有的数据区域，而线程A变量x时，首先是将变量从主内存拷贝到A线程的工作内存中，然后对变量进行操作，操作完成后再将变量x写回主内，而对于B线程的也是类似的，这样就有可能造成主内存与工作内存间数据存在一致性问题，假如A线程修改完后正在将数据写回主内存，而B线程此时正在读取主内存，即将x=1拷贝到自己的工作内存中，这样B线程读取到的值就是x=1，但如果A线程已将x=2写回主内存后，B线程才开始读取的话，那么此时B线程读取到的就是x=2，但到底是哪种情况先发生呢？这是不确定的，这也就是所谓的线程安全问题。<br><img src="https://ws1.sinaimg.cn/large/005DnJLEly1fu8xj6tyrbj30i70da40z.jpg" alt=""></p><p>为了解决类似上述的问题，JVM定义了一组规则，通过这组规则来决定一个线程对共享变量的写入何时对另一个线程可见，这组规则也称为Java内存模型（即JMM），JMM是围绕着程序执行的原子性、有序性、可见性展开的，下面我们看看这三个特性。</p><h1 id="Java内存模型的承诺"><a href="#Java内存模型的承诺" class="headerlink" title="Java内存模型的承诺"></a>Java内存模型的承诺</h1><p>这里我们先来了解几个概念，即原子性？可见性？有序性？最后再阐明JMM是如何保证这3个特性。</p><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>原子性指的是一个操作是不可中断的，即使是在多线程环境下，一个操作一旦开始就不会被其他线程影响。比如对于一个静态变量int x，两条线程同时对他赋值，线程A赋值为1，而线程B赋值为2，不管线程如何运行，最终x的值要么是1，要么是2，线程A和线程B间的操作是没有干扰的，这就是原子性操作，不可被中断的特点。有点要注意的是，对于32位系统的来说，long类型数据和double类型数据(对于基本数据类型，byte,short,int,float,boolean,char读写是原子操作)，它们的读写并非原子性的，也就是说如果存在两条线程同时对long类型或者double类型的数据进行读写是存在相互干扰的，因为对于32位虚拟机来说，每次原子读写是32位的，而long和double则是64位的存储单元，这样会导致一个线程在写时，操作完前32位的原子操作后，轮到B线程读取时，恰好只读取到了后32位的数据，这样可能会读取到一个既非原值又不是线程修改值的变量，它可能是“半个变量”的数值，即64位数据被两个线程分成了两次读取。但也不必太担心，因为读取到“半个变量”的情况比较少见，至少在目前的商用的虚拟机中，几乎都把64位的数据的读写操作作为原子操作来执行，因此对于这个问题不必太在意，知道这么回事即可。</p><h2 id="理解指令重排"><a href="#理解指令重排" class="headerlink" title="理解指令重排"></a>理解指令重排</h2><p>计算机在执行程序时，为了提高性能，编译器和处理器的常常会对指令做重排，一般分以下3种</p><ul><li><p>编译器优化的重排</p><p>编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</p></li><li><p>指令并行的重排</p><p>现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性(即后一个执行的语句无需依赖前面执行的语句的结果)，处理器可以改变语句对应的机器指令的执行顺序</p></li><li><p>内存系统的重排</p><p>由于处理器使用缓存和读写缓存冲区，这使得加载(load)和存储(store)操作看上去可能是在乱序执行，因为三级缓存的存在，导致内存与缓存的数据同步存在时间差。</p></li></ul><p>其中编译器优化的重排属于编译期重排，指令并行的重排和内存系统的重排属于处理器重排，在多线程环境中，这些重排优化可能会导致程序出现内存可见性问题，下面分别阐明这两种重排优化可能带来的问题</p><h3 id="编译器重排"><a href="#编译器重排" class="headerlink" title="编译器重排"></a>编译器重排</h3><p>下面我们简单看一个编译器重排的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">线程 1             线程 2</span><br><span class="line">1： x2 = a ;      3: x1 = b ;</span><br><span class="line">2: b = 1;         4: a = 2 ;</span><br></pre></td></tr></table></figure><p>两个线程同时执行，分别有1、2、3、4四段执行代码，其中1、2属于线程1 ， 3、4属于线程2 ，从程序的执行顺序上看，似乎不太可能出现x1 = 1 和x2 = 2 的情况，但实际上这种情况是有可能发现的，因为如果编译器对这段程序代码执行重排优化后，可能出现下列情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">线程 1              线程 2</span><br><span class="line">2: b = 1;          4: a = 2 ; </span><br><span class="line">1：x2 = a ;        3: x1 = b ;</span><br></pre></td></tr></table></figure><p>这种执行顺序下就有可能出现x1 = 1 和x2 = 2 的情况，这也就说明在多线程环境下，由于编译器优化重排的存在，两个线程中使用的变量能否保证一致性是无法确定的。</p><h3 id="处理器指令重排"><a href="#处理器指令重排" class="headerlink" title="处理器指令重排"></a>处理器指令重排</h3><p>先了解一下指令重排的概念，处理器指令重排是对CPU的性能优化，从指令的执行角度来说一条指令可以分为多个步骤完成，如下</p><ul><li>取指 IF</li><li>译码和取寄存器操作数 ID</li><li>执行或者有效地址计算 EX</li><li>存储器访问 MEM</li><li>写回 WB</li></ul><p>CPU在工作时，需要将上述指令分为多个步骤依次执行(注意硬件不同有可能不一样),由于每一个步会使用到不同的硬件操作，比如取指时会只有PC寄存器和存储器，译码时会执行到指令寄存器组，执行时会执行ALU(算术逻辑单元)、写回时使用到寄存器组。为了提高硬件利用率，CPU指令是按流水线技术来执行的，如下：</p><p><img src="https://ws1.sinaimg.cn/large/005DnJLEly1fu8xpkiqadj30f304uwf2.jpg" alt=""></p><p>从图中可以看出当指令1还未执行完成时，第2条指令便利用空闲的硬件开始执行，这样做是有好处的，如果每个步骤花费1ms，那么如果第2条指令需要等待第1条指令执行完成后再执行的话，则需要等待5ms，但如果使用流水线技术的话，指令2只需等待1ms就可以开始执行了，这样就能大大提升CPU的执行性能。虽然流水线技术可以大大提升CPU的性能，但不幸的是一旦出现流水中断，所有硬件设备将会进入一轮停顿期，当再次弥补中断点可能需要几个周期，这样性能损失也会很大，就好比工厂组装手机的流水线，一旦某个零件组装中断，那么该零件往后的工人都有可能进入一轮或者几轮等待组装零件的过程。因此我们需要尽量阻止指令中断的情况，指令重排就是其中一种优化中断的手段，我们通过一个例子来阐明指令重排是如何阻止流水线技术中断的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = b + c ;</span><br><span class="line">d = e + f ;</span><br></pre></td></tr></table></figure><p>下面通过汇编指令展示了上述代码在CPU执行的处理过程</p><p><img src="https://ws1.sinaimg.cn/large/005DnJLEly1fu8xry9s2mj30mp092768.jpg" alt=""></p><ul><li>LW指令 表示 load，其中LW R1,b表示把b的值加载到寄存器R1中</li><li>LW R2,c 表示把c的值加载到寄存器R2中</li><li>ADD 指令表示加法，把R1 、R2的值相加，并存入R3寄存器中。</li><li>SW 表示 store 即将 R3寄存器的值保持到变量a中</li><li>LW R4,e 表示把e的值加载到寄存器R4中</li><li>LW R5,f 表示把f的值加载到寄存器R5中</li><li>SUB 指令表示减法，把R4 、R5的值相减，并存入R6寄存器中。</li><li>SW d,R6 表示将R6寄存器的值保持到变量d中</li></ul><p>上述便是汇编指令的执行过程，在某些指令上存在X的标志，X代表中断的含义，也就是只要有X的地方就会导致指令流水线技术停顿，同时也会影响后续指令的执行，可能需要经过1个或几个指令周期才可能恢复正常，那为什么停顿呢？这是因为部分数据还没准备好，如执行ADD指令时，需要使用到前面指令的数据R1，R2，而此时R2的MEM操作没有完成，即未拷贝到存储器中，这样加法计算就无法进行，必须等到MEM操作完成后才能执行，也就因此而停顿了，其他指令也是类似的情况。前面阐述过，停顿会造成CPU性能下降，因此我们应该想办法消除这些停顿，这时就需要使用到指令重排了，如下图，既然ADD指令需要等待，那我们就利用等待的时间做些别的事情，如把<code>LW R4,e</code> 和 <code>LW R5,f</code> 移动到前面执行，毕竟<code>LW R4,e</code> 和 <code>LW R5,f</code>执行并没有数据依赖关系，对他们有数据依赖关系的<code>SUB R6,R5,R4</code>指令在R4,R5加载完成后才执行的，没有影响，过程如下：</p><p><img src="https://ws1.sinaimg.cn/large/005DnJLEly1fu8xu26x9bj30py0i4n25.jpg" alt=""></p><p>正如上图所示，所有的停顿都完美消除了，指令流水线也无需中断了，这样CPU的性能也能带来很好的提升，这就是处理器指令重排的作用。关于编译器重排以及指令重排(这两种重排我们后面统一称为指令重排)相关内容已阐述清晰了，我们必须意识到对于单线程而已指令重排几乎不会带来任何影响，比竟重排的前提是保证串行语义执行的一致性，但对于多线程环境而已，指令重排就可能导致严重的程序轮序执行问题，如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MixedOrder</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        a = <span class="number">1</span>;</span><br><span class="line">        flag = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            <span class="keyword">int</span> i = a + <span class="number">1</span>；</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上述代码，同时存在线程A和线程B对该实例对象进行操作，其中A线程调用写入方法，而B线程调用读取方法，由于指令重排等原因，可能导致程序执行顺序变为如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">线程A                    线程B</span><br><span class="line">writer：                 read：</span><br><span class="line">1:flag = true;           1:flag = true;</span><br><span class="line">2:a = 1;                 2: a = 0 ; //误读</span><br><span class="line">                         3: i = 1 ;</span><br></pre></td></tr></table></figure><p>由于指令重排的原因，线程A的flag置为true被提前执行了，而a赋值为1的程序还未执行完，此时线程B，恰好读取flag的值为true，直接获取a的值（此时B线程并不知道a为0）并执行i赋值操作，结果i的值为1，而不是预期的2，这就是多线程环境下，指令重排导致的程序乱序执行的结果。因此，请记住，指令重排只会保证单线程中串行语义的执行的一致性，但并不会关心多线程间的语义一致性。</p><h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>理解了指令重排现象后，可见性容易了，可见性指的是当一个线程修改了某个共享变量的值，其他线程是否能够马上得知这个修改的值。对于串行程序来说，可见性是不存在的，因为我们在任何一个操作中修改了某个变量的值，后续的操作中都能读取这个变量值，并且是修改过的新值。但在多线程环境中可就不一定了，前面我们分析过，由于线程对共享变量的操作都是线程拷贝到各自的工作内存进行操作后才写回到主内存中的，这就可能存在一个线程A修改了共享变量x的值，还未写回主内存时，另外一个线程B又对主内存中同一个共享变量x进行操作，但此时A线程工作内存中共享变量x对线程B来说并不可见，这种工作内存与主内存同步延迟现象就造成了可见性问题，另外指令重排以及编译器优化也可能导致可见性问题，通过前面的分析，我们知道无论是编译器优化还是处理器优化的重排现象，在多线程环境下，确实会导致程序轮序执行的问题，从而也就导致可见性问题。</p><h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><p>有序性是指对于单线程的执行代码，我们总是认为代码的执行是按顺序依次执行的，这样的理解并没有毛病，毕竟对于单线程而言确实如此，但对于多线程环境，则可能出现乱序现象，因为程序编译成机器码指令后可能会出现指令重排现象，重排后的指令与原指令的顺序未必一致，要明白的是，在Java程序中，倘若在本线程内，所有操作都视为有序行为，如果是多线程环境下，一个线程中观察另外一个线程，所有操作都是无序的，前半句指的是单线程内保证串行语义执行的一致性，后半句则指指令重排现象和工作内存与主内存同步延迟现象。</p><h2 id="JMM提供的解决方案"><a href="#JMM提供的解决方案" class="headerlink" title="JMM提供的解决方案"></a>JMM提供的解决方案</h2><p>在理解了原子性，可见性以及有序性问题后，看看JMM是如何保证的，在Java内存模型中都提供一套解决方案供Java工程师在开发过程使用，如原子性问题，除了JVM自身提供的对基本数据类型读写操作的原子性外，对于方法级别或者代码块级别的原子性操作，可以使用synchronized关键字或者重入锁(ReentrantLock)保证程序执行的原子性，关于synchronized的详解，看博主另外一篇文章( <a href="http://blog.csdn.net/javazejian/article/details/72828483" target="_blank" rel="external">深入理解Java并发之synchronized实现原理</a>)。而工作内存与主内存同步延迟现象导致的可见性问题，可以使用synchronized关键字或者volatile关键字解决，它们都可以使一个线程修改后的变量立即对其他线程可见。对于指令重排导致的可见性问题和有序性问题，则可以利用volatile关键字解决，因为volatile的另外一个作用就是禁止重排序优化，关于volatile稍后会进一步分析。除了靠sychronized和volatile关键字来保证原子性、可见性以及有序性外，JMM内部还定义一套happens-before 原则来保证多线程环境下两个操作间的原子性、可见性以及有序性。</p><h2 id="理解JMM中的happens-before-原则"><a href="#理解JMM中的happens-before-原则" class="headerlink" title="理解JMM中的happens-before 原则"></a>理解JMM中的happens-before 原则</h2><p>倘若在程序开发中，仅靠sychronized和volatile关键字来保证原子性、可见性以及有序性，那么编写并发程序可能会显得十分麻烦，幸运的是，在Java内存模型中，还提供了happens-before 原则来辅助保证程序执行的原子性、可见性以及有序性的问题，它是判断数据是否存在竞争、线程是否安全的依据，happens-before 原则内容如下</p><ul><li>程序顺序原则，即在一个线程内必须保证语义串行性，也就是说按照代码顺序执行。</li><li>锁规则 解锁(unlock)操作必然发生在后续的同一个锁的加锁(lock)之前，也就是说，如果对于一个锁解锁后，再加锁，那么加锁的动作必须在解锁动作之后(同一个锁)。</li><li>volatile规则 volatile变量的写，先发生于读，这保证了volatile变量的可见性，简单的理解就是，volatile变量在每次被线程访问时，都强迫从主内存中读该变量的值，而当该变量发生变化时，又会强迫将最新的值刷新到主内存，任何时刻，不同的线程总是能够看到该变量的最新值。</li><li>线程启动规则 线程的start()方法先于它的每一个动作，即如果线程A在执行线程B的start方法之前修改了共享变量的值，那么当线程B执行start方法时，线程A对共享变量的修改对线程B可见</li><li>传递性 A先于B ，B先于C 那么A必然先于C</li><li>线程终止规则 线程的所有操作先于线程的终结，Thread.join()方法的作用是等待当前执行的线程终止。假设在线程B终止之前，修改了共享变量，线程A从线程B的join方法成功返回后，线程B对共享变量的修改将对线程A可见。</li><li>线程中断规则 对线程 interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测线程是否中断。</li><li>对象终结规则 对象的构造函数执行，结束先于finalize()方法</li></ul><p>上述8条原则无需手动添加任何同步手段(synchronized|volatile)即可达到效果，下面我们结合前面的案例演示这8条原则如何判断线程是否安全，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MixedOrder</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        a = <span class="number">1</span>;</span><br><span class="line">        flag = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            <span class="keyword">int</span> i = a + <span class="number">1</span>；</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的道理，存在两条线程A和B，线程A调用实例对象的writer()方法，而线程B调用实例对象的read()方法，线程A先启动而线程B后启动，那么线程B读取到的i值是多少呢？现在依据8条原则，由于存在两条线程同时调用，因此程序次序原则不合适。writer()方法和read()方法都没有使用同步手段，锁规则也不合适。没有使用volatile关键字，volatile变量原则不适应。线程启动规则、线程终止规则、线程中断规则、对象终结规则、传递性和本次测试案例也不合适。线程A和线程B的启动时间虽然有先后，但线程B执行结果却是不确定，也是说上述代码没有适合8条原则中的任意一条，也没有使用任何同步手段，所以上述的操作是线程不安全的，因此线程B读取的值自然也是不确定的。修复这个问题的方式很简单，要么给writer()方法和read()方法添加同步手段，如synchronized或者给变量flag添加volatile关键字，确保线程A修改的值对线程B总是可见。</p><h1 id="volatile内存语义"><a href="#volatile内存语义" class="headerlink" title="volatile内存语义"></a>volatile内存语义</h1><p>volatile在并发编程中很常见，但也容易被滥用，现在我们就进一步分析volatile关键字的语义。volatile是Java虚拟机提供的轻量级的同步机制。volatile关键字有如下两个作用</p><ul><li><strong>保证被volatile修饰的共享变量对所有线程总数可见的，也就是当一个线程修改了一个被volatile修饰共享变量的值，新值总数可以被其他线程立即得知。</strong></li><li><strong>禁止指令重排序优化。</strong></li></ul><h2 id="volatile的可见性"><a href="#volatile的可见性" class="headerlink" title="volatile的可见性"></a>volatile的可见性</h2><p>关于volatile的可见性作用，我们必须意识到被volatile修饰的变量对所有线程总数立即可见的，对volatile变量的所有写操作总是能立刻反应到其他线程中，<strong>但是对于volatile变量运算操作在多线程环境并不保证安全性(原子性不能保证)</strong>，如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileVisibility</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> i =<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span></span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如上述代码所示，i变量的任何改变都会立马反应到其他线程中，但是如此存在多条线程同时调用increase()方法的话，就会出现线程安全问题，毕竟<code>i++;</code>操作并不具备原子性，该操作是先读取值，然后写回一个新值，相当于原来的值加上1，分两步完成，如果第二个线程在第一个线程读取旧值和写回新值期间读取i的域值，那么第二个线程就会与第一个线程一起看到同一个值，并执行相同值的加1操作，这也就造成了线程安全失败，因此对于increase方法必须使用synchronized修饰，以便保证线程安全，需要注意的是一旦使用synchronized修饰方法后，由于synchronized本身也具备与volatile相同的特性，即可见性 <strong>（简单来说就是有运算操作的一般都是先读后写，但是这个过程并不能保证写的就是刚刚读的，所以用volatile关键字修饰的话就不能保证安全性了，这个时候就得使用synchronize关键字修饰该方法）</strong> ，因此在这样种情况下就完全可以省去volatile修饰变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileVisibility</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> i =<span class="number">0</span>;   <span class="comment">//这里无需再用volatile修饰，因为synchronize和它具有相同的特性</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span></span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在来看另外一种场景，可以使用volatile修饰变量达到线程安全的目的，如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileSafe</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> close;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>&#123;</span><br><span class="line">        close=<span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!close)&#123;</span><br><span class="line">            System.out.println(<span class="string">"safe...."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于对于boolean变量close值的修改属于原子性操作，因此可以通过使用volatile修饰变量close，使用该变量对其他线程立即可见，从而达到线程安全的目的。那么JMM是如何实现让volatile变量对其他线程立即可见的呢？实际上，<strong>当写一个volatile变量时，JMM会把该线程对应的工作内存中的共享变量值刷新到主内存中，当读取一个volatile变量时，JMM会把该线程对应的工作内存置为无效，那么该线程将只能从主内存中重新读取共享变量。</strong> volatile变量正是通过这种写-读方式实现对其他线程可见（但其内存语义实现则是通过内存屏障，稍后会说明）。</p><h2 id="volatile禁止重排优化"><a href="#volatile禁止重排优化" class="headerlink" title="volatile禁止重排优化"></a>volatile禁止重排优化</h2><p>volatile关键字另一个作用就是禁止指令重排优化，从而避免多线程环境下程序出现乱序执行的现象，关于指令重排优化前面已详细分析过，这里主要简单说明一下volatile是如何实现禁止指令重排优化的。先了解一个概念，内存屏障(Memory Barrier）。<br>内存屏障，又称内存栅栏，是一个CPU指令，它的作用有两个，<strong>一是保证特定操作的执行顺序，二是保证某些变量的内存可见性（利用该特性实现volatile的内存可见性）</strong> 。由于编译器和处理器都能执行指令重排优化。如果在指令间插入一条Memory Barrier则会告诉编译器和CPU，不管什么指令都不能和这条Memory Barrier指令重排序，也就是说通过插入内存屏障禁止在内存屏障前后的指令执行重排序优化。Memory Barrier的另外一个作用是强制刷出各种CPU的缓存数据，因此任何CPU上的线程都能读取到这些数据的最新版本。总之，volatile变量正是通过内存屏障实现其在内存中的语义，即可见性和禁止重排优化。下面看一个非常典型的禁止重排优化的例子DCL（双检锁），如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by zejian on 2017/6/11.</span></span><br><span class="line"><span class="comment"> * Blog : http://blog.csdn.net/javazejian [原文地址,请尊重原创]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleCheckLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DoubleCheckLock instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DoubleCheckLock</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DoubleCheckLock <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一次检测</span></span><br><span class="line">        <span class="keyword">if</span> (instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//同步</span></span><br><span class="line">            <span class="keyword">synchronized</span> (DoubleCheckLock.class)&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="comment">//多线程环境下可能会出现问题的地方</span></span><br><span class="line">                    instance = <span class="keyword">new</span> DoubleCheckLock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码一个经典的单例的双重检测的代码，这段代码在单线程环境下并没有什么问题，但如果在多线程环境下就可以出现线程安全问题。原因在于某一个线程执行到第一次检测，读取到的instance不为null时，instance的引用对象可能没有完成初始化。因为<code>instance = new DoubleCheckLock();</code>可以分为以下3步完成(伪代码)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">memory = allocate(); <span class="comment">//1.分配对象内存空间</span></span><br><span class="line">instance(memory);    <span class="comment">//2.初始化对象</span></span><br><span class="line">instance = memory;   <span class="comment">//3.设置instance指向刚分配的内存地址，此时instance！=null123</span></span><br></pre></td></tr></table></figure><p>由于步骤1和步骤2间可能会重排序，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">memory = allocate(); <span class="comment">//1.分配对象内存空间</span></span><br><span class="line">instance = memory;   <span class="comment">//3.设置instance指向刚分配的内存地址，此时instance！=null，但是对象还没有初始化完成！</span></span><br><span class="line">instance(memory);    <span class="comment">//2.初始化对象123</span></span><br></pre></td></tr></table></figure><p>由于步骤2和步骤3不存在数据依赖关系，而且无论重排前还是重排后程序的执行结果在单线程中并没有改变，因此这种重排优化是允许的。但是指令重排只会保证串行语义的执行的一致性(单线程)，但并不会关心多线程间的语义一致性。所以当一条线程访问instance不为null时，由于instance实例未必已初始化完成，也就造成了线程安全问题。那么该如何解决呢，很简单，我们使用volatile禁止instance变量被执行指令重排优化即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//禁止指令重排优化</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> DoubleCheckLock instance;</span><br></pre></td></tr></table></figure><p>ok~，到此相信我们对Java内存模型和volatile应该都有了比较全面的认识，总而言之，我们应该清楚知道，JMM就是一组规则，这组规则意在解决在并发编程可能出现的线程安全问题，并提供了内置解决方案（happen-before原则）及其外部可使用的同步手段(synchronized/volatile等)，确保了程序执行在多线程环境中的应有的原子性，可视性及其有序性。</p><p>如有错误，欢迎留言，谢谢！</p><p>参考资料：<br><a href="http://tutorials.jenkov.com/java-concurrency/java-memory-model.html" target="_blank" rel="external">http://tutorials.jenkov.com/java-concurrency/java-memory-model.html</a><br><a href="http://blog.csdn.net/iter_zc/article/details/41843595" target="_blank" rel="external">http://blog.csdn.net/iter_zc/article/details/41843595</a><br><a href="http://ifeve.com/wp-content/uploads/2014/03/JSR133%E4%B8%AD%E6%96%87%E7%89%881.pdf" target="_blank" rel="external">http://ifeve.com/wp-content/uploads/2014/03/JSR133%E4%B8%AD%E6%96%87%E7%89%881.pdf</a></p><p>《深入理解JVM虚拟机》<br>《Java高并发程序设计》</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载自CSDN-&lt;a href=&quot;https://blog.csdn.net/javazejian/article/details/72772461&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;全面理解Java内存模型(JMM)及volatile关键字&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;理解Java内存区域与Java内存模型&quot;&gt;&lt;a href=&quot;#理解Java内存区域与Java内存模型&quot; class=&quot;headerlink&quot; title=&quot;理解Java内存区域与Java内存模型&quot;&gt;&lt;/a&gt;理解Java内存区域与Java内存模型&lt;/h1&gt;&lt;h2 id=&quot;Java内存区域&quot;&gt;&lt;a href=&quot;#Java内存区域&quot; class=&quot;headerlink&quot; title=&quot;Java内存区域&quot;&gt;&lt;/a&gt;Java内存区域&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/005DnJLEly1fu8x1lpjxrj30jx097goo.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;Java虚拟机在运行程序时会把其自动管理的内存划分为以上几个区域，每个区域都有的用途以及创建销毁的时机，其中蓝色部分代表的是所有线程共享的数据区域，而绿色部分代表的是每个线程的私有数据区域。&lt;/p&gt;
    
    </summary>
    
      <category term="JVM" scheme="https://caoler.cn/categories/JVM/"/>
    
    
      <category term="JVM" scheme="https://caoler.cn/tags/JVM/"/>
    
      <category term="jmm" scheme="https://caoler.cn/tags/jmm/"/>
    
  </entry>
  
  <entry>
    <title>详解类加载机制</title>
    <link href="https://caoler.cn//post/2018/java-lload-class.html"/>
    <id>https://caoler.cn//post/2018/java-lload-class.html</id>
    <published>2018-08-12T08:38:00.000Z</published>
    <updated>2018-10-14T12:56:05.423Z</updated>
    
    <content type="html"><![CDATA[<p>从类被加载到虚拟机内存中开始，到卸御出内存为止，它的整个生命周期分为7个阶段，加载(Loading)、验证(Verification)、准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using)、卸御(Unloading)。其中验证、准备、解析三个部分统称为连接。</p><a id="more"></a><p>7个阶段发生的顺序如下：</p><p><img src="http://upload-images.jianshu.io/upload_images/2843224-eef72dbf8b663012.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/633" alt="img"></p><p>类的生命周期</p><h2 id="1-加载"><a href="#1-加载" class="headerlink" title="1. 加载"></a>1. 加载</h2><ol><li>通过一个类的全限定名来获取定义此类的二进制字节流。</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li><li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</li></ol><blockquote><p><strong>注意：JVM中的ClassLoader类加载器加载Class发生在此阶段</strong></p></blockquote><h2 id="2-验证"><a href="#2-验证" class="headerlink" title="2. 验证"></a>2. 验证</h2><h4 id="2-1-文件格式的验证"><a href="#2-1-文件格式的验证" class="headerlink" title="2.1 文件格式的验证"></a>2.1 文件格式的验证</h4><ol><li>主要验证字节流是否符合Class文件格式的规范，如果符合则把字节流加载到方法区中进行存储。</li><li>文件头、主次版本验证等等</li></ol><h4 id="2-2-元数据验证"><a href="#2-2-元数据验证" class="headerlink" title="2.2 元数据验证"></a>2.2 元数据验证</h4><p>主要对字节码描述的信息进行语义分析，保证其描述符合Java语言的要求。</p><ol><li>类是否有父类</li><li>是否继承了不允许被继承的类（final修饰过的类）</li><li>如果这个类不是抽象类，是否实现其父类或接口中所有要求实现的方法</li><li>类中的字段、方法是否与父类产生矛盾（如：覆盖父类final类型的字段，或者不符合个则的方法）</li></ol><h4 id="2-3-字节码验证"><a href="#2-3-字节码验证" class="headerlink" title="2.3 字节码验证"></a>2.3 字节码验证</h4><p>最复杂的一个阶段。主要目的是通过数据量和控制流分析，确定程序语义是合法的，符合逻辑的。<br>保证被校验类的方法在运行时不会做出危害虚拟机安全的事件。</p><h4 id="2-4-符号引用验证"><a href="#2-4-符号引用验证" class="headerlink" title="2.4 符号引用验证"></a>2.4 符号引用验证</h4><p>符号引用中通过字符串描述的全限定名是否能找到对应的类。<br>在指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段。<br>符号引用中的类、字段、方法的访问性（private、protected、public、default）是否可被当前类访问。</p><h2 id="3、准备"><a href="#3、准备" class="headerlink" title="3、准备"></a>3、准备</h2><p>准备阶段正式为类变量分配内存并设置初始值阶段。<br>public <strong>static</strong> int value=123; 初始后为 value=0;<br>对于static final类型，在准备阶段会被赋予正确的值<br>public <strong>static final</strong> value=123;初始化为 value=123;</p><p>如果是boolean值默认赋值为：false<br>如果是对象引用默认赋值为：null<br>…</p><blockquote><p><strong>注意：<br>只设置类中的静态变量（方法区中），不包括实例变量（堆内存中），实例变量是在对象实例化的时候初始化分配值的</strong></p></blockquote><h2 id="4、解析"><a href="#4、解析" class="headerlink" title="4、解析"></a>4、解析</h2><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。</p><ol><li>符号引用：简单的理解就是字符串，比如引用一个类，java.util.ArrayList 这就是一个符号引用，字符串引用的对象不一定被加载。</li><li>直接引用：指针或者地址偏移量。引用对象一定在内存（已经加载）。</li></ol><h2 id="5、初始化"><a href="#5、初始化" class="headerlink" title="5、初始化"></a>5、初始化</h2><ol><li>执行类构造器<clinit></clinit></li><li>初始化静态变量、静态块中的数据等（一个类加载器只会初始化一次）</li><li>子类的<clinit>调用前保证父类的<clinit>被调用</clinit></clinit></li></ol><blockquote><p>**注意：</p><p><clinit>是线程安全的，执行<clinit>的线程需要先获取锁才能进行初始化操作，保证只有一个线程能执行<clinit>(利用此特性可以实现线程安全的懒汉单例模式)。**</clinit></clinit></clinit></p></blockquote><h2 id="什么是类装载器ClassLoader"><a href="#什么是类装载器ClassLoader" class="headerlink" title="什么是类装载器ClassLoader"></a>什么是类装载器ClassLoader</h2><ol><li>ClassLoader是一个抽象类</li><li>ClassLoader的实例将读入Java字节码将类装载到JVM中</li><li>ClassLoader可以定制，满足不同的字节码流获取方式</li><li>ClassLoader负责类装载过程中的加载阶段。</li></ol><h2 id="JVM中的类加载器"><a href="#JVM中的类加载器" class="headerlink" title="JVM中的类加载器"></a>JVM中的类加载器</h2><ol><li><strong>启动类加载器（BootStrap ClassLoader）：</strong>引导类装入器是用本地代码实现的类装入器，它负责将 jdk中jre/lib下面的核心类库或-Xbootclasspath选项指定的jar包加载到内存中。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。</li><li><strong>扩展类加载器（Extension ClassLoader）：</strong>扩展类加载器是由Sun的ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的。它负责将jdk中jre/lib/ext或者由系统变量-Djava.ext.dir指定位置中的类库加载到内存中。开发者可以直接使用标准扩展类加载器。</li><li><strong>系统类加载器（System ClassLoader）：</strong>系统类加载器是由 Sun的 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的。它负责将系统类路径java -classpath或-Djava.class.path变量所指的目录下的类库加载到内存中。开发者可以直接使用系统类加载器。</li></ol><h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><p>下图中展示了类加载器直接的关系和双亲委派模型</p><p><img src="http://upload-images.jianshu.io/upload_images/2843224-d999dd46f039346a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/530" alt="img"></p><p>类加载器双亲委派模型</p><p>从图中我们发现除启动类加载器外，每个加载器都有父的类加载器。<br>双亲委派机制：如果一个类加载器在接到加载类的请求时，它首先不会自己尝试去加载这个类，而是把这个请求任务委托给父类加载器去完成，依次递归，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。</p><p><img src="http://upload-images.jianshu.io/upload_images/2843224-659c58819750516c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/461" alt="img"></p><p>ClassLoader类关系图</p><p>从类的继承关系来看，ExtClassLoader和AppClassLoader都是继承URLClassLoader，都是ClassLoader的子类。而BootStrapClassLoader是有C写的，不再java的ClassLoader子类中。</p><blockquote><p><strong>注意：<br>从图中可以看到类加载器间的父子关系不是以继承的方式实现的，而是以组合关系的方式来复用父加载器的代码。<br>如果一个类加载器收到了类加载的请求，它首先会把这个请求委派给父加载器去完成，每一个层次的类加载器都是如此。  </strong></p></blockquote><h2 id="双亲委派模型的好处"><a href="#双亲委派模型的好处" class="headerlink" title="双亲委派模型的好处"></a>双亲委派模型的好处</h2><p>Java类随着加载它的类加载器一起具备了一种带有优先级的层次关系。比如，Java中的Object类，它存放在rt.jar之中,无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此Object在各种类加载环境中都是同一个类。如果不采用双亲委派模型，那么由各个类加载器自己取加载的话，那么系统中会存在多种不同的Object类。</p><h2 id="破坏双亲委派模型"><a href="#破坏双亲委派模型" class="headerlink" title="破坏双亲委派模型"></a>破坏双亲委派模型</h2><h4 id="案例一"><a href="#案例一" class="headerlink" title="案例一"></a>案例一</h4><p>双亲委派模型的问题：顶层ClassLoader，无法加载底层ClassLoader的类。<br>JDK的javax.xml.parsers包中定义了xml解析的类接口<br>Service Provider Interface SPI 位于rt.jar 即接口在启动ClassLoader中。而SPI的实现类，可能由第三方提供，AppClassLoader进行加载。<br><strong>解决思路：</strong>可以在线程中放入底层的ClassLoader到Thread. setContextClassLoader()中，然后在顶层ClassLoader中使用Thread.getContextClassLoader()获得底层的ClassLoader进行加载第三方实现。</p><h4 id="案例二"><a href="#案例二" class="headerlink" title="案例二"></a>案例二</h4><p>Tomcat中使用了自定ClassLoader，并且也破坏了双亲委托机制。<br>每个应用使用WebAppClassloader进行单独加载，他首先使用WebAppClassloader进行类加载，如果加载不了再委托父加载器去加载，这样可以保证每个应用中的类不冲突。每个tomcat中可以部署多个项目，每个项目中存在很多相同的class文件（很多相同的jar包），他们加载到jvm中可以做到互不干扰。</p><h4 id="案例三："><a href="#案例三：" class="headerlink" title="案例三："></a>案例三：</h4><p>利用破坏双亲委派来java的<strong>类热部署</strong>实现（每次修改类文件，不需要重启服务）。<br>因为一个Class只能被一个ClassLoader加载一次，否则会报java.lang.LinkageError。当我们想要实现代码热部署时，可以每次都new一个自定义的ClassLoader来加载新的Class文件。JSP的实现动态修改就是使用此特性实现。</p><h2 id="Class加密实现思路"><a href="#Class加密实现思路" class="headerlink" title="Class加密实现思路"></a>Class加密实现思路</h2><p>ClassLoader加载.class文件的方式不仅限于从jar包中读取，还可以从种地方读取，因为ClassLoader加载时需要的是byte[]数组.</p><blockquote><p><strong>ClassLoader加载Class文件方式：</strong></p></blockquote><ol><li>从本地系统中直接加载</li><li>通过网络下载.class文件</li><li>从zip，jar等归档文件中加载.class文件</li><li>从专有数据库中提取.class文件</li><li>将Java源文件动态编译为.class文件</li></ol><p><strong>加密实现思路：</strong>加载Class文件的方式灵活，我们可以自定义ClassLoader，把加密后的Class文件，在加载Class前先进行解密，然后在通过ClassLoader进行加载。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从类被加载到虚拟机内存中开始，到卸御出内存为止，它的整个生命周期分为7个阶段，加载(Loading)、验证(Verification)、准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using)、卸御(Unloading)。其中验证、准备、解析三个部分统称为连接。&lt;/p&gt;
    
    </summary>
    
      <category term="JVM" scheme="https://caoler.cn/categories/JVM/"/>
    
    
      <category term="jvm" scheme="https://caoler.cn/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>IOC概念和SpringBean的生命周期</title>
    <link href="https://caoler.cn//post/2018/springioc-bean.html"/>
    <id>https://caoler.cn//post/2018/springioc-bean.html</id>
    <published>2018-08-10T08:38:00.000Z</published>
    <updated>2018-10-14T12:54:13.742Z</updated>
    
    <content type="html"><![CDATA[<p>之前有写过SpringBean的文章，但是大部分都是搬运的，自己对它的深层次思想并没有掌握，所以在这里重写一下。</p><p>IOC部分在第一次学Spring的时候就已经在接触了，但是还是了解的不够深入，最近在看了一部分SpringIOC的源码之后，才模模糊糊的明白了一些，正好赶上组内技术分享，做此下文</p><a id="more"></a><h2 id="1-WEB发展简史"><a href="#1-WEB发展简史" class="headerlink" title="1. WEB发展简史"></a>1. WEB发展简史</h2><p>老一辈的软件开发人员一般经历了从Model1到Model2，然后到后来的三层模型，最后到现在的Spring Boot。如果从Model1到Model2说起到我们现在使用的Spring Boot为整个时间轴的话，大致可以分为4个阶段：</p><p>　　(1)初级阶段：使用Model1/Model2/三层模模型进行开发;</p><p>　　(2)中级阶段：使用EJB进行分布式应用开发，忍受重量级框架带来的种种麻烦;</p><p>　　(3)高级阶段：使用Spring春天带给我们的美好，但是还要忍受很多繁琐的配置;</p><p>　　(4)骨灰级阶段：使用Spring Boot，畅享“预定大于配置”带给我们的种种乐趣!</p><h3 id="1-1-Web发展初级阶段"><a href="#1-1-Web发展初级阶段" class="headerlink" title="1.1 Web发展初级阶段"></a>1.1 Web发展初级阶段</h3><p>　<strong>1、Model1开发模式：</strong></p><p>　　Model1的开发模式是：JSP+JavaBean的模式，它的核心是Jsp页面，在这个页面中，Jsp页面负责整合页面和JavaBean(业务逻辑)，而且渲染页面，它的基本流程如下：</p><p>　　<img src="http://ss.csdn.net/p?http://mmbiz.qpic.cn/mmbiz_png/UtWdDgynLdaZlHDsiahibvG80sBnZVmc7y9tZ4LhwAvX4EicI2mjYqialNauwLnDXjIQIjgCXkiaKPvx3GLu9htbxjw/?" alt="img"></p><p>　　相信很多小伙伴在刚学习Web的时候，肯定使用到了Model1开发模式，也就是我们的业务代码、持久化代码直接写在Jsp页面里边，使用Jsp直接处理Web浏览器的请求，并使用JavaBean处理业务逻辑。</p><p>　　利用我们现在熟悉的MVC模型的思想去看，虽然编写代码十分容易，但Jsp混淆了MVC模型中的视图层和控制层，高度耦合的结果是Jsp代码十分复杂，后期维护困难!</p><p>　<strong>2、Model2开发模式：</strong></p><p>　　Model1虽然在一定程度上解耦了，但JSP依旧即要负责页面控制，又要负责逻辑处理，职责不单一!此时Model2应运而生，使得各个部分各司其职，Model2是基于MVC模式的。</p><p>　　Model2的开发模式是：Jsp+Servlet+JavaBean的模式，它和Model1不同的是，增加了Servlet，将调用页面数据，调用业务逻辑等工作放到了Servlet中处理，从而减轻了Jsp的工作负担!它的基本流程如下：</p><p>　　</p><p><img src="http://ss.csdn.net/p?http://mmbiz.qpic.cn/mmbiz_png/UtWdDgynLdaZlHDsiahibvG80sBnZVmc7ytfXWeJPyadrv9s3Udb9sJ8BIbyQBdbkvfNic807hWDjTFcJYdIVriazQ/?" alt="img"></p><p>　　Model2开发模式将Servlet的概念引入架构体系中，使用它来分配视图层Jsp的显示页面，同时调用模型层的JavaBean来控制业务逻辑。</p><p>　<strong>3、Model1和Model2的区别：</strong></p><p>　　Model1：简单，适合小型项目的开发，但是Jsp的职责过于繁重，职责分工不明确。在后期的维护工作中，必将为此付出代价!</p><p>　　Model2：相对于Model1来说，职责分工更为明确，在Model1的基础上，抽取了Servlet层，体现了一个分层的思想，适合大型的项目开发!(当时的评判标准是适合大型项目开发的，现在看起来已经过时了!)</p><p>　　Model2看起来已经尽善尽美了，尽管如此，他还不能称之为一个比较完善的MVC设计模式!</p><p>　　<strong>4、Model1和Model2与三层的对比：</strong></p><p>　　在Model2中，我们将Servlet抽取出单独的一层，和Jsp协作完成用户数据交互的工作，也就是表示层。那么作为三层结构来说，又做了什么样的改进呢?三层则是在此基础上，将JavaBean再一次进行分割：业务逻辑、数据持久化，三层如下：</p><p>　　(1)表示层，JSP/Servlet;</p><p>　　(2)业务逻辑层：业务规则;</p><p>　　(3)持久化层：主要包装持久化的逻辑 ;</p><p>　　<img src="http://ss.csdn.net/p?http://mmbiz.qpic.cn/mmbiz_png/UtWdDgynLdaZlHDsiahibvG80sBnZVmc7yjQtBJcu47ycp41I35OvRaPKdudkZjhfp2KLK5llQXPmjEnFAwqsgug/?" alt="img"></p><p>　　各个的耦合性如下图：</p><p>　　<img src="http://ss.csdn.net/p?http://mmbiz.qpic.cn/mmbiz_png/UtWdDgynLdaZlHDsiahibvG80sBnZVmc7yWDdCzquCJcIzlU4Jukl615394J4ksNYwg6zqEEIjD3lpKZJU9GJIdA/?" alt="img"></p><p>　　Model1、Model2、三层是在解耦的基础上一步步进化而来，通过解耦我们可以进行进一步的抽象，以应对现实需求的变动。</p><h3 id="1-2-Web发展初级阶段存在的问题"><a href="#1-2-Web发展初级阶段存在的问题" class="headerlink" title="1.2 Web发展初级阶段存在的问题"></a>1.2 Web发展初级阶段存在的问题</h3><p>　　经历过初级阶段的小伙伴肯定看得懂下边的一个项目结构，一个简单的MVC三层结构，使用JSP+Servlet+MySQL+JDBC技术，面向接口编程：</p><p>　　</p><p><img src="http://ss.csdn.net/p?http://mmbiz.qpic.cn/mmbiz_png/UtWdDgynLdaZlHDsiahibvG80sBnZVmc7yoibibdzLsTZ2fK9VtWg0732VkxQLm0388XcHwmQPQCSKrIokCUvTwsnQ/?" alt="img"></p><p>　<strong>1、面向接口编程的实例化对象</strong></p><p>　　以用户管理模块为例，有一个UserDao接口，有一个接口的实现类UserDaoImpl，如下：</p><p>　　</p><p><img src="http://ss.csdn.net/p?http://mmbiz.qpic.cn/mmbiz_png/UtWdDgynLdaZlHDsiahibvG80sBnZVmc7yahIq03XlRavlSEDd7vcSic8x2337dMnuNhAXMlSgicnvicLUlLmyxAsgQ/?" alt="img"></p><p>　　由于是面向接口编程，因此我们在每次使用UserDao的时候，都要进行实例化一次，实例化代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UserDao userDao = <span class="keyword">new</span> UserDaoImpl();</span><br></pre></td></tr></table></figure><p>　　我们在每次使用UserDao的时候都需要进行实例化，当然不仅仅有UserDao需要进行实例化，还有很多需要进行实例化的，举例如下：</p><p>　　</p><p><img src="http://ss.csdn.net/p?http://mmbiz.qpic.cn/mmbiz_png/UtWdDgynLdaZlHDsiahibvG80sBnZVmc7ytRyyWSibiawRxVGgSmpxEdTNezvDG4XDk6XZzVeQCv8oOsb0j9brt6qQ/?" alt="img"></p><p>　　可以看出，每一个方法中都需要进行实例化我们需要用到的接口的实现类，这就会存在大量的实例化对象，并且他们的生命周期可能就是从方法的调用开始到方法的调用结束为止，加大了GC回收的压力!</p><p>　　<strong>2、使用单例模式的一次改进</strong></p><p>　　了解设计模式的可能会想到使用单例模式的方式来解决这个问题，以此来避免大量重复的创建对象，但是我们还要考虑到众多的这种对象的创建都需要改成单例模式的话，是一个耗时耗力的操作。</p><p>　　对于这个系统来说，如果都把这种面向接口的对象实现类转换为单例模式的方式的话，大概也要写十几个或者上百个这种单例模式代码，而对于一个单例模式的写法来说，往往是模板式的代码，以静态内部类的方式实现代理模式如下：</p><p>　　<img src="http://ss.csdn.net/p?http://mmbiz.qpic.cn/mmbiz_png/UtWdDgynLdaZlHDsiahibvG80sBnZVmc7yic2lFGziaS4m20ebHy7JsMBEQlnPw2ick5IApp1lKcEXS19SfnkSXGTEw/?" alt="img"></p><p>　　可以看出，这种方式有两个问题：</p><p>　　(1)业务代码与单例模式的模板代码放在一个类里，耦合性较高;</p><p>　　(2)大量重复的单例模式的模板代码;</p><p>　　从上述可以看出，使用的单例模式虽然从性能上有所提高，但是却加重了我们的开发成本。因此只会小规模的使用，例如我们操作JDBC的Utils对象等。</p><p>　<strong>3、我们开发中遇到的痛点</strong></p><p>　　从上述代码的演进过程我们可以看得出来，我们即需要一个单例的对象来避免系统中大量重复对象的创建和销毁，又不想因为使用单例模式造成大量重复无用的模板代码和代码的耦合!</p><p>　　<strong>4、我们还能怎么做</strong></p><p>　　作为学院派的书生来说，我们可能会联想到“数据库连接池”,我们在获取数据库连接的时候会从这个池子中拿到一个连接的，假设这个数据库连接池很特殊，有且只能有N个数据库连接，并且每一个连接对象都不同(假设)，那么这个不就相当于每一个连接都是单例的了吗?既可以避免大量对象的创建，也可以实现不会出现大量重复性的模板代码。</p><p>　　因此，这里应该有一个大胆的想法，我们是否可以建立一个池子，将我们的接口实现类对象放入到这个池子中，我们在使用的时候直接从这个池子里边取就行了!</p><p>　<strong>5、这个池子</strong></p><p>　　如果我们要创建这个池子，首先要确定需要把哪些对象放进这个池子，通过怎样的方式放进去，放进去之后如何进行管理，如何进行获取，池子中的每一个对象的生命周期是怎么样的等等这些东西都是我们需要考虑到的!</p><p>​     所以，Spring应运而生了！</p><h2 id="2-IOC理论概念"><a href="#2-IOC理论概念" class="headerlink" title="2. IOC理论概念"></a>2. IOC理论概念</h2><h3 id="2-1-背景"><a href="#2-1-背景" class="headerlink" title="2.1 背景"></a>2.1 背景</h3><p>我们都知道，在采用面向对象方法设计的软件系统中，它的底层实现都是由N个对象组成的，所有的对象通过彼此的合作，最终实现系统的业务逻辑。</p><p><img src="https://pic002.cnblogs.com/images/2011/230454/2011052709382686.jpg" alt="图1"></p><p>如果我们打开机械式手表的后盖，就会看到与上面类似的情形，但是如果有一个齿轮出了问题，就可能会影响到整个齿轮组的正常运转。</p><p>齿轮组中齿轮之间的啮合关系,与软件系统中对象之间的耦合关系非常相似。对象之间的耦合关系是无法避免的，也是必要的，这是协同工作的基础。</p><p><img src="https://pic002.cnblogs.com/images/2011/230454/2011052709390013.jpg" alt=""></p><p><strong>为了解决对象之间的耦合度过高的问题</strong>，软件专家Michael Mattson提出了IOC理论，用来实现对象之间的“解耦”，目前这个理论已经被成功地应用到实践当中，很多的J2EE项目均采用了IOC框架产品Spring。</p><hr><h3 id="2-2-什么是控制反转（IOC）"><a href="#2-2-什么是控制反转（IOC）" class="headerlink" title="2.2 什么是控制反转（IOC）"></a>2.2 什么是控制反转（IOC）</h3><p>IOC是Inversion of Control的缩写，多数书籍翻译成“控制反转”，还有些书籍翻译成为“控制反向”或者“控制倒置”。</p><p>观点大体是这样的：<strong>借助于“第三方”实现具有依赖关系的对象之间的解耦。</strong></p><p><img src="https://pic002.cnblogs.com/images/2011/230454/2011052709391014.jpg" alt=""></p><p>由于引进了中间位置的“第三方”，也就是IOC容器，使得A、B、C、D这4个对象没有了耦合关系，齿轮之间的传动全部依靠“第三方”了，全部对象的控制权全部上缴给“第三方”IOC容器，所以，IOC容器成了整个系统的关键核心，它起到了一种类似“粘合剂”的作用，把系统中的所有对象粘合在一起发挥作用，如果没有这个“粘合剂”，对象与对象之间会彼此失去联系，这就是有人把IOC容器比喻成“粘合剂”的由来。</p><p><img src="https://pic002.cnblogs.com/images/2011/230454/2011052709392670.jpg" alt=""></p><p>拿掉IoC容器后的系统就是现在看到的画面，就是我们要实现整个系统所需要完成的全部内容。</p><p>这时候，A、B、C、D这4个对象之间已经没有了耦合关系，彼此毫无联系，这样的话，当你在实现A的时候，根本无须再去考虑B、C和D了，对象之间的依赖关系已经降低到了最低程度。</p><p><strong>对比：</strong></p><ul><li><p>引入IOC容器之前：</p><p>如图1所示，对象A依赖于对象B，那么对象A在初始化或者运行到某一点的时候，自己必须主动去创建对象B或者使用已经创建的对象B。无论是创建还是使用对象B，控制权都在自己手上。</p></li><li><p>引入IOC容器之后</p><p>如图3所示，由于IOC容器的加入，对象A与对象B之间失去了直接联系，所以，当对象A运行到需要对象B的时候，IOC容器会主动创建一个对象B注入到对象A需要的地方。</p></li></ul><p>通过前后的对比，我们不难看出来：对象A获得依赖对象B的过程,由主动行为变为了被动行为，控制权颠倒过来了，这就是“控制反转”这个名称的由来。</p><hr><h3 id="2-3-IOC的别名：依赖注入（DI）"><a href="#2-3-IOC的别名：依赖注入（DI）" class="headerlink" title="2.3 IOC的别名：依赖注入（DI）"></a>2.3 IOC的别名：依赖注入（DI）</h3><p>既然IOC是控制反转，那么到底是“哪些方面的控制被反转了呢？”</p><p>“获得依赖对象的过程被反转了”</p><p>控制被反转之后，获得依赖对象的过程由自身管理变为了由IOC容器主动注入。</p><p>所谓依赖注入，就是由IOC容器在运行期间，动态地将某种依赖关系注入到对象之中。</p><p>所以，依赖注入(DI)和控制反转(IOC)是从不同的角度的描述的同一件事情，就是指<strong>通过引入IOC容器，利用依赖关系注入的方式，实现对象之间的解耦</strong>。</p><p>收到任务：从外部USB设备读取一个文件。</p><p><img src="https://pic002.cnblogs.com/images/2011/230454/2011052709393897.jpg" alt=""></p><p>电脑主机读取文件的时候，它一点也不会关心USB接口上连接的是什么外部设备，而且它确实也无须知道。它的任务就是读取USB接口，挂接的外部设备只要符合USB接口标准即可。所以，如果我给电脑主机连接上一个U盘，那么主机就从U盘上读取文件；如果我给电脑主机连接上一个外置硬盘，那么电脑主机就从外置硬盘上读取文件。挂接外部设备的权力由我作主，即控制权归我，至于USB接口挂接的是什么设备，电脑主机是决定不了，它只能被动的接受。电脑主机需要外部设备的时候，根本不用它告诉我，我就会主动帮它挂上它想要的外部设备，你看我的服务是多么的到位。这就是我们生活中常见的一个依赖注入的例子。在这个过程中，<strong>我就起到了IOC容器的作用</strong>。</p><p>当电脑主机读取文件的时候，我就把它所要依赖的外部设备，帮他挂接上。整个外部设备注入的过程和一个被依赖的对象在系统运行时被注入另外一个对象内部的过程完全一样。</p><p>我们把依赖注入应用到软件系统中，再来描述一下这个过程：<br>对象A依赖于对象B,当对象 A需要用到对象B的时候，IOC容器就会立即创建一个对象B送给对象A。IOC容器就是一个对象制造工厂，你需要什么，它会给你送去，你直接使用就行了，而再也不用去关心你所用的东西是如何制成的，也不用关心最后是怎么被销毁的，这一切全部由IOC容器包办。</p><p>在传统的实现中，由程序内部代码来控制组件之间的关系。我们经常使用new关键字来实现两个组件之间关系的组合，这种实现方式会造成组件之间耦合。IOC很好地解决了该问题，它将实现组件间关系从程序内部提到外部容器，也就是说由容器在运行期将组件间的某种依赖关系动态注入组件中。</p><hr><h3 id="2-4-IOC带来的好处"><a href="#2-4-IOC带来的好处" class="headerlink" title="2.4 IOC带来的好处"></a>2.4 IOC带来的好处</h3><ol><li>USB设备作为电脑主机的外部设备，在插入主机之前，与电脑主机没有任何的关系，只有被我们连接在一起之后，两者才发生联系，具有相关性。出问题了互不影响，便于调试，可维护性好。</li><li>USB设备和电脑主机的之间无关性，还带来了另外一个好处，生产USB设备的厂商和生产电脑主机的厂商完全可以是互不相干的人，各干各事，他们之间唯一需要遵守的就是USB接口标准。每个开发团队的成员都只需要关心实现自身的业务逻辑，完全不用去关心其它的人工作进展，因为你的任务跟别人没有任何关系，你的任务可以单独测试，你的任务也不用依赖于别人的组件，再也不用扯不清责任了。</li><li>同一个USB外部设备可以插接到任何支持USB的设备。可复用性好</li><li>同USB外部设备一样，模块具有热插拔特性。IOC生成对象的方式转为外置方式，也就是把对象生成放在配置文件里进行定义，这样，当我们更换一个实现子类将会变得很简单，只要修改配置文件就可以了，完全具有热插拨的特性。</li></ol><hr><h2 id="3-IOC容器的技术剖析"><a href="#3-IOC容器的技术剖析" class="headerlink" title="3. IOC容器的技术剖析"></a>3. IOC容器的技术剖析</h2><p><img src="https://fiverr-res.cloudinary.com/images/t_main1,q_auto,f_auto/gigs/107023980/original/fcd37c016e9b1c54b3272e27e5374b0d2fe3cc06/fix-bugs-in-spring-framework-applications.png" alt=""></p><p>Spring 是一个“引擎”；</p><p>Spring MVC 是基于Spring的一个 MVC 框架 ；</p><p>Spring Boot 是基于Spring的条件注册的一套快速开发整合包。</p><p>IOC中最基本的技术就是“反射(Reflection)”编程，目前.Net C#、<a href="http://lib.csdn.net/base/17" target="_blank" rel="external">Java</a>和PHP5等语言均支持，其中PHP5的技术书籍中，有时候也被翻译成“映射”。<strong>有关反射的概念和用法，大家应该都很清楚，通俗来讲就是根据给出的类名（字符串方式）来动态地生成对象</strong>。</p><p><strong>我们可以把IOC容器的工作模式看做是工厂模式的升华，可以把IOC容器看作是一个工厂，这个工厂里要生产的对象都在配置文件中给出定义，然后利用编程语言的的反射编程，根据配置文件中给出的类名生成相应的对象。从实现来看，IOC是把以前在工厂方法里写死的对象生成代码，改变为由配置文件来定义，也就是把工厂和对象生成这两者独立分隔开来，目的就是提高灵活性和可维护性。</strong></p><p>先看下最基本的启动 Spring 容器的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"classpath:applicationfile.xml"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ApplicationContext context = new ClassPathXmlApplicationContext(...)</code> 其实很好理解，从名字上就可以猜出一二，就是在 ClassPath 中寻找 xml 配置文件，根据 xml 文件内容来构建 ApplicationContext。当然，除了 ClassPathXmlApplicationContext 以外，我们也还有其他构建 ApplicationContext 的方案可供选择，我们先来看看大体的继承结构是怎么样的：</p><p><img src="https://javadoop.com/blogimages/spring-context/1.png" alt=""></p><p>我们可以看到，ClassPathXmlApplicationContext 兜兜转转了好久才到 ApplicationContext 接口，同样的，我们也可以使用绿颜色的 <strong>FileSystemXmlApplicationContext</strong> 和 <strong>AnnotationConfigApplicationContext</strong> 这两个类。</p><p><strong>FileSystemXmlApplicationContext</strong> 的构造函数需要一个 xml 配置文件在系统中的路径，其他和 ClassPathXmlApplicationContext 基本上一样。</p><p><strong>AnnotationConfigApplicationContext</strong> 是基于注解来使用的，它不需要配置文件，采用 java 配置类和各种注解来配置，是比较简单的方式，也是大势所趋吧。</p><p>不过今天旨在帮助大家理解整个构建流程，所以决定使用 ClassPathXmlApplicationContext 进行分析。</p><p>定义接口实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageServiceImpl</span> <span class="keyword">implements</span> <span class="title">MessageService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello world"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，我们在 <strong>resources</strong> 目录新建一个配置文件，文件名随意，通常叫 application.xml 或 application-xxx.xml 就可以了：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span> <span class="attr">default-autowire</span>=<span class="string">"byName"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"messageService"</span> <span class="attr">class</span>=<span class="string">"com.javadoop.example.MessageServiceImpl"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样，我们就可以跑起来了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 用我们的配置文件来启动一个 ApplicationContext</span></span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"classpath:application.xml"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"context 启动成功"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从 context 中取出我们的 Bean，而不是用 new MessageServiceImpl() 这种方式</span></span><br><span class="line">        MessageService messageService = context.getBean(MessageService.class);</span><br><span class="line">        <span class="comment">// 这句将输出: hello world</span></span><br><span class="line">        System.out.println(messageService.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上例子很简单，不过也够引出本文的主题了，就是怎么样通过配置文件来启动 Spring 的 ApplicationContext？也就是我们今天要分析的 IOC 的核心了。ApplicationContext 启动过程中，会负责创建实例 Bean，往各个 Bean 中注入依赖等。</p><h3 id="3-1BeanFactory-简介"><a href="#3-1BeanFactory-简介" class="headerlink" title="3.1BeanFactory 简介"></a>3.1BeanFactory 简介</h3><p>BeanFactory，从名字上也很好理解，生产 bean 的工厂，它负责生产和管理各个 bean 实例。</p><p>初学者可别以为我之前说那么多和 BeanFactory 无关，前面说的 ApplicationContext 其实就是一个 BeanFactory。我们来看下和 BeanFactory 接口相关的主要的继承结构：</p><p><img src="https://javadoop.com/blogimages/spring-context/2.png" alt="2"></p><p>我想，大家看完这个图以后，可能就不是很开心了。ApplicationContext 往下的继承结构前面一张图说过了，这里就不重复了。</p><ol><li>ApplicationContext 继承了 ListableBeanFactory，这个 Listable 的意思就是，通过这个接口，我们可以获取多个 Bean。</li><li>ApplicationContext 继承了 HierarchicalBeanFactory，Hierarchical 单词本身已经能说明问题了，也就是说我们可以在应用中起多个 BeanFactory，然后可以将各个 BeanFactory 设置为父子关系。</li><li>AutowireCapableBeanFactory 这个名字中的 Autowire 大家都非常熟悉，它就是用来自动装配 Bean 用的，但是仔细看上图，ApplicationContext 并没有继承它，不过不用担心，不使用继承，不代表不可以使用组合，如果你看到 ApplicationContext 接口定义中的最后一个方法 getAutowireCapableBeanFactory() 就知道了。</li><li>ConfigurableListableBeanFactory 也是一个特殊的接口，看图，特殊之处在于它继承了第二层所有的三个接口，而 ApplicationContext 没有。</li></ol><h3 id="3-2-SpringBean的生命周期"><a href="#3-2-SpringBean的生命周期" class="headerlink" title="3.2 SpringBean的生命周期"></a>3.2 SpringBean的生命周期</h3><p>Spring Bean的完整生命周期从创建Spring容器开始，直到最终Spring容器销毁Bean，这其中包含了一系列关键点。</p><p><img src="https://images0.cnblogs.com/i/580631/201405/181453414212066.png" alt="img"></p><p><img src="https://images0.cnblogs.com/i/580631/201405/181454040628981.png" alt="img"></p><h3 id="3-3接口分类"><a href="#3-3接口分类" class="headerlink" title="3.3接口分类"></a>3.3接口分类</h3><p>Bean的完整生命周期经历了各种方法调用，这些方法可以划分为以下几类：</p><ol><li>Bean自身的方法：这个包括了Bean本身调用的方法和通过配置文件中<bean>的init-method和destroy-method指定的方法</bean></li><li>Bean级生命周期接口方法：这个包括了BeanNameAware、BeanFactoryAware、InitializingBean和DiposableBean这些接口的方法</li><li>容器级生命周期接口方法：这个包括了InstantiationAwareBeanPostProcessor 和 BeanPostProcessor 这两个接口实现，一般称它们的实现类为“后处理器”。</li><li>工厂后处理器接口方法：这个包括了AspectJWeavingEnabler, ConfigurationClassPostProcessor, CustomAutowireConfigurer等等非常有用的工厂后处理器　　接口的方法。工厂后处理器也是容器级的。在应用上下文装配配置文件之后立即调用。</li></ol><h3 id="3-4-演示"><a href="#3-4-演示" class="headerlink" title="3.4 演示"></a>3.4 演示</h3><p>先来看看，Spring在Bean从创建到销毁的生命周期中可能做得事情。</p><p>详细代码在文章底部附录</p><h4 id="3-4-1-实现-Aware接口-在Bean中使用Spring框架的一些对象"><a href="#3-4-1-实现-Aware接口-在Bean中使用Spring框架的一些对象" class="headerlink" title="3.4.1 实现*Aware接口 在Bean中使用Spring框架的一些对象"></a>3.4.1 实现*Aware接口 在Bean中使用Spring框架的一些对象</h4><p>有些时候我们需要在Bean的初始化中使用Spring框架自身的一些对象来执行一些操作，比如获取ServletContext的一些参数，获取ApplicaitionContext中的BeanDefinition的名字，获取Bean在容器中的名字等等。为了让Bean可以获取到框架自身的一些对象，Spring提供了一组名为<em>Aware的接口。<br>这些接口均继承于<code>org.springframework.beans.factory.Aware</code>标记接口，并提供一个将由Bean实现的set</em>方法,Spring通过基于setter的依赖注入方式使相应的对象可以被Bean使用。</p><p>网上说，这些接口是利用观察者模式实现的，因为时间有限，所以我暂时还不太明白，有兴趣的话大家可以去详细的看一下。</p><p>重要的Aware接口：</p><ul><li>ApplicationContextAware: 获得ApplicationContext对象,可以用来获取所有Bean definition的名字。</li><li>BeanFactoryAware:获得BeanFactory对象，可以用来检测Bean的作用域。</li><li>BeanNameAware:获得Bean在配置文件中定义的名字。</li><li>ResourceLoaderAware:获得ResourceLoader对象，可以获得classpath中某个文件。</li><li>ServletContextAware:在一个MVC应用中可以获取ServletContext对象，可以读取context中的参数。</li><li>ServletConfigAware在一个MVC应用中可以获取ServletConfig对象，可以读取config中的参数。</li></ul><h4 id="3-4-2-BeanPostProcessor"><a href="#3-4-2-BeanPostProcessor" class="headerlink" title="3.4.2 BeanPostProcessor"></a>3.4.2 BeanPostProcessor</h4><p>上面的*Aware接口是针对某个实现这些接口的Bean定制初始化的过程，<br>Spring同样可以针对容器中的所有Bean，或者某些Bean定制初始化过程，只需提供一个实现BeanPostProcessor接口的类即可。 该接口中包含两个方法，postProcessBeforeInitialization和postProcessAfterInitialization。 postProcessBeforeInitialization方法会在容器中的Bean初始化之前执行， postProcessAfterInitialization方法在容器中的Bean初始化之后执行。</p><h3 id="3-5-总结"><a href="#3-5-总结" class="headerlink" title="3.5 总结"></a>3.5 总结</h3><p>所以。。。结合第一节控制台输出的内容，Spring Bean的生命周期是这样纸的：</p><ul><li>Bean容器找到配置文件中Spring Bean的定义。</li><li>Bean容器利用Java Reflection API创建一个Bean的实例。</li><li>如果涉及到一些属性值 利用set方法设置一些属性值。</li><li>如果Bean实现了BeanNameAware接口，调用setBeanName()方法，传入Bean的名字。</li><li>如果Bean实现了BeanClassLoaderAware接口，调用setBeanClassLoader()方法，传入ClassLoader对象的实例。</li><li>如果Bean实现了BeanFactoryAware接口，调用setBeanClassLoader()方法，传入ClassLoader对象的实例。</li><li>与上面的类似，如果实现了其他*Aware接口，就调用相应的方法。</li><li>如果有和加载这个Bean的Spring容器相关的BeanPostProcessor对象，执行postProcessBeforeInitialization()方法</li><li>如果Bean实现了InitializingBean接口，执行afterPropertiesSet()方法。</li><li>如果Bean在配置文件中的定义包含<code>init-method</code>属性，执行指定的方法。</li><li>如果有和加载这个Bean的Spring容器相关的BeanPostProcessor对象，执行postProcessAfterInitialization()方法</li><li>当要销毁Bean的时候，如果Bean实现了DisposableBean接口，执行destroy()方法。</li><li>当要销毁Bean的时候，如果Bean在配置文件中的定义包含<code>destroy-method</code>属性，执行指定的方法。</li></ul><p><img src="https://yemengying.com/qiniu/image/image/life.png" alt="Spring BeanLifeCycle"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>这篇文章参考了大量的博客，一一列举如下：</p><ul><li><a href="https://caoler.cn/post/2018/SpringBeanLife.html">自己之前写的一篇博客 - Spring Bean生命周期</a></li><li><a href="https://www.jianshu.com/p/3944792a5fff" target="_blank" rel="external">简书 - Spring Bean生命周期</a></li><li><a href="https://yemengying.com/2016/07/14/spring-bean-life-cycle/" target="_blank" rel="external">小姐姐Giraffe的博客 -【Spring】Bean的生命周期</a></li><li><a href="https://blog.csdn.net/yqj2065/article/details/51589813" target="_blank" rel="external">yqj2065-什么是控制反转（Inversion of Control）-渗透了部分严老师的思想</a></li><li><a href="https://www.cnblogs.com/zrtqsk/p/3735273.html" target="_blank" rel="external">Spring Bean的生命周期（非常详细）- 确实非常详细！</a></li><li><a href="https://javadoop.com/post/spring-ioc" target="_blank" rel="external">大佬的技术博客 - 里面还有大量好文章</a></li><li><a href="https://www.cnblogs.com/wang-meng/p/5597490.html" target="_blank" rel="external">Spring IOC的原理及详解 - 原理讲的很透彻</a></li><li><a href="https://www.easemob.com/news/1213" target="_blank" rel="external">这里详细描述了Spring的诞生史</a></li></ul><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>演示部分的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.myhexin.ioc.bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现InitializingBean和DisposableBean接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person1</span> <span class="keyword">implements</span> <span class="title">BeanFactoryAware</span>, <span class="title">BeanNameAware</span>, <span class="title">InitializingBean</span>, <span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> phone;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BeanFactory beanFactory;</span><br><span class="line">    <span class="keyword">private</span> String beanName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"【构造器】调用Person1的构造器实例化"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"【注入属性】注入属性name"</span>);</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAddress</span><span class="params">(String address)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"【注入属性】注入属性address"</span>);</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPhone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> phone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPhone</span><span class="params">(<span class="keyword">int</span> phone)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"【注入属性】注入属性phone"</span>);</span><br><span class="line">        <span class="keyword">this</span>.phone = phone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为一个bean设置属性，除了上面的通过setter注入的方式还有哪几种？</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", address='"</span> + address + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", phone="</span> + phone +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    这种方法比较简单，但是不建议使用。因为这样会将Bean的实现和Spring框架耦合在一起。</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"执行DisposableBean接口的destroy方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"执行InitializingBean接口的afterPropertiesSet方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanFactory</span><span class="params">(BeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"【BeanFactoryAware接口】调用BeanFactoryAware.setBeanFactory()"</span>);</span><br><span class="line">        <span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanName</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"【BeanNameAware接口】调用BeanNameAware.setBeanName()"</span>);</span><br><span class="line">        <span class="keyword">this</span>.beanName = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自定义的初始化函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myInit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"myInit被调用"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自定义的销毁方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"myDestroy被调用"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.myhexin.ioc.bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.PostConstruct;</span><br><span class="line"><span class="keyword">import</span> javax.annotation.PreDestroy;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用@PostConstruct和@PreDestroy注解</span></span><br><span class="line"><span class="comment">//@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person2</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"【构造器】调用Person2的构造器实例化"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initPostConstruct</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"执行PostConstruct注解标注的方法,初始化bean"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preDestroy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"执行preDestroy注解标注的方法，销毁bean"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.myhexin.ioc.bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.BeanDefinition;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.BeanFactoryPostProcessor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.ConfigurableListableBeanFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonBeanFactoryPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanFactoryPostProcessor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory configurableListableBeanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"BeanFactoryPostProcessor调用postProcessBeanFactory方法"</span>);</span><br><span class="line">        BeanDefinition bd = configurableListableBeanFactory.getBeanDefinition(<span class="string">"person1"</span>);</span><br><span class="line">        bd.getPropertyValues().addPropertyValue(<span class="string">"phone"</span>, <span class="string">"110"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.myhexin.ioc.bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.BeanPostProcessor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"BeanPostProcessor接口方法postProcessBeforeInitialization对属性进行更改！"</span>);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"BeanPostProcessor接口方法postProcessAfterInitialization对属性进行更改！"</span>);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.myhexin.ioc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.myhexin.ioc.bean.Person1;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IocApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"开始初始化容器"</span>);</span><br><span class="line">        ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"classpath:bean.xml"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"xml加载完毕"</span>);</span><br><span class="line">        Person1 person1 = (Person1) ac.getBean(<span class="string">"person1"</span>);</span><br><span class="line">        System.out.println(person1);</span><br><span class="line">        System.out.println(<span class="string">"关闭容器"</span>);</span><br><span class="line">        ((ClassPathXmlApplicationContext)ac).close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">            http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">            http://www.springframework.org/schema/beans/spring-beans-3.2.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"person1"</span> <span class="attr">destroy-method</span>=<span class="string">"myDestroy"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">init-method</span>=<span class="string">"myInit"</span> <span class="attr">class</span>=<span class="string">"com.myhexin.ioc.bean.Person1"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>巫妖王<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"address"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>东北<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;property name="phone"&gt;--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--&lt;value&gt;888&lt;/value&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;/property&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置自定义的后置处理器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"personBeanPostProcessor"</span> <span class="attr">class</span>=<span class="string">"com.myhexin.ioc.bean.PersonBeanPostProcessor"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"personBeanFactoryPostProcessor"</span> <span class="attr">class</span>=<span class="string">"com.myhexin.ioc.bean.PersonBeanFactoryPostProcessor"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前有写过SpringBean的文章，但是大部分都是搬运的，自己对它的深层次思想并没有掌握，所以在这里重写一下。&lt;/p&gt;
&lt;p&gt;IOC部分在第一次学Spring的时候就已经在接触了，但是还是了解的不够深入，最近在看了一部分SpringIOC的源码之后，才模模糊糊的明白了一些，正好赶上组内技术分享，做此下文&lt;/p&gt;
    
    </summary>
    
      <category term="Spring" scheme="https://caoler.cn/categories/Spring/"/>
    
      <category term="IOC" scheme="https://caoler.cn/categories/Spring/IOC/"/>
    
    
      <category term="spring" scheme="https://caoler.cn/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>Java ConcurrentModificationException异常原因和解决方法</title>
    <link href="https://caoler.cn//post/2018/ConcurrentModificationException.html"/>
    <id>https://caoler.cn//post/2018/ConcurrentModificationException.html</id>
    <published>2018-08-07T08:38:00.000Z</published>
    <updated>2018-10-14T12:54:20.517Z</updated>
    
    <content type="html"><![CDATA[<p>　　在前面一篇文章中提到，对Vector、ArrayList在迭代的时候如果同时对其进行修改就会抛出java.util.ConcurrentModificationException异常。下面我们就来讨论以下这个异常出现的原因以及解决办法。</p><a id="more"></a><p>　　以下是本文目录大纲：</p><p>　　一.ConcurrentModificationException异常出现的原因</p><p>　　二.在单线程环境下的解决办法</p><p>　　三.在多线程环境下的解决方法</p><p>　　若有不正之处请多多谅解，并欢迎批评指正</p><p>　　请尊重作者劳动成果，转载请标明原文链接：</p><p>　　<a href="http://www.cnblogs.com/dolphin0520/p/3933551.html" target="_blank" rel="external">http://www.cnblogs.com/dolphin0520/p/3933551.html</a></p><p>一.ConcurrentModificationException异常出现的原因</p><p>　　先看下面这段代码：</p><pre><code>public class Test {    public static void main(String[] args)  {        ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();        list.add(2);        Iterator&lt;Integer&gt; iterator = list.iterator();        while(iterator.hasNext()){            Integer integer = iterator.next();            if(integer==2)                list.remove(integer);        }    }}</code></pre><p> 　　运行结果：</p><p>　　</p><p>　　从异常信息可以发现，异常出现在checkForComodification()方法中。</p><p>　　我们不忙看checkForComodification()方法的具体实现，我们先根据程序的代码一步一步看ArrayList源码的实现：</p><p>　　首先看ArrayList的iterator()方法的具体实现，查看源码发现在ArrayList的源码中并没有iterator()这个方法，那么很显然这个方法应该是其父类或者实现的接口中的方法，我们在其父类AbstractList中找到了iterator()方法的具体实现，下面是其实现代码：</p><pre><code>public Iterator&lt;E&gt; iterator() {    return new Itr();}</code></pre><p> 　　从这段代码可以看出返回的是一个指向Itr类型对象的引用，我们接着看Itr的具体实现，在AbstractList类中找到了Itr类的具体实现，它是AbstractList的一个成员内部类，下面这段代码是Itr类的所有实现：</p><pre><code>private class Itr implements Iterator&lt;E&gt; {    int cursor = 0;    int lastRet = -1;    int expectedModCount = modCount;    public boolean hasNext() {           return cursor != size();    }    public E next() {           checkForComodification();        try {        E next = get(cursor);        lastRet = cursor++;        return next;        } catch (IndexOutOfBoundsException e) {        checkForComodification();        throw new NoSuchElementException();        }    }    public void remove() {        if (lastRet == -1)        throw new IllegalStateException();           checkForComodification();        try {        AbstractList.this.remove(lastRet);        if (lastRet &lt; cursor)            cursor--;        lastRet = -1;        expectedModCount = modCount;        } catch (IndexOutOfBoundsException e) {        throw new ConcurrentModificationException();        }    }    final void checkForComodification() {        if (modCount != expectedModCount)        throw new ConcurrentModificationException();    }}</code></pre><p>首先我们看一下它的几个成员变量：</p><p>　　cursor：表示下一个要访问的元素的索引，从next()方法的具体实现就可看出</p><p>　　lastRet：表示上一个访问的元素的索引</p><p>　　expectedModCount：表示对ArrayList修改次数的期望值，它的初始值为modCount。</p><p>　　modCount是AbstractList类中的一个成员变量</p><pre><code>protected transient int modCount = 0;</code></pre><p> 　　该值表示对List的修改次数，查看ArrayList的add()和remove()方法就可以发现，每次调用add()方法或者remove()方法就会对modCount进行加1操作。</p><p>　　好了，到这里我们再看看上面的程序：</p><p>　　当调用list.iterator()返回一个Iterator之后，通过Iterator的hashNext()方法判断是否还有元素未被访问，我们看一下hasNext()方法，hashNext()方法的实现很简单：</p><pre><code>public boolean hasNext() {    return cursor != size();}</code></pre><p> 　　如果下一个访问的元素下标不等于ArrayList的大小，就表示有元素需要访问，这个很容易理解，如果下一个访问元素的下标等于ArrayList的大小，则肯定到达末尾了。</p><p>　　然后通过Iterator的next()方法获取到下标为0的元素，我们看一下next()方法的具体实现：</p><pre><code>public E next() {    checkForComodification(); try {    E next = get(cursor);    lastRet = cursor++;    return next; } catch (IndexOutOfBoundsException e) {    checkForComodification();    throw new NoSuchElementException(); }}</code></pre><p> 　　这里是非常关键的地方：首先在next()方法中会调用checkForComodification()方法，然后根据cursor的值获取到元素，接着将cursor的值赋给lastRet，并对cursor的值进行加1操作。初始时，cursor为0，lastRet为-1，那么调用一次之后，cursor的值为1，lastRet的值为0。注意此时，modCount为0，expectedModCount也为0。</p><p>　　接着往下看，程序中判断当前元素的值是否为2，若为2，则调用list.remove()方法来删除该元素。</p><p>　　我们看一下在ArrayList中的remove()方法做了什么：</p><pre><code>public boolean remove(Object o) {    if (o == null) {        for (int index = 0; index &lt; size; index++)            if (elementData[index] == null) {                fastRemove(index);                return true;            }    } else {        for (int index = 0; index &lt; size; index++)            if (o.equals(elementData[index])) {                fastRemove(index);                return true;            }    }    return false;}</code></pre><p>​<br>​    private void fastRemove(int index) {<br>​        modCount++;<br>​        int numMoved = size - index - 1;<br>​        if (numMoved &gt; 0)<br>​            System.arraycopy(elementData, index+1, elementData, index,<br>​                    numMoved);<br>​        elementData[–size] = null; // Let gc do its work<br>​    }</p><p> 　　通过remove方法删除元素最终是调用的fastRemove()方法，在fastRemove()方法中，首先对modCount进行加1操作（因为对集合修改了一次），然后接下来就是删除元素的操作，最后将size进行减1操作，并将引用置为null以方便垃圾收集器进行回收工作。</p><p>　　那么注意此时各个变量的值：对于iterator，其expectedModCount为0，cursor的值为1，lastRet的值为0。</p><p>　　对于list，其modCount为1，size为0。</p><p>　　接着看程序代码，执行完删除操作后，继续while循环，调用hasNext方法()判断，由于此时cursor为1，而size为0，那么返回true，所以继续执行while循环，然后继续调用iterator的next()方法：</p><p>　　注意，此时要注意next()方法中的第一句：checkForComodification()。</p><p>　　在checkForComodification方法中进行的操作是：</p><pre><code>final void checkForComodification() {    if (modCount != expectedModCount)    throw new ConcurrentModificationException();}</code></pre><p> 　　如果modCount不等于expectedModCount，则抛出ConcurrentModificationException异常。</p><p>　　很显然，此时modCount为1，而expectedModCount为0，因此程序就抛出了ConcurrentModificationException异常。</p><p>　　到这里，想必大家应该明白为何上述代码会抛出ConcurrentModificationException异常了。</p><p>　　关键点就在于：调用list.remove()方法导致modCount和expectedModCount的值不一致。</p><p>　　注意，像使用for-each进行迭代实际上也会出现这种问题。</p><p>二.在单线程环境下的解决办法</p><p>　　既然知道原因了，那么如何解决呢？</p><p>　　其实很简单，细心的朋友可能发现在Itr类中也给出了一个remove()方法：</p><pre><code>public void remove() {    if (lastRet == -1)    throw new IllegalStateException();       checkForComodification();    try {    AbstractList.this.remove(lastRet);    if (lastRet &lt; cursor)        cursor--;    lastRet = -1;    expectedModCount = modCount;    } catch (IndexOutOfBoundsException e) {    throw new ConcurrentModificationException();    }}</code></pre><p> 　　在这个方法中，删除元素实际上调用的就是list.remove()方法，但是它多了一个操作：</p><pre><code>expectedModCount = modCount;</code></pre><p> 　　因此，在迭代器中如果要删除元素的话，需要调用Itr类的remove方法。</p><p>　　将上述代码改为下面这样就不会报错了：</p><pre><code>public class Test {    public static void main(String[] args)  {        ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();        list.add(2);        Iterator&lt;Integer&gt; iterator = list.iterator();        while(iterator.hasNext()){            Integer integer = iterator.next();            if(integer==2)                iterator.remove();   //注意这个地方        }    }}</code></pre><p>三.在多线程环境下的解决方法</p><p>　　上面的解决办法在单线程环境下适用，但是在多线程下适用吗？看下面一个例子：</p><pre><code>public class Test {    static ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();    public static void main(String[] args)  {        list.add(1);        list.add(2);        list.add(3);        list.add(4);        list.add(5);        Thread thread1 = new Thread(){            public void run() {                Iterator&lt;Integer&gt; iterator = list.iterator();                while(iterator.hasNext()){                    Integer integer = iterator.next();                    System.out.println(integer);                    try {                        Thread.sleep(100);                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                }            };        };        Thread thread2 = new Thread(){            public void run() {                Iterator&lt;Integer&gt; iterator = list.iterator();                while(iterator.hasNext()){                    Integer integer = iterator.next();                    if(integer==2)                        iterator.remove();                 }            };        };        thread1.start();        thread2.start();    }}</code></pre><p>　运行结果：</p><p>　　</p><p>　　有可能有朋友说ArrayList是非线程安全的容器，换成Vector就没问题了，实际上换成Vector还是会出现这种错误。</p><p>　　原因在于，虽然Vector的方法采用了synchronized进行了同步，但是实际上通过Iterator访问的情况下，每个线程里面返回的是不同的iterator，也即是说expectedModCount是每个线程私有。假若此时有2个线程，线程1在进行遍历，线程2在进行修改，那么很有可能导致线程2修改后导致Vector中的modCount自增了，线程2的expectedModCount也自增了，但是线程1的expectedModCount没有自增，此时线程1遍历时就会出现expectedModCount不等于modCount的情况了。</p><p>　　因此一般有2种解决办法：</p><p>　　1）在使用iterator迭代的时候使用synchronized或者Lock进行同步；</p><p>　　2）使用并发容器CopyOnWriteArrayList代替ArrayList和Vector。</p><p>　　关于并发容器的内容将在下一篇文章中讲述。</p><p>　　参考资料：</p><p>　　<a href="http://blog.csdn.net/izard999/article/details/6708738" target="_blank" rel="external">http://blog.csdn.net/izard999/article/details/6708738</a></p><p>　　<a href="http://www.2cto.com/kf/201403/286536.html" target="_blank" rel="external">http://www.2cto.com/kf/201403/286536.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　在前面一篇文章中提到，对Vector、ArrayList在迭代的时候如果同时对其进行修改就会抛出java.util.ConcurrentModificationException异常。下面我们就来讨论以下这个异常出现的原因以及解决办法。&lt;/p&gt;
    
    </summary>
    
      <category term="JAVASE" scheme="https://caoler.cn/categories/JAVASE/"/>
    
      <category term="集合框架" scheme="https://caoler.cn/categories/JAVASE/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="ArrayList" scheme="https://caoler.cn/tags/ArrayList/"/>
    
  </entry>
  
  <entry>
    <title>Gson解析动态key的JSON文件以及优化记录</title>
    <link href="https://caoler.cn//post/2018/gson-dynamic-key.html"/>
    <id>https://caoler.cn//post/2018/gson-dynamic-key.html</id>
    <published>2018-07-21T08:38:00.000Z</published>
    <updated>2018-10-14T12:54:04.828Z</updated>
    
    <content type="html"><![CDATA[<p>先说说具体场景，当前正在做一个项目，有部分接口是通过股票代码去后台请求数据的，但是作为初入职场的小白，并没有对传入的参数进行判断，所以导致测试服务器上项目每天都是处于<code>504</code>状态（因为安全部门每天凌晨都会对测试服务器上的接口进行注入式攻击，以保证提前发现问题，防止线上灾难）。</p><a id="more"></a><p>于是，我得对传入的参数进行判断，由此进入正题：</p><p>现有<code>a.json</code>文件（以下只做模拟，具体JSON文件大小为1MB左右），文件内容为：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"600000"</span>:&#123;</span><br><span class="line">      <span class="attr">"name"</span>:<span class="string">"股票1"</span></span><br><span class="line">      <span class="string">"source"</span>:<span class="string">"股票细节"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"600003"</span>:&#123;</span><br><span class="line">      <span class="attr">"name"</span>:<span class="string">"股票2"</span></span><br><span class="line">      <span class="string">"source"</span>:<span class="string">"股票细节"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"600006"</span>:&#123;</span><br><span class="line">      <span class="attr">"name"</span>:<span class="string">"股票3"</span></span><br><span class="line">      <span class="string">"source"</span>:<span class="string">"股票细节"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在需要解析出上述JSON的key与请求参数做一对照。</p><p>以下列出我的解析以及优化过程。</p><p><strong>方式一：（原始，解析时间长达4000ms!太恐怖了！）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先通过read方法读入json文件，以String方式返回</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    String str;</span><br><span class="line">    <span class="keyword">try</span> (BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"C:\\Users\\viruser.v-desktop\\Desktop\\a_code.json"</span>))) &#123;</span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">null</span> != (str = br.readLine())) &#123;</span><br><span class="line">      sb.append(str);</span><br><span class="line">      &#125;</span><br><span class="line">      br.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      System.out.println(<span class="string">"无法在指定目录下找到名为：1.json 的文件！"</span>);</span><br><span class="line">      System.exit(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isTrue</span><span class="params">(String code)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  String s = read();</span><br><span class="line">  <span class="keyword">long</span> startDate = System.currentTimeMillis();</span><br><span class="line">  JSONObject jsonObject = JSONObject.fromObject(<span class="string">""</span>);</span><br><span class="line">  Iterator&lt;String&gt; it = jsonObject.keys();</span><br><span class="line">  <span class="keyword">while</span> (it.hasNext())&#123;</span><br><span class="line">    String key = it.next();</span><br><span class="line">    <span class="keyword">if</span> (key.equals(code))&#123;</span><br><span class="line">      <span class="keyword">long</span> endDate = System.currentTimeMillis();</span><br><span class="line">      System.out.println(<span class="string">"耗时:"</span>+ (endDate-startDate));</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方式二：(运行时间稍有改观，但是平均也在3000毫秒左右)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先通过read方法读入json文件，以String方式返回</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    String str;</span><br><span class="line">    <span class="keyword">try</span> (BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"C:\\Users\\viruser.v-desktop\\Desktop\\a_code.json"</span>))) &#123;</span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">null</span> != (str = br.readLine())) &#123;</span><br><span class="line">      sb.append(str);</span><br><span class="line">      &#125;</span><br><span class="line">      br.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      System.out.println(<span class="string">"无法在指定目录下找到名为：1.json 的文件！"</span>);</span><br><span class="line">      System.exit(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isTrue</span><span class="params">(String code)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  String s = read();</span><br><span class="line">  <span class="keyword">long</span> startDate = System.currentTimeMillis();</span><br><span class="line">  Type type = <span class="keyword">new</span> TypeToken&lt;ArrayList&lt;StockCodeEntity&gt;&gt;()&#123;&#125;.getType();</span><br><span class="line">  Gson gson = <span class="keyword">new</span> Gson();</span><br><span class="line">  List&lt;String&gt; stringList = gson.fromJson(s,type);</span><br><span class="line">  System.out.println(<span class="string">"stringList:"</span>+stringList);</span><br><span class="line">  <span class="keyword">if</span> (stringList.contains(code))&#123;</span><br><span class="line">    <span class="keyword">long</span> endDate = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">"耗时:"</span>+ (endDate-startDate));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方式三：（为什么要将文件读入完（将近2000毫秒）再拿去循环解析呢？我太笨了！）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">read</span><span class="params">(String code)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> startDate = System.currentTimeMillis();</span><br><span class="line">  JsonParser parser = <span class="keyword">new</span> JsonParser();</span><br><span class="line">  JsonObject json = (JsonObject) parser.parse(<span class="keyword">new</span> FileReader(<span class="string">"C:\\Users\\viruser.v-desktop\\Desktop\\a_code.json"</span>));</span><br><span class="line">  Iterator&lt;String&gt; it = json.keySet();</span><br><span class="line">  <span class="keyword">while</span> (it.hasNext())&#123;</span><br><span class="line">    String key = it.next();</span><br><span class="line">    <span class="keyword">if</span> (key.equals(code))&#123;</span><br><span class="line">      <span class="keyword">long</span> endDate = System.currentTimeMillis();</span><br><span class="line">      System.out.println(<span class="string">"耗时:"</span>+ (endDate-startDate));</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方式四：经过上面的优化，我已经将解析时间缩小到了1000毫秒左右，但是对于一个请求过来，就光解析json就花了1秒，那也太不能接受了！所以我再次进行优化</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">read</span><span class="params">(String code)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> startDate = System.currentTimeMillis();</span><br><span class="line">  JsonParser parser = <span class="keyword">new</span> JsonParser();</span><br><span class="line">  JsonObject json = (JsonObject) parser.parse(<span class="keyword">new</span> FileReader(<span class="string">"C:\\Users\\viruser.v-desktop\\Desktop\\a_code.json"</span>));</span><br><span class="line">  <span class="keyword">for</span>(String key:json.keySet())&#123;</span><br><span class="line">    <span class="keyword">if</span> (key.equals(code))&#123;</span><br><span class="line">      System.out.println(<span class="string">"key:"</span>+key);</span><br><span class="line">      <span class="keyword">long</span> endDate = System.currentTimeMillis();</span><br><span class="line">      System.out.println(<span class="string">"耗时:"</span>+ (endDate-startDate));</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过上述优化，我已经可以将解析时间控制在400毫秒以内.但是还是不能满足要求！</p><p><strong>方式五：目前技术极限</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">read</span><span class="params">(String code)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> startDate = System.currentTimeMillis();</span><br><span class="line">  JsonParser parser = <span class="keyword">new</span> JsonParser();</span><br><span class="line">  JsonObject json = (JsonObject) parser.parse(<span class="keyword">new</span> FileReader(<span class="string">"C:\\Users\\viruser.v-desktop\\Desktop\\a_code.json"</span>));</span><br><span class="line">  <span class="keyword">for</span>(Map.Entry&lt;String, JsonElement&gt; map : json.entrySet())&#123;</span><br><span class="line">    <span class="keyword">if</span> (map.getKey().equals(code))&#123;</span><br><span class="line">      <span class="keyword">long</span> endDate = System.currentTimeMillis();</span><br><span class="line">      System.out.println(<span class="string">"耗时:"</span>+ (endDate-startDate));</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化完成之后，解析时间大概在150ms左右，可以说差不多可以满足要求了，但是对于1MB的文件解析花了0.1秒，也是很不理想的！所以说留给自己提升的机会还有很大哈哈！</p><p><strong>总结</strong></p><p>这里顺便一提遍历Map的两种方法keySet()，entrySet()的差别。</p><p>keySet()方法返回的是key的集合set，entrySet()返回的是键值对的集合set。虽然两者从set遍历取出元素的方法是一样的，但是根据这个元素取出value的效率有些不同。前者取出的元素是key，还要去原map中遍历取出value。<br>后者取出的元素是键值对，直接调用getkey()，getvalue()方法就能快速取出key和value。显然在map中存在大量键值对时，使用entrySet()来取出value的效率更高。</p><p><strong>问题：</strong></p><p>我有点想不明白的是，我现在只需要获取键值对中的key，使用keySet()方法为什么耗费的时间要比使用entrySet()方法获取到键值对再去getKey()花费的时间还要长呢？？？非常奇怪！</p><p><strong>这里参考了很多博客，对我的帮助很大</strong></p><ul><li><a href="https://blog.csdn.net/Chaosminds/article/details/49049455" target="_blank" rel="external">Gson解析JSON中动态未知字段key的方法</a></li><li><a href="https://www.cnblogs.com/CryOnMyShoulder/p/7755930.html" target="_blank" rel="external">JSONObject遍历获取键值</a></li><li><a href="https://www.cnblogs.com/boy1025/p/4551593.html" target="_blank" rel="external">JAVA解析JSON数据</a></li><li><a href="https://www.cnblogs.com/zhengshiqiang47/p/7349667.html" target="_blank" rel="external">几种Java的JSON解析库速度对比</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;先说说具体场景，当前正在做一个项目，有部分接口是通过股票代码去后台请求数据的，但是作为初入职场的小白，并没有对传入的参数进行判断，所以导致测试服务器上项目每天都是处于&lt;code&gt;504&lt;/code&gt;状态（因为安全部门每天凌晨都会对测试服务器上的接口进行注入式攻击，以保证提前发现问题，防止线上灾难）。&lt;/p&gt;
    
    </summary>
    
      <category term="实用教程" scheme="https://caoler.cn/categories/%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B/"/>
    
      <category term="JSON" scheme="https://caoler.cn/categories/%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B/JSON/"/>
    
    
      <category term="JSON" scheme="https://caoler.cn/tags/JSON/"/>
    
  </entry>
  
  <entry>
    <title>网络抓包工具 wireshark 入门教程</title>
    <link href="https://caoler.cn//post/2018/wireshark.html"/>
    <id>https://caoler.cn//post/2018/wireshark.html</id>
    <published>2018-07-20T08:48:00.000Z</published>
    <updated>2018-10-14T12:56:09.659Z</updated>
    
    <content type="html"><![CDATA[<p>Wireshark（前称Ethereal）是一个网络数据包分析软件。网络数据包分析软件的功能是截取网络数据包，并尽可能显示出最为详细的网络数据包数据。Wireshark使用WinPCAP作为接口，直接与网卡进行数据报文交换。</p><p>网络管理员使用Wireshark来检测网络问题，网络安全工程师使用Wireshark来检查资讯安全相关问题，开发者使用Wireshark来为新的通讯协定除错，普通使用者使用Wireshark来学习网络协定的相关知识。当然，有的人也会“居心叵测”的用它来寻找一些敏感信息……。Wireshark相对于tcpdump而言，界面更友好，功能更强大。</p><a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><a href="http://www.bo56.com/mac%E5%AE%89%E8%A3%85wireshark/" target="_blank" rel="external">mac上安装wireshark</a></p><p><a href="http://jingyan.baidu.com/article/656db918834874e381249cae.html" target="_blank" rel="external">windows上安装wireshark</a></p><p><a href="http://jingyan.baidu.com/article/656db918834874e381249cae.html" target="_blank" rel="external">linux下安装wireshark</a></p><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>以下的介绍都是以mac下的wireshark 1.12.2版本为基础。</p><h3 id="认识界面"><a href="#认识界面" class="headerlink" title="认识界面"></a>认识界面</h3><p><img src="https://images2015.cnblogs.com/blog/381128/201701/381128-20170108224550987-2121918276.jpg" alt="img"></p><p>说明：</p><p>常用按钮从左到右的功能依次是：</p><p>1、列出可用接口。</p><p>2、抓包时需要设置的一些选项。一般会保留最后一次的设置结果。</p><p>3、开始新的一次抓包。</p><p>4、暂停抓包。</p><p>5、继续进行本次抓包。</p><p>6、打开抓包文件。可以打开之前抓包保存后的文件。不仅可以打开wireshark软件保存的文件，也可以打开tcpdump使用-w参数保存的文件。</p><p>7、保存文件。把本次抓包或者分析的结果进行保存。</p><p>8、关闭打开的文件。文件被关闭后，就会切换到初始界面。</p><p>9、重载抓包文件。</p><h3 id="设置数据抓取选项"><a href="#设置数据抓取选项" class="headerlink" title="设置数据抓取选项"></a>设置数据抓取选项</h3><p>点击常用按钮中的设置按钮，就会弹出设置选项对话框。在这个对话框中我们可以选中需要监听的接口，设置混杂模式，设置抓取数据包的过滤条件。如下图：</p><p><img src="https://images2015.cnblogs.com/blog/381128/201701/381128-20170108224600409-1740577772.png" alt="img"></p><p>首先，选中需要监听获取数据包的接口。接口列表区列出了所有可以使用的接口。如果接口前面的复选框被选中，说明对这个接口监听捕获数据包。</p><p>其次，设置混杂模式。设置混杂模式的作用是将网卡设置到混杂模式。如果不设置混杂模式，你的计算机只能获取数据包发往的目标是你计算机和从你计算机出去的数据包。如果设置了混杂模式，你就可以捕获局域网中所有的数据包。如果窗口中的 “Use promiscuous mode on all interfaces”前面的复选框被选中，说明对所有的接口使用混杂模式。如果想单独设置，可以双击接口列表中的接口，会弹出如下的对话框。然后选中或者去掉“Capture packets in promiscuous mode”前面复选框。然后点ok按钮。<br><img src="https://images2015.cnblogs.com/blog/381128/201701/381128-20170108224616378-240890781.jpg" alt="img"></p><p>再次，设置捕获过滤条件。在点设置按钮弹出的主设置对话框中和双击接口列表弹出的对话框中都会有“Capture Filter”项。在文本框中我们可以设置捕获过滤条件。如，我们只捕获http相关的数据包，我们就可以设置捕获条件为“port 80”。因为http使用的是80端口。</p><p>最后，所有的设置完毕后，点击设置主窗口中的“Start”按钮，开始捕获数据。数据捕获完后，可以点常用按钮中的“保存”按钮保存数据。</p><h3 id="使用显示过滤器"><a href="#使用显示过滤器" class="headerlink" title="使用显示过滤器"></a>使用显示过滤器</h3><p>显示过滤器应用于捕获文件，用来告诉wireshark只显示那些符合过滤条件的数据包。显示过滤器比捕获过滤器更常用。他可以用来过滤不想看到的数据包，但是不会把数据删除。如果想恢复原状，只要把过滤条件删除即可。</p><p>过滤器表达式对话框，是的wireshark的可以很简单的设置过滤表达式。点击“Expression”按钮就可以打开这个对话框。如下图：</p><p><img src="https://images2015.cnblogs.com/blog/381128/201701/381128-20170108224624862-1963551755.jpg" alt="img"></p><p>对话框分左中右三部分。左边为可以使用的所有协议域。右边为和协议域相关的条件值。中间为协议域与条件值之间的关系。过滤器表达式对于初学者很有用。如上图，我们创建的表达式的作用是，只显示http协议包中包含关键词“bo56.com”的所有数据包。</p><p>Field name说明：<br>这个列表中展示了所有支持的协议。点击前面的三角标志后，可以列出本协议的可过滤字段。当选中“Field name”列表中的任何一项，只需要输入你想要的协议域，就会自动定位到相应的协议域选项。</p><p>Relation说明：<br>is present    如果选择的协议域存在，则显示相关数据包。<br>contains     判断一个协议，字段或者分片包含一个值<br>matches             判断一个协议或者字符串匹配一个给定的Perl表达式。</p><p>Value（Protocol）说明：<br>此处输入合适的值。如果选择的协议域和这个值满足Relation中指定的关系，则显示相关数据包。</p><p>Predefined values说明：<br>有些协议域包含了预先定义的值，有点类似于c语言中的枚举类型。如果你选择的协议域包含这样的值，你可以在这个列表中选择。</p><p>Function函数说明：<br>过滤器的语言还有下面几个函数：<br>upper(string－field)－把字符串转换成大写<br>lower(string－field)－把字符串转换成小写<br>upper((和lower((在处理大小写敏感的字符串比较时很有用。例如：<br>upper(ncp.nds_stream_name) contains “BO56.COM”<br>lower(mount.dump.hostname) ==”BO56.COM”</p><p>如果你熟悉了这个规则之后你就会发现手动输入表达式更有效率。当时手动在flter文本框中输入表达时，如果输入的语法有问题，文本框的背景色会变成红色。这时候，你可以继续输入或者修改，知道文本框中的表达式正确后，文本框的背景色又会变成绿色。</p><h3 id="使用着色规则"><a href="#使用着色规则" class="headerlink" title="使用着色规则"></a>使用着色规则</h3><p>你经常会在数据包列表区域中看到不同的颜色。这就是wireshark做的很人性化的一方面。它可以让你指定条件，把符合条件的数据包按指定的颜色显示。这样你查找数据包会更方便些。下面我们说一下如何设置颜色规则。</p><p>点击“view”菜单，然后选择“Coloring Rules”选项就会弹出设置颜色规则设置对话框。你点击颜色规则设置的快捷按钮也可以打开颜色设置对话框。如下图：</p><p><img src="https://images2015.cnblogs.com/blog/381128/201701/381128-20170108224633800-670165436.jpg" alt="img"></p><p>打开的对话框中默认已经有一些规则。我们抓取的数据包中经常会看到一些不同的颜色，就是应用的这些默认的规则。点击“New”按钮可以添加规则。如下图：</p><p><img src="https://images2015.cnblogs.com/blog/381128/201701/381128-20170108224641816-326923654.png" alt="img"></p><p>name字段中填写规则的名称，方便记忆。</p><p>string字段中填写过滤规则。这里的语法和显示规则表达式一致。点击 上图中的“Expression”按钮，你就会看到熟悉的规则表达式对话。</p><p>Foreground Color按钮用于选择前景色。</p><p>Background Color按钮用于选择背景色。</p><p>Disabled按钮用于指示是否禁用这条规则。</p><p>点击ok按钮后，规则自动会添加到规则列表中的最前端。</p><p>注意：wireshark在应用规则的时候，是按自上而下的顺序去应用规则。因此刚添加的规则会优先应用。如果你想调整顺序，可以选中要调整顺序的规则，然后点击右边的“UP” 或则 “Down” 按钮。</p><p>颜色规则设置好后，只需要点apply按钮就可以应用规则了。规则效果应用如下图：</p><p><img src="https://images2015.cnblogs.com/blog/381128/201701/381128-20170108224650316-930205325.jpg" alt="img"></p><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><h3 id="使用图表"><a href="#使用图表" class="headerlink" title="使用图表"></a>使用图表</h3><p>图形分析是数据分析中必不可少的一部分。也是wireshark的一大亮点。wireshark有不同的图形展现功能，以帮助你了解捕获的数据包。下面我们对经常使用的IO图，双向时间图做下介绍。</p><h4 id="IO图"><a href="#IO图" class="headerlink" title="IO图"></a>IO图</h4><p>wireshark的IO图让你可以对网络上的吞吐量绘图。让你了解网络数据传输过程中的峰值和波动情况。通过“Statistics”菜单中的“IO Graphs”选项可以打开这个IO图对话框。如下图：</p><p><img src="https://images2015.cnblogs.com/blog/381128/201701/381128-20170108224707659-397131729.jpg" alt="img"></p><p>可以看到IO图表对话框中会分为三个区。</p><p>过滤器区：设置过滤条件，用于图形化展示过滤条件相关数据包的变化情况。而且可以为每个不同的条件指定不同的颜色。过滤条件的语法和之前介绍的显示过滤器的语法一致。过滤条件为空，此图形显示所有流量。</p><p>坐标区：在这里可以设置图表的x轴和y轴。x轴为时间，y轴为包的数量。如图，我们设置Y轴的单位是Bytes/Tick。</p><p>趋势图区：根据过滤器设置的条件和坐标区设置，数据分析后回在这个区域以图形化方式展示。点击图形中的点，会自动定位到相应的数据包。点击趋势图中的低谷点，你会发现大量的数据包重传。</p><p>IO图表还可以通过函数对数据进行聚合处理。</p><p>点击Y轴中Unit选项中的Advanced后，就会再过滤器区就会增加Calc选项。如下图：</p><p><img src="https://images2015.cnblogs.com/blog/381128/201701/381128-20170108224716628-1364079332.jpg" alt="img"></p><p>相关函数说明：</p><p>MIN( ), AVG( ), MAX( ) 分别是统计协议域中数值的最小，平均和最大值。注意，这三个聚合函数只对协议域的值为数字的才有效。</p><p>Count( ) 此函数计算时间间隔内事件发生的次数，在查看TCP分析标识符时很有用，例如重传。</p><p>Sum( ) 该函数统计事件的累加值。和MIN()函数一样，这个也只有协议域的值为数字的情况下才有效。</p><h4 id="双向时间图"><a href="#双向时间图" class="headerlink" title="双向时间图"></a>双向时间图</h4><p>wireshark还有一个功能就是可以对网络传输中的双向时间进行绘图。双向时间（round-trip time, RTT）,就是一个数据包被确认正常接收所花费的时间。以tcp协议为例，就是你push一个数据到一台主机，主机回应一个ack给你的主机，你的主机并成功接收ack回应。这两个过程花费的时间总和就是双向时间。双向时间通常用来寻找网络传输过程中的慢点和瓶颈，用以判断网络传输是否有延迟。</p><p>通过“Statistics”菜单中的“Tcp  StreamGraph”中的“Round Trip Time Graph”选项可以打开这个双向时间图对话框。如下图：</p><p><img src="https://images2015.cnblogs.com/blog/381128/201701/381128-20170108224724784-1750849891.jpg" alt="img"></p><p>这个图表中的每个点代表一个数据包的双向时间。你可以单机图表中的任何一点，然后在数据包列表区就会自动定位到相应的数据包。从数据表来看，我们下载压缩包还是比较稳定的。数据包的rtt时间大多数在0.05s以下，其他大多数在0.1s左右，少数超过了1.5s。</p><h3 id="跟踪tcp流"><a href="#跟踪tcp流" class="headerlink" title="跟踪tcp流"></a>跟踪tcp流</h3><p>Wireshark分析功能中最不错的一个功能是它能够将TCP流重组。重组后的数据格式更容易阅读。跟踪TCP流这个功能可以将接收到的数据排好顺序使之容易查看，而不需要一小块一小块地看。这在查看HTTP、FTP等纯文本应用层协议时非常有用。</p><p>我们以一个简单的HTTP请求举例来说明一下。打开wireshark_bo56_pcap.pcapng，并在显示过滤器中输入“http contains wireshark”，点击“apply”按钮后，在数据包列表框中就会只剩下一条记录。如下图。</p><p><img src="https://images2015.cnblogs.com/blog/381128/201701/381128-20170108224819253-1056716209.png" alt="img"></p><p>右键单击这条记录并选择Follow TCP Stream。这时TCP流就会在一个单独的窗口中显示出来。如下图：</p><p><a href="http://www.bo56.com/wp-content/uploads/2014/11/wireshark_tcp_follow_dialog.png" target="_blank" rel="external"><img src="http://www.bo56.com/wp-content/uploads/2014/11/wireshark_tcp_follow_dialog.png" alt="wireshark_tcp_follow_dialog"></a></p><p>我们看到这个窗口中的文字会有两种颜色。其中红色用于表示从源地址到目标地址的流量。在我们的例子里面就是从我们本机到web服务器的流量。你可以看到最开始的红色部分是一个GET请求。蓝色部分是和红色部分相反的方向，也就是从目标地址到源地址的流量。在我们的例子中，蓝色部分的第一行是“HTTP/1.1 200 OK”，是来自服务器的一个http成功响应。</p><p>在这个窗口中除了能够看到这些原始数据，你还可以在文本间进行搜索，将其保存成一个文件、打印，或者以ASCII码、EBCDIC、十六进制或者C数组的格式去查看。这些选项都可以在跟踪TCP流窗口的下面找到。</p><p>转载自：<a href="https://blog.csdn.net/zjy900507/article/details/79303359" target="_blank" rel="external">https://blog.csdn.net/zjy900507/article/details/79303359</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Wireshark（前称Ethereal）是一个网络数据包分析软件。网络数据包分析软件的功能是截取网络数据包，并尽可能显示出最为详细的网络数据包数据。Wireshark使用WinPCAP作为接口，直接与网卡进行数据报文交换。&lt;/p&gt;
&lt;p&gt;网络管理员使用Wireshark来检测网络问题，网络安全工程师使用Wireshark来检查资讯安全相关问题，开发者使用Wireshark来为新的通讯协定除错，普通使用者使用Wireshark来学习网络协定的相关知识。当然，有的人也会“居心叵测”的用它来寻找一些敏感信息……。Wireshark相对于tcpdump而言，界面更友好，功能更强大。&lt;/p&gt;
    
    </summary>
    
      <category term="实用教程" scheme="https://caoler.cn/categories/%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B/"/>
    
      <category term="网络抓包" scheme="https://caoler.cn/categories/%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B/%E7%BD%91%E7%BB%9C%E6%8A%93%E5%8C%85/"/>
    
    
      <category term="wireshark" scheme="https://caoler.cn/tags/wireshark/"/>
    
  </entry>
  
  <entry>
    <title>MAVEN多模块项目的创建以及部署(SpringBoot+MyBatis+IDEA)</title>
    <link href="https://caoler.cn//post/2018/maven-springboot-mybatis.html"/>
    <id>https://caoler.cn//post/2018/maven-springboot-mybatis.html</id>
    <published>2018-07-20T08:38:00.000Z</published>
    <updated>2018-10-14T12:55:27.810Z</updated>
    
    <content type="html"><![CDATA[<p>项目基于SpringBoot+MyBatis+Maven构建，由于需要将定时任务与前台业务模块分离开来，所以需要进行maven多模块项目的开发。</p><a id="more"></a><p>项目整体结构如下：</p><pre><code>kiv-parent　|----pom.xml　|----kiv-core    　　　|----pom.xml　|----kiv-job    　　　|----pom.xml</code></pre><p>##多模块项目的创建</p><p>这里使用IDEA开发工具进行创建，步骤如下：</p><h3 id="创建父moudle"><a href="#创建父moudle" class="headerlink" title="创建父moudle"></a>创建父moudle</h3><ol><li><p>新建MAVEN项目</p><p><img src="https://images2015.cnblogs.com/blog/845019/201612/845019-20161216085421979-1104449991.png" alt=""></p></li><li><p>输入GroupId（一般为域名反写，类似com.myhexin）和artifactid（项目名），后面步骤直接next，最后finish</p><p><img src="https://ws1.sinaimg.cn/large/005DnJLEgy1fteyudrorsj30ol0gjq35.jpg" alt=""></p></li><li><p>创建完成之后，删除项目中除<code>pom.xml</code>文件以外的所有文件，因为这里是父节点，只对下面的模块进行管理，之后在pom中添加：</p><blockquote><packaging>pom</packaging></blockquote><p>最终结构如下：</p><p><img src="https://ws1.sinaimg.cn/large/005DnJLEgy1fteyudsbncj30n709ijsa.jpg" alt=""></p></li></ol><h3 id="创建第一个子模块"><a href="#创建第一个子模块" class="headerlink" title="创建第一个子模块"></a>创建第一个子模块</h3><ol><li><p>在主项目名称上点右键，创建第一个子模块</p><p><img src="https://ws1.sinaimg.cn/large/005DnJLEgy1fteyy5halnj30l80byt9z.jpg" alt=""></p></li><li><p>创建子模块，因为是springboot项目，所以选择下面项目</p><p><img src="https://ws1.sinaimg.cn/large/005DnJLEgy1fteyy5gqp9j30ol0gjq3q.jpg" alt=""></p></li><li><p>这一步保证groupId和之前创建的ID一致，Artifact为模块名称</p></li></ol><p><img src="https://ws1.sinaimg.cn/large/005DnJLEgy1fteyy5glpoj30ol0gjq3f.jpg" alt=""></p><ol><li><p>配置依赖</p><p><img src="https://ws1.sinaimg.cn/large/005DnJLEgy1fteyy5golzj30ol0gjt9n.jpg" alt=""></p></li><li><p>完成之后，结构如下：</p><p><img src="https://ws1.sinaimg.cn/large/005DnJLEgy1fteyy5gqz8j30bh09g74o.jpg" alt=""></p></li></ol><h3 id="创建第二个子模块"><a href="#创建第二个子模块" class="headerlink" title="创建第二个子模块"></a>创建第二个子模块</h3><p>至此，一个模块已经创建好了，再创建第二个模块：</p><p>由于第二个模块为utils，所以不需要任何maven模板，按照默认maven工程创建即可。</p><ol><li><p>创建新的模块<img src="https://images2015.cnblogs.com/blog/845019/201612/845019-20161216090943323-349400447.png" alt=""></p></li><li><p>简单配置</p><p><img src="https://ws1.sinaimg.cn/large/005DnJLEgy1ftezac5532j30on0hkgmf.jpg" alt=""></p></li><li><p>接下来保证子模块路径在父模块路径之下即可</p></li></ol><h3 id="模块关联关系的配置"><a href="#模块关联关系的配置" class="headerlink" title="模块关联关系的配置"></a>模块关联关系的配置</h3><p>完成之后，项目结构如下：</p><p><img src="https://ws1.sinaimg.cn/large/005DnJLEgy1ftfah0us2ij30bm09it94.jpg" alt=""></p><p><strong>添加项目依赖：</strong> </p><p>我们希望api项目能够使用utils项目的类，需要在api项目中引用utils项目 ，在api项目的pom.xml的dependencies节点添加如下内容</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--引用springboot-utils项目 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.gl<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springboot-utils<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在IDEA中配置:</p><p>按<code>Ctrl+Shift+s</code>打开项目设置，选择左侧module，选中将依赖其他模块的模块，在右侧选择dependence，点击绿色加号，选中被依赖的模块，apply即可。</p><h2 id="多模块项目的部署"><a href="#多模块项目的部署" class="headerlink" title="多模块项目的部署"></a>多模块项目的部署</h2><p>待完善。</p><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p><strong>1. Idea在导入有maven项目时，不能自动识别pom.xml</strong></p><p>当在idea中导入maven项目时，不能自动识别pom文件，显示为普通橙色xml文件。</p><p>解决方法：点击最右侧侧边栏<code>MavenProjects</code>点击添加（蓝的的小加号），选择你导入项目的pom.xml文件</p><p><strong>2. 提示“Unmapped Spring configuration files found.Please configure Spring facet.”解决办法</strong>、</p><p>首先为模块新增spring配置，“Ctrl+Shift+Alt+S”打开project的配置界面，选择“Modules”页签，</p><p><img src="https://ws1.sinaimg.cn/large/005DnJLEgy1ftfawfuh58j30js0hp75f.jpg" alt=""></p><p>再选择报“Unmapped Spring configuration files found.”的Module，点击“+”按钮；</p><p><img src="https://ws1.sinaimg.cn/large/005DnJLEgy1ftfaqer0nwj30pn0dht9d.jpg" alt=""></p><p>在弹出的窗口内，全部勾选Unmapped的Spring配置文件，点击“确定”，然后在父界面中点击“应用”或“确定”完成保存。</p><p><img src="https://ws1.sinaimg.cn/mw690/005DnJLEly1ftfat81p92j31060q6q5y.jpg" alt=""></p><p>如果是SpringBoot项目，添加各种config即可，application.yml无需添加。</p><p><strong>3. 多模块项目Module must not contain source root. The root already belongs to module</strong></p><p><img src="https://ws1.sinaimg.cn/large/005DnJLEly1ftfazbf7hij30tq0jhwgf.jpg" alt=""></p><p>打开页面，删除报错提示的ContentRoot即可，右侧。</p><p><strong>4. Failed to load property source from location ‘classpath:/application.yml’</strong> </p><p>解决办法<br>仔细的检查一下你的配置文件;我出现该错误的原因是因为未删除干净分模块的配置文件分隔符<code>---</code></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.cnblogs.com/xdp-gacl/p/4242221.html" target="_blank" rel="external">https://www.cnblogs.com/xdp-gacl/p/4242221.html</a></li><li><a href="https://www.cnblogs.com/tibit/p/6185704.html" target="_blank" rel="external">https://www.cnblogs.com/tibit/p/6185704.html</a></li><li><a href="https://blog.csdn.net/qq_36467463/article/details/77851421" target="_blank" rel="external">https://blog.csdn.net/qq_36467463/article/details/77851421</a></li><li><a href="https://blog.csdn.net/flyingnet/article/details/78009254" target="_blank" rel="external">https://blog.csdn.net/flyingnet/article/details/78009254</a></li><li><a href="https://blog.csdn.net/willjgl/article/details/77773634" target="_blank" rel="external">https://blog.csdn.net/willjgl/article/details/77773634</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;项目基于SpringBoot+MyBatis+Maven构建，由于需要将定时任务与前台业务模块分离开来，所以需要进行maven多模块项目的开发。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring" scheme="https://caoler.cn/categories/Spring/"/>
    
    
      <category term="springboot" scheme="https://caoler.cn/tags/springboot/"/>
    
      <category term="maven" scheme="https://caoler.cn/tags/maven/"/>
    
  </entry>
  
  <entry>
    <title>MySQL存储引擎及其对比</title>
    <link href="https://caoler.cn//post/2018/mysql-engine.html"/>
    <id>https://caoler.cn//post/2018/mysql-engine.html</id>
    <published>2018-07-15T16:41:28.000Z</published>
    <updated>2018-10-14T12:55:36.890Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MySql中有哪些存储引擎？"><a href="#MySql中有哪些存储引擎？" class="headerlink" title="MySql中有哪些存储引擎？"></a>MySql中有哪些存储引擎？</h2><a id="more"></a><ol><li><p><strong>MyISAM：</strong> 这种引擎是mysql最早提供的。这种引擎又可以分为静态MyISAM、动态MyISAM 和压缩MyISAM三种：</p><ul><li><strong>静态MyISAM</strong>：如果数据表中的<strong>各数据列的长度都是预先固定好的</strong>，服务器将自动选择这种表类型。因为数据表中每一条记录所占用的空间都是一样的，所以这种表<strong>存取和更新的效率非常高</strong>。当数据受损时，恢复工作也比较容易做。</li><li><strong>动态MyISAM</strong>：如果数据表中<strong>出现varchar、xxxtext或xxxBLOB字段时</strong>，服务器将自动选择这种表类型。相对于静态MyISAM，这种表存储空间比较小，但由于每条记录的长度不一，所以多次修改数据后，数据表中的数据就可能离散的存储在内存中，进而导致执行效率下降。同时，内存中也可能会出现很多碎片。因此，这种类型的表要经常用optimize table 命令或优化工具来进行碎片整理。</li><li><strong>压缩MyISAM</strong>：以上说到的两种类型的表都可以用myisamchk工具压缩。这种类型的表进一步减小了占用的存储，但是这种表压缩之后不能再被修改。另外，因为是压缩数据，所以这种表在读取的时候要先时行解压缩。</li></ul><p>静态表是默认的存储格式，静态表中的字段都是非变长的字段，优点是：存储非常迅速，容易缓存，出现故障容易恢复；缺点是：占用的空间通常比动态表多。（注意： 在存储时，列的宽度不足时，用空格补足，当时在访问的时候并不会得到这些空格）<br>动态表的字段是变长的，优点是：占用的空间相对较少，但是频繁地更新删除记录会产生碎片，需要定期改善性能，并且出现故障的时候恢复相对比较困难。 但是，不管是何种MyISAM表，目前它都<strong><em>不支持事务，行级锁和外键约束的功能</em></strong>。</p></li><li><p><strong>MyISAM Merge引擎：</strong> 这种类型是MyISAM类型的一种变种。合并表是将几个相同的MyISAM表合并为一个虚表。常应用于日志和数据仓库。</p></li><li><p><strong>InnoDB：</strong> InnoDB表类型可以看作是对MyISAM的进一步更新产品，它提供了事务、行级锁机制和外键约束的功能。</p></li><li><p><strong>memory(heap)：</strong> 这种类型的数据表只存在于内存中。它使用散列索引，所以数据的存取速度非常快。因为是存在于内存中，所以这种类型常应用于临时表中.</p></li><li><p><strong>archive：</strong> 这种类型只支持select 和 insert语句，而且不支持索引。常应用于日志记录和聚合分析方面。</p><p>当然MySql支持的表类型不止上面几种。</p></li></ol><h2 id="MyISAM-vs-InnoDB"><a href="#MyISAM-vs-InnoDB" class="headerlink" title="MyISAM vs InnoDB"></a>MyISAM vs InnoDB</h2><h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><p><strong>定义</strong>：（默认的存储引擎）</p><p>InnoDB是一个事务型的存储引擎，有行级锁定和外键约束。</p><p>Innodb引擎提供了对数据库ACID事务的支持，并且实现了SQL标准的四种隔离级别，关于数据库事务与其隔离级别的内容请见数据库事务与其隔离级别这类型的文章。该引擎还提供了行级锁和外键约束，它的设计目标是处理大容量数据库系统，它本身其实就是基于MySQL后台的完整数据库系统，MySQL运行时Innodb<strong>会在内存中建立缓冲池，用于缓冲数据和索引</strong>。但是该引擎不支持FULLTEXT类型的索引，而且它没有保存表的行数，当<code>SELECT COUNT(*) FROM TABLE</code>时需要扫描全表。当需要使用数据库事务时，该引擎当然是首选。由于锁的粒度更小，写操作不会锁定全表，所以在<strong>并发较高时，使用Innodb引擎会提升效率</strong>。但是使用行级锁也不是绝对的，如果在执行一个SQL语句时MySQL不能确定要扫描的范围，InnoDB表同样会锁全表。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//这个就是<span class="keyword">select</span>锁表的一种，不明确主键。增删改查都可能会导致锁全表，在以后我们会详细列出。</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> <span class="keyword">name</span>=<span class="string">'Mouse'</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure><p><strong>适用场景</strong>：</p><ol><li>经常更新的表，适合处理多重并发的更新请求。</li><li>支持事务。</li><li>可以从灾难中恢复（通过bin-log日志等）。</li><li>外键约束。只有他支持外键。</li><li>支持自动增加列属性auto_increment。</li></ol><p><strong>MySQL官方对InnoDB的讲解</strong>：</p><ol><li>InnoDB给MySQL提供了具有提交、回滚和崩溃恢复能力的事务安全（ACID兼容）存储引擎。</li><li>InnoDB锁定在行级并且也在SELECT语句提供一个Oracle风格一致的非锁定读，这些特色增加了多用户部署和性能。没有在InnoDB中扩大锁定的需要，因为在InnoDB中行级锁定适合非常小的空间。</li><li>InnoDB也支持FOREIGN KEY强制。在SQL查询中，你可以自由地将InnoDB类型的表与其它MySQL的表的类型混合起来，甚至在同一个查询中也可以混合。</li><li>InnoDB是为处理巨大数据量时的最大性能设计，它的CPU效率可能是任何其它基于磁盘的关系数据库引擎所不能匹敌的。</li><li>InnoDB被用来在众多需要高性能的大型数据库站点上产生。</li></ol><p><strong>补充</strong>：什么叫事务？简称ACID</p><p>A 事务的原子性(Atomicity)：指一个事务要么全部执行,要么不执行.也就是说一个事务不可能只执行了一半就停止了.比如你从取款机取钱,这个事务可以分成两个步骤:1划卡,2出钱.不可能划了卡,而钱却没出来.这两步必须同时完成.要么就不完成.</p><p>C 事务的一致性(Consistency)：指事务的运行并不改变数据库中数据的一致性.例如,完整性约束了a+b=10,一个事务改变了a,那么b也应该随之改变.</p><p>I 独立性(Isolation）:事务的独立性也有称作隔离性,是指两个以上的事务不会出现交错执行的状态.因为这样可能会导致数据不一致.</p><p>D 持久性(Durability）:事务的持久性是指事务执行成功以后,该事务所对数据库所作的更改便是持久的保存在数据库之中，不会无缘无故的回滚.</p><h3 id="MyIsam"><a href="#MyIsam" class="headerlink" title="MyIsam"></a>MyIsam</h3><p><strong>定义</strong>：</p><p>MyIASM是MySQL默认的引擎，但是它没有提供对数据库事务的支持，也不支持行级锁和外键，因此当INSERT(插入)或UPDATE(更新)数据时即写操作需要锁定整个表，效率便会低一些。</p><p>MyIsam 存储引擎独立于操作系统，也就是可以在windows上使用，也可以比较简单的将数据转移到linux操作系统上去。</p><p>意味着：引擎在创建表的时候，会创建三个文件，一个是.frm文件用于存储表的定义，一个是.MYD文件用于存储表的数据，另一个是.MYI文件，存储的是索引。操作系统对大文件的操作是比较慢的，这样将表分为三个文件，那么.MYD这个文件单独来存放数据自然可以优化数据库的查询等操作。<strong>有索引管理和字段管理</strong>。MyISAM还使用一种表格锁定的机制，来优化多个并发的读写操作，其代价是你需要经常运行OPTIMIZE TABLE命令，来恢复被更新机制所浪费的空间。</p><p><strong>适用场景</strong>：</p><ol><li>不支持事务的设计，但是并不代表着有事务操作的项目不能用MyIsam存储引擎，可以在service层进行根据自己的业务需求进行相应的控制。</li><li>不支持外键的表设计。</li><li>查询速度很快，如果数据库insert和update的操作比较多的话不太适用。</li><li>整天 对表进行加锁的场景。</li><li>MyISAM极度强调快速读取操作。</li><li>MyIASM中存储了表的行数，于是<code>SELECT COUNT(*) FROM TABLE</code>时只需要直接读取已经保存好的值而不需要进行全表扫描。如果表的读操作远远多于写操作且不需要数据库事务的支持，那么MyIASM也是很好的选择。</li></ol><p><strong>缺点：</strong></p><p>就是不能在表损坏后恢复数据。（是不能主动恢复）</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;MySql中有哪些存储引擎？&quot;&gt;&lt;a href=&quot;#MySql中有哪些存储引擎？&quot; class=&quot;headerlink&quot; title=&quot;MySql中有哪些存储引擎？&quot;&gt;&lt;/a&gt;MySql中有哪些存储引擎？&lt;/h2&gt;
    
    </summary>
    
      <category term="Mysql" scheme="https://caoler.cn/categories/Mysql/"/>
    
    
  </entry>
  
  <entry>
    <title>学习Spring的长期or短期目标</title>
    <link href="https://caoler.cn//post/2018/SpringAims.html"/>
    <id>https://caoler.cn//post/2018/SpringAims.html</id>
    <published>2018-07-13T14:27:11.000Z</published>
    <updated>2018-07-13T14:27:18.692Z</updated>
    
    <content type="html"><![CDATA[<p>最近非常想研究透彻Spring，但是又找不到合适的方法。之前一直打算阅读Spring源码，但是又有人说 <strong>如果什么框架要你必须阅读源代码才能掌握，那这个框架一定很烂、不成熟，或者说至少处于成熟的前期。</strong> 显然Spring不是这样的框架。</p><a id="more"></a><p>想想自己详细认真读过spring所有项目的reference，并对所有API doc了如指掌吗？我直接开始读源代码干嘛？</p><p>说明书和各种电器参数都不看就想把家里的电视拆了研究的，只能是熊孩子干出来的事。</p><p>有时候认为实战是最好的老师。</p><p>但是有些事情又是迫不得已必须去做的，必须得在正确的时间里做正确的事。</p><p>所以短期目标是看一下源码~嘻嘻，主要是Bean的加载，IOC原理，还有就是SpringAOP。</p><p>提供给自己一点资源：</p><p>这个是目前最新版的说明书：<br><a href="https://docs.spring.io/spring/docs/5.0.7.RELEASE/spring-framework-reference/" target="_blank" rel="external">https://docs.spring.io/spring/docs/5.0.7.RELEASE/spring-framework-reference/</a></p><p>大神翻译的中文版：<br><a href="https://muyinchen.gitbooks.io/spring-framework-5-0-0-m3/content/" target="_blank" rel="external">https://muyinchen.gitbooks.io/spring-framework-5-0-0-m3/content/</a></p><p>可以说非常想看英文原版了，奈何自己的英语水平实在是太差了！难受啊 :cry:</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近非常想研究透彻Spring，但是又找不到合适的方法。之前一直打算阅读Spring源码，但是又有人说 &lt;strong&gt;如果什么框架要你必须阅读源代码才能掌握，那这个框架一定很烂、不成熟，或者说至少处于成熟的前期。&lt;/strong&gt; 显然Spring不是这样的框架。&lt;/p&gt;
    
    </summary>
    
      <category term="SSM框架" scheme="https://caoler.cn/categories/SSM%E6%A1%86%E6%9E%B6/"/>
    
      <category term="Spring" scheme="https://caoler.cn/categories/SSM%E6%A1%86%E6%9E%B6/Spring/"/>
    
    
      <category term="Spring" scheme="https://caoler.cn/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>《Spring实战》读书笔记3-SpringAOP</title>
    <link href="https://caoler.cn//post/2018/SpringInAction-3.html"/>
    <id>https://caoler.cn//post/2018/SpringInAction-3.html</id>
    <published>2018-07-13T14:25:11.000Z</published>
    <updated>2018-07-13T14:27:20.139Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-参考"><a href="#1-参考" class="headerlink" title="1. 参考"></a>1. 参考</h3><ul><li><a href="https://blog.csdn.net/w1196726224/article/details/50535659" target="_blank" rel="external">Spring 4 学习笔记5：Spring AOP</a></li><li>《Spring实战 第四版》</li><li><a href="https://blog.csdn.net/wangpeng047/article/details/8556800" target="_blank" rel="external">SpringAop 详尽教程</a></li></ul><a id="more"></a><h3 id="2-AOP术语"><a href="#2-AOP术语" class="headerlink" title="2. AOP术语"></a>2. AOP术语</h3><ol><li><p>通知（active）</p><p>切面的工作被称为通知，比如抄表员去每家每户抄电表的数据，这个<strong>动作（活动）就是通知</strong>。</p><p>通知一共包含以下五种：</p><ul><li>前置通知（Before）：在目标方法被调用之前调用通知功能；</li><li>后置通知（After）：在目标方法完成之后调用通知，此时不会关心方法的输出是什么；</li><li>返回通知（After-returning）：在目标方法成功执行之后调用通知；</li><li>异常通知（After-throwing）：在目标方法抛出异常后调用通知；</li><li>环绕通知（Around）：通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为。</li></ul></li></ol><ol><li><p>连接点（Join point）</p><p>可以<strong>被插入的时机</strong> 就是连接点。连接点是在应用执行过程中能够插入切面的一个点。这个点可以是调用方法时、抛出异常时、甚至修改一个字段时。切面代码可以利用这些点插入到应用的正常流程之中，并添加新的行为。</p></li><li><p>切点（Poincut）</p><p>如果说通知定义了切面的“什么”和“何时”的话，那么切点就定义了 <strong>“何处”</strong>。切点的定义会匹配通知所要织入的一个或多个连接点。我们通常使用明确的类和方法名称，或是利用正则表达式定义所匹配的类和方法名称来指定这些切点。有些AOP框架允许我们创建动态的切点，可以根据运行时的决策（比如方法的参数值）来决定是否应用通知。</p></li><li><p>切面（Aspect）</p><p>当抄表员开始一天的工作时，他知道自己要做的事情（报告用电量）和从哪些房屋收集信息。因此，他知道要完成工作所需要的一切东西。</p><p> <strong>切面是通知和切点的结合</strong>。通知和切点共同定义了切面的全部内容——它是什么，在何时和何处完成其功能。</p></li><li><p>引入（Introduction）</p><p>引入允许我们<strong>向现有的类添加新方法或属性</strong> 。例如，我们可以创建一个Auditable通知类，该类记录了对象最后一次修改时的状态。这很简单，只需一个方法，setLastModified(Date)，和一个实例变量来保存这个状态。然后，这个新方法和实例变量就可以被引入到现有的类中，从而可以在无需修改这些现有的类的情况下，让它们具有新的行为和状态。</p></li><li><p>织入（Weaving）</p><p>织入是把切面应用到目标对象并创建新的代理对象的过程。切面在指定的连接点被织入到目标对象中。在目标对象的生命周期里有多个点可以进行织入：</p><ul><li>编译期：切面在目标类编译时被织入。这种方式需要特殊的编译器。AspectJ的织入编译器就是以这种方式织入切面的。</li><li>类加载期：切面在目标类加载到JVM时被织入。这种方式需要特殊的类加载器（ClassLoader），它可以在目标类被引入应用之前增强该目标类的字节码。AspectJ5的加载时织入（load-time weaving，LTW）就支持以这种方式织入切面。</li><li>运行期：切面在应用运行的某个时刻被织入。一般情况下，在织入切面时，AOP容器会为目标对象动态地创建一个代理对象。Spring AOP就是以这种方式织入切面的。</li></ul></li></ol><p>在AOP术语中这些关注点被称为<strong>横切关注点（crosscutting）</strong>。如下图所示： </p><p><img src="https://img-blog.csdn.net/20160118113324494" alt=""></p><p><strong>通知（Advice）</strong>的类型：</p><table><thead><tr><th>类型</th><th>执行点</th></tr></thead><tbody><tr><td>Before</td><td>在主方法调用之前执行</td></tr><tr><td>After</td><td>通知在主方法完成之后执行，不管主方法的调用结果如何</td></tr><tr><td>After-returnning</td><td>通知在主方法正常返回后执行。比如在不抛出异常时正常返回</td></tr><tr><td>After-throwing</td><td>通知在主方法抛出异常后执行</td></tr><tr><td>Around</td><td>通知包装了主方法，提供在方法调用一直或之后提供一些功能</td></tr></tbody></table><h3 id="3-代码示例"><a href="#3-代码示例" class="headerlink" title="3. 代码示例"></a>3. 代码示例</h3><p>首先，我们定义被代理的接口和实现：</p><p>清单1. 被代理接口和实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyBean.java</span></span><br><span class="line"><span class="keyword">package</span> org.archerie.aop.bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(String msg)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MyBeanImpl.java</span></span><br><span class="line"><span class="keyword">package</span> org.archerie.aop.bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用spring @Component注解，加载到spring上下文中</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanImpl</span> <span class="keyword">implements</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        System.out.println(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，我们就开始定义我们的切面。如下：</p><p>清单2. 切面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.archerie.aop.aspect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.After;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Before;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Pointcut;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdviceExampleAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义切点</span></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(** org.archerie..*Bean.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beanPointCut</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"beanPointCut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">silenceCellPhone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"手机静音！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"execution(** org.archerie..MyBean.sayHello(String)) &amp;&amp; args(msg)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printMsg</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyBean将要说的是："</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span>(<span class="string">"beanPointCut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">applause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"鼓掌！鼓掌！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们就需要定义我们的spring配置文件了。我们选择<strong>Java配置</strong>的方式来配置Spring。</p><p>清单3. Spring配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.archerie.aop.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.EnableAspectJAutoProxy;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(basePackages = &#123;<span class="string">"org.archerie.aop"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AopJavaConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上，切面就准备好了，现在就差使用了。下面，使用JUnit来进行测试：</p><p>清单4. JUnit测试切面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.archerie.aop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.archerie.aop.bean.MyBean;</span><br><span class="line"><span class="keyword">import</span> org.archerie.aop.bean.MyOtherBean;</span><br><span class="line"><span class="keyword">import</span> org.archerie.aop.config.AopJavaConfig;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.ContextConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringJUnit4ClassRunner;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner.class)</span><br><span class="line"><span class="meta">@ContextConfiguration</span>(classes = AopJavaConfig.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AspectTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    MyBean myBean;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    MyOtherBean otherBean;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAspect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        myBean.sayHello(<span class="string">"我要把你做成一个玩偶！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上，就是完成的代码示例。现在运行查看结果：</p><blockquote><p>MyBean将要说的是：我要把你做成一个玩偶！<br>手机静音！<br>我要把你做成一个玩偶！<br>鼓掌！鼓掌！</p></blockquote><h3 id="4-术语详解"><a href="#4-术语详解" class="headerlink" title="4. 术语详解"></a>4. 术语详解</h3><p>Spring AOP主要由<strong>连接点</strong>、<strong>切入点</strong>和<strong>通知</strong>组成切面。而切入点是用来选择某一范围的连接点的，所以我们首先讨论如何定义<strong>切入点</strong>。这里要说明一点的就是：Spring AOP只支持一种<strong>Join point</strong>，就是<strong>方法的执行</strong>。所以，以下<strong>切入点（Pointcut）</strong>只能选取方法执行的<strong>连接点（Join Point）</strong>。看我：:happy:</p><h4 id="4-1-切入点（Pointcuts）"><a href="#4-1-切入点（Pointcuts）" class="headerlink" title="4.1. 切入点（Pointcuts）"></a><strong>4.1. 切入点（Pointcuts）</strong></h4><p>以下是SpringAOP支持的AspectJ切入点：</p><table><thead><tr><th>AspectJ表达式</th><th>描述</th></tr></thead><tbody><tr><td>execution</td><td>匹配方法执行的连接点，这是使用Spring AOP时主要使用的切入点</td></tr><tr><td>within</td><td>匹配特定<strong>类型</strong>中的连接点（在Spring AOP中则限制为<strong>匹配类型</strong>中的方法执行）</td></tr><tr><td>this</td><td>匹配Spring AOP代理对象中的连接点（在Spring AOP中为方法的执行），注意匹配的是spring aop代理对象为指定的类型。this表达式必须使用完整的限定类名，不能使用通配符。</td></tr><tr><td>target</td><td>匹配目标对象中的连接点（在Spring AOP中为方法的执行），但是目标对象得为特定的类型。target表达式必须使用完整的限定类名，不能使用通配符。</td></tr><tr><td>args</td><td>匹配参数为特定类型实例的连接点（Spring AOP中为方法的执行）</td></tr><tr><td>@target</td><td>匹配特定的连接点（Spring AOP中为方法执行），执行方法的类拥有指定类型的注解</td></tr><tr><td>@args</td><td>匹配特定的连接点（Spring AOP中为方法的执行），运行时传入的参数必须拥有特定类型的注解</td></tr><tr><td>@within</td><td>用于匹配拥有特定注解的类型中的连接点</td></tr><tr><td>@annotation</td><td>用于匹配拥有特定注解的连接点（Spring AOP中为方法的执行）</td></tr><tr><td>bean</td><td>Spring AOP扩展的切入点，可以匹配特定的类名中的连接点（方法的执行）</td></tr></tbody></table><h5 id="4-1-1-通配符（Wildcards）"><a href="#4-1-1-通配符（Wildcards）" class="headerlink" title="4.1.1 通配符（Wildcards）"></a>4.1.1 通配符（Wildcards）</h5><p>在使用切入点表达式的时候，有些时候我们可以使用通配符：*、..、+。</p><table><thead><tr><th>符号</th><th>含义</th></tr></thead><tbody><tr><td>..</td><td>在类型匹配时，匹配任何以 <strong>.</strong>，以 <strong>.</strong> 结尾的包名。在方法定义时匹配任意数量的参数。</td></tr><tr><td>+</td><td>匹配给定类型的任意子类型。</td></tr><tr><td>*</td><td>匹配数量的任意字符，除了*字符。</td></tr></tbody></table><h5 id="4-1-2-类型（Type）指示符"><a href="#4-1-2-类型（Type）指示符" class="headerlink" title="4.1.2 类型（Type）指示符"></a>4.1.2 类型（Type）指示符</h5><p>通过类型来过滤方法，比如<em>接口</em>、<em>类名</em>或者是<em>包名</em>。Spring提供<strong>within</strong>切入点，使用方式如下。<code>type name</code>可以被替换为<code>package name</code>或者<code>class name</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">within(&lt;type name&gt;)</span><br></pre></td></tr></table></figure><p>以下是一些例子：</p><ul><li><code>within(com.xyz.web..*)</code>：匹配<code>com.xyz.web</code>包下面的所有类中方法的执行，而且因为使用了 <strong>..</strong> 通配符，所以可以匹配<code>com.xyz.web</code>的所有子包。*通配符匹配所有的类名，所以可以匹配所有类中方法的执行。</li><li><code>with(com.xyz.web.*)</code>：匹配<code>com.xyz.web</code>包下面所有类中方法的执行。因为没有使用..通配符，所有只是匹配到<code>web</code>包，不包括子包。*一样匹配所有的类名。</li><li><code>with(com.xyz.service.AccountService)</code>：匹配<code>AccountService</code>类下面所有方法的执行。</li><li><code>with(com.xyz.interface.MyServiceInterface+)</code>：匹配所有实现了<code>MyServiceInterface</code>接口的类中的所有方法的执行。</li><li><code>with(com.xyz.service.MyBaseService+)</code>：匹配<code>MyBaseService</code>类和它的子类。</li></ul><h5 id="4-1-3-方法（Method）指示符"><a href="#4-1-3-方法（Method）指示符" class="headerlink" title="4.1.3 方法（Method）指示符"></a>4.1.3 方法（Method）指示符</h5><p>匹配特定方法的执行，可以使用<code>execution</code>关键字。execution表达式的格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">execution(modifiers-pattern? ret-type-pattern </span><br><span class="line">        declaring-type-pattern?name-pattern(param-pattern)</span><br><span class="line">            throws-pattern?)123</span><br></pre></td></tr></table></figure><p>其中，所有的部分除了返回值类型（ret-type-pattern）、方法名（name-pattern）和参数（param-pattern）都是可选的。 <strong>修饰符（modifiers-pattern）</strong> <code>public</code>、<code>protected</code>或<code>private</code>，也可以使用<code>*</code>匹配所有的修饰符。<strong>返回值类型（ret-type-pattern）</strong> 匹配特定的返回类型。大多数情况都是使用<code>*</code>通配符匹配所有的返回类型。<strong>方法名（name-pattern）</strong> 匹配执行方法的名称，可以使用<code>*</code>通配符匹配任意数量够的字符。如果要匹配特定类中方法的执行，就必须指定 <strong>类名（declaring-type-pattern）</strong> 部分，这部分使用的格式参考 <strong>4.1.2 类型指示符</strong>。<strong>参数列表（param-pattern）</strong> 部分，指定方法的参数必须满足的格式。<code>()</code>匹配没有参数的方法，<code>(..)</code>匹配任意数量的参数。当然你也可以使用<code>*</code>匹配任意一个参数的类型，比如<code>(\*, String)</code>匹配第二个参数为<code>String</code>类型，第一个参数为任意类型的情况。<strong>异常列表（throws-pattern）</strong> 匹配全限定类名异常类型，如果有多个异常，使用<code>,</code>分割，比如<code>throws java.lang.IllegalArgumentException, java.lang.ArrayIndexOutOfBoundsException</code>。</p><p>示例如下：</p><ul><li><code>execution(public * *(..))</code>：匹配所有的<code>public</code>方法的执行。</li><li><code>execution(* set*(..))</code>：匹配所有方法名以set开头的方法的执行。</li><li><code>execution(* com.xyz.service.AccountService.*(..))</code>：匹配<code>AccountService</code>接口下所有方法的执行。</li><li><code>execution(* com.xyz.service.*.*(..))</code>：匹配包<code>com.xyz.service</code>下所有类（或接口）下的所有方法的执行。</li><li><code>execution(* com.xyz.service..*.*(..))</code>：匹配包<code>com.xyz.service</code>和其子包中的类（或接口）下的所有方法的执行。</li><li><code>execution(* *(.., String)</code>：匹配所有最后一个参数为<code>String</code>的方法的执行。</li><li><code>execution(* ..Sample+.sampleGenericCollectionMethod(*))</code>：匹配任意以.Sample结尾的包，以及其子包中的<code>sampleGenericCollectionMethod</code>方法的执行，且具有唯一的任意类型的参数。</li><li><code>execution(* *(*, String, ..)</code>：匹配第一个参数为任意类型，第二个参数为<code>String</code>，后面可拥有任意个参数的方法的执行。</li></ul><h5 id="4-1-4-其他的切入点指示符"><a href="#4-1-4-其他的切入点指示符" class="headerlink" title="4.1.4 其他的切入点指示符"></a>4.1.4 其他的切入点指示符</h5><ul><li><code>bean(*Service)</code>：所有bean名称以Service结尾的bean。</li><li><code>@annotation(org.springframework.transaction.annotation.Transactional)</code>：匹配所有连接点（Spring AOP中方法的执行）拥有<code>@Transaction</code>注解在方法上。</li><li><code>this(com.xyz.service.AccountService)</code>：匹配实现了<code>AccountService</code>接口的代理类中的所有连接点（Spring AOP中方法的执行）</li><li><code>target(com.xyz.service.AccountService)</code>：匹配实现了<code>AccountService</code>接口的目标类的所有连接点（Spring AOP中方法的执行）</li></ul><h5 id="4-1-5-组合多个切入点"><a href="#4-1-5-组合多个切入点" class="headerlink" title="4.1.5 组合多个切入点"></a>4.1.5 组合多个切入点</h5><p>很多时候可能一个切入点并不能满足我们的需求，这时候就需要组合使用切入点来限制匹配的切入点。在Spring AOP中可以使用<code>and</code>(<code>&amp;&amp;</code>)、<code>or</code>(<code>||</code>)和<code>not</code>(<code>!</code>)。既可以使用文字的形式也可以使用符号的形式。比如 <code>execution(* concert.Performance.perform(..)) &amp;&amp; within(concert.*))</code>。</p><h4 id="4-2-定义切面（-Aspect）"><a href="#4-2-定义切面（-Aspect）" class="headerlink" title="4.2 定义切面（@Aspect）"></a>4.2 定义切面（@Aspect）</h4><p>现在，我们可以使用我们学到的来定义切面了。在Spring中可以使用XML和注解的方式来定义切面，本文将只讨论使用注解定义切面的方式。Spring支持使用<strong>AspectJ</strong>的注解<code>@Aspect</code>来定义切面，就像<strong>清单2</strong>所使用的那样。但是，如果我们要让Spring知道我们定义了一个<strong>切面</strong>的话，还必须把这个切面声明为一个<strong>Bean</strong>。所以我们使用<code>@Component</code>注解，这样Spring就会识别它，并把它当做<strong>切面</strong>来看待了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdviceExampleAspect</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="4-3-定义切点（-Pointcut）"><a href="#4-3-定义切点（-Pointcut）" class="headerlink" title="4.3 定义切点（@Pointcut）"></a><strong>4.3 定义切点（@Pointcut）</strong></h4><p><strong>切点（Pointcut）</strong>定义使用<code>@Pointcut</code>注解。注解中我们就可以使用<strong>4.1 切点</strong>中的表达式来选择连接点。定义切点时，可以组合多个切点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"execution(public * *(..))"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">anyPublicOperation</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"within(com.xyz.someapp.trading..*)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inTrading</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组合切点</span></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"anyPublicOperation() &amp;&amp; inTrading()"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">tradingOperation</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="4-4-定义通知"><a href="#4-4-定义通知" class="headerlink" title="4.4 定义通知"></a><strong>4.4 定义通知</strong></h4><p>在<strong>清单2</strong>中我们已经定义了<code>@Before</code>和<code>@After</code>通知，也可以使用其他类型的通知。这里主要介绍如何使用<code>@Around</code>注解，定义 <strong>环绕（Around）</strong> 通知类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.archerie.aop.aspect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Around;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Pointcut;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdviceAroundAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(** org.archerie..*Bean.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beanPointCut</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"beanPointCut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">watchBean</span><span class="params">(ProceedingJoinPoint jp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"手机静音！"</span>);</span><br><span class="line">            jp.proceed();</span><br><span class="line">            System.out.println(<span class="string">"鼓掌！鼓掌！"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"投诉！投诉！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Around通知类型中，我们可以定义具体方法运行前或者后的逻辑。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-参考&quot;&gt;&lt;a href=&quot;#1-参考&quot; class=&quot;headerlink&quot; title=&quot;1. 参考&quot;&gt;&lt;/a&gt;1. 参考&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/w1196726224/article/details/50535659&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Spring 4 学习笔记5：Spring AOP&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;《Spring实战 第四版》&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/wangpeng047/article/details/8556800&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;SpringAop 详尽教程&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="SSM框架" scheme="https://caoler.cn/categories/SSM%E6%A1%86%E6%9E%B6/"/>
    
      <category term="Spring" scheme="https://caoler.cn/categories/SSM%E6%A1%86%E6%9E%B6/Spring/"/>
    
    
      <category term="Spring" scheme="https://caoler.cn/tags/Spring/"/>
    
  </entry>
  
</feed>
