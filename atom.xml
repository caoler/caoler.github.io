<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Caole&#39;s blog</title>
  
  <subtitle>Caole的个人博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://caoler.cn/"/>
  <updated>2018-04-08T10:40:02.162Z</updated>
  <id>https://caoler.cn/</id>
  
  <author>
    <name>Caole</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>V2RayN 使用教程</title>
    <link href="https://caoler.cn//post/2018/v2rayn-st.html"/>
    <id>https://caoler.cn//post/2018/v2rayn-st.html</id>
    <published>2018-04-08T09:24:47.000Z</published>
    <updated>2018-04-08T10:40:02.162Z</updated>
    
    <content type="html"><![CDATA[<p>由于酸酸乳容易被墙，所以更换V2RayN。</p><p><strong>勿外传</strong></p><p><strong>勿外传</strong></p><p><strong>勿外传</strong></p><p><strong>勿外传</strong></p><a id="more"></a><h1 id="PC端"><a href="#PC端" class="headerlink" title="PC端"></a>PC端</h1><h2 id="下载-V2Ray"><a href="#下载-V2Ray" class="headerlink" title="下载 V2Ray"></a>下载 V2Ray</h2><p>下载链接： <a href="https://github.com/v2ray/v2ray-core/releases/latest" target="_blank" rel="external">https://github.com/v2ray/v2ray-core/releases/latest</a><br>然后选择 v2ray-windows-64.zip 下载，如果你的系统是 32 位的那就选择 v2ray-windows-32.zip。<br>下载完成，解压。<br>打开解压出来的文件夹 (例如 v2ray-xxxx-windows-64，xxxx为版本号)</p><h2 id="下载-V2RayN"><a href="#下载-V2RayN" class="headerlink" title="下载 V2RayN"></a>下载 V2RayN</h2><p>下载链接： <a href="https://github.com/2dust/v2rayN/releases/latest" target="_blank" rel="external">https://github.com/2dust/v2rayN/releases/latest</a><br>然后选择 V2RayN.exe 下载<br>将下载完成后的 V2RayN.exe 复制到之前打开的 V2Ray 文件夹目录</p><h2 id="配置-V2RayN"><a href="#配置-V2RayN" class="headerlink" title="配置 V2RayN"></a>配置 V2RayN</h2><p>双击 V2RayN.exe 启动，然后在任务栏托盘找到 V2RayN 图标并双击它<br>添加一个 VMess 服务器<br><img src="https://i.loli.net/2018/02/10/5a7ef4f42264c.png" alt="image"></p><p>复制以下内容<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">vmess:</span><span class="comment">//ew0KICAicHMiOiAiMjMzYmxvZ192MnJheV9SZWRpcmVjdGluZy4uLiIsDQogICJhZGQiOiAiMTk4LjIzLjIzNy4yMjciLA0KICAicG9ydCI6ICI0ODE2MSIsDQogICJpZCI6ICJmOWM5YzVmNS0zZDllLTQ5N2ItYmM1NS0zNzJmYWFhODYyYTEiLA0KICAiYWlkIjogIjIzMyIsDQogICJuZXQiOiAid3MiLA0KICAidHlwZSI6ICJub25lIiwNCiAgImhvc3QiOiAiIiwNCiAgInRscyI6ICIiDQp9</span></span><br></pre></td></tr></table></figure></p><p>从剪贴板导入 URL<br><img src="https://i.loli.net/2018/02/10/5a7ef4f422311.png" alt="image"></p><p>设置本地监听端口，此处我将它设置为 2333<br><img src="https://i.loli.net/2018/02/10/5a7ef4f425367.png" alt="image"></p><h2 id="启用系统代理"><a href="#启用系统代理" class="headerlink" title="启用系统代理"></a>启用系统代理</h2><p>在任务栏托盘找到 V2RayN 图标并鼠标右键<br>先启动系统代理，然后更新PAC，之后 系统代理模式 》PAC 模式<br><img src="https://i.loli.net/2018/02/10/5a7ef4f422a05.png" alt="image"></p><p>备注，选择 更新 PAC 之后，双击打开 V2RayN 图标打开主界面在下面信息那里看看有没有显示 PAC更新成功！</p><h2 id="测试一下"><a href="#测试一下" class="headerlink" title="测试一下"></a>测试一下</h2><p>在完成上面的步骤的时候，正常来说，你已经处于翻出去的状态了</p><h1 id="Android-安卓"><a href="#Android-安卓" class="headerlink" title="Android (安卓)"></a>Android (安卓)</h1><p>使用 v2rayNG (对新手友好，推荐使用)</p><p>Google Play 搜索 v2rayNG 安装即可。<a href="https://github.com/2dust/v2rayNG/releases/download/0.3.10/app-universal-release.apk" target="_blank" rel="external">备用下载点我</a></p><p>安装完成后打开，点击右上角设置图标，选上绕过中国大陆，分应用代理的话，自己视情况而定就行。</p><p><img src="https://ws1.sinaimg.cn/large/005DnJLEly1fq5fot27rxj309m08at94.jpg" alt=""></p><p>v2rayNG 主界面点击右上角 + 图标，选择扫描二维码即可，便会自动识别 V2Ray 配置信息<br>扫描完成后，点击主界面右下角小飞机图标启动<br>OK，开始愉快的使用互联网吧。</p><h1 id="IOS"><a href="#IOS" class="headerlink" title="IOS"></a>IOS</h1><p><strong>待更新</strong></p><p><del>## 如何使用</del><br><del>1. 手动填写服务器配置 ( 推荐 )</del><br><del>shadowrocket 不支持扫入一键脚 本或 V2rayN</del> <del>生成的二维码。如何填写以及注意事项见以下。</del></p><p><del>2. 扫码导入服务器配置 ( 不推荐 )</del><br><del>正如之前所说，shadowrocket 不支持扫入一键脚本或 V2rayN 生成的二维码，只能扫入</del> <del>shadowrocket 导出的 vmess 服务器设置，所以这种导入方式没有泛用性。</del></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于酸酸乳容易被墙，所以更换V2RayN。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;勿外传&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;勿外传&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;勿外传&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;勿外传&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="实用教程" scheme="https://caoler.cn/categories/%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B/"/>
    
      <category term="科学上网" scheme="https://caoler.cn/categories/%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"/>
    
    
      <category term="原创" scheme="https://caoler.cn/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="科学上网" scheme="https://caoler.cn/tags/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>Spring Bean生命周期</title>
    <link href="https://caoler.cn//post/2018/SpringBeanLife.html"/>
    <id>https://caoler.cn//post/2018/SpringBeanLife.html</id>
    <published>2018-04-07T11:13:48.000Z</published>
    <updated>2018-04-07T11:15:06.818Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring-Bean-生命周期"><a href="#Spring-Bean-生命周期" class="headerlink" title="Spring Bean 生命周期"></a>Spring Bean 生命周期</h1><p>BeanFactory和ApplicationContext是Spring两种很重要的容器,前者提供了最基本的依赖注入的支持，而后者在继承前者的基础进行了功能的拓展，例如增加了事件传播，资源访问和国际化的消息访问等功能。</p><p>概括来说主要有四个阶段：实例化，初始化，使用，销毁。</p><a id="more"></a><h2 id="Bean-作用范围"><a href="#Bean-作用范围" class="headerlink" title="Bean 作用范围"></a>Bean 作用范围</h2><p>常用的Bean作用范围：singleton和prototype</p><h3 id="singleton"><a href="#singleton" class="headerlink" title="singleton"></a>singleton</h3><p>在默认情况下,Spring的ApplicationContext容器在启动时,自动实例化所有singleton的Bean并缓存于容器中.虽然启动时会花费一些时间,但带来两个好处:首先对Bean提前的实例化操作会及早发现一些潜在的配置问题.其次Bean以缓存的方式保存,当运行时使用到该Bean时就无须再实例化了,加快了运行效率.如果用户不希望在容器启动时提前实例化singleton的Bean,可以通过lazy-init属性进行控制.</p><h3 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h3><p>在默认情况下,Spring容器在启动时不实例化prototype的Bean.此外,Spring容器将prototype的Bean交给调用者后,就不再管理它的生命周期.</p><h2 id="ApplicationContext-Bean生命周期"><a href="#ApplicationContext-Bean生命周期" class="headerlink" title="ApplicationContext Bean生命周期"></a>ApplicationContext Bean生命周期</h2><p>Spring Bean的完整生命周期从创建Spring容器开始，直到最终Spring容器销毁Bean，这其中包含了一系列关键点。</p><h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p><img src="https://ws1.sinaimg.cn/large/005DnJLEly1fq4aidk8uij30ko0e2dgb.jpg" alt=""></p><h3 id="各种接口方法分类"><a href="#各种接口方法分类" class="headerlink" title="各种接口方法分类"></a>各种接口方法分类</h3><p>Bean的完整生命周期经历了各种方法调用，这些方法可以划分为以下几类：</p><ol><li><p>Bean自身的方法：这个包括了Bean本身调用的方法和通过配置文件中<bean>的init-method和destroy-method指定的方法</bean></p></li><li><p>Bean级生命周期接口方法：这个包括了BeanNameAware、BeanFactoryAware、InitializingBean和DiposableBean这些接口的方法</p></li><li><p>容器级生命周期接口方法：这个包括了InstantiationAwareBeanPostProcessor和 BeanPostProcessor这两个接口实现，一般称它们的实现类为“后处理器”。容器中每个bean初始化都要经过这一步。</p></li><li><p>工厂后处理器接口BeanFactoryPostProcessor方法：这个包括了AspectJWeavingEnabler, ConfigurationClassPostProcessor, CustomAutowireConfigurer等等非常有用的工厂后处理器接口的方法。工厂后处理器也是容器级的，在应用上下文装配配置文件之后立即调用。</p></li></ol><h3 id="流程说明"><a href="#流程说明" class="headerlink" title="流程说明"></a>流程说明</h3><p>ApplicationContext容器中，Bean的生命周期流程如上图所示，流程大致如下：</p><ol><li><p>首先容器启动后，会对scope为singleton且非懒加载的bean进行实例化，</p></li><li><p>按照Bean定义信息配置信息，注入所有的属性，</p></li><li><p>如果Bean实现了BeanNameAware接口，会回调该接口的setBeanName()方法，传入该Bean的id，此时该Bean就获得了自己在配置文件中的id，</p></li><li><p>如果Bean实现了BeanFactoryAware接口,会回调该接口的setBeanFactory()方法，传入该Bean的BeanFactory，这样该Bean就获得了自己所在的BeanFactory，</p></li><li><p>如果Bean实现了ApplicationContextAware接口,会回调该接口的setApplicationContext()方法，传入该Bean的ApplicationContext，这样该Bean就获得了自己所在的ApplicationContext，</p></li><li><p>如果有Bean实现了BeanPostProcessor接口，则会回调该接口的postProcessBeforeInitialzation()方法，</p></li><li><p>如果Bean实现了InitializingBean接口，则会回调该接口的afterPropertiesSet()方法，</p></li><li><p>如果Bean配置了init-method方法，则会执行init-method配置的方法，</p></li><li><p>如果有Bean实现了BeanPostProcessor接口，则会回调该接口的postProcessAfterInitialization()方法，</p></li><li><p>经过流程9之后，就可以正式使用该Bean了,对于scope为singleton的Bean,Spring的ioc容器中会缓存一份该bean的实例，而对于scope为prototype的Bean,每次被调用都会new一个新的对象，期生命周期就交给调用方管理了，不再是Spring容器进行管理了</p></li><li><p>容器关闭后，如果Bean实现了DisposableBean接口，则会回调该接口的destroy()方法，</p></li><li><p>如果Bean配置了destroy-method方法，则会执行destroy-method配置的方法，至此，整个Bean的生命周期结束</p></li></ol><h2 id="BeanFactory-Bean生命周期"><a href="#BeanFactory-Bean生命周期" class="headerlink" title="BeanFactory Bean生命周期"></a>BeanFactory Bean生命周期</h2><p>BeanFactoty容器中, Bean的生命周期如下图所示，与ApplicationContext相比，有如下几点不同:</p><ol><li><p>BeanFactory容器中，不会调用ApplicationContextAware接口的setApplicationContext()方法</p></li><li><p>BeanPostProcessor接口的postProcessBeforeInitialzation()方法和postProcessAfterInitialization()方法不会自动调用，必须自己通过代码手动注册</p></li><li><p>BeanFactory容器启动的时候，不会去实例化所有Bean,包括所有scope为singleton且非懒加载的Bean也是一样，而是在调用的时候去实例化。</p></li></ol><h3 id="流程图-1"><a href="#流程图-1" class="headerlink" title="流程图"></a>流程图</h3><p><img src="https://ws1.sinaimg.cn/large/005DnJLEly1fq4amcingnj30kq0cw0t7.jpg" alt=""></p><h3 id="流程说明-1"><a href="#流程说明-1" class="headerlink" title="流程说明"></a>流程说明</h3><ol><li>当调用者通过 getBean(name)向 容器寻找Bean时，如果容器注册了org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessor接口，在实例bean之前，将调用该接口的 postProcessBeforeInstantiation()方法</li><li>容器寻找Bean的定义信息，并将其实例化</li><li>使用依赖注入，Spring按照Bean定义信息配置Bean的所有属性</li><li>如果Bean实现了BeanNameAware接口，工厂调用Bean的setBeanName()方法传递Bean的id</li><li>如果实现了BeanFactoryAware接口，工厂调用setBeanFactory()方法传入工厂自身</li><li>如果BeanPostProcessor和Bean关联，那么它们的postProcessBeforeInitialization()方法将被调用（需要手动进行注册！）</li><li>如果Bean实现了InitializingBean接口，则会回调该接口的afterPropertiesSet()方法</li><li>如果Bean指定了init-method方法，就会调用init-method方法</li><li>如果BeanPostProcessor和Bean关联，那么它的postProcessAfterInitialization()方法将被调用（需要手动注册！）</li><li>现在Bean已经可以使用了<ol><li>scope为singleton的Bean缓存在Spring IOC容器中</li><li>scope为prototype的Bean生命周期交给客户端</li></ol></li><li>销毁<ol><li>如果Bean实现了DisposableBean接口，destory()方法将会被调用</li><li>如果配置了destory-method方法，就调用这个方法</li></ol></li></ol><h2 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h2><p>用一个简单的Spring Bean来演示一下Spring Bean的生命周期。</p><p>1、首先是一个简单的Spring Bean，调用Bean自身的方法和Bean级生命周期接口方法，为了方便演示，它实现了BeanNameAware、ApplicationContextAware、BeanFactoryAware、InitializingBean和DiposableBean这5个接口，同时有2个方法，对应配置文件中<bean>的init-method和destroy-method。如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.BeanFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.BeanFactoryAware;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.BeanNameAware;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.DisposableBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.InitializingBean;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">BeanFactoryAware</span>, <span class="title">BeanNameAware</span>, <span class="title">InitializingBean</span>, <span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> String address;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> phone;</span><br><span class="line">  <span class="keyword">private</span> BeanFactory beanFactory;</span><br><span class="line">  <span class="keyword">private</span> String beanName;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"【构造器】调用Person的构造器实例化"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"【注入属性】注入属性name"</span>);</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> address;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAddress</span><span class="params">(String address)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"【注入属性】注入属性address"</span>);</span><br><span class="line">    <span class="keyword">this</span>.address = address;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPhone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> phone;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPhone</span><span class="params">(<span class="keyword">int</span> phone)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"【注入属性】注入属性phone"</span>);</span><br><span class="line">    <span class="keyword">this</span>.phone = phone;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Person [address="</span> + address + <span class="string">", name="</span> + name + <span class="string">", phone="</span> + phone + <span class="string">"]"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 这是BeanFactoryAware接口方法</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanFactory</span><span class="params">(BeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"【BeanFactoryAware接口】调用BeanFactoryAware.setBeanFactory()"</span>);</span><br><span class="line">    <span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 这是BeanNameAware接口方法</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"【BeanNameAware接口】调用BeanNameAware.setBeanName()"</span>);</span><br><span class="line">    <span class="keyword">this</span>.beanName = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 这是InitializingBean接口方法</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"【InitializingBean接口】调用InitializingBean.afterPropertiesSet()"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 这是DiposibleBean接口方法</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"【DiposibleBean接口】调用DiposibleBean.destory()"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 通过&lt;bean&gt;的init-method属性指定的初始化方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myInit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"【init-method】调用&lt;bean&gt;的init-method属性指定的初始化方法"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 通过&lt;bean&gt;的destroy-method属性指定的初始化方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myDestory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"【destroy-method】调用&lt;bean&gt;的destroy-method属性指定的初始化方法"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></bean></p><p>2、接下来是演示BeanPostProcessor接口的方法，如下：<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.BeanPostProcessor;</span><br><span class="line"><span class="keyword">public</span> class MyBeanPostProcessor implements BeanPostProcessor &#123;</span><br><span class="line">  <span class="keyword">public</span> MyBeanPostProcessor() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"这是BeanPostProcessor实现类构造器！！"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  @Override</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">Object</span> postProcessBeforeInitialization(<span class="keyword">Object</span> bean, <span class="keyword">String</span> beanName) <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"BeanPostProcessor接口方法postProcessBeforeInitialization对属性进行更改！"</span>);</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">Object</span> postProcessAfterInitialization(<span class="keyword">Object</span> bean, <span class="keyword">String</span> beanName) <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"BeanPostProcessor接口方法postProcessAfterInitialization对属性进行更改！"</span>);</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如上，BeanPostProcessor接口包括2个方法postProcessAfterInitialization和postProcessBeforeInitialization，这两个方法的第一个参数都是要处理的Bean对象，第二个参数都是Bean的name。返回值也都是要处理的Bean对象。</p><p>3、InstantiationAwareBeanPostProcessor 接口本质是BeanPostProcessor的子接口，一般我们继承Spring为其提供的适配器类InstantiationAwareBeanPostProcessorAdapter来使用它，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.beans.PropertyDescriptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.PropertyValues;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessorAdapter;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInstantiationAwareBeanPostProcessor</span> <span class="keyword">extends</span> <span class="title">InstantiationAwareBeanPostProcessorAdapter</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MyInstantiationAwareBeanPostProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    System.out.println(<span class="string">"这是InstantiationAwareBeanPostProcessorAdapter实现类构造器！！"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 接口方法、实例化Bean之前调用</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInstantiation</span><span class="params">(Class beanClass, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"InstantiationAwareBeanPostProcessor调用postProcessBeforeInstantiation方法"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 接口方法、实例化Bean之后调用</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"InstantiationAwareBeanPostProcessor调用postProcessAfterInitialization方法"</span>);</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 接口方法、设置某个属性时调用</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> PropertyValues <span class="title">postProcessPropertyValues</span><span class="params">(PropertyValues pvs, PropertyDescriptor[] pds, Object bean,</span></span></span><br><span class="line"><span class="function"><span class="params">      String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"InstantiationAwareBeanPostProcessor调用postProcessPropertyValues方法"</span>);</span><br><span class="line">    <span class="keyword">return</span> pvs;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个有3个方法，其中第二个方法postProcessAfterInitialization就是重写了BeanPostProcessor的方法。第三个方法postProcessPropertyValues用来操作属性，返回值也应该是PropertyValues对象。</p><p>4、工厂后处理器接口方法，如下：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="meta-keyword">import</span> org.springframework.beans.BeansException;</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">import</span> org.springframework.beans.factory.config.BeanDefinition;</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">import</span> org.springframework.beans.factory.config.BeanFactoryPostProcessor;</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">import</span> org.springframework.beans.factory.config.ConfigurableListableBeanFactory;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanFactoryPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanFactoryPostProcessor</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> MyBeanFactoryPostProcessor() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    System.out.println(<span class="string">"这是BeanFactoryPostProcessor实现类构造器！！"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  @Override</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException &#123;</span><br><span class="line">    System.out.println(<span class="string">"BeanFactoryPostProcessor调用postProcessBeanFactory方法"</span>);</span><br><span class="line">    BeanDefinition bd = arg0.getBeanDefinition(<span class="string">"person"</span>);</span><br><span class="line">    bd.getPropertyValues().addPropertyValue(<span class="string">"phone"</span>, <span class="string">"110"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>BeanFactoryPostProcessor 可以修改 bean 的配置信息而 BeanPostProcessor 不能<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanFactoryPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanFactoryPostProcessor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="comment">//BeanFactoryPostProcessor可以修改BEAN的配置信息而BeanPostProcessor不能</span></span><br><span class="line">        <span class="comment">//我们在这里修改postProcessorBean的username注入属性</span></span><br><span class="line">        BeanDefinition bd = beanFactory.getBeanDefinition(<span class="string">"postProcessorBean"</span>);</span><br><span class="line">        MutablePropertyValues pv =  bd.getPropertyValues();</span><br><span class="line">        <span class="keyword">if</span>(pv.contains(<span class="string">"username"</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            pv.addPropertyValue(<span class="string">"username"</span>, <span class="string">"xiaojun"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>5、配置文件如下beans.xml，使用ApplicationContext,处理器不用手动注册：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span> <span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">            http://www.springframework.org/schema/beans </span></span></span><br><span class="line"><span class="tag"><span class="string">            http://www.springframework.org/schema/beans/spring-beans-3.2.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"beanPostProcessor"</span> <span class="attr">class</span>=<span class="string">"springBeanTest.MyBeanPostProcessor"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"instantiationAwareBeanPostProcessor"</span> <span class="attr">class</span>=<span class="string">"springBeanTest.MyInstantiationAwareBeanPostProcessor"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"beanFactoryPostProcessor"</span> <span class="attr">class</span>=<span class="string">"springBeanTest.MyBeanFactoryPostProcessor"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"person"</span> <span class="attr">class</span>=<span class="string">"springBeanTest.Person"</span> <span class="attr">init-method</span>=<span class="string">"myInit"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">destroy-method</span>=<span class="string">"myDestory"</span> <span class="attr">scope</span>=<span class="string">"singleton"</span> <span class="attr">p:name</span>=<span class="string">"张三"</span> <span class="attr">p:address</span>=<span class="string">"广州"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">p:phone</span>=<span class="string">"15900000000"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>6、测试<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanLifeCycleTest</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="type">String</span>[] args) &#123;</span><br><span class="line">    <span class="type">System</span>.out.<span class="built_in">println</span>(<span class="string">"现在开始初始化容器"</span>);</span><br><span class="line">    <span class="type">ApplicationContext</span> factory = new <span class="type">ClassPathXmlApplicationContext</span>(<span class="string">"beans.xml"</span>);</span><br><span class="line">    <span class="type">System</span>.out.<span class="built_in">println</span>(<span class="string">"容器初始化成功"</span>);</span><br><span class="line">    <span class="comment">// 得到Preson，并使用</span></span><br><span class="line">    <span class="type">Person</span> person = factory.getBean(<span class="string">"person"</span>, <span class="type">Person</span>.<span class="keyword">class</span>);</span><br><span class="line">    <span class="type">System</span>.out.<span class="built_in">println</span>(person);</span><br><span class="line">    <span class="type">System</span>.out.<span class="built_in">println</span>(<span class="string">"现在开始关闭容器！"</span>);</span><br><span class="line">    ((<span class="type">ClassPathXmlApplicationContext</span>) factory).registerShutdownHook();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>关闭容器使用的是实际是AbstractApplicationContext的钩子方法。</p><p>7、结果：<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">现在开始初始化容器</span><br><span class="line">[location]<span class="number">15</span>:<span class="number">15</span>:<span class="number">33</span> <span class="number">100</span>  INFO (<span class="keyword">org.springframework.context.support.ClassPathXmlApplicationContext:510) </span>- Refreshing <span class="keyword">org.springframework.context.support.ClassPathXmlApplicationContext@75a70476: </span>startup date [Mon May <span class="number">08</span> <span class="number">15</span>:<span class="number">15</span>:<span class="number">33</span> CST <span class="number">2017</span>]<span class="comment">; root of context hierarchy</span></span><br><span class="line">[location]<span class="number">15</span>:<span class="number">15</span>:<span class="number">33</span> <span class="number">194</span>  INFO (<span class="keyword">org.springframework.beans.factory.xml.XmlBeanDefinitionReader:315) </span>- Loading XML <span class="keyword">bean </span>definitions from class path resource [<span class="keyword">beans.xml]</span></span><br><span class="line"><span class="keyword">这是BeanFactoryPostProcessor实现类构造器！！</span></span><br><span class="line"><span class="keyword">BeanFactoryPostProcessor调用postProcessBeanFactory方法</span></span><br><span class="line"><span class="keyword">这是BeanPostProcessor实现类构造器！！</span></span><br><span class="line"><span class="keyword">这是InstantiationAwareBeanPostProcessorAdapter实现类构造器！！</span></span><br><span class="line"><span class="keyword">[location]15:15:33 </span><span class="number">695</span>  INFO (<span class="keyword">org.springframework.beans.factory.support.DefaultListableBeanFactory:596) </span>- Pre-<span class="keyword">instantiating </span>singletons in <span class="keyword">org.springframework.beans.factory.support.DefaultListableBeanFactory@461d434f: </span>defining <span class="keyword">beans </span>[<span class="keyword">beanPostProcessor,instantiationAwareBeanPostProcessor,beanFactoryPostProcessor,person]; </span>root of factory hierarchy</span><br><span class="line"><span class="keyword">InstantiationAwareBeanPostProcessor调用postProcessBeforeInstantiation方法</span></span><br><span class="line"><span class="keyword">【构造器】调用Person的构造器实例化</span></span><br><span class="line"><span class="keyword">InstantiationAwareBeanPostProcessor调用postProcessPropertyValues方法</span></span><br><span class="line"><span class="keyword">【注入属性】注入属性address</span></span><br><span class="line"><span class="keyword">【注入属性】注入属性name</span></span><br><span class="line"><span class="keyword">【注入属性】注入属性phone</span></span><br><span class="line"><span class="keyword">【BeanNameAware接口】调用BeanNameAware.setBeanName()</span></span><br><span class="line"><span class="keyword">【BeanFactoryAware接口】调用BeanFactoryAware.setBeanFactory()</span></span><br><span class="line"><span class="keyword">BeanPostProcessor接口方法postProcessBeforeInitialization对属性进行更改！</span></span><br><span class="line"><span class="keyword">【InitializingBean接口】调用InitializingBean.afterPropertiesSet()</span></span><br><span class="line"><span class="keyword">【init-method】调用&lt;bean&gt;的init-method属性指定的初始化方法</span></span><br><span class="line"><span class="keyword">BeanPostProcessor接口方法postProcessAfterInitialization对属性进行更改！</span></span><br><span class="line"><span class="keyword">InstantiationAwareBeanPostProcessor调用postProcessAfterInitialization方法</span></span><br><span class="line"><span class="keyword">容器初始化成功</span></span><br><span class="line"><span class="keyword">Person </span>[<span class="keyword">address=广州, </span>name=张三, phone=<span class="number">110</span>]</span><br><span class="line">现在开始关闭容器！</span><br><span class="line">[location]<span class="number">15</span>:<span class="number">15</span>:<span class="number">33</span> <span class="number">752</span>  INFO (<span class="keyword">org.springframework.context.support.ClassPathXmlApplicationContext:1042) </span>- <span class="keyword">Closing </span><span class="keyword">org.springframework.context.support.ClassPathXmlApplicationContext@75a70476: </span>startup date [Mon May <span class="number">08</span> <span class="number">15</span>:<span class="number">15</span>:<span class="number">33</span> CST <span class="number">2017</span>]<span class="comment">; root of context hierarchy</span></span><br><span class="line">[location]<span class="number">15</span>:<span class="number">15</span>:<span class="number">33</span> <span class="number">752</span>  INFO (<span class="keyword">org.springframework.beans.factory.support.DefaultListableBeanFactory:444) </span>- Destroying singletons in <span class="keyword">org.springframework.beans.factory.support.DefaultListableBeanFactory@461d434f: </span>defining <span class="keyword">beans </span>[<span class="keyword">beanPostProcessor,instantiationAwareBeanPostProcessor,beanFactoryPostProcessor,person]; </span>root of factory hierarchy</span><br><span class="line">【<span class="keyword">DiposibleBean接口】调用DiposibleBean.destory()</span></span><br><span class="line"><span class="keyword">【destroy-method】调用&lt;bean&gt;的destroy-method属性指定的初始化方法</span></span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Bean的完整生命周期从 spring 容器开始实例化 bean 开始，到销毁。可以从三点来理解</p><ol><li>bean自身的方法：包括构造方法、 set 方法、 init-method 指定的方法、 destroy-method 指定的方法</li><li>bean级生命周期接口方法：如BeanNameAware 、 BeanFactoryAware 等这些接口方法由 bean类实现</li><li>容器级生命周期接口方法：有InstantiationAwareBeanPostProcessor 、 BeanPostProcessor等。一般称为后处理器。他们一般不由bean 本身实现，独立存在，注册到 spring 容器中。 Spring 通过接口反射预先知道，当 spring 容器创建任何 bean 时，这些后处理器都会发生作用。所以他们是全局的，用户可以通过编码对只感兴趣的 bean 进行处理</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.jianshu.com/p/3944792a5fff" target="_blank" rel="external">简书 - SpringBean生命周期</a></li><li><a href="https://www.cnblogs.com/zrtqsk/p/3735273.html" target="_blank" rel="external">博客园 - Spring Bean的生命周期（非常详细）</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Spring-Bean-生命周期&quot;&gt;&lt;a href=&quot;#Spring-Bean-生命周期&quot; class=&quot;headerlink&quot; title=&quot;Spring Bean 生命周期&quot;&gt;&lt;/a&gt;Spring Bean 生命周期&lt;/h1&gt;&lt;p&gt;BeanFactory和ApplicationContext是Spring两种很重要的容器,前者提供了最基本的依赖注入的支持，而后者在继承前者的基础进行了功能的拓展，例如增加了事件传播，资源访问和国际化的消息访问等功能。&lt;/p&gt;
&lt;p&gt;概括来说主要有四个阶段：实例化，初始化，使用，销毁。&lt;/p&gt;
    
    </summary>
    
      <category term="SSM框架" scheme="https://caoler.cn/categories/SSM%E6%A1%86%E6%9E%B6/"/>
    
      <category term="Spring" scheme="https://caoler.cn/categories/SSM%E6%A1%86%E6%9E%B6/Spring/"/>
    
    
      <category term="Spring" scheme="https://caoler.cn/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>《深入理解Java虚拟机》读书笔记2 - 垃圾收集器与内存分配策略</title>
    <link href="https://caoler.cn//post/2018/deep-in-jvm-part2.html"/>
    <id>https://caoler.cn//post/2018/deep-in-jvm-part2.html</id>
    <published>2018-03-07T13:17:43.000Z</published>
    <updated>2018-03-08T08:33:04.714Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第三章-垃圾收集器与内存分配策略"><a href="#第三章-垃圾收集器与内存分配策略" class="headerlink" title="第三章 垃圾收集器与内存分配策略"></a>第三章 垃圾收集器与内存分配策略</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>思考GC需要完成的3件事情：</p><ul><li>哪些内存需要回收？</li><li>什么时候回收？</li><li>如何回收？<br>再回头看看第二章介绍的Java内存运行时区域的各个部分：</li></ul><a id="more"></a><ul><li>程序计时器、虚拟机栈、本地方法栈：随线程而灭，栈帧随方法而进行出栈和入栈，每一个栈帧分配的内存在类结构确定就已知，因此这几个区域不需要考虑回收；</li><li>对于Java堆和方法区，只有程序运行期间才知道会创建哪些对象，内存的分配和回收都是动态的，垃圾收集器所关注的是这部分内存；<h3 id="对象已死吗？"><a href="#对象已死吗？" class="headerlink" title="对象已死吗？"></a>对象已死吗？</h3>在垃圾收集器进行回收前，第一件事就是确定这些对象哪些还存活，哪些已经死去。</li></ul><h3 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h3><p>给对象添加引用计数器，当有地方引用它时就加1，引用失效就减1，为0时就认为对象不再被使用可回收。该算法失效简单，判断高效，但并不被主流虚拟机采用，主要原因是它很难解决对象之间相互循环引用的问题。</p><h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>通过一系列的称为“GC Roots”的对象作为起点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），如果一个对象到GC Roots没有引用链相连，则该对象是不可用的。</p><p><img src="https://ws1.sinaimg.cn/large/005DnJLEly1fp4h76x2l2j30nm0ekdia.jpg" alt=""></p><p>在Java语言中，可作为GC Roots的对象包括：</p><ul><li>虚拟机栈（栈帧中的本地变量表）中引用的对象；</li><li>方法区中类静态属性引用的对象；</li><li>方法区中常量引用的对象；</li><li>本地方法栈中JNI（即一般说的Native方法）引用的对象；</li></ul><h4 id="再谈引用"><a href="#再谈引用" class="headerlink" title="再谈引用"></a>再谈引用</h4><p>在JDK 1.2之后，Java对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用和虚引用，这4种引用强度依次减弱。</p><h4 id="生存还是死亡"><a href="#生存还是死亡" class="headerlink" title="生存还是死亡"></a>生存还是死亡</h4><p>要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize方法（如没有重写finalize方法或者已经被调用过则认为没有必要执行）；如果有必要执行则将该对象放置在F-Queue队列中，并在稍后由一个由虚拟机自己建立的、低优先级的Finalizer线程去执行它；稍后GC将对F-Queue中的对象进行第二次标记，如果对象还是没有被引用，则会被回收。</p><p>但是作者不建议通过finalize方法“拯救”对象，因为它运行代价高、不确定性大、无法保证各个对象的调用顺序。</p><h4 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h4><p>永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类。</p><p>一个无用的类需要满足以下三个条件：</p><ul><li>该类的所有实例都已经被回收；</li><li>加载该类的ClassLoader已经被回收；</li><li>该类对象的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法；</li><li>在大量使用反射、动态代理、CGLib等ByteCode框架、动态生成JSP以及OSGI这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能（HotSpot提供-Xnoclassgc参数控制），以保证永久代不会溢出。</li></ul><h4 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h4><ul><li>标记-清除算法：首先标记出所有需要回收的对象，然后统一回收所有被标记的对象；缺点是效率不高且容易产生大量不连续的内存碎片；</li><li>复制算法：将可用内存分为大小相等的两块，每次只使用其中一块；当这一块用完了，就将还活着的对象复制到另一块上，然后把已使用过的内存清理掉。在HotSpot里，考虑到大部分对象存活时间很短将内存分为Eden和两块Survivor，默认比例为8:1:1。代价是存在部分内存空间浪费，适合在新生代使用；</li><li>标记-整理算法：首先标记出所有需要回收的对象，然后让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。适用于老年代。</li><li>分代收集算法：一般把Java堆分新生代和老年代，在新生代用复制算法，在老年代用标记-清理或标记-整理算法，是现代虚拟机通常采用的算法。</li></ul><h3 id="HotSpot的算法实现"><a href="#HotSpot的算法实现" class="headerlink" title="HotSpot的算法实现"></a>HotSpot的算法实现</h3><h4 id="枚举根节点"><a href="#枚举根节点" class="headerlink" title="枚举根节点"></a>枚举根节点</h4><p>由于要确保在一致性的快照中进行可达性分析，从而导致GC进行时必须要停顿所有Java执行线程；<br>在HotSpot里通过一组OopMap数据结构来知道哪些地方存放着对象引用；</p><h4 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h4><p>HotSpot只在特定的位置记录了OopMap，这些位置称为安全点（SafePoint）；<br>即程序执行时并非在所有地方都能停顿下来开始GC，只有到达安全点时才能暂停；<br>对于安全点基本上是以程序“是否具有让程序长时间执行的特征”（比如方法调用、循环跳转、异常跳转等）为标准进行选定的；<br>另外还需要考虑如果在GC时让所有线程都跑到最近的安全点上，有两种方案：抢先式中断和主动式中断（主流选择）；</p><h4 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h4><p>如果程序没有分配CPU时间（如线程处于Sleep或Blocked），此时就需要安全区域（Safe Region），其是指在一段代码片段之中，引用关系不会发生变化；<br>线程执行到安全区域时，首先标识自己已经进入了安全区域，这样JVM在GC时就不管这些线程了；</p><h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><p>垃圾收集算法是内存回收的方法论，垃圾收集器就是内存回收的具体实现。<br>这里讨论JDK 1.7 Update 14之后的HotSpot虚拟机（此时G1仍处于实验状态），包含的虚拟机如下图所示（存在连线的表示可以搭配使用）：</p><p><img src="https://ws1.sinaimg.cn/large/005DnJLEly1fp5hg0ke6qj30el0dt75o.jpg" alt=""></p><h3 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h3><p><img src="https://ws1.sinaimg.cn/large/005DnJLEly1fp5hg21nftj30pm05jgmv.jpg" alt=""></p><ul><li>最基本、发展历史最悠久，在JDK 1.3之前是新生代收集的唯一选择；</li><li>是一个单线程（并非指一个收集线程，而是会暂停所有工作线程）的收集器，采用的是复制算法；</li><li>现在依然是虚拟机运行在Client模式下的默认新生代收集器，主要就是因为它简单而高效（没有线程交互的开销）；</li></ul><h4 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h4><p><img src="https://ws1.sinaimg.cn/large/005DnJLEly1fp5hg1ygpnj30r005idha.jpg" alt=""></p><ul><li>其实就是Serial收集器的多线程版本；</li><li>ParNew收集器在单CPU环境中绝对不会有比Serial收集器更好的效果；</li><li>是许多运行在Server模式下虚拟机首选的新生代收集器，重要原因就是除了Serial收集器外，只有它能与CMS收集器配合工作；</li><li>并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态；</li><li>并发（Concurrent）：指用户线程与垃圾收集线程同时执行，用户线程在继续执行而垃圾收集程序运行在另外一个CPU上；</li></ul><h4 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h4><ul><li>新生代收集器，使用复制算法，并行的多线程收集器；</li><li>与其他收集器关注于尽可能缩短垃圾收集时用户线程停顿时间不同，它的目标是达到一个可控制的吞吐量；</li><li>高吞吐量可以高效率利用CPU时间，适合在后台运算而不需要太多交互的任务；</li><li>-XX:MaxGCPauseMillis参数可以设置最大停顿时间，而停顿时间缩短是以牺牲吞吐量和新生代空间来换取的；</li><li>另外它还支持GC自适应的调节策略；</li></ul><h4 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h4><p><img src="https://ws1.sinaimg.cn/large/005DnJLEly1fp5hg21nftj30pm05jgmv.jpg" alt=""></p><ul><li>是Serial收集器的老年代版本，同样是单线程，使用标记-整理算法；</li><li>主要是给Client模式下的虚拟机使用的；</li><li>在Server模式下主要是给JDK 1.5及之前配合Parallel Scavenge使用或作为CMS收集器的后备预案；</li></ul><h4 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h4><p><img src="https://ws1.sinaimg.cn/large/005DnJLEly1fp5hg5t46ej30pr05o3zy.jpg" alt=""></p><ul><li>是Parallel Scavenge的老年代版本，使用多线程和标记-整理算法；</li><li>是JDK 1.6中才开始提供的；</li></ul><h4 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h4><p><img src="https://ws1.sinaimg.cn/large/005DnJLEly1fp5hg42u69j30qi05omz2.jpg" alt=""></p><ul><li>是一种以获取最短回收停顿时间为目标的收集器，特别适合互联网站或者B/S的服务端；</li><li>它是基于标记-清除 算法实现的，主要包括4个步骤：初始标记（STW，只是初始标记一下GC Roots能直接关联到的对象，速度很快）、并发标记（非STW，执行GC RootsTracing，耗时比较长）、重新标记（STW，修正并发标记期间因用户程序继续导致变动的那一部分对象标记）和并发清除（非STW，耗时较长）；</li><li>还有3个明显的缺点：CMS收集器对CPU非常敏感（占用部分线程及CPU资源，影响总吞吐量）、无法处理浮动垃圾（默认达到92%就触发垃圾回收）、大量内存碎片产生（可以通过参数启动压缩）；</li></ul><h4 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h4><p><img src="https://ws1.sinaimg.cn/large/005DnJLEly1fp5hg3af3bj30p905g40q.jpg" alt=""></p><ul><li>一款面向服务端应用的垃圾收集器，后续会替换掉CMS垃圾收集器；</li><li>特点：并行与并发（充分利用多核多CPU缩短Stop-The-World时间）、分代收集（独立管理整个Java堆，但针对不同年龄的对象采取不同的策略）、空间整合（基于标记-整理）、可预测的停顿（将堆分为大小相等的独立区域，避免全区域的垃圾收集）；</li><li>关于Region：新生代和老年代不再物理隔离，只是部分Region的集合；G1跟踪各个Region垃圾堆积的价值大小，在后台维护一个优先列表，根据允许的收集时间优先回收价值最大的Region；Region之间的对象引用以及其他收集器中的新生代与老年代之间的对象引用，采用Remembered Set来避免全堆扫描；</li><li>分为几个步骤：初始标记（标记一下GC Roots能直接关联的对象并修改TAMS值，需要STW但耗时很短）、并发标记（从GC Root从堆中对象进行可达性分析找存活的对象，耗时较长但可以与用户线程并发执行）、最终标记（为了修正并发标记期间产生变动的那一部分标记记录，这一期间的变化记录在Remembered Set Log里，然后合并到Remembered Set里，该阶段需要STW但是可并行执行）、筛选回收（对各个Region回收价值排序，根据用户期望的GC停顿时间制定回收计划来回收）；</li></ul><h4 id="理解GC日志"><a href="#理解GC日志" class="headerlink" title="理解GC日志"></a>理解GC日志</h4><p><img src="https://ws1.sinaimg.cn/large/005DnJLEly1fp5hpklzkhj30x303s3yn.jpg" alt=""></p><ul><li>最前面的数字代表GC发生的时间（虚拟机启动以后的秒杀）；</li><li>“[GC”和“[Full GC”说明停顿类型，有Full代表的是Stop-The-World的；</li><li>“[DefNew”、“[Tenured”和“[Perm”表示GC发生的区域；</li><li>方括号内部的“3324K -&gt; 152K(3712K)” 含义是 “GC前该内存已使用容量 -&gt; GC后该内存区域已使用容量(该区域总容量)”;</li><li>方括号之外的“3324K -&gt; 152K(11904)” 含义是 “GC前Java堆已使用容量 -&gt; GC后Java堆已使用容量(Java堆总容量)”;</li><li>再往后“0.0025925 secs”表示该内存区域GC所占用的时间；</li></ul><h4 id="垃圾收集器参数总结"><a href="#垃圾收集器参数总结" class="headerlink" title="垃圾收集器参数总结"></a>垃圾收集器参数总结</h4><p><img src="https://ws1.sinaimg.cn/large/005DnJLEly1fp5hqutlicj30rs0g5wmc.jpg" alt=""><br><img src="https://ws1.sinaimg.cn/large/005DnJLEly1fp5hr56tv9j30rs087adj.jpg" alt=""></p><h4 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h4><ul><li>对象优先在新生代分配</li><li>大对象直接进入老年代</li><li>长期存活的对象将进入老年代</li><li>动态对象年龄判断：如果在Survivor空间中相同年龄所有对象大小总和大于Survivor空间的一半，大于或等于该年龄的对象直接进入老年代；</li><li>空间分配担保：发生Minor GC前，虚拟机会先检查老年代最大可用连续空间是否大于新生代所有对象总空间，如果不成立，虚拟机会查看HandlePromotionFailure设置值是否允许担保失败，如果允许继续检查老年代最大可用的连续空间是否大于历次晋升到老年代的平均大小，如果大于会尝试进行一次Minor GC；如果小于或者不允许冒险，会进行一次Full GC；</li></ul><h3 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h3><p>本章介绍了垃圾回收算法、几款JDK 1.7中提供的垃圾收集器特点以及运作原理。内存回收与垃圾收集器在很多时候都是影响系统性能、并发能力的主要因素之一，然而没有固定收集器和参数组合，也没有最优的调优方法，需要根据实践了解各自的行为、优势和劣势。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;第三章-垃圾收集器与内存分配策略&quot;&gt;&lt;a href=&quot;#第三章-垃圾收集器与内存分配策略&quot; class=&quot;headerlink&quot; title=&quot;第三章 垃圾收集器与内存分配策略&quot;&gt;&lt;/a&gt;第三章 垃圾收集器与内存分配策略&lt;/h2&gt;&lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;思考GC需要完成的3件事情：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;哪些内存需要回收？&lt;/li&gt;
&lt;li&gt;什么时候回收？&lt;/li&gt;
&lt;li&gt;如何回收？&lt;br&gt;再回头看看第二章介绍的Java内存运行时区域的各个部分：&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="JVM" scheme="https://caoler.cn/categories/JVM/"/>
    
    
      <category term="JVM" scheme="https://caoler.cn/tags/JVM/"/>
    
      <category term="读书笔记" scheme="https://caoler.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>一个小程序员的2017年年度总结</title>
    <link href="https://caoler.cn//post/2018/summary_for_2017.html"/>
    <id>https://caoler.cn//post/2018/summary_for_2017.html</id>
    <published>2018-01-24T03:03:24.000Z</published>
    <updated>2018-01-24T03:22:02.181Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一个小程序员2017年的进步、收获与成长。"><a href="#一个小程序员2017年的进步、收获与成长。" class="headerlink" title="一个小程序员2017年的进步、收获与成长。"></a>一个小程序员2017年的进步、收获与成长。</h3><p>今天是腊八，新历新年已经过去了两个月。在很早之前就打算写一篇年终总结，但是因为考试一直拖延。放假之后愉快的玩♂耍了一周 决定在这个安静的早晨动笔写起。</p><p>2017年是上大学以来最有收获的一年，大概学习了一整个JavaWeb的框架部分，而且还通过参加服务外包比赛让自己的学习成功付诸实现，虽然和组里的DB、HJ比起来自己的实力和别人还有不小差距。但是作为一个容易满足的人，我的2017也算是很完美了。</p><a id="more"></a><h3 id="回顾总结与展望"><a href="#回顾总结与展望" class="headerlink" title="回顾总结与展望"></a>回顾总结与展望</h3><h4 id="学习部分"><a href="#学习部分" class="headerlink" title="学习部分"></a>学习部分</h4><ol><li>学习Spring，刚开学的三月份翻起Spring的教程，从头至尾学习了一遍。</li><li>Hibernate初体验，当时学习的目标就是SSH框架，所以在Spring学习结束之后就直接开始学习Hibernate了。了解到了一个很方便很牛逼的技能–<a href="http://blog.csdn.net/qq_34197553/article/details/77718925" target="_blank" rel="external">IntelliJ IDEA下自动生成Hibernate映射文件以及实体类</a></li><li>遇到了一个国产轻量级的框架——JFinal，一个小提问还得到了框架作者(波总)的回复 <a href="https://www.oschina.net/question/3479290_2245223" target="_blank" rel="external">点我查看</a> 但是问题到现在都没有解决。头晕</li><li>7月，大二的学习生活结束，留校参加了第八届服务外包比赛，用了半个月的时间学习了MyBatis。虽然这个框架学习的时间很短，但是我觉的这个框架是自己吃的最透的一个（其中一部分原因是时间紧迫做项目马上就要用到，逃~）当时用到的几个好工具：<ul><li><a href="http://blog.csdn.net/baidu_32877851/article/details/53959268" target="_blank" rel="external">代码生成器Generator</a></li><li><a href="https://gitee.com/free/Mybatis_PageHelper" target="_blank" rel="external">MyBatis的分页插件–MyBaits_PageHelper</a></li><li><a href="http://baomidou.oschina.io/mybatis-plus-doc/#/" target="_blank" rel="external">MyBatisPlus</a></li></ul></li><li>新学期，再学Spring，这次的学习一部分是为了回顾，另一部分是为了之后的SpringMVC做准备。这次的学习时间比较仓促，也只用了不到半个月，对控制反转IOC 依赖注入DI 面向切面编程有了更深入的了解，跟第一次的学习比较起来收获更大。</li><li>SpringMVC的学习。一直到9月26日，SSM框架整合完毕。框架部分的学习也算告一段落。</li><li>10月，我接触了一部分前端的知识。包括JavaScriptDOM、jQuery，但是这部分的学习学的比较潦草，跟读书一样 只能称作是泛读。</li><li>精读《图解HTTP》，插画风格的书阅读起来很轻松，也很容易理解，虽然书的内容很少，但是我了解了网络协议的传输过程，手里还有一本《图解TCP/IP》也打算好好啃一啃。</li><li>阅读《Core Java》，大一下对JAVASE部分的学习实在是太粗略了，在学习JAVAWEB部分的时候我甚至不知道泛型、迭代器、集合、map。学习《Core Java》这段时间学习很多，以前似懂非懂的东西那段时间里都得到了解决。对Java集合框架部分的内容进行了深入的研究，用四个字来表达，那就是收获颇多！</li><li>JAVA并发编程的学习，这段时间 我一改以前的看视频学习方法，转为看博客，看书。一直通过<a href="http://ifeve.com/" target="_blank" rel="external">并发编程网</a>来进行学习，同时也借鉴了不少博客的内容，包括CSDN 博客园。</li><li>阅读《JAVA并发编程的艺术》《深入理解JVM》，第五部分的内容也就是之前学的并发部分的内容，我的侧重点是第二章和第三章，还没开始看，希望通过这本书我能够深入的了解JAVA内存模型和它的垃圾回收机制。</li><li>做项目之前，学习了Git，项目的过程中和DB同学进行了深入的交♂流。对Git的协作开发有了一定的认识和理解。</li><li>升级了自己的IDE，由之前的Eclipse到现在的IntelliJ IDEA，编程环境更舒适了，代码写作的效率也变高了。</li><li>学习了通过MAVEN编程，抛弃了之前导包的过程，使开发更加方便轻松。</li><li>适应了MarkDown的写作，基本丢弃了以前Word的写作方式，也算是一个进步.</li></ol><p>emmm..学习部分就这些。想到了再补充。</p><h4 id="生活部分"><a href="#生活部分" class="headerlink" title="生活部分"></a>生活部分</h4><ol><li><p>最有成就的就是拿到了驾照，虽然前前后后花了快一年的时间，但是拿到证的那一刻还是非常开心的哈哈哈哈(即使照片其丑无比！！！垃圾摄影师)。下面下面：<br> <img src="https://ws1.sinaimg.cn/large/005DnJLEly1fnrh7pj5xcj30uo0h9gq1.jpg" alt=""></p></li><li><p>认识了我的两个好好好朋友FJY,AYS。<br><img src="https://ws1.sinaimg.cn/large/005DnJLEly1fnrhqcc0evj30qo0qojtn.jpg" alt=""></p></li><li><p>这一年没有经常去外面玩，除了端午节去长沙玩的几天。但是吃了无数次小龙坎 刘一手！最好吃的还算长沙吃的井格。<br><img src="https://ws1.sinaimg.cn/large/005DnJLEly1fnrhr7yo6yj31400u042k.jpg" alt=""></p></li><li><p>看了17年所有自己想看的电影，没有遗憾！（照片没拍，我觉得有二三十张）</p></li><li><p>去夜店蹦迪，去酒吧喝到失去知觉，体验了以前没有体验到的东西。<br><img src="https://ws1.sinaimg.cn/large/005DnJLEly1fnrhswxzm8j30u0140acb.jpg" alt=""></p></li><li><p>平时还有不菲的收入，除了必要的生活费没有向父母额外多要一分钱，我很自豪。</p></li><li><p>和几千人一起跨年！！！<br><img src="https://ws1.sinaimg.cn/large/005DnJLEly1fnrhtt935oj32io1w0npd.jpg" alt=""></p></li><li><p>生活很规律，每天都有吃早饭，除了玩每天12点前睡觉，喝水很多，也很爱喝水。</p></li><li><p>养了三只小乌龟，其中一个跳楼了。还有三颗富贵竹，希望寒假这段时间不要被冻死。</p></li><li><p>还有就是以前念想的博客，我也按照自己喜欢的风格搭建好了，每一篇学习记录我也都会在这里坚持写下来！–<a href="https://caoler.cn">Caole’s Blog</a></p></li></ol><h4 id="遗憾"><a href="#遗憾" class="headerlink" title="遗憾"></a>遗憾</h4><ol><li>CET-4！！！！！头晕</li><li>没有找到女朋友！！</li></ol><p>我自己很感谢这些点点滴滴的积累带来的变化，并且坚信在新的一年会变得更好。<br><img src="https://ws1.sinaimg.cn/large/005DnJLEly1fnrj68gv66j30ih0rhabd.jpg" alt=""><br>为了自拍专门下载的相机哈哈！！</p><p>知乎：<a href="https://www.zhihu.com/question/263416941/answer/302598812" target="_blank" rel="external">https://www.zhihu.com/question/263416941/answer/302598812</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一个小程序员2017年的进步、收获与成长。&quot;&gt;&lt;a href=&quot;#一个小程序员2017年的进步、收获与成长。&quot; class=&quot;headerlink&quot; title=&quot;一个小程序员2017年的进步、收获与成长。&quot;&gt;&lt;/a&gt;一个小程序员2017年的进步、收获与成长。&lt;/h3&gt;&lt;p&gt;今天是腊八，新历新年已经过去了两个月。在很早之前就打算写一篇年终总结，但是因为考试一直拖延。放假之后愉快的玩♂耍了一周 决定在这个安静的早晨动笔写起。&lt;/p&gt;
&lt;p&gt;2017年是上大学以来最有收获的一年，大概学习了一整个JavaWeb的框架部分，而且还通过参加服务外包比赛让自己的学习成功付诸实现，虽然和组里的DB、HJ比起来自己的实力和别人还有不小差距。但是作为一个容易满足的人，我的2017也算是很完美了。&lt;/p&gt;
    
    </summary>
    
      <category term="CodingLife" scheme="https://caoler.cn/categories/CodingLife/"/>
    
    
      <category term="CodingLife" scheme="https://caoler.cn/tags/CodingLife/"/>
    
  </entry>
  
  <entry>
    <title>《深入理解Java虚拟机》读书笔记1 - Java技术体系、Java内存区域和内存溢出异常</title>
    <link href="https://caoler.cn//post/2017/deep-in-jvm-part1.html"/>
    <id>https://caoler.cn//post/2017/deep-in-jvm-part1.html</id>
    <published>2017-12-01T08:18:22.000Z</published>
    <updated>2018-03-07T12:29:11.125Z</updated>
    
    <content type="html"><![CDATA[<p>世界上并没有完美的程序，但我们并不因此而沮丧，因为写程序本来就是一个不断追求完美的过程。</p><p>笔记第一部分对应原书的第一章，主要介绍了Java的技术体系、Java虚拟机的发展历史。第二部分对应原书的第二章，主要介绍了Java运行时区域的划分、对象的创建和访问以及内存溢出的实战。</p><a id="more"></a><h1 id="Part-1-走进Java"><a href="#Part-1-走进Java" class="headerlink" title="Part 1: 走进Java"></a>Part 1: 走进Java</h1><h2 id="第一章-走进Java"><a href="#第一章-走进Java" class="headerlink" title="第一章 走进Java"></a>第一章 走进Java</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Java的优点</p><ul><li>结构严谨、面向对象</li><li>摆脱平台的束缚，一次编写到处运行</li><li>提供了相对安全的内存管理和访问机制</li><li>实现了热点代码检测和运行时编译及优化</li><li>一套完善的应用程序接口以及无数的第三方类库</li></ul><h3 id="Java技术体系"><a href="#Java技术体系" class="headerlink" title="Java技术体系"></a>Java技术体系</h3><p>Sun官方所定义的Java技术体系包括：</p><ul><li>Java程序设计语言</li><li>各种硬件平台上的Java虚拟机</li><li>Class文件格式</li><li>Java API类库</li><li>来自商业机构和开源社区的第三方Java类库<br>JDK是用于支持Java开发的最小环境，JRE是支持Java程序运行的标准环境，整个Java体系如下所示：<br><img src="https://ws1.sinaimg.cn/large/005DnJLEgy1fm1c7gqhv6j30nt0e6dkt.jpg" alt=""></li></ul><h3 id="Java发展史"><a href="#Java发展史" class="headerlink" title="Java发展史"></a>Java发展史</h3><p><img src="https://ws1.sinaimg.cn/large/005DnJLEgy1fm1c7x19lnj30ps09mjt7.jpg" alt=""></p><ul><li>JDK 1.0: Java虚拟机、Applet、AWT等；</li><li>JDK 1.1：JAR文件格式、JDBC、JavaBeans、RMI、内部类、反射；</li><li>JDK 1.2：拆分为J2SE/J2EE/J2ME、内置JIT编译器、一系列Collections集合类；</li><li>JDK 1.3：JNDI服务、使用CORBA IIOP实现RMI通信协议、Java 2D改进；</li><li>JDK 1.4：正则表达式、异常链、NIO、日志类、XML解析器和XSLT转换器；</li><li>JDK 1.5：自动装箱、泛型、动态注解、枚举、可变参数、遍历循环、改进了Java内存模型、提供了java.util.concurrent并发包；</li><li>JDK 1.6：提供动态语言支持、提供编译API和微型HTTP服务器API、虚拟机优化（锁与同步、垃圾收集、类加载等）；</li><li>JDK 1.7：G1收集器、加强对Java语言的调用支持、升级类加载架构；</li><li>JDK 1.8：Lambda表达式等；</li></ul><h3 id="Java虚拟机发展史"><a href="#Java虚拟机发展史" class="headerlink" title="Java虚拟机发展史"></a>Java虚拟机发展史</h3><ul><li>Sun Classic/Exact VM：Classic VM是第一款商用虚拟机，纯解析器方式来执行Java代码，如果要使用JIT编译器就必须进行外挂，解析器和编译器不能配合工作，编译器执行效率非常差；Exact VM是Sun虚拟机团队曾在Solaris平台发布的虚拟机，支持两级即时编译器、编译器和解释器混合工作、使用准确内存管理（虚拟机可以知道内存中某个位置的数据具体是什么类型），但很快就被HotSpot VM所取代；</li><li>Sun HotSpot VM：Sun JDK和OpenJDK所带的虚拟机，目前使用范围最广；继承了前两款虚拟机的优点，还支持热点代码探测技术（通过计数器找出最具编译价值的代码）；2006年Sun公司宣布JDK包括HotSpot VM开源，在此基础上建立OpenJDK；</li><li>Sun Mobile-Embedded VM/Meta-Circular VM：还有一些Sun开发的面对移动和嵌入式发布的和实验性质的虚拟机；</li><li>BEA JRockit/IBM J9 VM：JRockit VM号称是世界上最快的Java虚拟机，专注于服务器端应用，不包含解析器实现，全部靠即时编译器编译执行；J9 VM定位于HotSpot比较接近，主要目的是作为IBM公司各种Java产品的执行平台；</li><li>Azul VM/BEA Liquid VM：特定硬件平台专有的高性能虚拟机；</li><li>Apache Harmony/Google Android Dalvik VM：Apache Harmony包含自己的虚拟机和Java库，但没有通过TCK认证；Dalvik VM是Android平台的核心组成部分，其并没有遵循Java虚拟机规范，不能直接执行Class文件，使用的是寄存器架构而不是JVM常见的栈架构；</li><li>Microsoft JVM及其他：微软曾经是Java技术的铁杆支持者，开发过Windows下性能最好的Java虚拟机，但后来被Sun起诉终止其发展；</li></ul><h3 id="展望Java技术的未来"><a href="#展望Java技术的未来" class="headerlink" title="展望Java技术的未来"></a>展望Java技术的未来</h3><ul><li>模块化</li><li>混合语言</li><li>多核并行</li><li>进一步丰富语法</li><li>64位虚拟机</li></ul><h3 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h3><p>本章介绍了Java技术体系的过去、现在以及未来的一些发展趋势，并独立编译一个OpenJDK 7的版本。</p><h1 id="Part-2-自动内存管理机制"><a href="#Part-2-自动内存管理机制" class="headerlink" title="Part 2:自动内存管理机制"></a>Part 2:自动内存管理机制</h1><h2 id="第二章-Java内存区域与内存溢出异常"><a href="#第二章-Java内存区域与内存溢出异常" class="headerlink" title="第二章 Java内存区域与内存溢出异常"></a>第二章 Java内存区域与内存溢出异常</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>对于JAVA程序员，在虚拟机自动内存管理机制下，不需要为new操作去写配对的delete/free代码，不容易出现内存泄漏。但是如果出现内存泄漏问题，如果不了解虚拟机的机制，便难以定位。</p><h3 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h3><p><img src="https://ws1.sinaimg.cn/large/005DnJLEgy1fm1c863056j30em0bhtar.jpg" alt=""></p><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><ul><li>一块较小的内存，可以看作是当前线程所执行的字节码的行号指示器；</li><li>在虚拟机概念模型（各种虚拟机实现可能不一样）中，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令；</li><li>程序计数器是属于线程私有的内存；</li><li>如果执行的是Java方法，该计数器记录的是正在执行的虚拟机字节码指令的地址；如果是Native方法则为空；</li></ul><h4 id="JAVA虚拟机栈"><a href="#JAVA虚拟机栈" class="headerlink" title="JAVA虚拟机栈"></a>JAVA虚拟机栈</h4><ul><li>Java虚拟机栈也是线程私有的；</li><li>描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机中入栈到出栈的过程；</li><li>局部变量表存放了编译器可知的各种基本数据类型(int、double…)、对象引用和returnAddress类型；其所需的内存空间在编辑期完成分配，不会再运行期改变；<br>可能存在两种异常：StackOverflowError（栈深度大于所允许深度）和OutOfMemoryError（无法申请到足够的内存时）；</li></ul><h4 id="JAVA堆"><a href="#JAVA堆" class="headerlink" title="JAVA堆"></a>JAVA堆</h4><ul><li>JAVA堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。</li><li>这里的主要目的就是存放对象和实例，几乎所有的对象实例都在这里分配内存。</li><li>JAVA堆是垃圾收集器管理的主要区域，而且还可以细分为新生代和老年代。</li><li>JAVA堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。</li><li>在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutofMemoryError异常。</li></ul><h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><ul><li>是线程共享的区域；</li><li>用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据；</li><li>该区域对于垃圾收集来说条件比较苛刻，但是还是非常有必要要进行回收处理，回收目标主要是针对常量池的回收和对类型的卸载；</li><li>当无法满足内存分配需求时，将抛出OutOfMemoryError异常；<h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4></li><li>是方法区的一部分；</li><li>Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译器生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放；</li><li>Java虚拟机规范要求较少，通常还会把翻译出来的直接引用也存储在此；</li><li>另外一个重要特征是具备动态性，可以在运行期间将新的常量放入池中，如String的intern方法；</li><li>可能存在的异常：OutOfMemoryError；<h4 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h4></li><li>并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域；</li><li>JDK 1.4的NIO引入了基于通道（Channel）和缓冲区（Buffer）的IO方法，可以使用Native函数库直接分配对外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作以提升性能；</li></ul><h3 id="HotSpot虚拟机对象探秘"><a href="#HotSpot虚拟机对象探秘" class="headerlink" title="HotSpot虚拟机对象探秘"></a>HotSpot虚拟机对象探秘</h3><p>进一步了解虚拟机内存中数据的其他细节，比如它们是如何创建、如何布局以及如何访问的。下面以虚拟机HotSpot和常用的内存区域Java堆为例，深入探讨HotSpot虚拟机在Java堆中对象分配、布局和访问的全过程。</p><h4 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h4><ol><li>虚拟机遇到一条new指令时，先检查指令的参数是否能在常量池中定位到一个类的符号，并且检查这个符号引用代码的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程；</li><li>接下来虚拟机将为新生对象分配内存。对象所需的内存大小在类加载完成后便完全确定，为对象分配空间等同于把一块确定大小的内存从Java堆中划分出来。在使用Serial、ParNew等带Compact过程的收集器时，系统采用的分配算法是指针碰撞（内存绝对规整，只要通过指针作为分界点标识）；而使用CMS这种基于Mark-Sweep算法收集器时，通常使用空闲列表（内存不规整，通过维护一个列表记录那块内存是可用的）；</li><li>另外一个需要考虑的并发下的线程安全问题，有两种方案：一是分配内存空间的动作进行同步处理（实际上虚拟机采用CAS配上失败重试的方式保证更新操作的原子性）；二是为每个线程分配一小块内存（称为本地线程分配缓冲，TLAB），各个线程独立分配，只有TLAB用完需要分配新的才需要同步锁定，虚拟机通过-XX:+/-UseTLAB参数来设定；<br>内存分配完后，虚拟机将分配到的内存空间都初始化为零值（不包括对象头），这保证了对象的实例字段在Java代码中可以不赋值就直接使用，程序能访问到这些字段数据类型对应的零值；</li><li>接下来设置对象的对象头（Object Header）信息，包括对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象GC分代年龄等；</li><li>接着执行方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来；</li><li>HotSpot解释器的代码片段：略<h4 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h4></li></ol><ul><li>对象在内存中存储的布局可以分为3块区域：对象头（Object Header）、实例数据（Instance Data）和对齐填充（Padding）；<br>对象头包括两部分信息：第一部分用于存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等；另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例（并不是所有虚拟机都必须在对象数据上保留类型指针）。另外如果对象是一个Java数组，对象头中还必须有一块用于记录数组长度的数据。</li><li>实例数据部分是真正存储的有效信息，也是在代码中所定义的各种类型字段内容。无论是父类继承的还是子类中定义的都需要记录下来。这部分存储的顺序会受到虚拟机分配策略参数和字段在Java源码中定义顺序的影响。</li><li>对齐填充不是必然存在的，主要是由于HotSpot </li><li>VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍。<h4 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h4></li><li>栈上的reference类型在虚拟机规范中只规定了一个指向对象的引用，并没有定义这个引用应该通过何种方式去定位、访问堆栈对象的具体位置，目前主流的方式方式有句柄和直接直接两种。</li><li><p>通过句柄：Java堆中划出一块内存作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。其最大好处就是reference存储的是稳定的句柄地址，在对象被移到（垃圾收集时移到）只改变实例数据指针，而reference不需要修改；</p></li><li><p><img src="https://ws1.sinaimg.cn/large/005DnJLEly1fp4gn2h74pj30lv09ymyx.jpg" alt=""></p></li><li><p>通过直接指针：Java堆对象的布局中必须考虑如果放置访问类型数据的相关信息，而reference中存在的直接就是对象地址。其最大好处在于速度更快，节省了一次指针定位的时机开销。HotSpot采用该方式进行对象访问，但其他语言和框架采用句柄的也非常常见。</p></li></ul><p><img src="https://ws1.sinaimg.cn/large/005DnJLEly1fp4go1uhbuj30mu09twg2.jpg" alt=""></p><h3 id="实战：OutOfMemoryError异常"><a href="#实战：OutOfMemoryError异常" class="headerlink" title="实战：OutOfMemoryError异常"></a>实战：OutOfMemoryError异常</h3><ul><li>通过代码验证Java虚拟机规范中描述各个运行时区域存储的内容；</li><li>在实际遇到内存溢出异常时，能根据异常的信息快速判断是哪个区域内存溢出；<h4 id="Java堆溢出"><a href="#Java堆溢出" class="headerlink" title="Java堆溢出"></a>Java堆溢出</h4></li></ul><p><img src="https://ws1.sinaimg.cn/large/005DnJLEly1fp4gpop763j30jc0d0mxm.jpg" alt=""><br>解决思路：先通过内存映像分析工具对dump出来的堆转储快照进行分析，先分清楚是内存泄漏还是内存溢出；如果是内存泄漏，进一步查看泄漏对象到GC Roots的引用链，从而确认为什么无法回收；如果是内存溢出，则应当检查虚拟机堆参数（-Xmx与-Xmx）或检查是否存在对象生命周期过长、持有状态时间过长的情况；</p><h4 id="虚拟机栈和本地方法栈溢出"><a href="#虚拟机栈和本地方法栈溢出" class="headerlink" title="虚拟机栈和本地方法栈溢出"></a>虚拟机栈和本地方法栈溢出</h4><ul><li>HotSpot不区分虚拟机栈和本地方法栈；</li><li>StackOverflowError和OutOfMemoryError存在互相重叠的地方；<br>栈容量由-Xss参数设定；</li></ul><p><img src="https://ws1.sinaimg.cn/large/005DnJLEly1fp4gqkuwx7j30jw0j9t9w.jpg" alt=""><br>虚拟机的默认参数对于通常的方法调用（1000~2000层）完全够用，通常根据异常的堆栈日志就可以很容易定位问题。</p><h4 id="方法区和运行时常量池溢出"><a href="#方法区和运行时常量池溢出" class="headerlink" title="方法区和运行时常量池溢出"></a>方法区和运行时常量池溢出</h4><p>对于这个区域的测试，基本思路是运行时产生大量的类去填满方法区（比如使用反射和动态代理），这里我们借助CGLib直接操作字节码运行时产生大量的动态类（很对主流框架如Spring、Hibernate都会采用类似的字节码技术）。在这里需要特别注意垃圾回收的状况。<br><img src="https://ws1.sinaimg.cn/large/005DnJLEly1fp4grjfqt6j30vy05jq33.jpg" alt=""></p><p><img src="https://ws1.sinaimg.cn/large/005DnJLEly1fp4gs11oazj30vy0ffmy2.jpg" alt=""></p><h4 id="本机直接内存溢出"><a href="#本机直接内存溢出" class="headerlink" title="本机直接内存溢出"></a>本机直接内存溢出</h4><p><img src="https://ws1.sinaimg.cn/large/005DnJLEly1fp4gstzep0j30m80badgg.jpg" alt=""></p><p><img src="https://ws1.sinaimg.cn/large/005DnJLEly1fp4gtcldwmj30m8025aa2.jpg" alt=""><br>DirectMemory导致的内存溢出，在Heap Dump里不会看见明显的异常。如果发现OouOfMemory之后Dump文件很小，程序又使用了NIO，那就可以检查下是否这方面的原因。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;世界上并没有完美的程序，但我们并不因此而沮丧，因为写程序本来就是一个不断追求完美的过程。&lt;/p&gt;
&lt;p&gt;笔记第一部分对应原书的第一章，主要介绍了Java的技术体系、Java虚拟机的发展历史。第二部分对应原书的第二章，主要介绍了Java运行时区域的划分、对象的创建和访问以及内存溢出的实战。&lt;/p&gt;
    
    </summary>
    
      <category term="JVM" scheme="https://caoler.cn/categories/JVM/"/>
    
    
      <category term="JVM" scheme="https://caoler.cn/tags/JVM/"/>
    
      <category term="读书笔记" scheme="https://caoler.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>有趣</title>
    <link href="https://caoler.cn//post/2017/goole-birthday.html"/>
    <id>https://caoler.cn//post/2017/goole-birthday.html</id>
    <published>2017-11-29T03:48:43.000Z</published>
    <updated>2017-11-29T03:50:32.940Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws1.sinaimg.cn/large/005DnJLEly1flytamyqqvj30j30aw74l.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/005DnJLEly1flytamyqqvj30j30aw74l.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="CodingLife" scheme="https://caoler.cn/categories/CodingLife/"/>
    
    
      <category term="CodingLife" scheme="https://caoler.cn/tags/CodingLife/"/>
    
  </entry>
  
  <entry>
    <title>join()方法和TheadLocal类</title>
    <link href="https://caoler.cn//post/2017/join-and-threadlocal.html"/>
    <id>https://caoler.cn//post/2017/join-and-threadlocal.html</id>
    <published>2017-11-27T05:37:00.000Z</published>
    <updated>2017-11-28T05:37:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Thread-join"><a href="#Thread-join" class="headerlink" title="Thread.join()"></a>Thread.join()</h1><h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><figure class="highlight pony"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> t = <span class="function"><span class="keyword">new</span> <span class="title">AThread</span>();</span></span><br><span class="line"><span class="function"><span class="title">t</span>.<span class="title">start</span>();</span></span><br><span class="line"><span class="function"><span class="title">t</span>.<span class="title">join</span>();</span></span><br></pre></td></tr></table></figure><h2 id="为什么要用join-方法"><a href="#为什么要用join-方法" class="headerlink" title="为什么要用join()方法"></a>为什么要用join()方法</h2><p>在很多情况下，主线程生成并起动了子线程，如果子线程里要进行大量的耗时的运算，主线程往往将于子线程之前结束，但是如果主线程处理完其他的事务后，需要用到子线程的处理结果，也就是主线程需要等待子线程执行完成之后再结束，这个时候就要用到join()方法了。</p><h2 id="join方法的作用"><a href="#join方法的作用" class="headerlink" title="join方法的作用"></a>join方法的作用</h2><p>JDK中对join方法解释为：“等待该线程终止”，换句话说就是：”当前线程等待子线程的终止“。也就是在子线程调用了join()方法后面的代码，只有等到子线程结束了当前线程才能执行。</p><h2 id="用实例来理解"><a href="#用实例来理解" class="headerlink" title="用实例来理解"></a>用实例来理解</h2><ol><li>简单了解join()的用法：</li></ol><a id="more"></a><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BThread</span> <span class="title">extends</span> <span class="title">Thread</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BThread</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">        super(<span class="string">"[BThread] Thread"</span>);  </span><br><span class="line">    &#125;;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">        String threadName = Thread.currentThread().getName();  </span><br><span class="line">        System.<span class="keyword">out</span>.println(threadName + <span class="string">" start."</span>);  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;  </span><br><span class="line">                System.<span class="keyword">out</span>.println(threadName + <span class="string">" loop at "</span> + i);  </span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);  </span><br><span class="line">            &#125;  </span><br><span class="line">            System.<span class="keyword">out</span>.println(threadName + <span class="string">" end."</span>);  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"Exception from "</span> + threadName + <span class="string">".run"</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AThread</span> <span class="title">extends</span> <span class="title">Thread</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    BThread bt;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AThread</span>(<span class="params">BThread bt</span>) </span>&#123;  </span><br><span class="line">        super(<span class="string">"[AThread] Thread"</span>);  </span><br><span class="line">        <span class="keyword">this</span>.bt = bt;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">        String threadName = Thread.currentThread().getName();  </span><br><span class="line">        System.<span class="keyword">out</span>.println(threadName + <span class="string">" start."</span>);  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            bt.<span class="keyword">join</span>();  </span><br><span class="line">            System.<span class="keyword">out</span>.println(threadName + <span class="string">" end."</span>);  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"Exception from "</span> + threadName + <span class="string">".run"</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestDemo</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;  </span><br><span class="line">        String threadName = Thread.currentThread().getName();  </span><br><span class="line">        System.<span class="keyword">out</span>.println(threadName + <span class="string">" start."</span>);  </span><br><span class="line">        BThread bt = <span class="keyword">new</span> BThread();  </span><br><span class="line">        AThread at = <span class="keyword">new</span> AThread(bt);  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            bt.start();  </span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);  </span><br><span class="line">            at.start();  </span><br><span class="line">            at.<span class="keyword">join</span>();  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"Exception from main"</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        System.<span class="keyword">out</span>.println(threadName + <span class="string">" end!"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">main start.                  <span class="comment">-- 主线程启动, 因为主线程中调用了at.join(), 所以主线程要等到 AThread线程结束之后才能执行  </span></span><br><span class="line">[BThread] <span class="keyword">Thread</span> start.  </span><br><span class="line">[BThread] <span class="keyword">Thread</span> <span class="keyword">loop</span> <span class="keyword">at</span> <span class="number">0</span>  </span><br><span class="line">[BThread] <span class="keyword">Thread</span> <span class="keyword">loop</span> <span class="keyword">at</span> <span class="number">1</span>  </span><br><span class="line">[AThread] <span class="keyword">Thread</span> start.      <span class="comment">-- AThread线程启动, 因为AThread线程中调用了bt.join(), 所以AThread线程要等到BThread线程结束之后才能执行  </span></span><br><span class="line">[BThread] <span class="keyword">Thread</span> <span class="keyword">loop</span> <span class="keyword">at</span> <span class="number">2</span>  </span><br><span class="line">[BThread] <span class="keyword">Thread</span> <span class="keyword">loop</span> <span class="keyword">at</span> <span class="number">3</span>  </span><br><span class="line">[BThread] <span class="keyword">Thread</span> <span class="keyword">loop</span> <span class="keyword">at</span> <span class="number">4</span>  </span><br><span class="line">[BThread] <span class="keyword">Thread</span> end.        <span class="comment">-- BThread线程结束了, AThread线程执行  </span></span><br><span class="line">[AThread] <span class="keyword">Thread</span> end.        <span class="comment">-- AThread线程结束了, 主线程执行  </span></span><br><span class="line"><span class="keyword">main</span> <span class="keyword">end</span>!</span><br></pre></td></tr></table></figure><ol><li>深入的了解join()的用法：</li></ol><p>网上有很多人是这样解释 join()的用法的：”主线程等待子线程的终止“ ，相信有很多人都会这么说，但是这个说法是完全错误的，为什么呢？<br>请看例子，在上边代码的基础上，我们对TestDemo类做一下改动：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestDemo</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;  </span><br><span class="line">        String threadName = Thread.currentThread().getName();  </span><br><span class="line">        System.<span class="keyword">out</span>.println(threadName + <span class="string">" start."</span>);  </span><br><span class="line">        BThread bt = <span class="keyword">new</span> BThread();  </span><br><span class="line">        AThread at = <span class="keyword">new</span> AThread(bt);  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            bt.start();  </span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);  </span><br><span class="line">            at.start();  </span><br><span class="line">            <span class="comment">// at.join();  //这里注释掉  </span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"Exception from main"</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        System.<span class="keyword">out</span>.println(threadName + <span class="string">" end!"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">main start.                     <span class="comment">-- 主线程启动  </span></span><br><span class="line">[BThread] <span class="keyword">Thread</span> start.         <span class="comment">-- BThread线程启动  </span></span><br><span class="line">[BThread] <span class="keyword">Thread</span> <span class="keyword">loop</span> <span class="keyword">at</span> <span class="number">0</span>  </span><br><span class="line">[BThread] <span class="keyword">Thread</span> <span class="keyword">loop</span> <span class="keyword">at</span> <span class="number">1</span>  </span><br><span class="line"><span class="keyword">main</span> <span class="keyword">end</span>!                       <span class="comment">-- 主线程结束，（也就是说AThread线程中调用了bt.join()并不会影响到主线程）  </span></span><br><span class="line">[AThread] <span class="keyword">Thread</span> start.         <span class="comment">-- AThread线程启动, 因为AThread线程中调用了bt.join(), 所以AThread线程要等到BThread线程结束之后才能执行  </span></span><br><span class="line">[BThread] <span class="keyword">Thread</span> <span class="keyword">loop</span> <span class="keyword">at</span> <span class="number">2</span>  </span><br><span class="line">[BThread] <span class="keyword">Thread</span> <span class="keyword">loop</span> <span class="keyword">at</span> <span class="number">3</span>  </span><br><span class="line">[BThread] <span class="keyword">Thread</span> <span class="keyword">loop</span> <span class="keyword">at</span> <span class="number">4</span>       </span><br><span class="line">[BThread] <span class="keyword">Thread</span> end.           <span class="comment">-- BThread线程结束了, AThread线程执行  </span></span><br><span class="line">[AThread] <span class="keyword">Thread</span> end.</span><br></pre></td></tr></table></figure><p>相信聪明的读者已经猜到为什么说 ”主线程等待子线程的终止 “ 的错误原因了吧，正确的说法应该是：”当前线程等待子线程的终止“</p><h2 id="从源码看join-方法"><a href="#从源码看join-方法" class="headerlink" title="从源码看join()方法"></a>从源码看join()方法</h2><p>在AThread的run方法里，执行了<code>bt.join();</code>，进入看一下它的JDK源码：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="keyword">join</span>() <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">join</span>(<span class="number">0</span>L);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后进入join(0L)方法：<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="built_in">join</span>(<span class="keyword">long</span> <span class="built_in">millis</span>)</span><br><span class="line"><span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">long</span> base = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">long</span> now = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">millis</span> &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout value is negative"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">millis</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果线程被生成了，但还未被起动，isAlive()将返回false，调用它的join()方法是没有作用的，将直接继续向下执行。 </span></span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            wait(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            <span class="keyword">long</span> delay = <span class="built_in">millis</span> - now;</span><br><span class="line">            <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            wait(delay);</span><br><span class="line">            now = System.currentTimeMillis() - base;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>单纯从代码上看：在AThread类中的run方法中，bt.join()是判断bt的active状态，如果bt的isActive()方法返回false，在bt.join(),这一点就不用等待BThread线程结束，AThread就可以继续向下进行。</p><p>isAlive()方法的签名是：public final native boolean isAlive()，也就是说isAlive()是判断当前线程的状态。</p><h1 id="TheadLocal"><a href="#TheadLocal" class="headerlink" title="TheadLocal"></a>TheadLocal</h1><p>Java中的ThreadLocal类可以让你创建的变量只被同一个线程进行读和写操作。因此，尽管有两个线程同时执行一段相同的代码，而且这段代码又有一个指向同一个ThreadLocal变量的引用，但是这两个线程依然不能看到彼此的ThreadLocal变量域。</p><h2 id="创建一个ThreadLocal对象"><a href="#创建一个ThreadLocal对象" class="headerlink" title="创建一个ThreadLocal对象"></a>创建一个ThreadLocal对象</h2><p>如下所示，创建一个ThreadLocal变量：<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ThreadLocal myThreadLocal = <span class="keyword">new</span> <span class="type">ThreadLocal</span>();</span><br></pre></td></tr></table></figure></p><p>你实例化了一个ThreadLocal对象。每个线程仅需要实例化一次即可。虽然不同的线程执行同一段代码时，访问同一个ThreadLocal变量，但是每个线程只能看到私有的ThreadLocal实例。所以不同的线程在给ThreadLocal对象设置不同的值时，他们也不能看到彼此的修改。</p><h2 id="访问ThreadLocal对象"><a href="#访问ThreadLocal对象" class="headerlink" title="访问ThreadLocal对象"></a>访问ThreadLocal对象</h2><p>一旦创建了一个ThreadLocal对象，你就可以通过以下方式来存储此对象的值：<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myThreadLocal<span class="meta">.set</span>(<span class="string">"A thread local value"</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure></p><p>也可以直接读取一个ThreadLocal对象的值：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">String</span> threadLocalValue = (<span class="keyword">String</span>) myThreadLocal.<span class="built_in">get</span>();</span><br></pre></td></tr></table></figure></p><p>get()方法会返回一个Object对象，而set()方法则依赖一个Object对象参数。</p><h2 id="ThreadLocal泛型"><a href="#ThreadLocal泛型" class="headerlink" title="ThreadLocal泛型"></a>ThreadLocal泛型</h2><p>为了使get()方法返回值不用做强制类型转换，通常可以创建一个泛型化的ThreadLocal对象。以下就是一个泛型化的ThreadLocal示例：<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ThreadLocal myThreadLocal1 = <span class="keyword">new</span> <span class="type">ThreadLocal</span>&lt;<span class="keyword">String</span>&gt;();</span><br></pre></td></tr></table></figure></p><p>现在你可以存储一个字符串到ThreadLocal实例里，此外，当你从此ThreadLocal实例中获取值的时候，就不必要做强制类型转换。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">myThreadLocal1.<span class="builtin-name">set</span>(<span class="string">"Hello ThreadLocal"</span>);</span><br><span class="line"></span><br><span class="line">String threadLocalValues = myThreadLocal.<span class="builtin-name">get</span>();</span><br></pre></td></tr></table></figure></p><h2 id="初始化ThreadLocal"><a href="#初始化ThreadLocal" class="headerlink" title="初始化ThreadLocal"></a>初始化ThreadLocal</h2><p>由于ThreadLocal对象的set()方法设置的值只对当前线程可见，那有什么方法可以为ThreadLocal对象设置的值对所有线程都可见。</p><p>为此，我们可以通过ThreadLocal子类的实现，并覆写initialValue()方法，就可以为ThreadLocal对象指定一个初始化值。如下所示:<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ThreadLocal myThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;<span class="built_in">String</span>&gt;() &#123;</span><br><span class="line">   <span class="meta">@Override</span> <span class="keyword">protected</span> <span class="built_in">String</span> initialValue() &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="string">"This is the initial value"</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>此时，在set()方法调用前，当调用get()方法的时候，所有线程都可以看到同一个初始化值。</p><h2 id="Full-ThreadLocal-Example"><a href="#Full-ThreadLocal-Example" class="headerlink" title="Full ThreadLocal Example"></a>Full ThreadLocal Example</h2><p>以下是一个完整的ThreadLocal示例：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">package cn.caoler.ThreadTest2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: Caole</span></span><br><span class="line"><span class="comment"> * CreateDateTime: 2017/11/27 13:21</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ThreadLocalExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="title">implements</span> <span class="title">Runnable</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> ThreadLocal&lt;Integer&gt; threadLocal =</span><br><span class="line">               <span class="keyword">new</span> ThreadLocal&lt;Integer&gt;();</span><br><span class="line">        @Override</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            threadLocal.<span class="keyword">set</span>( (<span class="keyword">int</span>) (Math.random() * <span class="number">100</span>D) );</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            System.<span class="keyword">out</span>.println(threadLocal.<span class="keyword">get</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) throws InterruptedException </span>&#123;</span><br><span class="line">        MyRunnable sharedRunnableInstance = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(sharedRunnableInstance);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(sharedRunnableInstance);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread1.<span class="keyword">join</span>(); <span class="comment">//wait for thread 1 to terminate</span></span><br><span class="line">        thread2.<span class="keyword">join</span>(); <span class="comment">//wait for thread 2 to terminate</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面创建了两个线程共享一个MyRunnable实例。每个线程执行run()方法的时候，会给同一个ThreadLocal实例设置不同的值。如果调用set()方法的时候用synchronized关键字同步，而不是ThreadLocal对象的实例，那么第二个线程将会覆盖第一个线程所设置的值。</p><p>然而，由于是ThreadLocal对象，所以两个线程无法看到彼此的值。因此，可以设置或者获取不同的值。</p><h2 id="InheritableThreadLocal"><a href="#InheritableThreadLocal" class="headerlink" title="InheritableThreadLocal"></a>InheritableThreadLocal</h2><p>InheritableThreadLocal类是ThreadLocal的子类。为了解决ThreadLocal实例内部每个线程都只能看到自己的私有值，所以InheritableThreadLocal允许一个线程创建的所有子线程访问其父线程的值。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li>CSDN:<a href="http://blog.csdn.net/dabing69221/article/details/17472901" target="_blank" rel="external">Java Thread.join详解</a></li><li>并发编程网：<a href="http://ifeve.com/java-theadlocal/" target="_blank" rel="external">《Java并发性和多线程介绍》-Java TheadLocal</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Thread-join&quot;&gt;&lt;a href=&quot;#Thread-join&quot; class=&quot;headerlink&quot; title=&quot;Thread.join()&quot;&gt;&lt;/a&gt;Thread.join()&lt;/h1&gt;&lt;h2 id=&quot;使用方式&quot;&gt;&lt;a href=&quot;#使用方式&quot; class=&quot;headerlink&quot; title=&quot;使用方式&quot;&gt;&lt;/a&gt;使用方式&lt;/h2&gt;&lt;figure class=&quot;highlight pony&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;Thread&lt;/span&gt; t = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;AThread&lt;/span&gt;();&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;t&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;start&lt;/span&gt;();&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;t&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;join&lt;/span&gt;();&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;为什么要用join-方法&quot;&gt;&lt;a href=&quot;#为什么要用join-方法&quot; class=&quot;headerlink&quot; title=&quot;为什么要用join()方法&quot;&gt;&lt;/a&gt;为什么要用join()方法&lt;/h2&gt;&lt;p&gt;在很多情况下，主线程生成并起动了子线程，如果子线程里要进行大量的耗时的运算，主线程往往将于子线程之前结束，但是如果主线程处理完其他的事务后，需要用到子线程的处理结果，也就是主线程需要等待子线程执行完成之后再结束，这个时候就要用到join()方法了。&lt;/p&gt;
&lt;h2 id=&quot;join方法的作用&quot;&gt;&lt;a href=&quot;#join方法的作用&quot; class=&quot;headerlink&quot; title=&quot;join方法的作用&quot;&gt;&lt;/a&gt;join方法的作用&lt;/h2&gt;&lt;p&gt;JDK中对join方法解释为：“等待该线程终止”，换句话说就是：”当前线程等待子线程的终止“。也就是在子线程调用了join()方法后面的代码，只有等到子线程结束了当前线程才能执行。&lt;/p&gt;
&lt;h2 id=&quot;用实例来理解&quot;&gt;&lt;a href=&quot;#用实例来理解&quot; class=&quot;headerlink&quot; title=&quot;用实例来理解&quot;&gt;&lt;/a&gt;用实例来理解&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;简单了解join()的用法：&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="并发编程" scheme="https://caoler.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="线程通信" scheme="https://caoler.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/"/>
    
    
      <category term="并发编程" scheme="https://caoler.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="转载" scheme="https://caoler.cn/tags/%E8%BD%AC%E8%BD%BD/"/>
    
      <category term="线程通信" scheme="https://caoler.cn/tags/%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>死锁以及如何避免死锁</title>
    <link href="https://caoler.cn//post/2017/deadlock.html"/>
    <id>https://caoler.cn//post/2017/deadlock.html</id>
    <published>2017-11-27T02:30:00.000Z</published>
    <updated>2017-11-27T12:40:22.311Z</updated>
    
    <content type="html"><![CDATA[<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>锁是两个或更多线程阻塞着等待其它处于死锁状态的线程所持有的锁。死锁通常发生在多个线程同时但以不同的顺序请求同一组锁的时候。</p><p>例如，如果线程1锁住了A，然后尝试对B进行加锁，同时线程2已经锁住了B，接着尝试对A进行加锁，这时死锁就发生了。线程1永远得不到B，线程2也永远得不到A，并且它们永远也不会知道发生了这样的事情。为了得到彼此的对象（A和B），它们将永远阻塞下去。这种情况就是一个死锁。</p><p>该情况如下：</p><blockquote><p>Thread 1  locks A, waits for B<br>Thread 2  locks B, waits for A</p></blockquote><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.caoler.DeadLockDemo;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: Caole</span></span><br><span class="line"><span class="comment"> * CreateDateTime: 2017/11/23 11:56</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String A = <span class="string">"A"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String B = <span class="string">"B"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> DeadLockDemo().deadLock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deadLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span>(A)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.currentThread().sleep(<span class="number">20</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">synchronized</span>(B)&#123;</span><br><span class="line">                        System.out.println(<span class="string">"1"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span>(B)&#123;</span><br><span class="line">                    <span class="keyword">synchronized</span>(A)&#123;</span><br><span class="line">                        System.out.println(<span class="string">"2"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h2><p>常见方法有如下几个：</p><ul><li>避免一个线程同时获取多个锁。</li><li>避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源。</li><li>尝试使用定时锁，使用lock.tryLock(timeout)来代替使用内部锁机制。</li><li>对于数据库锁，加锁和解锁必须在同一个数据库连接里，否则会出现解锁异常的情况。</li></ul><p>具体解释详见<a href="http://ifeve.com/deadlock-prevention/" target="_blank" rel="external">并发编程网-避免死锁</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;死锁&quot;&gt;&lt;a href=&quot;#死锁&quot; class=&quot;headerlink&quot; title=&quot;死锁&quot;&gt;&lt;/a&gt;死锁&lt;/h2&gt;&lt;p&gt;锁是两个或更多线程阻塞着等待其它处于死锁状态的线程所持有的锁。死锁通常发生在多个线程同时但以不同的顺序请求同一组锁的时候。&lt;/p&gt;
&lt;p&gt;例如，如果线程1锁住了A，然后尝试对B进行加锁，同时线程2已经锁住了B，接着尝试对A进行加锁，这时死锁就发生了。线程1永远得不到B，线程2也永远得不到A，并且它们永远也不会知道发生了这样的事情。为了得到彼此的对象（A和B），它们将永远阻塞下去。这种情况就是一个死锁。&lt;/p&gt;
&lt;p&gt;该情况如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Thread 1  locks A, waits for B&lt;br&gt;Thread 2  locks B, waits for A&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h3&gt;
    
    </summary>
    
      <category term="并发编程" scheme="https://caoler.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="锁" scheme="https://caoler.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E9%94%81/"/>
    
    
      <category term="并发编程" scheme="https://caoler.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="转载" scheme="https://caoler.cn/tags/%E8%BD%AC%E8%BD%BD/"/>
    
      <category term="死锁" scheme="https://caoler.cn/tags/%E6%AD%BB%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>基于SSR的科学上网教程</title>
    <link href="https://caoler.cn//post/2017/ssrfq.html"/>
    <id>https://caoler.cn//post/2017/ssrfq.html</id>
    <published>2017-11-24T08:38:00.000Z</published>
    <updated>2017-12-01T08:27:11.255Z</updated>
    
    <content type="html"><![CDATA[<h2 id="PC客户端"><a href="#PC客户端" class="headerlink" title="PC客户端"></a>PC客户端</h2><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>链接: <a href="https://pan.baidu.com/s/1dFzus4h" target="_blank" rel="external">https://pan.baidu.com/s/1dFzus4h</a> 密码: bfrd</p><h3 id="添加服务器"><a href="#添加服务器" class="headerlink" title="添加服务器"></a>添加服务器</h3><p>将压缩包内文件解压到一个固定位置会后，选择<code>ShadowsocksR-dotnet4.0.exe</code> 打开客户端。</p><a id="more"></a><p>这时候，右下角托盘图标会出现一个纸飞机，<strong>然后右键 纸飞机 图标</strong>，弹出菜单并选择 <code>服务器 —— 编辑服务器</code>。</p><p><img src="https://ws1.sinaimg.cn/large/005DnJLEly1flt8s04fvfj30dr099q35.jpg" alt=""></p><p>然后就会出现 <strong>编辑服务器的窗口</strong>，默认是有一个节点配置示例的，你可以 直接改 或者 删掉 新添加一个服务器。</p><p>然后就是填写Shadowsocks账号信息。</p><p>依次填写 <strong>服务器 IP、服务器端口、密码、加密方式</strong>，如果你的账号是原版Shadowsocks，那么写到这里就行了。</p><blockquote><p>注意：<br>协议        : auth_sha1_v4_compatible<br>客户端中选择：auth_sha1_v4<br>混淆        : tls1.2_ticket_auth_compatible<br>客户端中选择：tls1.2_ticket_auth</p></blockquote><p>如果你的账号是ShadowsocksR账号，那么根据ShadowsocksR账号信息，选择对应的协议和混淆（origin/plain是原版SS的意思）</p><p>根据需要，你可以填写 备注 和 Group（分组） ，具体效果自己试一下就知道了。</p><p>密码前面的 选择框 是明文显示密码的意思。</p><hr><p>然后一些人会问为什么右边显示二维码的地方老是显示一个图片却不显示二维码？</p><p>实际上主要是很多人截图不知道打码，暴露了自己的Shadowsocks账号所有信息，所以默认都是不显示二维码的，只要点击 下图蓝条选中的SSR链接输入框，就会显示二维码了。</p><p>而SSR链接前面的 选择框 ，勾选代表是显示SSR的二维码，不勾选则显示SS的二维码。</p><p>填写完毕后，点击 确定 按钮，继续下一步。</p><p><img src="https://ws1.sinaimg.cn/large/005DnJLEgy1flt8va1w8gj30r40dzabq.jpg" alt=""></p><h3 id="选择服务器"><a href="#选择服务器" class="headerlink" title="选择服务器"></a>选择服务器</h3><p>右键 纸飞机 图标，出现菜单并选择 <code>服务器 —— 分组(empty group) —— 要使用的Shadowsocks账号</code>。(如果没有设置分组，直接选择要连接的服务器即可)</p><p><img src="https://ws1.sinaimg.cn/large/005DnJLEgy1flt8xb58q7j30d90993ys.jpg" alt=""></p><p>右键 纸飞机 图标弹出菜单并选择<code>系统代理模式 —— PAC模式</code> </p><p><img src="https://ws1.sinaimg.cn/large/005DnJLEgy1flt8ya28lij30ie0djt9g.jpg" alt=""></p><p>代理规则选 <strong>用户自定义</strong></p><p><img src="https://ws1.sinaimg.cn/large/005DnJLEgy1flt8ztan6bj30ic0cdjs3.jpg" alt=""></p><blockquote><p>目前ShadowsocksR客户端的国内外分流规则分两种，PAC规则（系统代理模式） 和 代理规则<br>PAC规则 是根据PAC文件中的黑白地址名单来判断那些网站走代理，也就是判断 流量数据是进入SSR客户端还是直连。<br>代理规则 是根据IP判断，分 绕过局域网/绕过局域网和大陆/绕过局域网和非大陆 ，用于判断 进入SSR客户端的数据流量是走代理还是直连。</p></blockquote><p>至此，PC端设置完毕。点击试试看：<a href="https://www.google.com" target="_blank" rel="external">https://www.google.com</a></p><h3 id="附加设置"><a href="#附加设置" class="headerlink" title="附加设置"></a>附加设置</h3><p>右键选择选项设置</p><p><img src="https://ws1.sinaimg.cn/large/005DnJLEgy1fltahjj0yuj30cj0c7gm0.jpg" alt=""></p><p>选择开机自启，设置开机自启后，只要电脑一开机就可以直接访问google了</p><p><img src="https://ws1.sinaimg.cn/large/005DnJLEgy1fltai4cu7xj30he0ej752.jpg" alt=""></p><h2 id="iOS客户端"><a href="#iOS客户端" class="headerlink" title="iOS客户端"></a>iOS客户端</h2><h3 id="下载-1"><a href="#下载-1" class="headerlink" title="下载"></a>下载</h3><ul><li>方式一：登录美区AppStore，购买并下载shadowrocket（18RMB）</li><li>方式二：使用电脑下载PP助手并安装，官网：<a href="https://pro.25pp.com/" target="_blank" rel="external">https://pro.25pp.com/</a></li></ul><p>连接手机之后搜索shadowrocket并安装</p><p><img src="https://ws1.sinaimg.cn/large/005DnJLEgy1fltaoljhsqj30ca046gli.jpg" alt=""></p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>打开shadowrocket，点击右上角加号</p><p><img src="https://ws1.sinaimg.cn/large/005DnJLEgy1fltas9wgpaj30ku0edjt4.jpg" alt=""></p><p><strong>类型选择shadowrocksR</strong> 输入账号密码，以及混淆参数等等。</p><blockquote><p>注意：<br>协议        : auth_sha1_v4_compatible<br>客户端中选择：auth_sha1_v4<br>混淆        : tls1.2_ticket_auth_compatible<br>客户端中选择：tls1.2_ticket_auth</p></blockquote><p><img src="https://ws1.sinaimg.cn/large/005DnJLEgy1fltasyhs2rj30ku112773.jpg" alt=""></p><p>在首页全局路由处选择<code>配置</code></p><p><img src="https://ws1.sinaimg.cn/large/005DnJLEgy1fltasqpem2j30ku112dir.jpg" alt=""></p><p>点击连接即可。</p><p>至此iOS端设置完毕，点击试试：<a href="https://www.google.com" target="_blank" rel="external">https://www.google.com</a></p><h2 id="安卓客户端"><a href="#安卓客户端" class="headerlink" title="安卓客户端"></a>安卓客户端</h2><h3 id="下载-2"><a href="#下载-2" class="headerlink" title="下载"></a>下载</h3><p>链接: <a href="https://pan.baidu.com/s/1i5vi3tz" target="_blank" rel="external">https://pan.baidu.com/s/1i5vi3tz</a> 密码: 9y9t</p><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><p>安装之后配置你的服务器信息，<strong>远程端口为我给你的端口，本地端口为默认1080</strong></p><blockquote><p>注意：<br>协议        : auth_sha1_v4_compatible<br>客户端中选择：auth_sha1_v4<br>混淆        : tls1.2_ticket_auth_compatible<br>客户端中选择：tls1.2_ticket_auth</p></blockquote><p><img src="https://ws1.sinaimg.cn/large/005DnJLEly1fltbgxqftkj30f00qogmc.jpg" alt=""></p><p>路由处选择如图所示绕过局域网和大陆，如果不能上网，再设置为全局</p><p><img src="https://ws1.sinaimg.cn/large/005DnJLEly1fltbi98qemj30f00qoq3u.jpg" alt=""></p><p>当处于全局状态时，手机消耗的所有数据将使用那50G流量，也可切换为<code>仅代理为中国大陆无法访问的网址</code></p><p>点击右上角小飞机，同意连接之后，即可成功FQ<br><img src="https://ws1.sinaimg.cn/large/005DnJLEly1fltbkj2pvij30f00qoaal.jpg" alt=""></p><p>至此，安卓客户端设置完毕，点击试试：<a href="https://www.google.com" target="_blank" rel="external">https://www.google.com</a></p><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>设置切记按照文章中所说的一步一步操作，尤其是PC端的选择PAC，iOS端的配置，还有安卓客户端的路由选项</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;PC客户端&quot;&gt;&lt;a href=&quot;#PC客户端&quot; class=&quot;headerlink&quot; title=&quot;PC客户端&quot;&gt;&lt;/a&gt;PC客户端&lt;/h2&gt;&lt;h3 id=&quot;下载&quot;&gt;&lt;a href=&quot;#下载&quot; class=&quot;headerlink&quot; title=&quot;下载&quot;&gt;&lt;/a&gt;下载&lt;/h3&gt;&lt;p&gt;链接: &lt;a href=&quot;https://pan.baidu.com/s/1dFzus4h&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://pan.baidu.com/s/1dFzus4h&lt;/a&gt; 密码: bfrd&lt;/p&gt;
&lt;h3 id=&quot;添加服务器&quot;&gt;&lt;a href=&quot;#添加服务器&quot; class=&quot;headerlink&quot; title=&quot;添加服务器&quot;&gt;&lt;/a&gt;添加服务器&lt;/h3&gt;&lt;p&gt;将压缩包内文件解压到一个固定位置会后，选择&lt;code&gt;ShadowsocksR-dotnet4.0.exe&lt;/code&gt; 打开客户端。&lt;/p&gt;
    
    </summary>
    
      <category term="实用教程" scheme="https://caoler.cn/categories/%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B/"/>
    
      <category term="科学上网" scheme="https://caoler.cn/categories/%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"/>
    
    
      <category term="原创" scheme="https://caoler.cn/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="科学上网" scheme="https://caoler.cn/tags/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>线程通信</title>
    <link href="https://caoler.cn//post/2017/thread-signaling.html"/>
    <id>https://caoler.cn//post/2017/thread-signaling.html</id>
    <published>2017-11-22T10:31:00.000Z</published>
    <updated>2017-11-27T12:37:56.861Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>线程通信的目标是使线程间能够互相发送信号。另一方面，线程通信使线程能够等待其他线程的信号。</p><p>例如，线程B可以等待线程A的一个信号，这个信号会通知线程B数据已经准备好了。本文将讲解以下几个JAVA线程间通信的主题：</p><h3 id="通过共享对象通信"><a href="#通过共享对象通信" class="headerlink" title="通过共享对象通信"></a>通过共享对象通信</h3><p>线程间发送信号的一个简单方式是在共享对象的变量里设置信号值。线程A在一个同步块里设置boolean型成员变量hasDataToProcess为true，线程B也在同步块里读取hasDataToProcess这个成员变量。这个简单的例子使用了一个持有信号的对象，并提供了set和check方法:</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySignal</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">boolean</span> hasDataToProcess = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">hasDataToProcess</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.hasDataToProcess;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setHasDataToProcess</span><span class="params">(<span class="keyword">boolean</span> hasData)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.hasDataToProcess = hasData;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程A和B必须获得指向一个MySignal共享实例的引用，以便进行通信。如果它们持有的引用指向不同的MySingal实例，那么彼此将不能检测到对方的信号。需要处理的数据可以存放在一个共享缓存区里，它和MySignal实例是分开存放的。</p><h3 id="忙等待"><a href="#忙等待" class="headerlink" title="忙等待"></a>忙等待</h3><p>准备处理数据的线程B正在等待数据变为可用。换句话说，它在等待线程A的一个信号，这个信号使hasDataToProcess()返回true。线程B运行在一个循环里，以等待这个信号：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> MySignal sharedSignal = <span class="params">...</span></span><br><span class="line"></span><br><span class="line"><span class="params">...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(!sharedSignal.hasDataToProcess())&#123;</span><br><span class="line">  <span class="comment">//do nothing... busy waiting</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="wait-notify-和notifyAll"><a href="#wait-notify-和notifyAll" class="headerlink" title="wait(),notify()和notifyAll()"></a>wait(),notify()和notifyAll()</h3><p>忙等待没有对运行等待线程的CPU进行有效的利用，除非平均等待时间非常短。否则，让等待线程进入睡眠或者非运行状态更为明智，直到它接收到它等待的信号。</p><p>Java有一个内建的等待机制来允许线程在等待信号的时候变为非运行状态。java.lang.Object 类定义了三个方法，wait()、notify()和notifyAll()来实现这个等待机制。</p><p>一个线程一旦调用了任意对象的wait()方法，就会变为非运行状态，直到另一个线程调用了<strong>同一个对象</strong> 的notify()方法。为了调用wait()或者notify()，线程必须先获得那个对象的锁。也就是说，线程必须在同步块里调用wait()或者notify()。以下是MySingal的修改版本——使用了wait()和notify()的MyWaitNotify：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MonitorObject</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyWaitNotify</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  MonitorObject myMonitorObject = <span class="keyword">new</span> MonitorObject();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWait</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(myMonitorObject)&#123;</span><br><span class="line">      <span class="keyword">try</span>&#123;</span><br><span class="line">        myMonitorObject.wait();</span><br><span class="line">      &#125; <span class="keyword">catch</span>(InterruptedException e)&#123;...&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doNotify</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(myMonitorObject)&#123;</span><br><span class="line">      myMonitorObject.notify();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>等待线程将调用doWait()，而唤醒线程将调用doNotify()。当一个线程调用一个对象的notify()方法，正在等待该对象的所有线程中将有一个线程被唤醒并允许执行 <em>（校注：这个将被唤醒的线程是随机的，不可以指定唤醒哪个线程）。</em> 同时也提供了一个notifyAll()方法来唤醒正在等待一个给定对象的所有线程。</p><p>如你所见，不管是等待线程还是唤醒线程都在同步块里调用wait()和notify()。这是强制性的！<strong>一个线程如果没有持有对象锁，将不能调用wait()，notify()或者notifyAll()。</strong> 否则，会抛出IllegalMonitorStateException异常。</p><p><em>（校注：JVM是这么实现的，当你调用wait时候它首先要检查下当前线程是否是锁的拥有者，不是则抛出IllegalMonitorStateExcept，参考JVM源码的 1422行。）</em></p><p>但是，这怎么可能？等待线程在同步块里面执行的时候，不是一直持有监视器对象（myMonitor对象）的锁吗？等待线程不能阻塞唤醒线程进入doNotify()的同步块吗？答案是：的确不能。<strong>一旦线程调用了wait()方法，它就释放了所持有的监视器对象上的锁。这将允许其他线程也可以调用wait()或者notify()。</strong></p><p>一旦一个线程被唤醒，不能立刻就退出wait()的方法调用，直到调用notify()的线程退出了它自己的同步块。换句话说：被唤醒的线程必须重新获得监视器对象的锁，才可以退出wait()的方法调用，因为wait方法调用运行在同步块里面。如果多个线程被notifyAll()唤醒，那么在同一时刻将只有一个线程可以退出wait()方法，因为每个线程在退出wait()前必须获得监视器对象的锁。</p><h3 id="丢失的信号"><a href="#丢失的信号" class="headerlink" title="丢失的信号"></a>丢失的信号</h3><p>notify()和notifyAll()方法不会保存调用它们的方法，因为当这两个方法被调用时，有可能没有线程处于等待状态。通知信号过后便丢弃了。因此，如果一个线程先于被通知线程调用wait()前调用了notify()，等待的线程将错过这个信号。这可能是也可能不是个问题。不过，在某些情况下，这可能使等待线程永远在等待，不再醒来，因为线程错过了唤醒信号。</p><p>为了避免丢失信号，必须把它们保存在信号类里。在MyWaitNotify的例子中，通知信号应被存储在MyWaitNotify实例的一个成员变量里。以下是MyWaitNotify的修改版本：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyWaitNotify2</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  MonitorObject myMonitorObject = <span class="keyword">new</span> MonitorObject();</span><br><span class="line">  <span class="keyword">boolean</span> wasSignalled = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWait</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(myMonitorObject)&#123;</span><br><span class="line">      <span class="keyword">if</span>(!wasSignalled)&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">          myMonitorObject.wait();</span><br><span class="line">         &#125; <span class="keyword">catch</span>(InterruptedException e)&#123;...&#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//clear signal and continue running.</span></span><br><span class="line">      wasSignalled = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doNotify</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(myMonitorObject)&#123;</span><br><span class="line">      wasSignalled = <span class="keyword">true</span>;</span><br><span class="line">      myMonitorObject.notify();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>留意doNotify()方法在调用notify()前把wasSignalled变量设为true。同时，留意doWait()方法在调用wait()前会检查wasSignalled变量。事实上，如果没有信号在前一次doWait()调用和这次doWait()调用之间的时间段里被接收到，它将只调用wait()。</p><p><em>（校注：为了避免信号丢失， 用一个变量来保存是否被通知过。在notify前，设置自己已经被通知过。在wait后，设置自己没有被通知过，需要等待通知。）</em></p><p><strong>自己的理解，wasSignalled标注的功能就是限制Wait和Notify的顺序</strong></p><h3 id="假唤醒"><a href="#假唤醒" class="headerlink" title="假唤醒"></a>假唤醒</h3><p>由于莫名其妙的原因，线程有可能在没有调用过notify()和notifyAll()的情况下醒来。这就是所谓的假唤醒（spurious wakeups）。无端端地醒过来了。</p><p>如果在MyWaitNotify2的doWait()方法里发生了假唤醒，等待线程即使没有收到正确的信号，也能够执行后续的操作。这可能导致你的应用程序出现严重问题。</p><p>为了防止假唤醒，保存信号的成员变量将在一个while循环里接受检查，而不是在if表达式里。这样的一个while循环叫做自旋锁 <em>（校注：这种做法要慎重，目前的JVM实现自旋会消耗CPU，如果长时间不调用doNotify方法，doWait方法会一直自旋，CPU会消耗太大）。</em> 被唤醒的线程会自旋直到自旋锁(while循环)里的条件变为false。以下MyWaitNotify2的修改版本展示了这点：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyWaitNotify3</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">  MonitorObject myMonitorObject = <span class="keyword">new</span> MonitorObject();</span><br><span class="line">  <span class="keyword">boolean</span> wasSignalled = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWait</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(myMonitorObject)&#123;</span><br><span class="line">      <span class="keyword">while</span>(!wasSignalled)&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">          myMonitorObject.wait();</span><br><span class="line">         &#125; <span class="keyword">catch</span>(InterruptedException e)&#123;...&#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//clear signal and continue running.</span></span><br><span class="line">      wasSignalled = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doNotify</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(myMonitorObject)&#123;</span><br><span class="line">      wasSignalled = <span class="keyword">true</span>;</span><br><span class="line">      myMonitorObject.notify();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>留意wait()方法是在while循环里，而不在if表达式里。如果等待线程没有收到信号就唤醒，wasSignalled变量将变为false,while循环会再执行一次，促使醒来的线程回到等待状态。</p><h3 id="多线程等待相同信号"><a href="#多线程等待相同信号" class="headerlink" title="多线程等待相同信号"></a>多线程等待相同信号</h3><p>如果你有多个线程在等待，被notifyAll()唤醒，但只有一个被允许继续执行，使用while循环也是个好方法。每次只有一个线程可以获得监视器对象锁，意味着只有一个线程可以退出wait()调用并清除wasSignalled标志（设为false）。一旦这个线程退出doWait()的同步块，其他线程退出wait()调用，并在while循环里检查wasSignalled变量值。但是，这个标志已经被第一个唤醒的线程清除了，所以其余醒来的线程将回到等待状态，直到下次信号到来。</p><h3 id="不要对常量字符串或全局对象调用wait"><a href="#不要对常量字符串或全局对象调用wait" class="headerlink" title="不要对常量字符串或全局对象调用wait()"></a>不要对常量字符串或全局对象调用wait()</h3><p><em>（校注：本章说的字符串常量指的是值为常量的变量）</em></p><p>本文早期的一个版本在MyWaitNotify例子里使用字符串常量（””）作为管程对象。以下是那个例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyWaitNotify3</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">  String myMonitorObject = <span class="string">""</span>;</span><br><span class="line">  <span class="keyword">boolean</span> wasSignalled = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWait</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(myMonitorObject)&#123;</span><br><span class="line">      <span class="keyword">while</span>(!wasSignalled)&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">          myMonitorObject.wait();</span><br><span class="line">         &#125; <span class="keyword">catch</span>(InterruptedException e)&#123;...&#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//clear signal and continue running.</span></span><br><span class="line">      wasSignalled = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doNotify</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(myMonitorObject)&#123;</span><br><span class="line">      wasSignalled = <span class="keyword">true</span>;</span><br><span class="line">      myMonitorObject.notify();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在空字符串作为锁的同步块(或者其他常量字符串)里调用wait()和notify()产生的问题是，JVM/编译器内部会把常量字符串转换成同一个对象。这意味着，即使你有2个不同的MyWaitNotify实例，它们都引用了相同的空字符串实例。同时也意味着存在这样的风险：在第一个MyWaitNotify实例上调用doWait()的线程会被在第二个MyWaitNotify实例上调用doNotify()的线程唤醒。这种情况可以画成以下这张图：</p><p><img src="https://ws1.sinaimg.cn/large/005DnJLEgy1flr17ajfdjj30a4083t8r.jpg" alt=""></p><h2 id="等待-通知机制-总结"><a href="#等待-通知机制-总结" class="headerlink" title="等待/通知机制 总结"></a>等待/通知机制 总结</h2><h3 id="相关方法"><a href="#相关方法" class="headerlink" title="相关方法"></a>相关方法</h3><table><thead><tr><th>方法名称</th><th>描述</th></tr></thead><tbody><tr><td>notify()</td><td>通知一个在对象上等待的线程，由WAITING状态变为BLOCKING状态，从等待队列移动到同步队列，等待CPU调度获取该对象的锁，当该线程获取到了对象的锁后，该线程从wait()方法返回</td></tr><tr><td>notifyAll()</td><td>通知所有等待在该对象上的线程，由WAITING状态变为BLOCKING状态，等待CPU调度获取该对象的锁</td></tr><tr><td>wait()</td><td>调用该方法的线程进入WAITING状态，并将当前线程放置到对象的等待队列，只有等待另外线程的通知或被中断才会返回，需要注意，调用wait()方法后，会释放对象的锁</td></tr><tr><td>wait(long)</td><td>超时等待一段时间，这里的参数时间是毫秒，也就是等待长达n毫秒，如果没有通知就超时返回</td></tr><tr><td>wait(long，int)</td><td>对于超时时间更细力度的控制，可以达到纳秒</td></tr></tbody></table><h3 id="代码清单"><a href="#代码清单" class="headerlink" title="代码清单"></a>代码清单</h3><p>如下代码本人觉得更加清晰<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.caoler.WaitNotify;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: Caole</span></span><br><span class="line"><span class="comment"> * CreateDateTime: 2017/11/23 12:43</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNotify</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">static</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread waitThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Wait(), <span class="string">"WaitThread"</span>);</span><br><span class="line">        waitThread.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        Thread notifyThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Notify(), <span class="string">"NotifyThread"</span>);</span><br><span class="line">        notifyThread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Wait</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//加锁，拥有lock的Monitor</span></span><br><span class="line">            <span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">                <span class="comment">//当条件不满足时继续wait，同时释放了lock的锁</span></span><br><span class="line">                <span class="keyword">while</span> (flag)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread() + <span class="string">"flag is true .wait@"</span></span><br><span class="line">                         + <span class="keyword">new</span> SimpleDateFormat(<span class="string">"HH:mm:ss"</span>).format(<span class="keyword">new</span> Date()));</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//条件满足时，完成工作</span></span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"flag is false .running@"</span></span><br><span class="line">                 + <span class="keyword">new</span> SimpleDateFormat(<span class="string">"HH:mm:ss"</span>).format(<span class="keyword">new</span> Date()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Notify</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//加锁，拥有lock的Monitor</span></span><br><span class="line">            <span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">                <span class="comment">//获取lock的锁，然后进行通知，通知时不会释放lock的锁</span></span><br><span class="line">                <span class="comment">//直到当前线程释放了lock锁之后，WaitThread才能从wait方法中返回</span></span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"hold lock .notify @"</span></span><br><span class="line">                        + <span class="keyword">new</span> SimpleDateFormat(<span class="string">"HH:mm:ss"</span>).format(<span class="keyword">new</span> Date()));</span><br><span class="line">                lock.notifyAll();</span><br><span class="line">                flag = <span class="keyword">false</span>;</span><br><span class="line">                SleepUtils.second(<span class="number">5</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//再次加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"hold lock again .sleep @"</span></span><br><span class="line">                        + <span class="keyword">new</span> SimpleDateFormat(<span class="string">"HH:mm:ss"</span>).format(<span class="keyword">new</span> Date()));</span><br><span class="line">                SleepUtils.second(<span class="number">5</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出如下：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">Thread</span><span class="selector-attr">[WaitThread,5,main]</span><span class="selector-tag">flag</span> <span class="selector-tag">is</span> <span class="selector-tag">true</span> <span class="selector-class">.wait</span>@<span class="selector-tag">15</span><span class="selector-pseudo">:54</span><span class="selector-pseudo">:24</span></span><br><span class="line"><span class="selector-tag">Thread</span><span class="selector-attr">[NotifyThread,5,main]</span><span class="selector-tag">hold</span> <span class="selector-tag">lock</span> <span class="selector-class">.notify</span> @<span class="selector-tag">15</span><span class="selector-pseudo">:54</span><span class="selector-pseudo">:24</span></span><br><span class="line"><span class="selector-tag">Thread</span><span class="selector-attr">[NotifyThread,5,main]</span><span class="selector-tag">hold</span> <span class="selector-tag">lock</span> <span class="selector-tag">again</span> <span class="selector-class">.sleep</span> @<span class="selector-tag">15</span><span class="selector-pseudo">:54</span><span class="selector-pseudo">:30</span></span><br><span class="line"><span class="selector-tag">Thread</span><span class="selector-attr">[WaitThread,5,main]</span><span class="selector-tag">flag</span> <span class="selector-tag">is</span> <span class="selector-tag">false</span> <span class="selector-class">.running</span>@<span class="selector-tag">15</span><span class="selector-pseudo">:54</span><span class="selector-pseudo">:35</span></span><br></pre></td></tr></table></figure><h3 id="使用wait-notify注意事项和问题"><a href="#使用wait-notify注意事项和问题" class="headerlink" title="使用wait/notify注意事项和问题"></a>使用wait/notify注意事项和问题</h3><ul><li><p>执行完wait后会释放锁， 在执行notify()方法后，当前线程不会立刻释放该对象锁。呈wait状态的线程并不能马上获取该对象锁，要等执行notify()方法的线程将程序执行完，也就是退出synchronized代码块后，当前线程才会释放锁。</p></li><li><p>在调用wait()或notify()方法之前，必须获得该对象的对象级别锁，即只能在同步方法或者同步块中调用wait()方法，在执行wait()方法之后，当前线程释放锁。</p></li><li><p>在调用notify通知某线程后，该线程不会立即进入Running状态，而是先进入Runnable状态。</p></li><li><p>notify每次仅通知一个线程，多次调用可将wait线程全部唤醒。</p></li><li><p>当线程呈wait状态时，调用线程对象的interrupt方法会抛出InterruptedException异常。</p></li><li><p>通知过早: 如果通知过早，会打乱程序正常运行逻辑。</p></li></ul><h3 id="等待-通知的经典范式"><a href="#等待-通知的经典范式" class="headerlink" title="等待/通知的经典范式"></a>等待/通知的经典范式</h3><p>从前断示例中可以提炼出等待/通知经典范式，该范式分为两部分，分别为等待方(消费者)和通知方（生产者）。</p><ul><li><p>等待方遵循如下原则。</p><ol><li>获取对象的锁</li><li>如果条件不满足，那么调用对象的<code>wait()</code>方法，被通知后仍要检查条件。</li><li><p>条件满足则执行对应的逻辑。</p><p>对应的伪代码如下</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">synchronized</span>(对象)&#123;</span><br><span class="line">    <span class="selector-tag">while</span>(不满足)&#123;</span><br><span class="line">        对象<span class="selector-class">.wait</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    对应的处理逻辑</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>通知方遵循如下原则</p><ol><li>获得对象的锁</li><li>改变条件</li><li><p>通知所有等待在对象上的线程</p><p>对应的伪代码如下：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">synchronized</span>(对象)&#123;</span><br><span class="line">    改变条件</span><br><span class="line">    对象<span class="selector-class">.notifyAll</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>自并发编程网 – <a href="http://ifeve.com" target="_blank" rel="external">ifeve.com</a>本文链接地址: <a href="http://ifeve.com/java-concurrency-thread-directory/" target="_blank" rel="external">strings-wait-notify</a></li><li>JAVA并发编程的艺术（方腾飞） 4.3.2节</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;线程通信的目标是使线程间能够互相发送信号。另一方面，线程通信使线程能够等待其他线程的信号。&lt;/p&gt;
&lt;p&gt;例如，线程B可以等待线程A的一个信号，这个信号会通知线程B数据已经准备好了。本文将讲解以下几个JAVA线程间通信的主题：&lt;/p&gt;
&lt;h3 id=&quot;通过共享对象通信&quot;&gt;&lt;a href=&quot;#通过共享对象通信&quot; class=&quot;headerlink&quot; title=&quot;通过共享对象通信&quot;&gt;&lt;/a&gt;通过共享对象通信&lt;/h3&gt;&lt;p&gt;线程间发送信号的一个简单方式是在共享对象的变量里设置信号值。线程A在一个同步块里设置boolean型成员变量hasDataToProcess为true，线程B也在同步块里读取hasDataToProcess这个成员变量。这个简单的例子使用了一个持有信号的对象，并提供了set和check方法:&lt;/p&gt;
    
    </summary>
    
      <category term="并发编程" scheme="https://caoler.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="线程通信" scheme="https://caoler.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/"/>
    
    
      <category term="并发编程" scheme="https://caoler.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="转载" scheme="https://caoler.cn/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>线程安全及其实现方法</title>
    <link href="https://caoler.cn//post/2017/thread-safety-realize.html"/>
    <id>https://caoler.cn//post/2017/thread-safety-realize.html</id>
    <published>2017-11-22T10:28:00.000Z</published>
    <updated>2017-11-27T12:39:29.112Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>线程安全：当多个对象访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方法进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那么这个对象是线程安全的。</p><h3 id="互斥同步"><a href="#互斥同步" class="headerlink" title="互斥同步"></a>互斥同步</h3><p>互斥同步是常见的一种并发正确性保障手段。<strong>同步是指多个线程并发访问共享数据时，保障数据在同一时刻只被一个（或者是一些，使用信号量的时候）线程使用。</strong> 而互斥是实现同步的一种手段，临界区、互斥量、信号量都是主要的互斥实现方式、因此在这4个字里面，互斥是因、同步是果；互斥是方法，同步是目的。</p><h4 id="synchronied关键字"><a href="#synchronied关键字" class="headerlink" title="synchronied关键字"></a>synchronied关键字</h4><a id="more"></a><p>synchronized是java中最基本的同步手段，他在经过编译之后，会在同步前后分别形成monitorenter和monitorexit这两个字节码，这两个字节码都需要一个reference类型的参数来指明要锁定和解锁的对象。<strong>如果java程序中的synchronized明确指定了对象参数，那就是这个对象的reference；如果没有明确指定，那就根据synchronized修饰的是实例还是类方法去取对应的对象实例或class对象来作为锁对象。</strong></p><p>在虚拟机规范对monitorenter和monitorexit的行为描述中有2点是特别要注意的。</p><ul><li>synchronized同步块对同一条线程来说是可重入的，不会出现自己把自己锁死的问题。</li><li>同步块在已进入的线程执行完之前，会阻塞后面其他线程的进入。</li></ul><p>java线程是映射到操作系统的原生线程之上的，如果要阻塞或者唤醒一个线程都需要操作系统来帮忙完成，这就需要从用户态转到核心态中，因此状态转换需要耗费很多的处理时间。对于代码简单的同步块（如被synchronized修饰的set和get方法），状态转换消耗的时间比用户代码执行的时间还要长，所以synchronized是java语言中一个重量级的操作。</p><h4 id="ReentrantLock重入锁"><a href="#ReentrantLock重入锁" class="headerlink" title="ReentrantLock重入锁"></a>ReentrantLock重入锁</h4><p>基本用法上重入锁和synchronized很相似，他们都具备一样的线程重入特性，只是在代码写法上有点区别，一个表现为API层面的互斥锁，另一个表现在语法层面的互斥锁。不过相比较synchronized，ReetrantLock增加了一些高级功能，主要有以下3项：等待可中断、可实现公平锁，以及锁可以绑定多个条件。</p><ul><li>等待可中断是指当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情，可中断特性对处理执行时间非常长的同步块很有帮助。</li><li>公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁；而非公平锁则不保证这一点，在锁被释放时，任何一个等待锁的线程都有机会获得锁。synchronized中的锁是非公平的，ReentrantLock默认情况下也是非公平的，但可以通过带布尔值的构造函数要求使用公平锁。</li><li>锁绑定多个条件是指一个ReentrantLock对象可以同时绑定多个Condition对象，而在synchronized中，锁对象的wait（）和notify（）或notifyAll（）方法可以实现一个隐含的条件，如果要和多于一个的条件关联的时候，就不得不额外地添加一个锁，而ReentrantLock则无需这样做，只需要多次调用newCondition()方法即可。   </li></ul><p>通过对比两种锁的吞吐量可知：<br> 1.6中加入了很多针对锁的优化措施，JDK 1.6发布之后，人们就发现synchronized与ReentrantLock的性能基本上是完全持平了。因此，如果读者的程序是使用JDK 1.6或以上部署的话，性能因素就不再是选择ReentrantLock的理由了，虚拟机在未来的性能改进中肯定也会更加偏向于原生的synchronized，所以还是提倡在synchronized能实现需求的情况下，优先考虑使用synchronized来进行同步。</p><h3 id="非阻塞同步"><a href="#非阻塞同步" class="headerlink" title="非阻塞同步"></a>非阻塞同步</h3><p>互斥同步最主要的问题就是进行线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步（Blocking Synchronization）。从处理问题的方式上说，互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施（例如加锁），那就肯定会出现问题，无论共享数据是否真的会出现竞争，它都要进行加锁（这里讨论的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁）、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。随着硬件指令集的发展，我们有了另外一个选择：基于冲突检测的乐观并发策略，通俗地说，就是先进行操作，如果没有其他线程争用共享数据，那操作就成功了；如果共享数据有争用，产生了冲突，那就再采取其他的补偿措施（最常见的补偿措施就是不断地重试，直到成功为止），这种乐观的并发策略的许多实现都不需要把线程挂起，因此这种同步操作称为非阻塞同步（Non-Blocking Synchronization）。</p><h3 id="无同步方案"><a href="#无同步方案" class="headerlink" title="无同步方案"></a>无同步方案</h3><p>要保证线程安全，并不是一定就要进行同步，两者没有因果关系。同步只是保证共享数据争用时的正确性的手段，如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性，因此会有一些代码天生就是线程安全的，笔者简单地介绍其中的两类。</p><h4 id="可重入代码（Reentrant-Code）"><a href="#可重入代码（Reentrant-Code）" class="headerlink" title="可重入代码（Reentrant Code）"></a>可重入代码（Reentrant Code）</h4><p>这种代码也叫做纯代码（Pure Code），可以在代码执行的任何时刻中断它，转而去执行另外一段代码（包括递归调用它本身），而在控制权返回后，原来的程序不会出现任何错误。相对线程安全来说，可重入性是更基本的特性，它可以保证线程安全，<strong>即所有的可重入的代码都是线程安全的，但是并非所有的线程安全的代码都是可重入的。</strong></p><p>可重入代码有一些共同的特征，例如不依赖存储在堆上的数据和公用的系统资源、用到的状态量都由参数中传入、不调用非可重入的方法等。我们可以通过一个简单的原则来判断代码是否具备可重入性：<strong>如果一个方法，它的返回结果是可以预测的，只要输入了相同的数据，就都能返回相同的结果，那它就满足可重入性的要求，当然也就是线程安全的。</strong></p><h4 id="线程本地存储（Thread-Local-Storage）"><a href="#线程本地存储（Thread-Local-Storage）" class="headerlink" title="线程本地存储（Thread Local Storage）"></a>线程本地存储（Thread Local Storage）</h4><p>如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行？如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。<br>符合这种特点的应用并不少见，大部分使用消费队列的架构模式（如“生产者-消费者”模式）都会将产品的消费过程尽量在一个线程中消费完，其中最重要的一个应用实例就是经典Web交互模型中的“一个请求对应一个服务器线程”（Thread-per-Request）的处理方式，这种处理方式的广泛应用使得很多Web服务端应用都可以使用线程本地存储来解决线程安全问题。<br>Java语言中，如果一个变量要被多线程访问，可以使用volatile关键字声明它为“易变的”；如果一个变量要被某个线程独享，Java中就没有类似C++中__declspec（thread）[3]这样的关键字，不过还是可以通过java.lang.ThreadLocal类来实现线程本地存储的功能。每一个线程的Thread对象中都有一个ThreadLocalMap对象，这个对象存储了一组以ThreadLocal.threadLocalHashCode为键，以本地线程变量为值的K-V值对，ThreadLocal对象就是当前线程的ThreadLocalMap的访问入口，每一个ThreadLocal对象都包含了一个独一无二的threadLocalHashCode值，使用这个值就可以在线程K-V值对中找回对应的本地线程变量。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>本文内容摘自周志明老师的深入理解Java虚拟机第十三章线程安全与锁优化。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;线程安全&quot;&gt;&lt;a href=&quot;#线程安全&quot; class=&quot;headerlink&quot; title=&quot;线程安全&quot;&gt;&lt;/a&gt;线程安全&lt;/h2&gt;&lt;p&gt;线程安全：当多个对象访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方法进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那么这个对象是线程安全的。&lt;/p&gt;
&lt;h3 id=&quot;互斥同步&quot;&gt;&lt;a href=&quot;#互斥同步&quot; class=&quot;headerlink&quot; title=&quot;互斥同步&quot;&gt;&lt;/a&gt;互斥同步&lt;/h3&gt;&lt;p&gt;互斥同步是常见的一种并发正确性保障手段。&lt;strong&gt;同步是指多个线程并发访问共享数据时，保障数据在同一时刻只被一个（或者是一些，使用信号量的时候）线程使用。&lt;/strong&gt; 而互斥是实现同步的一种手段，临界区、互斥量、信号量都是主要的互斥实现方式、因此在这4个字里面，互斥是因、同步是果；互斥是方法，同步是目的。&lt;/p&gt;
&lt;h4 id=&quot;synchronied关键字&quot;&gt;&lt;a href=&quot;#synchronied关键字&quot; class=&quot;headerlink&quot; title=&quot;synchronied关键字&quot;&gt;&lt;/a&gt;synchronied关键字&lt;/h4&gt;
    
    </summary>
    
      <category term="并发编程" scheme="https://caoler.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="线程安全" scheme="https://caoler.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="并发编程" scheme="https://caoler.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="转载" scheme="https://caoler.cn/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>使用WMITool解决浏览器主页被hao123劫持问题</title>
    <link href="https://caoler.cn//post/2017/wmitools.html"/>
    <id>https://caoler.cn//post/2017/wmitools.html</id>
    <published>2017-11-21T06:50:00.000Z</published>
    <updated>2017-11-27T12:40:43.002Z</updated>
    
    <content type="html"><![CDATA[<p>最近一段时间发现，无论Chrome 还是 Firefox 主页都被流氓(hao123)劫持了。</p><p>一些具体症状：</p><ul><li>删掉原先的快捷方式以后再重新创建一个，问题依然存在；</li><li>快捷方式属性没有问题，没有后缀网址；</li><li>直接启动exe文件没有异常；</li><li>chrome主页设置也没有问题，但是如果重新设置一遍主页，从快捷方式就可以正常启动chrome，但再次启动电脑又会恢复原样；</li><li>改exe文件名可解决但我不想用这种回避的方式。</li></ul><p>本人又没有安装360，电脑管家等流氓软件的习惯，于是通过Google找到了解决办法，具体如下：</p><a id="more"></a><h3 id="一、下载-WIM-Tools"><a href="#一、下载-WIM-Tools" class="headerlink" title="一、下载 WIM Tools"></a>一、下载 WIM Tools</h3><p>官网连接：<a href="https://www.adremsoft.com/wmitools/" target="_blank" rel="external">https://www.adremsoft.com/wmitools/</a> 软件体积较大(不推荐)</p><p>百度云链接: <a href="https://pan.baidu.com/s/1slJU2Rz" target="_blank" rel="external">https://pan.baidu.com/s/1slJU2Rz</a> 密码: o400</p><h3 id="二、安装完成之后按照如下操作"><a href="#二、安装完成之后按照如下操作" class="headerlink" title="二、安装完成之后按照如下操作"></a>二、安装完成之后按照如下操作</h3><p><img src="https://ws1.sinaimg.cn/large/005DnJLEgy1flpp9oiwtbj30gy0a2wep.jpg" alt=""></p><p><img src="https://ws1.sinaimg.cn/large/005DnJLEgy1flppcbyy6xj30hm09cjrk.jpg" alt=""></p><p><img src="https://ws1.sinaimg.cn/large/005DnJLEgy1flppa2i3z2j30hm09caah.jpg" alt=""></p><p><img src="https://ws1.sinaimg.cn/large/005DnJLEgy1flppa2irogj30b907k74i.jpg" alt=""></p><p><strong>在右侧选中后右击——&gt;选择view instant properties</strong></p><p><img src="https://ws1.sinaimg.cn/large/005DnJLEgy1flppa2iv4cj30ki0aswev.jpg" alt=""></p><p>至此查看ScriptText项可知，这是一段VBScript调用系统服务间隔30分钟执行一次，将所有浏览器调用加上如下糟糕链接</p><p><img src="https://ws1.sinaimg.cn/large/005DnJLEgy1flppa2j33uj30lb0c0jsn.jpg" alt=""></p><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>选中左侧选项，点击上面的X按钮。 删不掉？ 到WMITool安装路径（例如：C:\Program Files (x86)\WMI Tools）下，右键点击wbemeventviewer.exe，选择以管理员身份运行！删之！<br><img src="https://ws1.sinaimg.cn/large/005DnJLEgy1flppfl3r75j30d106cglv.jpg" alt=""><br><img src="https://ws1.sinaimg.cn/large/005DnJLEgy1flppa2iaeij30hm09c3yz.jpg" alt=""></p><p>还没完，还要手动将快速启动栏中，将各个浏览器快捷命令中的<a href="http://hk.jtsh123.com/?r=b&amp;m=10去掉！" target="_blank" rel="external">http://hk.jtsh123.com/?r=b&amp;m=10去掉！</a></p><p><img src="https://ws1.sinaimg.cn/large/005DnJLEgy1flppgo35m6j30c307n3yp.jpg" alt=""></p><p>大功告成！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近一段时间发现，无论Chrome 还是 Firefox 主页都被流氓(hao123)劫持了。&lt;/p&gt;
&lt;p&gt;一些具体症状：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;删掉原先的快捷方式以后再重新创建一个，问题依然存在；&lt;/li&gt;
&lt;li&gt;快捷方式属性没有问题，没有后缀网址；&lt;/li&gt;
&lt;li&gt;直接启动exe文件没有异常；&lt;/li&gt;
&lt;li&gt;chrome主页设置也没有问题，但是如果重新设置一遍主页，从快捷方式就可以正常启动chrome，但再次启动电脑又会恢复原样；&lt;/li&gt;
&lt;li&gt;改exe文件名可解决但我不想用这种回避的方式。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本人又没有安装360，电脑管家等流氓软件的习惯，于是通过Google找到了解决办法，具体如下：&lt;/p&gt;
    
    </summary>
    
      <category term="实用教程" scheme="https://caoler.cn/categories/%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B/"/>
    
      <category term="浏览器" scheme="https://caoler.cn/categories/%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
      <category term="原创" scheme="https://caoler.cn/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="实用教程" scheme="https://caoler.cn/tags/%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java同步块</title>
    <link href="https://caoler.cn//post/2017/synchronized-blocks.html"/>
    <id>https://caoler.cn//post/2017/synchronized-blocks.html</id>
    <published>2017-11-20T10:44:00.000Z</published>
    <updated>2017-11-27T12:42:51.970Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Java 同步块（synchronized block）用来标记方法或者代码块是同步的。Java同步块用来避免竞争。</p><h2 id="Java-同步关键字（synchronized）"><a href="#Java-同步关键字（synchronized）" class="headerlink" title="Java 同步关键字（synchronized）"></a>Java 同步关键字（synchronized）</h2><p>Java中的同步块用synchronized标记。同步块在Java中是同步在某个对象上。所有同步在一个对象上的同步块在同时只能被一个线程进入并执行操作。所有其他等待进入该同步块的线程将被阻塞，直到执行该同步块中的线程退出。</p><p>有四种不同的同步块：</p><ul><li>实例方法</li><li>静态方法</li><li>实例方法中的同步块</li><li>静态方法中的同步块</li></ul><p>上述同步块都同步在不同对象上。实际需要那种同步块视具体情况而定。</p><a id="more"></a><h3 id="实例方法同步"><a href="#实例方法同步" class="headerlink" title="实例方法同步"></a>实例方法同步</h3><p>下面是一个同步的实例方法：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> synchronized <span class="keyword">void</span> <span class="title">add</span>(<span class="params"><span class="keyword">int</span> <span class="keyword">value</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.count += <span class="keyword">value</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意在方法声明中同步（synchronized ）关键字。这告诉Java该方法是同步的。</p><p><strong>Java实例方法同步是同步在拥有该方法的对象上。</strong> 这样，每个实例其方法同步都同步在不同的对象上，即该方法所属的实例。只有一个线程能够在实例方法同步块中运行。如果有多个实例存在，那么一个线程一次可以在一个实例同步块中执行操作。一个实例一个线程。</p><h3 id="静态方法同步"><a href="#静态方法同步" class="headerlink" title="静态方法同步"></a>静态方法同步</h3><p>静态方法同步和实例方法同步方法一样，也使用synchronized 关键字。Java静态方法同步如下示例：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> synchronized <span class="keyword">void</span> <span class="title">add</span>(<span class="params"><span class="keyword">int</span> <span class="keyword">value</span></span>)</span>&#123;</span><br><span class="line">    count += <span class="keyword">value</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>同样，这里synchronized 关键字告诉Java这个方法是同步的。</p><p><strong>静态方法的同步是指同步在该方法所在的类对象上。</strong> 因为在Java虚拟机中一个类只能对应一个类对象，所以同时只允许一个线程执行同一个类中的静态同步方法。</p><p>对于不同类中的静态同步方法，一个线程可以执行每个类中的静态同步方法而无需等待。不管类中的那个静态同步方法被调用，一个类只能由一个线程同时执行。</p><h3 id="实例方法中的同步块"><a href="#实例方法中的同步块" class="headerlink" title="实例方法中的同步块"></a>实例方法中的同步块</h3><p>有时你不需要同步整个方法，而是同步方法中的一部分。Java可以对方法的一部分进行同步。</p><p>在非同步的Java方法中的同步块的例子如下所示：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span>(<span class="params"><span class="keyword">int</span> <span class="keyword">value</span></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    synchronized(<span class="keyword">this</span>)&#123;</span><br><span class="line">       <span class="keyword">this</span>.count += <span class="keyword">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>示例使用Java同步块构造器来标记一块代码是同步的。该代码在执行时和同步方法一样。</p><p>注意Java同步块构造器用括号将对象括起来。在上例中，使用了“this”，即为调用add方法的实例本身。在同步构造器中用括号括起来的对象叫做监视器对象。上述代码使用监视器对象同步，同步实例方法使用调用方法本身的实例作为监视器对象。</p><p>一次只有一个线程能够在同步于同一个监视器对象的Java方法内执行。</p><p>下面两个例子都同步他们所调用的实例对象上，因此他们在同步的执行效果上是等效的。<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class MyClass &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> log1(<span class="keyword">String</span> msg1, <span class="keyword">String</span> msg2)&#123;</span><br><span class="line">      <span class="built_in">log</span>.writeln(msg1);</span><br><span class="line">      <span class="built_in">log</span>.writeln(msg2);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> log2(<span class="keyword">String</span> msg1, <span class="keyword">String</span> msg2)&#123;</span><br><span class="line">      <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">         <span class="built_in">log</span>.writeln(msg1);</span><br><span class="line">         <span class="built_in">log</span>.writeln(msg2);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在上例中，每次只有一个线程能够在两个同步块中任意一个方法内执行。</p><p>如果第二个同步块不是同步在this实例对象上，那么两个方法可以被线程同时执行。</p><h3 id="静态方法中的同步块"><a href="#静态方法中的同步块" class="headerlink" title="静态方法中的同步块"></a>静态方法中的同步块</h3><p>和上面类似，下面是两个静态方法同步的例子。这些方法同步在该方法所属的类对象上。<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class MyClass &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> log1(<span class="keyword">String</span> msg1, <span class="keyword">String</span> msg2)&#123;</span><br><span class="line">       <span class="built_in">log</span>.writeln(msg1);</span><br><span class="line">       <span class="built_in">log</span>.writeln(msg2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> log2(<span class="keyword">String</span> msg1, <span class="keyword">String</span> msg2)&#123;</span><br><span class="line">       <span class="keyword">synchronized</span>(MyClass.class)&#123;</span><br><span class="line">          <span class="built_in">log</span>.writeln(msg1);</span><br><span class="line">          <span class="built_in">log</span>.writeln(msg2);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这两个方法不允许同时被线程访问。</p><p>如果第二个同步块不是同步在MyClass.class这个对象上。那么这两个方法可以同时被线程访问。</p><h2 id="Java同步实例"><a href="#Java同步实例" class="headerlink" title="Java同步实例"></a>Java同步实例</h2><p>在下面例子中，启动了两个线程，都调用Counter类同一个实例的add方法。因为同步在该方法所属的实例上，所以同时只能有一个线程访问该方法。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Counter</span>&#123;</span><br><span class="line">     <span class="keyword">long</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> synchronized <span class="keyword">void</span> <span class="title">add</span>(<span class="params"><span class="keyword">long</span> <span class="keyword">value</span></span>)</span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.count += <span class="keyword">value</span>;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CounterThread</span> <span class="title">extends</span> <span class="title">Thread</span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">protected</span> Counter counter = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">CounterThread</span>(<span class="params">Counter counter</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.counter = counter;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">           counter.<span class="keyword">add</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Example</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span>&#123;</span><br><span class="line">      Counter counter = <span class="keyword">new</span> Counter();</span><br><span class="line">      Thread  threadA = <span class="keyword">new</span> CounterThread(counter);</span><br><span class="line">      Thread  threadB = <span class="keyword">new</span> CounterThread(counter);</span><br><span class="line"></span><br><span class="line">      threadA.start();</span><br><span class="line">      threadB.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>创建了两个线程。他们的构造器引用同一个Counter实例。<code>Counter.add</code>方法是同步在实例上，是因为add方法是实例方法并且被标记上<code>synchronized</code>关键字。因此每次只允许一个线程调用该方法。另外一个线程必须要等到第一个线程退出<code>add()</code>方法时，才能继续执行方法。</p><p>如果两个线程引用了两个不同的<code>Counter</code>实例，那么他们可以同时调用<code>add()</code>方法。这些方法调用了不同的对象，因此这些方法也就同步在不同的对象上。这些方法调用将不会被阻塞。如下面这个例子所示：<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] args)&#123;</span><br><span class="line">     Counter counterA = <span class="keyword">new</span> <span class="type">Counter</span>();</span><br><span class="line">     Counter counterB = <span class="keyword">new</span> <span class="type">Counter</span>();</span><br><span class="line">     Thread  threadA = <span class="keyword">new</span> <span class="type">CounterThread</span>(counterA);</span><br><span class="line">     Thread  threadB = <span class="keyword">new</span> <span class="type">CounterThread</span>(counterB);</span><br><span class="line"></span><br><span class="line">     threadA.start();</span><br><span class="line">     threadB.start();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意这两个线程，<code>threadA和threadB</code>，不再引用同一个<code>counter</code>实例。<code>CounterA和counterB</code>的<code>add</code>方法同步在他们所属的对象上。调用<code>counterA</code>的<code>add</code>方法将不会阻塞调用<code>counterB</code>的<code>add</code>方法。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>本文转载于<a href="http://ifeve.com/synchronized-blocks/" target="_blank" rel="external">并发编程网</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;Java 同步块（synchronized block）用来标记方法或者代码块是同步的。Java同步块用来避免竞争。&lt;/p&gt;
&lt;h2 id=&quot;Java-同步关键字（synchronized）&quot;&gt;&lt;a href=&quot;#Java-同步关键字（synchronized）&quot; class=&quot;headerlink&quot; title=&quot;Java 同步关键字（synchronized）&quot;&gt;&lt;/a&gt;Java 同步关键字（synchronized）&lt;/h2&gt;&lt;p&gt;Java中的同步块用synchronized标记。同步块在Java中是同步在某个对象上。所有同步在一个对象上的同步块在同时只能被一个线程进入并执行操作。所有其他等待进入该同步块的线程将被阻塞，直到执行该同步块中的线程退出。&lt;/p&gt;
&lt;p&gt;有四种不同的同步块：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;实例方法&lt;/li&gt;
&lt;li&gt;静态方法&lt;/li&gt;
&lt;li&gt;实例方法中的同步块&lt;/li&gt;
&lt;li&gt;静态方法中的同步块&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上述同步块都同步在不同对象上。实际需要那种同步块视具体情况而定。&lt;/p&gt;
    
    </summary>
    
      <category term="并发编程" scheme="https://caoler.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="线程安全" scheme="https://caoler.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="并发编程" scheme="https://caoler.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="转载" scheme="https://caoler.cn/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>JAVA与线程</title>
    <link href="https://caoler.cn//post/2017/java-and-thread.html"/>
    <id>https://caoler.cn//post/2017/java-and-thread.html</id>
    <published>2017-11-19T07:30:00.000Z</published>
    <updated>2017-11-27T12:42:37.446Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线程的实现方式"><a href="#线程的实现方式" class="headerlink" title="线程的实现方式"></a>线程的实现方式</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>在传统的操作系统中，拥有资源和独立调度的基本单位都是进程。在引入线程的操作系统中，线程是独立调度的基本单位，进程是资源拥有的基本单位。在同一进程中，线程的切换不会引起进程切换。在不同进程中进行线程切换,如从一个进程内的线程切换到另一个进程中的线程时，会引起进程切换</p><p>根据操作系统内核是否对线程可感知，可以把线程分为内核线程和用户线程</p><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>用户级线程(User-LevelThread, ULT)</td><td>由应用程序所支持的线程实现, 内核意识不到用户级线程的实现</td></tr><tr><td>内核级线程(Kemel-LevelThread, KLT)</td><td>内核级线程又称为内核支持的线程</td></tr></tbody></table><p>实现线程主要有3种方式：使用内核线程、使用用户级线程和使用用户线程加轻量级进程混合实现。</p><a id="more"></a><h3 id="使用内核线程实现"><a href="#使用内核线程实现" class="headerlink" title="使用内核线程实现"></a>使用内核线程实现</h3><p>内核线程就是直接由操作系统内核支持的线程，这种线程有内核来完成线程切换，内核通过调度器(Scheduler) 对线程进行调度，并负责将线程的任务映射到各个处理器上。</p><h4 id="轻量级进程-LWP"><a href="#轻量级进程-LWP" class="headerlink" title="轻量级进程(LWP)"></a>轻量级进程(LWP)</h4><p>程序一般不会直接使用内核线程，而是去使用内核线程的一种高级接口———轻量级进程（LWP），轻量级进程就是我们通常意义上所讲的线程，轻量级进程(LWP)是一种由内核支持的用户线程。它是基于内核线程的高级抽象，因此只有先支持内核线程，才能有LWP。</p><p><img src="https://ws1.sinaimg.cn/large/005DnJLEly1flndprfk3pj30cq08ot8z.jpg" alt="轻量级进程与内核线程之间的1:1的关系"></p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>多处理器系统中，内核能够并行执行同一进程内的多个线程</li><li>如果进程中的一个线程被阻塞，能够切换同一进程内的其他线程继续执行（用户级线程的一个缺点）</li><li>所有能够阻塞线程的调用都以系统调用的形式实现，代价可观</li><li>当一个线程阻塞时，内核根据选择可以运行另一个进程的线程，而用户空间实现的线程中，运行时系统始终运行自己进程中的线程</li><li>信号是发给进程而不是线程的，当一个信号到达时，应该由哪一个线程处理它？线程可以“注册”它们感兴趣的信号</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>对于用户的线程切换而言，其模式切换到饿开销较大，在同一个进程中，从一个线程切换到另一个线程时，需要从用户态转到核心态进行，这是因为用户的线程在用户态运行，而线程调度和管理实在内核中实现的，系统开销较大。</p><h3 id="使用用户线程实现"><a href="#使用用户线程实现" class="headerlink" title="使用用户线程实现"></a>使用用户线程实现</h3><p>LWP虽然本质上属于用户线程，但LWP线程库是建立在内核之上的，LWP的许多操作都要进行系统调用，因此效率不高。而这里的用户线程指的是完全建立在用户空间的线程库，用户线程的建立，同步，销毁，调度完全在用户空间完成，不需要内核的帮助。因此这种线程的操作是极其快速的且低消耗的。</p><p><img src="https://ws1.sinaimg.cn/large/005DnJLEly1flne300p6hj308805mt8n.jpg" alt="进程与用户线程之间的1:N的关系"></p><p>从中可以看出，进程中包含线程，用户线程在用户空间中实现，内核并没有直接对用户线程进程调度，内核的调度对象和传统进程一样，还是进程本身，内核并不知道用户线程的存在。用户线程之间的调度由在用户空间实现的线程库实现。</p><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul><li>可以在不支持线程的操作系统中实现。</li><li>创建和销毁线程、线程切换代价等线程管理的代价比内核线程少得多, 因为保存线程状态的过程和调用程序都只是本地过程</li><li>允许每个进程定制自己的调度算法，线程管理比较灵活。这就是必须自己写管理程序，与内核线程的区别</li><li>线程能够利用的表空间和堆栈空间比内核级线程多</li><li>不需要陷阱，不需要上下文切换，也不需要对内存高速缓存进行刷新，使得线程调用非常快捷</li><li>线程的调度不需要内核直接参与，控制简单。</li></ul><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul><li>线程发生I/O或页面故障引起的阻塞时，如果调用阻塞系统调用则内核由于不知道有多线程的存在，而会阻塞整个进程从而阻塞所有线程, 因此同一进程中只能同时有一个线程在运行</li><li>页面失效也会产生类似的问题。</li><li>一个单独的进程内部，没有时钟中断，所以不可能用轮转调度的方式调度线程</li><li>资源调度按照进程进行，多个处理机下，同一个进程中的线程只能在同一个处理机下分时复用</li></ul><blockquote><p>补充<br>在用户级线程中，每个进程里的线程表由运行时系统管理。当一个线程转换到就绪状态或阻塞状态时，在该线程表中存放重新启动该线程所需的信息，与内核在进程表中存放的进程的信息完全一样</p></blockquote><h3 id="使用用户线程加轻量级进程混合实现"><a href="#使用用户线程加轻量级进程混合实现" class="headerlink" title="使用用户线程加轻量级进程混合实现"></a>使用用户线程加轻量级进程混合实现</h3><p>这种模型对应着恐龙书中多对多模型。用户线程库还是完全建立在用户空间中，因此用户线程的操作还是很廉价，因此可以建立任意多需要的用户线程。操作系统提供了 LWP 作为用户线程和内核线程之间的桥梁。 LWP 还是和前面提到的一样，具有内核线程支持，是内核的调度单元，并且用户线程的系统调用要通过 LWP ，因此进程中某个用户线程的阻塞不会影响整个进程的执行。用户线程库将建立的用户线程关联到 LWP 上， LWP 与用户线程的数量不一定一致。当内核调度到某个 LWP 上时，此时与该 LWP 关联的用户线程就被执行。</p><p><img src="https://ws1.sinaimg.cn/large/005DnJLEgy1flne8uhdi7j30ba078jrj.jpg" alt="用户线程与轻量级进程之间的N:M的关系"></p><h2 id="JAVA线程调度"><a href="#JAVA线程调度" class="headerlink" title="JAVA线程调度"></a>JAVA线程调度</h2><p>进程调度属于低级调度，用来决定就绪队列中的那个进程获取处理器，然后有分派程序将执行把处理器分派给该进程的具体操作。进程调度的方式有两个非抢占式调度和抢占式调度</p><h3 id="非抢占方式-Non-preemptive-Mode"><a href="#非抢占方式-Non-preemptive-Mode" class="headerlink" title="非抢占方式(Non-preemptive Mode)"></a>非抢占方式(Non-preemptive Mode)</h3><p><strong>概念:</strong> 当某一进程正在处理机上执行时，即使有某个更为重要或紧迫的进程进入就绪队列，该进程仍继续执行，直到其完成或发生某种事件而进入完成或阻 塞状态时，才把处理机分配给更为重要或紧迫的进程 </p><p><strong>引起进程调度的因素:</strong></p><ul><li>正在执行的进程执行完毕， 或因发生某事件而不能再继续执行 </li><li>执行中的进程因提出I/O请求而暂停执行； </li><li>在进程通信或同步过程中执行了某种原语操作，如wait、Block、Wakeup原语 </li></ul><p><strong>优点:</strong> 算法简单，系统开销小 </p><p><strong>缺点:</strong> 紧急任务不能及时响应；短进程到达要等待长进程运行结束<br>适用于大多数批处理系统环境 </p><h3 id="抢占方式-Preemptive-Mode"><a href="#抢占方式-Preemptive-Mode" class="headerlink" title="抢占方式(Preemptive Mode)"></a>抢占方式(Preemptive Mode)</h3><p><strong>概念:</strong> 当某一进程正在处理机上执行时，若有某个更为重要或紧迫的进程进入就绪队列，则立即暂停正在执行的进程，将处理机分配给这个更为重要或紧迫的进程 </p><p><strong>抢占式调度主要有以下原则</strong></p><ul><li>优先权原则 允许高优先权的新到进程抢占当前进程的处理机 </li><li>短作业(进程)优先原则允许执行时间短的新到进程抢占当前进程的处理机 </li><li>时间片原则 时间片用完后停止执行，重新进行调度，适用于分时系统</li></ul><p><strong>优点：</strong> 适于时间要求严格的实时系统 </p><p><strong>缺点：</strong> 调度算法复杂，系统开销大</p><h2 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h2><p><img src="https://ws1.sinaimg.cn/large/005DnJLEgy1flnf9avvzlj30hs0cot9e.jpg" alt=""></p><p><strong>线程间的状态转换：</strong> </p><ol><li><p>新建(new)：新创建了一个线程对象。</p></li><li><p>可运行(runnable)：线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取cpu 的使用权 。</p></li><li><p>运行(running)：可运行状态(runnable)的线程获得了cpu 时间片（timeslice） ，执行程序代码。</p></li><li><p>阻塞(block)：阻塞状态是指线程因为某种原因放弃了cpu 使用权，也即让出了cpu timeslice，暂时停止运行。直到线程进入可运行(runnable)状态，才有机会再次获得cpu timeslice 转到运行(running)状态。阻塞的情况分三种： </p><ul><li>等待阻塞：运行(running)的线程执行o.wait()方法，JVM会把该线程放入等待队列(waitting queue)中。</li><li>同步阻塞：运行(running)的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池(lock pool)中。</li><li>其他阻塞：运行(running)的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。</li></ul></li><li><p>死亡(dead)：线程run()、main() 方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。</p></li></ol><p><img src="https://ws1.sinaimg.cn/large/005DnJLEgy1flnf9i3jjoj30qw0iwwgo.jpg" alt=""></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>CSDN:  <a href="http://blog.csdn.net/ylyuanlu/article/details/9115073" target="_blank" rel="external">linux内核线程、轻量级进程和用户进程</a></li><li>CSDN: <a href="http://blog.csdn.net/gatieme/article/details/51892437" target="_blank" rel="external">线程的3种实现方式–内核级线程, 用户级线程和混合型线程</a></li><li>计算机操作系统（第四版）2.8.1/3.3.1</li><li>深入理解Java虚拟机：JVM高级特性与最佳实践（第二版）</li><li>CSDN ：<a href="http://blog.csdn.net/u011774517/article/details/61418550" target="_blank" rel="external">进程调度方式</a></li><li>OSChina：<a href="https://my.oschina.net/mingdongcheng/blog/139263" target="_blank" rel="external">一张图让你看懂JAVA线程间的状态转换</a></li><li>今日头条：<a href="https://www.toutiao.com/i6368772681411592706/" target="_blank" rel="external">Java线程状态转换</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;线程的实现方式&quot;&gt;&lt;a href=&quot;#线程的实现方式&quot; class=&quot;headerlink&quot; title=&quot;线程的实现方式&quot;&gt;&lt;/a&gt;线程的实现方式&lt;/h2&gt;&lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;在传统的操作系统中，拥有资源和独立调度的基本单位都是进程。在引入线程的操作系统中，线程是独立调度的基本单位，进程是资源拥有的基本单位。在同一进程中，线程的切换不会引起进程切换。在不同进程中进行线程切换,如从一个进程内的线程切换到另一个进程中的线程时，会引起进程切换&lt;/p&gt;
&lt;p&gt;根据操作系统内核是否对线程可感知，可以把线程分为内核线程和用户线程&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;用户级线程(User-LevelThread, ULT)&lt;/td&gt;
&lt;td&gt;由应用程序所支持的线程实现, 内核意识不到用户级线程的实现&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;内核级线程(Kemel-LevelThread, KLT)&lt;/td&gt;
&lt;td&gt;内核级线程又称为内核支持的线程&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;实现线程主要有3种方式：使用内核线程、使用用户级线程和使用用户线程加轻量级进程混合实现。&lt;/p&gt;
    
    </summary>
    
      <category term="并发编程" scheme="https://caoler.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="JAVA与线程" scheme="https://caoler.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/JAVA%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="原创" scheme="https://caoler.cn/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="并发编程" scheme="https://caoler.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="操作系统" scheme="https://caoler.cn/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>先行并发原则</title>
    <link href="https://caoler.cn//post/2017/Happens-Before.html"/>
    <id>https://caoler.cn//post/2017/Happens-Before.html</id>
    <published>2017-11-18T06:26:00.000Z</published>
    <updated>2017-11-27T12:39:53.469Z</updated>
    
    <content type="html"><![CDATA[<p>先行发生原则（Happens-Before）是判断数据是否存在竞争、线程是否安全的主要依据。</p><p>先行发生是Java内存，模型中定义的两项操作之间的偏序关系，如果操作A先行发生于操作B，那么操作A产生的影响能够被操作B观察到,”影响”包括修改了内存中共享变量的值、发送了消息、调用了方法等。</p><p>Java内存模型中存在的天然的先行发生关系：</p><a id="more"></a><ol><li><p>程序次序规则：同一个线程内，按照代码出现的顺序，前面的代码先行于后面的代码，准确的说是控制流顺序，因为要考虑到分支和循环结构。</p></li><li><p>管程锁定规则：一个unlock操作先行发生于后面（时间上）对同一个锁的lock操作。</p></li><li><p>volatile变量规则：对一个volatile变量的写操作先行发生于后面（时间上）对这个变量的读操作。</p></li><li><p>线程启动规则：Thread的start( )方法先行发生于这个线程的每一个操作。</p></li><li><p>线程终止规则：线程的所有操作都先行于此线程的终止检测。可以通过Thread.join( )方法结束、Thread.isAlive( )的返回值等手段检测线程的终止。 </p></li><li><p>线程中断规则：对线程interrupt( )方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupt( )方法检测线程是否中断</p></li><li><p>对象终结规则：一个对象的初始化完成先行于发生它的finalize（）方法的开始。</p></li><li><p>传递性：如果操作A先行于操作B，操作B先行于操作C，那么操作A先行于操作C。</p></li></ol><p><strong>总结</strong>：一个操作“时间上的先发生”不代表这个操作先行发生；一个操作先行发生也不代表这个操作在时间上是先发生的（重排序的出现）。<br>时间上的先后顺序对先行发生没有太大的关系，所以衡量并发安全问题的时候不要受到时间顺序的影响，一切以先行发生原则为准。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;先行发生原则（Happens-Before）是判断数据是否存在竞争、线程是否安全的主要依据。&lt;/p&gt;
&lt;p&gt;先行发生是Java内存，模型中定义的两项操作之间的偏序关系，如果操作A先行发生于操作B，那么操作A产生的影响能够被操作B观察到,”影响”包括修改了内存中共享变量的值、发送了消息、调用了方法等。&lt;/p&gt;
&lt;p&gt;Java内存模型中存在的天然的先行发生关系：&lt;/p&gt;
    
    </summary>
    
      <category term="并发编程" scheme="https://caoler.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="内存模型" scheme="https://caoler.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    
    
      <category term="原创" scheme="https://caoler.cn/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="并发编程" scheme="https://caoler.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>JAVA的原子性、可见性、有序性</title>
    <link href="https://caoler.cn//post/2017/javasanxin.html"/>
    <id>https://caoler.cn//post/2017/javasanxin.html</id>
    <published>2017-11-16T09:26:00.000Z</published>
    <updated>2017-11-27T12:37:27.074Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>是指一个操作或多个操作要么全部执行，且执行的过程不会被任何因素打断，要么都不执行。</p><h3 id="原子操作原理（处理器是如何实现原子操作的）"><a href="#原子操作原理（处理器是如何实现原子操作的）" class="headerlink" title="原子操作原理（处理器是如何实现原子操作的）"></a>原子操作原理（处理器是如何实现原子操作的）</h3><p>处理器实现原子操作有3种方式：</p><ol><li>处理器自动保证基本内存操作的原子性</li><li>使用总线锁保证原子性</li><li>使用缓存锁保证原子性</li></ol><a id="more"></a><h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>可见性是指：当一个线程修改了线程共享变量的值，其它线程能够立即得知这个修改。</p><p>Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方法来实现可见性的，无论是普通变量还是volatile变量都是如此。</p><h3 id="普通变量与volatile变量的区别"><a href="#普通变量与volatile变量的区别" class="headerlink" title="普通变量与volatile变量的区别"></a>普通变量与volatile变量的区别</h3><p>是volatile的特殊规则保证了新值能立即同步到主内存，以及每使用前立即从内存刷新。因为我们可以说volatile保证了线程操作时变量的可见性，而普通变量则不能保证这一点。</p><h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>有序性：即程序执行的顺序按照代码的先后顺序执行。</p><p>Java内存模型中的程序天然有序性可以总结为一句话：<strong>如果在本线程内观察，所有操作都是有序的；如果在一个线程中观察另一个线程，所有操作都是无序的。</strong> 前半句是指“线程内表现为串行语义”，后半句是指“指令重排序”现象和“工作内存主主内存同步延迟”现象。</p><p>有序性的语意有几层， </p><ol><li>最常见的就是保证多线程运行的串行顺序 </li><li>防止重排序引起的问题 </li><li>程序运行的先后顺序。比方JMM定义的一些Happens-before规则</li></ol><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger atomicCount = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> synchronizedCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//  分别调用，打印结果</span></span><br><span class="line">        <span class="comment">// volatileCount();</span></span><br><span class="line">        <span class="comment">//  atomicCount();</span></span><br><span class="line">        synchronizedCount();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">volatileCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            Executors.newFixedThreadPool(<span class="number">3</span>).execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 虽然使用volatile关键字修饰int变量，但是对于多线程的环境下，也很难保证没问题，所以一般用来修饰标志位</span></span><br><span class="line">                    System.out.println(<span class="string">"volatile count: "</span> + ++count);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//    打印结果：有重复数据，且顺序错乱。表示数据操作不是原子的，线程之间也不是有序的</span></span><br><span class="line">    <span class="comment">//    volatile count: 1</span></span><br><span class="line">    <span class="comment">//    volatile count: 5</span></span><br><span class="line">    <span class="comment">//    volatile count: 4</span></span><br><span class="line">    <span class="comment">//    volatile count: 3</span></span><br><span class="line">    <span class="comment">//    volatile count: 1</span></span><br><span class="line">    <span class="comment">//    volatile count: 2</span></span><br><span class="line">    <span class="comment">//    volatile count: 6</span></span><br><span class="line">    <span class="comment">//    volatile count: 7</span></span><br><span class="line">    <span class="comment">//    volatile count: 8</span></span><br><span class="line">    <span class="comment">//    volatile count: 9</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">atomicCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            Executors.newFixedThreadPool(<span class="number">3</span>).execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 通过使用Atomic包中的原子类保证数据操作是原子的（数据没有重复，表示是原子操作），但是不能保障有序性</span></span><br><span class="line">                    System.out.println(<span class="string">"atomic count: "</span> + atomicCount.incrementAndGet());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//    打印结果：虽然顺序错乱，但是数据没有重复，也就说明保障了数据的操作是原子的，但是线程间不是有序的</span></span><br><span class="line">    <span class="comment">//    atomic count: 1</span></span><br><span class="line">    <span class="comment">//    atomic count: 2</span></span><br><span class="line">    <span class="comment">//    atomic count: 3</span></span><br><span class="line">    <span class="comment">//    atomic count: 5</span></span><br><span class="line">    <span class="comment">//    atomic count: 8</span></span><br><span class="line">    <span class="comment">//    atomic count: 9</span></span><br><span class="line">    <span class="comment">//    atomic count: 10</span></span><br><span class="line">    <span class="comment">//    atomic count: 4</span></span><br><span class="line">    <span class="comment">//    atomic count: 7</span></span><br><span class="line">    <span class="comment">//    atomic count: 6</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">synchronizedCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            Executors.newFixedThreadPool(<span class="number">3</span>).execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (MyClass.class) &#123;  <span class="comment">// 通过synchronized关键字来保证线程之间的有序性</span></span><br><span class="line">                        System.out.println(<span class="string">"synchronized count: "</span> + ++synchronizedCount);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//    打印结果：没有重复数据，也没有错乱现象，说明数据操作是原子的，同时线程操作也是顺序的。同时也说明，有序性可以保障数据操作的原子性</span></span><br><span class="line">    <span class="comment">//    synchronized count: 1</span></span><br><span class="line">    <span class="comment">//    synchronized count: 2</span></span><br><span class="line">    <span class="comment">//    synchronized count: 3</span></span><br><span class="line">    <span class="comment">//    synchronized count: 4</span></span><br><span class="line">    <span class="comment">//    synchronized count: 5</span></span><br><span class="line">    <span class="comment">//    synchronized count: 6</span></span><br><span class="line">    <span class="comment">//    synchronized count: 7</span></span><br><span class="line">    <span class="comment">//    synchronized count: 8</span></span><br><span class="line">    <span class="comment">//    synchronized count: 9</span></span><br><span class="line">    <span class="comment">//    synchronized count: 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><ul><li>CSDN:  <a href="http://blog.csdn.net/qq_33689414/article/details/73527438" target="_blank" rel="external">Java的原子性&amp;&amp;可见性&amp;&amp;有序性</a></li><li>深入理解Java虚拟机：JVM高级特性与最佳实践（第二版）</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;原子性&quot;&gt;&lt;a href=&quot;#原子性&quot; class=&quot;headerlink&quot; title=&quot;原子性&quot;&gt;&lt;/a&gt;原子性&lt;/h2&gt;&lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h3&gt;&lt;p&gt;是指一个操作或多个操作要么全部执行，且执行的过程不会被任何因素打断，要么都不执行。&lt;/p&gt;
&lt;h3 id=&quot;原子操作原理（处理器是如何实现原子操作的）&quot;&gt;&lt;a href=&quot;#原子操作原理（处理器是如何实现原子操作的）&quot; class=&quot;headerlink&quot; title=&quot;原子操作原理（处理器是如何实现原子操作的）&quot;&gt;&lt;/a&gt;原子操作原理（处理器是如何实现原子操作的）&lt;/h3&gt;&lt;p&gt;处理器实现原子操作有3种方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;处理器自动保证基本内存操作的原子性&lt;/li&gt;
&lt;li&gt;使用总线锁保证原子性&lt;/li&gt;
&lt;li&gt;使用缓存锁保证原子性&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="并发编程" scheme="https://caoler.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="内存模型" scheme="https://caoler.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    
    
      <category term="原创" scheme="https://caoler.cn/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="并发编程" scheme="https://caoler.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Volatile型变量的语义解释</title>
    <link href="https://caoler.cn//post/2017/volatile.html"/>
    <id>https://caoler.cn//post/2017/volatile.html</id>
    <published>2017-11-16T08:41:00.000Z</published>
    <updated>2017-11-27T12:41:44.751Z</updated>
    
    <content type="html"><![CDATA[<p>关键字volatile可以说是Java虚拟机提供的最轻量级的同步机制，但是它并不容易完全被正确、 完整地理解，以至于许多程序员都习惯不去使用它，遇到需要处理多线程数据竞争问题的时候一律使用synchronized来进行同步。 了解volatile变量的语义对后面了解多线程操作的其他特性很有意义，在这里我们将多花费一些时间去弄清楚volatile的语义到底是什么。</p><p>Java内存模型对volatile专门定义了一些特殊的访问规则，在介绍这些比较拗口的规则定义之前，笔者先用不那么正式但通俗易懂的语言来介绍一下这个关键字的作用。</p><a id="more"></a><h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p><strong>当一个变量定义为volatile之后，它将具备两种特性，第一是保证此变量对所有线程的可见性，这里的“可见性”是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。</strong> 而普通变量不能做到这一点，普通变量的值在线程间传递均需要通过主内存来完成，例如，线程A修改一个普通变量的值，然后向主内存进行回写，另外一条线程B在线程A回写完成了之后再从主内存进行读取操作，新变量值才会对线程B可见。</p><p>volatile变量在各个线程的工作内存中不存在一致性问题（在各个线程的工作内存中，volatile变量也可以存在不一致的情况，但由于每次使用之前都要先刷新，执行引擎看不到不一致的情况，因此可以认为不存在一致性问题），但是Java里面的运算并非原子操作，导致volatile变量的运算在并发下一样是不安全的.</p><h2 id="禁止指令重排序优化"><a href="#禁止指令重排序优化" class="headerlink" title="禁止指令重排序优化"></a>禁止指令重排序优化</h2><p>使用volatile变量的第二个语义是禁止指令重排序优化，普通的变量仅仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。 因为在一个线程的方法执行过程中无法感知到这点，这也就是Java内存模型中描述的所谓的“线程内表现为串行的语义”（Within-Thread As-If-SerialSemantics）。 </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>解决了volatile的语义问题，再来看看在众多保障并发安全的工具中选用volatile的意义——它能让我们的代码比使用其他的同步工具更快吗？在某些情况下，volatile的同步机制的性能确实要优于锁（使用synchronized关键字或java.util.concurrent包里面的锁），但是由于虚拟机对锁实行的许多消除和优化，使得我们很难量化地认为volatile就会比synchronized快多少。 如果让volatile自己与自己比较，那可以确定一个原则：volatile变量读操作的性能消耗与普通变量几乎没有什么差别，但是写操作则可能会慢一些，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行。 不过即便如此，大多数场景下volatile的总开销仍然要比锁低，我们在volatile与锁之中选择的唯一依据仅仅是volatile的语义能否满足使用场景的需求。</p><p>需要注意两点</p><ol><li>load、read动作相关联，必须连续一起出现。</li><li>store、writer动作相关联，必须连续一起出现。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关键字volatile可以说是Java虚拟机提供的最轻量级的同步机制，但是它并不容易完全被正确、 完整地理解，以至于许多程序员都习惯不去使用它，遇到需要处理多线程数据竞争问题的时候一律使用synchronized来进行同步。 了解volatile变量的语义对后面了解多线程操作的其他特性很有意义，在这里我们将多花费一些时间去弄清楚volatile的语义到底是什么。&lt;/p&gt;
&lt;p&gt;Java内存模型对volatile专门定义了一些特殊的访问规则，在介绍这些比较拗口的规则定义之前，笔者先用不那么正式但通俗易懂的语言来介绍一下这个关键字的作用。&lt;/p&gt;
    
    </summary>
    
      <category term="并发编程" scheme="https://caoler.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="内存模型" scheme="https://caoler.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    
    
      <category term="原创" scheme="https://caoler.cn/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="并发编程" scheme="https://caoler.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java内存模型</title>
    <link href="https://caoler.cn//post/2017/java-memory-model-1.html"/>
    <id>https://caoler.cn//post/2017/java-memory-model-1.html</id>
    <published>2017-11-16T08:38:00.000Z</published>
    <updated>2017-11-27T12:43:11.796Z</updated>
    
    <content type="html"><![CDATA[<p>并发处理的广泛应用是使得Amdahl定律代替摩尔定律成为计算机性能发展源动力的根本原因，也是人类“压榨”计算机运算能力的最有力武器。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Java内存模型规范了Java虚拟机与计算机内存是如何协同工作的。Java虚拟机是一个完整的计算机的一个模型，因此这个模型自然也包含一个内存模型——又称为Java内存模型。</p><p>如果你想设计表现良好的并发程序，理解Java内存模型是非常重要的。Java内存模型规定了如何和何时可以看到由其他线程修改过后的共享变量的值，以及在必须时如何同步的访问共享变量。</p><a id="more"></a><p>原始的Java内存模型存在一些不足，因此Java内存模型在Java1.5时被重新修订。这个版本的Java内存模型在Java8中仍在使用。</p><h2 id="硬件的效率与一致性"><a href="#硬件的效率与一致性" class="headerlink" title="硬件的效率与一致性"></a>硬件的效率与一致性</h2><p>现代计算机在执行并发任务的时候，为了更充分的利用计算机处理器的效能，所以不得不加入一层读写速度尽可能接近处理器运算速度的<strong>高速缓存（Cache）</strong> 来作为内存与处理器之间的缓冲：将运算与要用到的数据复制到缓存中，让运算能够快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无须等待缓慢的内存读写了。</p><p><img src="https://ws1.sinaimg.cn/large/005DnJLEgy1fljyymlm4yj30ov09w0t8.jpg" alt=""></p><p>每个CPU可能还有一个CPU缓存层。实际上，绝大多数的现代CPU都有一定大小的缓存层。CPU访问缓存层的速度快于访问主存的速度，但通常比访问内部寄存器的速度还要慢一点。一些CPU还有多层缓存，但这些对理解Java内存模型如何和内存交互不是那么重要。只要知道CPU中可以有一个缓存层就可以了。</p><p>通常情况下，当一个CPU需要读取主存时，它会将主存的部分读到CPU缓存中。它甚至可能将缓存中的部分内容读到它的内部寄存器中，然后在寄存器中执行操作。当CPU需要将结果写回到主存中去时，它会将内部寄存器的值刷新到缓存中，然后在某个时间点将值刷新回主存。</p><p>当CPU需要在缓存层存放一些东西的时候，存放在缓存中的内容通常会被刷新回主存。CPU缓存可以在某一时刻将数据局部写到它的内存中，和在某一时刻局部刷新它的内存。它不会再某一时刻读/写整个缓存。通常，在一个被称作“cache lines”的更小的内存块中缓存被更新。一个或者多个缓存行可能被读到缓存，一个或者多个缓存行可能再被刷新回主存。</p><p>“内存模型”一词可以理解为在特定的操作协议下，对特定的内存或者高速缓存进行读写访问的过程抽象。</p><h2 id="JAVA内存模型"><a href="#JAVA内存模型" class="headerlink" title="JAVA内存模型"></a>JAVA内存模型</h2><p>JAVA虚拟机规范中视图定义一种JAVA内存模型(JMM)来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让JAVA程序在各种平台下都能够达到一致的内存访问效果。Java1.5发布后，Java内存模型已经成熟和完善起来了。</p><h3 id="JVM内部存储结构—堆、线程栈"><a href="#JVM内部存储结构—堆、线程栈" class="headerlink" title="JVM内部存储结构—堆、线程栈"></a>JVM内部存储结构—堆、线程栈</h3><p>Java内存模型把Java虚拟机内部划分为线程栈和堆。如下图所示：</p><p><img src="https://ws1.sinaimg.cn/large/005DnJLEgy1fljzmse453j309y07pdfo.jpg" alt=""></p><p>栈是运行时的单位，而堆是存储的单位。在Java中每一个运行在Java虚拟机里的线程都拥有自己的线程栈。一个线程仅能访问自己的线程栈。一个线程创建的本地变量对其它线程不可见，即使两个线程执行的是同一段代码，它们也会在各自的线程栈中创建各自的本地变量。</p><ol><li>所有的基本类型的本地变量和对象引用都存放在栈中，因此对其它线程不可见。一个线程可能向另一个线程传递一个基本类型变量的拷贝，但是它不能共享这个基本类型变量自身。</li><li>对象都存放在堆中，包括基本类型的对象版本。如果一个对象被创建然后赋值给一个局部变量，或者用来作为另一个对象的成员变量，这个对象任然是存放在堆上。</li><li>一个本地变量也可能是指向一个对象的一个引用。在这种情况下，引用（这个本地变量）存放在线程栈上，但是对象本身存放在堆上。</li><li>一个对象可能包含方法，这些方法可能包含本地变量。这些本地变量任然存放在线程栈上，即使这些方法所属的对象存放在堆上。</li><li>一个对象的成员变量可能随着这个对象自身存放在堆上。不管这个成员变量是原始类型还是引用类型。</li><li>静态成员变量跟随着类定义一起也存放在堆上。</li><li>存放在堆上的对象可以被所有持有对这个对象引用的线程访问。当多个线程通过调用同一个对象的相同方法访问其成员变量的时候，每个线程都将拥有该成员变量的拷贝而不是其自身。</li></ol><h3 id="主内存和工作内存"><a href="#主内存和工作内存" class="headerlink" title="主内存和工作内存"></a>主内存和工作内存</h3><p>Java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存中取出变量这样的底层细节。此处的<strong>变量(Variables)</strong> 与Java编程中所说的变量有所区别，它包括了实例字段、静态字段和构成数组对象的元素，但不包括局部变量与方法参数，因为后者不是私有的，<strong>不会被共享，自然就不会存在竞争问题。</strong></p><p>JAVA内存模型规定了所有的变量都存储在主内存中。每条线程还有自己的工作内存(与计算机的高速缓冲类比),线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取、赋值）都必须在工作内存中进行，而不能直接读写主内存中的变量。不同的线程之间也无法访问对方工作内存中的变量，线程间变量值的传递云需要通过主内存来完成。</p><p><img src="https://ws1.sinaimg.cn/large/005DnJLEgy1fljyz7yuqbj30od09v74s.jpg" alt=""></p><p>Java内存模型与硬件内存架构之间存在差异。硬件内存架构没有区分线程栈和堆。对于硬件，所有的线程栈和堆都分布在主内中。部分线程栈和堆可能有时候会出现在CPU缓存中和CPU内部的寄存器中。这种交叉对应关系如下图所示：  </p><p><img src="https://ws1.sinaimg.cn/large/005DnJLEgy1fljynkoplcj30mp0ao0t4.jpg" alt=""></p><p>当对象和变量被存放在计算机中各种不同的内存区域中时，就可能会出现一些具体的问题。主要包括如下两个方面：</p><ul><li>线程对共享变量修改的可见性</li><li>当读，写和检查共享变量时出现race conditions</li></ul><h3 id="内存间交互操作"><a href="#内存间交互操作" class="headerlink" title="内存间交互操作"></a>内存间交互操作</h3><p>交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存之间的细节操作。虚拟机保证下列操作都是原子的、不可再分的。</p><table><thead><tr><th>状态</th><th>作用内存</th><th>功能</th></tr></thead><tbody><tr><td>lock（锁定）</td><td>主</td><td>将变量标识为线程独占状态</td></tr><tr><td>unlock（解锁）</td><td>主</td><td>释放锁定的变量，释放后的变量才可以被锁定</td></tr><tr><td>read（读取）</td><td>主</td><td>将变量的值从主内存传输到线程的工作内存中</td></tr><tr><td>load（载入）</td><td>工作</td><td>把read到的变量放入工作内存的变量副本中</td></tr><tr><td>use（使用）</td><td>工作</td><td>将工作内存中的变量值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时会执行这个操作</td></tr><tr><td>assign（赋值）</td><td>工作</td><td>将执行引擎中的变量值传递给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时会执行这个操作</td></tr><tr><td>store（存储）</td><td>工作</td><td>将工作内存中的一个变量的值传递到主内存中</td></tr><tr><td>write（写入）</td><td>主</td><td>将得到的变量的值放入主内存的变量中</td></tr></tbody></table><p>线程、工作内存、主内存三者的交互关系如下图所示：<br><img src="https://ws1.sinaimg.cn/large/005DnJLEly1fljzjvie8jj30nr0af0u2.jpg" alt=""></p><p>JAVA内存模型规定上述操作必须按顺序执行，但是没有保证是连续执行，也就说其中某连续两个操作之间可以插入其他指令，除此之外JAVA内存模型还规定执行上述操作时需要满足较多规则，<a href="http://pzh9527.iteye.com/blog/2386925" target="_blank" rel="external">规则详情查看</a> 这里不做详细说明。</p><p>8种内存访问操作以及上述规定以及完全确定了JAVA程序中那些内存访问操作在并发下是安全的。由于过于严谨，实践起来很麻烦，所以 <a href="https://caoler.cn/blog/2017/%E5%85%88%E8%A1%8C%E5%8F%91%E7%94%9F%E5%8E%9F%E5%88%99%EF%BC%88Happens-before%EF%BC%89.html">此篇文章</a> 将介绍这种定义的一个等效判断原则————先行发生原则，来确认一个访问在并发环境下是否安全。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>并发编程网：<a href="http://ifeve.com/java-memory-model-6/" target="_blank" rel="external">Java内存模型</a></li><li>iteye：<a href="http://pzh9527.iteye.com/blog/2386925" target="_blank" rel="external">Java内存模型JMM之一内存交互操作</a></li><li>深入理解Java虚拟机：JVM高级特性与最佳实践（第二版）</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;并发处理的广泛应用是使得Amdahl定律代替摩尔定律成为计算机性能发展源动力的根本原因，也是人类“压榨”计算机运算能力的最有力武器。&lt;/p&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;Java内存模型规范了Java虚拟机与计算机内存是如何协同工作的。Java虚拟机是一个完整的计算机的一个模型，因此这个模型自然也包含一个内存模型——又称为Java内存模型。&lt;/p&gt;
&lt;p&gt;如果你想设计表现良好的并发程序，理解Java内存模型是非常重要的。Java内存模型规定了如何和何时可以看到由其他线程修改过后的共享变量的值，以及在必须时如何同步的访问共享变量。&lt;/p&gt;
    
    </summary>
    
      <category term="并发编程" scheme="https://caoler.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="内存模型" scheme="https://caoler.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    
    
      <category term="原创" scheme="https://caoler.cn/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="并发编程" scheme="https://caoler.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>全站开启HTTPS加密模式访问</title>
    <link href="https://caoler.cn//post/2017/ssl-https.html"/>
    <id>https://caoler.cn//post/2017/ssl-https.html</id>
    <published>2017-11-14T09:17:00.000Z</published>
    <updated>2017-11-27T12:41:05.485Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近发现，各大网站好像已经开始全站使用HTTPS，看着浏览器地址栏左边有着一把绿色的小锁，好像是一件很酷的事情。国内的网络环境好像越来越差，除了学会科学上网之外，好像也难免会遇到通讯服务商在网站上加上小广告的问题。随着不断了解计算机的知识，安全概念也越来越重。看着某某网站又被脱裤，一不小心自己的隐私可能就泄露出去了。在社工库上一查，还真能发现自己小学时候使用过的密码。不过，现在当然已经学会了各种措施，每个网站独立密码，能双重保护地就进行双重保护。1password也是我经常使用的一个密码管理软件……啊，好像扯远了。今天，天气很好，也想给自己的博客加上把绿色的小锁HTTPS。</p><h2 id="什么是HTTPS"><a href="#什么是HTTPS" class="headerlink" title="什么是HTTPS"></a>什么是HTTPS</h2><a id="more"></a><p>HTTPS全称Hypertext Transfer Protocol Secure 超文本安全协议。也就是HTTP加上安全传输层协议TSL/SSL。介于HTTP层与TCP层之间的一层安全协议。通过安全认证，可以避免HTTP中间人攻击，信息污染，信息劫持等问题。详细信息的话<a href="https://segmentfault.com/a/1190000004199917" target="_blank" rel="external">腾讯Bugly的文章</a>全站HTTPS来了介绍得很详细。HTTPS基础原理，通信过程，在这篇文章里都有详细地讲到。</p><p>直接进入主题，为博客加上HTTPS吧。</p><h2 id="给博客加上HTTPS"><a href="#给博客加上HTTPS" class="headerlink" title="给博客加上HTTPS"></a>给博客加上HTTPS</h2><h3 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h3><p>通过上述的HTTPS介绍，可以知道如果我们要给让博客的协议变成HTTPS，就需要有CA认可的证书才可以，一般这样子的证书是需要自己进行购买和申请认证的。简单RSA非对称性的加密算法是无法避免中间人攻击的。存在着中间人攻击和信息抵赖的风险。所以我这里所采用的方法是用，Cloudflare所提供的CDN来作为HTTPS的接入口。</p><h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3><p>什么是CDN? CDN的全称就是Content Delivery Network，内容分发网络。其最基本的思路就是，用户在访问一个网站的时候，不直接访问这个网站的服务器，CDN系统会根据地理位置，将用户重新导向离其最近的CDN服务器。网站的内容在这个CDN服务器上会有相应的缓存，从而使用户更快地访问到所需要的内容，可以减少网络拥堵的情况，也可以减轻网站的服务器承受太大的访问量，以及带宽不足的情况。</p><h3 id="主要步骤"><a href="#主要步骤" class="headerlink" title="主要步骤"></a>主要步骤</h3><ul><li>注册Cloudflare，添加个人网站</li><li>获取Cloudflare的Domain Name Server</li><li>在域名提供商处修改自己域名的Domain Name Server为2所获取的DNS</li><li>开启SSL加密，选择flexible</li><li>开启强制跳转，使http自动跳转到https</li></ul><p>步骤1，2在注册cloudflare的过程中，跟着流程一步一步做就好了。步骤3的话我们要先取消掉原有的DNS的解析服务，修改为cloudflare的DNS的地址。然后在Cloudflare的DNS中添加相应的DNS记录即可。可能会用到的DNS record大概有下面几种</p><blockquote><p>A记录: 将一个域名指向一个ipv4的地址<br>AAAA记录: 将一个域名指向一个ipv6的地址<br>CNAME记录: 将一个域名指向另一个域名</p></blockquote><p>步骤4中，我们所使用的是flexible的SSL加密方式。这种加密方式<br>根据cloudflare的解释如下：</p><blockquote><p>Flexible SSL: There is an encrypted connection between your website visitors and Cloudflare, but not from Cloudflare to your server.<br>You do not need an SSL certificate on your server<br>Visitors will see the SSL lock icon in their browser</p></blockquote><p><img src="https://ws1.sinaimg.cn/large/005DnJLEly1flhq7b9nwkj30k00cvq36.jpg" alt=""><br>也就是说这其实不是一种安全的加密方式，因为其实服务器与CDN在通信过程中的信息是没有加密的。但是因为我使用的git page 以及没有购买相应的证书，所以没法再服务器上部署SSL。所以CDN与服务器之间的通信就不是加密的通信。</p><p>步骤5共有两种方法</p><ul><li>第一种：在cloudflare上的Page Rules设置中，添加上一条规则使得通过http协议的访问也会强制跳转到https上。</li></ul><p><img src="https://ws1.sinaimg.cn/large/005DnJLEgy1flhq9h68szj317k0tktd3.jpg" alt=""></p><ul><li>第二种：在网站head标签中加入如下代码：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">   <span class="keyword">var</span> host = <span class="string">"caoler.cn"</span>;</span><br><span class="line">   <span class="keyword">if</span> ((host == <span class="built_in">window</span>.location.host) &amp;&amp; (<span class="built_in">window</span>.location.protocol != <span class="string">"https:"</span>))</span><br><span class="line">   <span class="built_in">window</span>.location.protocol = <span class="string">"https"</span>;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>防跳坑：</strong> 上述两种方式只能使用其中一种，不然浏览器会报出循环重定向错误，导致网站无法正常访问。别问我为什么知道~ （逃</p><h2 id="全站HTTPS"><a href="#全站HTTPS" class="headerlink" title="全站HTTPS"></a>全站HTTPS</h2><p>要做到成功让这个博客满足https的要求，在博客所使用所有的图片自然也是要使用https的链接才行的，只要网站上所使用的资源不是全部通过https的就存在着安全的风险。且网站会被chrome等浏览器认为是不安全的。(放弃七牛云作为图床)</p><p>这里所使用的是新浪微博的图床，在chrome商店可以找到对应的插件。在左下角有的https的选项，只要勾选上了就可以默认生成https的图片链接了。<a href="https://chrome.google.com/webstore/detail/%E6%96%B0%E6%B5%AA%E5%BE%AE%E5%8D%9A%E5%9B%BE%E5%BA%8A/fdfdnfpdplfbbnemmmoklbfjbhecpnhf/reviews" target="_blank" rel="external">谷歌商店地址</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>虽然这里所使用的方法，不是安全的一种方法。网站仍然会面临中间人攻击等一系列问题。因为服务器与CDN之间的通信未加密。但是至少用户在访问网站的时候，不会被通信服务商再拦截再什么广告了。刚好在学习计算机网络的过程中，了解了一些https、cdn、dns、ssl的知识。随着chrome,firefox等浏览器和苹果的大力推进。HTTPS肯定是接下去的发展趋势了，而且证书的费用也在下降。所以，各个网站都是很有必要，向这里过渡的。还有，看着自己浏览的网站，有一个绿色的小锁，就是一件很酷的事情啊，哈哈。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近发现，各大网站好像已经开始全站使用HTTPS，看着浏览器地址栏左边有着一把绿色的小锁，好像是一件很酷的事情。国内的网络环境好像越来越差，除了学会科学上网之外，好像也难免会遇到通讯服务商在网站上加上小广告的问题。随着不断了解计算机的知识，安全概念也越来越重。看着某某网站又被脱裤，一不小心自己的隐私可能就泄露出去了。在社工库上一查，还真能发现自己小学时候使用过的密码。不过，现在当然已经学会了各种措施，每个网站独立密码，能双重保护地就进行双重保护。1password也是我经常使用的一个密码管理软件……啊，好像扯远了。今天，天气很好，也想给自己的博客加上把绿色的小锁HTTPS。&lt;/p&gt;
&lt;h2 id=&quot;什么是HTTPS&quot;&gt;&lt;a href=&quot;#什么是HTTPS&quot; class=&quot;headerlink&quot; title=&quot;什么是HTTPS&quot;&gt;&lt;/a&gt;什么是HTTPS&lt;/h2&gt;
    
    </summary>
    
      <category term="博客相关" scheme="https://caoler.cn/categories/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="博客相关" scheme="https://caoler.cn/tags/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/"/>
    
  </entry>
  
  <entry>
    <title>线程安全</title>
    <link href="https://caoler.cn//post/2017/thread-safety.html"/>
    <id>https://caoler.cn//post/2017/thread-safety.html</id>
    <published>2017-11-13T10:48:00.000Z</published>
    <updated>2017-11-27T12:39:34.673Z</updated>
    
    <content type="html"><![CDATA[<h2 id="竞态条件与临界区"><a href="#竞态条件与临界区" class="headerlink" title="竞态条件与临界区"></a>竞态条件与临界区</h2><p>在同一程序中运行多个线程本身不会导致问题，问题在于多个线程访问了相同的资源。如，同一内存区（变量，数组，或对象）、系统（数据库，web services等）或文件。实际上，这些问题只有在一或多个线程向这些资源做了写操作时才有可能发生，只要资源没有发生变化,多个线程读取相同的资源就是安全的。</p><p>多线程同时执行下面的代码可能会出错：<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">long</span> <span class="keyword">count</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> add(<span class="keyword">long</span> value)&#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">count</span> = <span class="keyword">this</span>.<span class="keyword">count</span> + value;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>想象下线程A和B同时执行同一个Counter对象的add()方法，我们无法知道操作系统何时会在两个线程之间切换。JVM并不是将这段代码视为单条指令来执行的，而是按照下面的顺序：</p><blockquote><p>从内存获取 this.count 的值放到寄存器<br>将寄存器中的值增加value<br>将寄存器中的值写回内存</p></blockquote><p>观察线程A和B交错执行会发生什么：</p><blockquote><pre><code>this.count = 0;</code></pre><p>  A:    读取 this.count 到一个寄存器 (0)<br>  B:    读取 this.count 到一个寄存器 (0)<br>  B:     将寄存器的值加2<br>  B:    回写寄存器值(2)到内存. this.count 现在等于 2<br>  A:    将寄存器的值加3<br>  A:    回写寄存器值(3)到内存. this.count 现在等于 3</p></blockquote><p>两个线程分别加了2和3到count变量上，两个线程执行结束后count变量的值应该等于5。然而由于两个线程是交叉执行的，两个线程从内存中读出的初始值都是0。然后各自加了2和3，并分别写回内存。最终的值并不是期望的5，而是最后写回内存的那个线程的值，上面例子中最后写回内存的是线程A，但实际中也可能是线程B。如果没有采用合适的同步机制，线程间的交叉执行情况就无法预料。</p><h3 id="竞态条件-amp-临界区"><a href="#竞态条件-amp-临界区" class="headerlink" title="竞态条件 &amp; 临界区"></a>竞态条件 &amp; 临界区</h3><p>当两个线程竞争同一资源时，如果对资源的访问顺序敏感，就称存在竞态条件。导致竞态条件发生的代码区称作临界区。上例中add()方法就是一个临界区,它会产生竞态条件。在临界区中使用适当的同步就可以避免竞态条件。</p><h2 id="线程安全与共享资源"><a href="#线程安全与共享资源" class="headerlink" title="线程安全与共享资源"></a>线程安全与共享资源</h2><p>允许被多个线程同时执行的代码称作线程安全的代码。线程安全的代码不包含竞态条件。当多个线程同时更新共享资源时会引发竞态条件。因此，了解Java线程执行时共享了什么资源很重要。</p><h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><p>局部变量存储在线程自己的栈中。也就是说，局部变量永远也不会被多个线程共享。所以，基础类型的局部变量是线程安全的。下面是基础类型的局部变量的一个例子：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">someMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">long</span> threadSafeInt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  threadSafeInt++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="局部的对象引用"><a href="#局部的对象引用" class="headerlink" title="局部的对象引用"></a>局部的对象引用</h3><p>对象的局部引用和基础类型的局部变量不太一样。尽管引用本身没有被共享，但引用所指的对象并没有存储在线程的栈内。所有的对象都存在共享堆中。如果在某个方法中创建的对象不会逃逸出（译者注：即该对象不会被其它方法获得，也不会被非局部变量引用到）该方法，那么它就是线程安全的。实际上，哪怕将这个对象作为参数传给其它方法，只要别的线程获取不到这个对象，那它仍是线程安全的。下面是一个线程安全的局部引用样例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">someMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  LocalObject localObject = <span class="keyword">new</span> LocalObject();</span><br><span class="line"></span><br><span class="line">  localObject.callMethod();</span><br><span class="line">  method2(localObject);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">(LocalObject localObject)</span></span>&#123;</span><br><span class="line">  localObject.setValue(<span class="string">"value"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>样例中LocalObject对象没有被方法返回，也没有被传递给someMethod()方法外的对象。每个执行someMethod()的线程都会创建自己的LocalObject对象，并赋值给localObject引用。因此，这里的LocalObject是线程安全的。事实上，整个someMethod()都是线程安全的。即使将LocalObject作为参数传给同一个类的其它方法或其它类的方法时，它仍然是线程安全的。当然，如果LocalObject通过某些方法被传给了别的线程，那它就不再是线程安全的了。</p><h3 id="对象成员"><a href="#对象成员" class="headerlink" title="对象成员"></a>对象成员</h3><p>对象成员存储在堆上。如果两个线程同时更新同一个对象的同一个成员，那这个代码就不是线程安全的。下面是一个样例：<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class NotThreadSafe&#123;</span><br><span class="line">    StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">add</span>(<span class="keyword">String</span> <span class="built_in">text</span>)&#123;</span><br><span class="line">        <span class="keyword">this</span>.builder.<span class="built_in">append</span>(<span class="built_in">text</span>);</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果两个线程同时调用同一个NotThreadSafe实例上的add()方法，就会有竞态条件问题。例如：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">NotThreadSafe sharedInstance = new NotThreadSafe();</span><br><span class="line"></span><br><span class="line">new Thread(new MyRunnable(sharedInstance)).start();</span><br><span class="line">new Thread(new MyRunnable(sharedInstance)).start();</span><br><span class="line"> </span><br><span class="line">public class MyRunnable implements Runnable&#123;</span><br><span class="line">  NotThreadSafe<span class="built_in"> instance </span>= <span class="literal">null</span>;</span><br><span class="line">   </span><br><span class="line">  public MyRunnable(NotThreadSafe instance)&#123;</span><br><span class="line">    this.instance = instance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void <span class="builtin-name">run</span>()&#123;</span><br><span class="line">    this.instance.<span class="builtin-name">add</span>(<span class="string">"some text"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意两个MyRunnable共享了同一个NotThreadSafe对象。因此，当它们调用add()方法时会造成竞态条件。</p><p>当然，如果这两个线程在不同的NotThreadSafe实例上调用call()方法，就不会导致竞态条件。下面是稍微修改后的例子：<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="type">Thread</span>(<span class="keyword">new</span> <span class="type">MyRunnable</span>(<span class="keyword">new</span> <span class="type">NotThreadSafe</span>())).start();</span><br><span class="line"><span class="keyword">new</span> <span class="type">Thread</span>(<span class="keyword">new</span> <span class="type">MyRunnable</span>(<span class="keyword">new</span> <span class="type">NotThreadSafe</span>())).start();</span><br></pre></td></tr></table></figure></p><p>现在两个线程都有自己单独的NotThreadSafe对象，调用add()方法时就会互不干扰，再也不会有竞态条件问题了。所以非线程安全的对象仍可以通过某种方式来消除竞态条件。</p><h3 id="线程控制逃逸规则"><a href="#线程控制逃逸规则" class="headerlink" title="线程控制逃逸规则"></a>线程控制逃逸规则</h3><p>线程控制逃逸规则可以帮助你判断代码中对某些资源的访问是否是线程安全的。</p><blockquote><p>如果一个资源的创建，使用，销毁都在同一个线程内完成，<br>且永远不会脱离该线程的控制，则该资源的使用就是线程安全的。</p></blockquote><p>资源可以是对象，数组，文件，数据库连接，套接字等等。Java中你无需主动销毁对象，所以“销毁”指不再有引用指向对象。</p><p>即使对象本身线程安全，但如果该对象中包含其他资源（文件，数据库连接），整个应用也许就不再是线程安全的了。比如2个线程都创建了各自的数据库连接，每个连接自身是线程安全的，但它们所连接到的同一个数据库也许不是线程安全的。比如，2个线程执行如下代码：</p><blockquote><p>检查记录X是否存在，如果不存在，插入X</p></blockquote><p>如果两个线程同时执行，而且碰巧检查的是同一个记录，那么两个线程最终可能都插入了记录：</p><blockquote><p>线程1检查记录X是否存在。检查结果：不存在<br>线程2检查记录X是否存在。检查结果：不存在<br>线程1插入记录X<br>线程2插入记录X</p></blockquote><p>同样的问题也会发生在文件或其他共享资源上。因此，区分某个线程控制的对象是资源本身，还是仅仅到某个资源的引用很重要。</p><h2 id="线程安全及不可变性"><a href="#线程安全及不可变性" class="headerlink" title="线程安全及不可变性"></a>线程安全及不可变性</h2><p>当多个线程同时访问同一个资源，并且其中的一个或者多个线程对这个资源进行了写操作，才会产生竞态条件。多个线程同时读同一个资源不会产生竞态条件。</p><p>我们可以通过创建不可变的共享对象来保证对象在线程间共享时不会被修改，从而实现线程安全。如下示例：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ImmutableValue</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> <span class="keyword">value</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ImmutableValue</span>(<span class="params"><span class="keyword">int</span> <span class="keyword">value</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">value</span> = <span class="keyword">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.<span class="keyword">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意ImmutableValue类的成员变量value是通过构造函数赋值的，并且在类中没有set方法。这意味着一旦ImmutableValue实例被创建，value变量就不能再被修改，这就是不可变性。但你可以通过getValue()方法读取这个变量的值。</p><p>（<em>译者注：注意，“不变”（Immutable）和“只读”（Read Only）是不同的。当一个变量是“只读”时，变量的值不能直接改变，但是可以在其它变量发生改变的时候发生改变。比如，一个人的出生年月日是“不变”属性，而一个人的年龄便是“只读”属性，但是不是“不变”属性。随着时间的变化，一个人的年龄会随之发生变化，而一个人的出生年月日则不会变化。这就是“不变”和“只读”的区别。（摘自《Java与模式》第34章）</em>）</p><p>如果你需要对ImmutableValue类的实例进行操作，可以通过得到value变量后创建一个新的实例来实现，下面是一个对value变量进行加法操作的示例：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ImmutableValue</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> <span class="keyword">value</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ImmutableValue</span>(<span class="params"><span class="keyword">int</span> <span class="keyword">value</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">value</span> = <span class="keyword">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.<span class="keyword">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ImmutableValue <span class="title">add</span>(<span class="params"><span class="keyword">int</span> valueToAdd</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ImmutableValue(<span class="keyword">this</span>.<span class="keyword">value</span> + valueToAdd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意add()方法以加法操作的结果作为一个新的ImmutableValue类实例返回，而不是直接对它自己的value变量进行操作。</p><p><strong>引用不是线程安全的！</strong></p><p>重要的是要记住，即使一个对象是线程安全的不可变对象，指向这个对象的引用也可能不是线程安全的。看这个例子：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> Calculator&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ImmutableValue currentValue = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ImmutableValue <span class="title">getValue</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> currentValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span>(<span class="params">ImmutableValue newValue</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.currentValue = newValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span>(<span class="params"><span class="keyword">int</span> newValue</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.currentValue = <span class="keyword">this</span>.currentValue.<span class="keyword">add</span>(newValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Calculator类持有一个指向ImmutableValue实例的引用。注意，通过setValue()方法和add()方法可能会改变这个引用。因此，即使Calculator类内部使用了一个不可变对象，但Calculator类本身还是可变的，因此Calculator类不是线程安全的。换句话说：ImmutableValue类是线程安全的，但使用它的类不是。当尝试通过不可变性去获得线程安全时，这点是需要牢记的。</p><p>要使Calculator类实现线程安全，将getValue()、setValue()和add()方法都声明为同步方法即可。</p><h2 id="本文转载于并发编程网"><a href="#本文转载于并发编程网" class="headerlink" title="本文转载于并发编程网"></a>本文转载于并发编程网</h2><p>来源：<a href="http://ifeve.com/java-concurrency-thread-directory/" target="_blank" rel="external">http://ifeve.com/java-concurrency-thread-directory/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;竞态条件与临界区&quot;&gt;&lt;a href=&quot;#竞态条件与临界区&quot; class=&quot;headerlink&quot; title=&quot;竞态条件与临界区&quot;&gt;&lt;/a&gt;竞态条件与临界区&lt;/h2&gt;&lt;p&gt;在同一程序中运行多个线程本身不会导致问题，问题在于多个线程访问了相同的资源。如，同一内存区（变量，数组，或对象）、系统（数据库，web services等）或文件。实际上，这些问题只有在一或多个线程向这些资源做了写操作时才有可能发生，只要资源没有发生变化,多个线程读取相同的资源就是安全的。&lt;/p&gt;
&lt;p&gt;多线程同时执行下面的代码可能会出错：&lt;br&gt;&lt;figure class=&quot;highlight axapta&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Counter&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;count&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; add(&lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; value)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;keyword&quot;&gt;count&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;keyword&quot;&gt;count&lt;/span&gt; + value;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="并发编程" scheme="https://caoler.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="多线程" scheme="https://caoler.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="并发编程" scheme="https://caoler.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="转载" scheme="https://caoler.cn/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
</feed>
