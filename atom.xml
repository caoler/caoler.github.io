<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Caole&#39;s blog</title>
  
  <subtitle>Caole的个人博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://caoler.cn/"/>
  <updated>2018-09-26T13:49:20.907Z</updated>
  <id>https://caoler.cn/</id>
  
  <author>
    <name>Caole</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>梦想破灭</title>
    <link href="https://caoler.cn//post/2018/over.html"/>
    <id>https://caoler.cn//post/2018/over.html</id>
    <published>2018-09-26T13:48:57.000Z</published>
    <updated>2018-09-26T13:49:20.907Z</updated>
    
    <content type="html"><![CDATA[<p>梦想破灭</p><p>2018年9月26日21:48:48</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;梦想破灭&lt;/p&gt;
&lt;p&gt;2018年9月26日21:48:48&lt;/p&gt;

      
    
    </summary>
    
      <category term="CodingLife" scheme="https://caoler.cn/categories/CodingLife/"/>
    
    
      <category term="CodingLife" scheme="https://caoler.cn/tags/CodingLife/"/>
    
  </entry>
  
  <entry>
    <title>《Spring实战》读书笔记3-SpringAOP</title>
    <link href="https://caoler.cn//post/2018/SpringInAction-3.html"/>
    <id>https://caoler.cn//post/2018/SpringInAction-3.html</id>
    <published>2018-07-13T14:25:11.000Z</published>
    <updated>2018-07-13T14:27:20.139Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-参考"><a href="#1-参考" class="headerlink" title="1. 参考"></a>1. 参考</h3><ul><li><a href="https://blog.csdn.net/w1196726224/article/details/50535659" target="_blank" rel="external">Spring 4 学习笔记5：Spring AOP</a></li><li>《Spring实战 第四版》</li><li><a href="https://blog.csdn.net/wangpeng047/article/details/8556800" target="_blank" rel="external">SpringAop 详尽教程</a></li></ul><a id="more"></a><h3 id="2-AOP术语"><a href="#2-AOP术语" class="headerlink" title="2. AOP术语"></a>2. AOP术语</h3><ol><li><p>通知（active）</p><p>切面的工作被称为通知，比如抄表员去每家每户抄电表的数据，这个<strong>动作（活动）就是通知</strong>。</p><p>通知一共包含以下五种：</p><ul><li>前置通知（Before）：在目标方法被调用之前调用通知功能；</li><li>后置通知（After）：在目标方法完成之后调用通知，此时不会关心方法的输出是什么；</li><li>返回通知（After-returning）：在目标方法成功执行之后调用通知；</li><li>异常通知（After-throwing）：在目标方法抛出异常后调用通知；</li><li>环绕通知（Around）：通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为。</li></ul></li></ol><ol><li><p>连接点（Join point）</p><p>可以<strong>被插入的时机</strong> 就是连接点。连接点是在应用执行过程中能够插入切面的一个点。这个点可以是调用方法时、抛出异常时、甚至修改一个字段时。切面代码可以利用这些点插入到应用的正常流程之中，并添加新的行为。</p></li><li><p>切点（Poincut）</p><p>如果说通知定义了切面的“什么”和“何时”的话，那么切点就定义了 <strong>“何处”</strong>。切点的定义会匹配通知所要织入的一个或多个连接点。我们通常使用明确的类和方法名称，或是利用正则表达式定义所匹配的类和方法名称来指定这些切点。有些AOP框架允许我们创建动态的切点，可以根据运行时的决策（比如方法的参数值）来决定是否应用通知。</p></li><li><p>切面（Aspect）</p><p>当抄表员开始一天的工作时，他知道自己要做的事情（报告用电量）和从哪些房屋收集信息。因此，他知道要完成工作所需要的一切东西。</p><p> <strong>切面是通知和切点的结合</strong>。通知和切点共同定义了切面的全部内容——它是什么，在何时和何处完成其功能。</p></li><li><p>引入（Introduction）</p><p>引入允许我们<strong>向现有的类添加新方法或属性</strong> 。例如，我们可以创建一个Auditable通知类，该类记录了对象最后一次修改时的状态。这很简单，只需一个方法，setLastModified(Date)，和一个实例变量来保存这个状态。然后，这个新方法和实例变量就可以被引入到现有的类中，从而可以在无需修改这些现有的类的情况下，让它们具有新的行为和状态。</p></li><li><p>织入（Weaving）</p><p>织入是把切面应用到目标对象并创建新的代理对象的过程。切面在指定的连接点被织入到目标对象中。在目标对象的生命周期里有多个点可以进行织入：</p><ul><li>编译期：切面在目标类编译时被织入。这种方式需要特殊的编译器。AspectJ的织入编译器就是以这种方式织入切面的。</li><li>类加载期：切面在目标类加载到JVM时被织入。这种方式需要特殊的类加载器（ClassLoader），它可以在目标类被引入应用之前增强该目标类的字节码。AspectJ5的加载时织入（load-time weaving，LTW）就支持以这种方式织入切面。</li><li>运行期：切面在应用运行的某个时刻被织入。一般情况下，在织入切面时，AOP容器会为目标对象动态地创建一个代理对象。Spring AOP就是以这种方式织入切面的。</li></ul></li></ol><p>在AOP术语中这些关注点被称为<strong>横切关注点（crosscutting）</strong>。如下图所示： </p><p><img src="https://img-blog.csdn.net/20160118113324494" alt=""></p><p><strong>通知（Advice）</strong>的类型：</p><table><thead><tr><th>类型</th><th>执行点</th></tr></thead><tbody><tr><td>Before</td><td>在主方法调用之前执行</td></tr><tr><td>After</td><td>通知在主方法完成之后执行，不管主方法的调用结果如何</td></tr><tr><td>After-returnning</td><td>通知在主方法正常返回后执行。比如在不抛出异常时正常返回</td></tr><tr><td>After-throwing</td><td>通知在主方法抛出异常后执行</td></tr><tr><td>Around</td><td>通知包装了主方法，提供在方法调用一直或之后提供一些功能</td></tr></tbody></table><h3 id="3-代码示例"><a href="#3-代码示例" class="headerlink" title="3. 代码示例"></a>3. 代码示例</h3><p>首先，我们定义被代理的接口和实现：</p><p>清单1. 被代理接口和实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyBean.java</span></span><br><span class="line"><span class="keyword">package</span> org.archerie.aop.bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(String msg)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MyBeanImpl.java</span></span><br><span class="line"><span class="keyword">package</span> org.archerie.aop.bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用spring @Component注解，加载到spring上下文中</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanImpl</span> <span class="keyword">implements</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        System.out.println(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，我们就开始定义我们的切面。如下：</p><p>清单2. 切面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.archerie.aop.aspect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.After;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Before;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Pointcut;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdviceExampleAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义切点</span></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(** org.archerie..*Bean.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beanPointCut</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"beanPointCut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">silenceCellPhone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"手机静音！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"execution(** org.archerie..MyBean.sayHello(String)) &amp;&amp; args(msg)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printMsg</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyBean将要说的是："</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span>(<span class="string">"beanPointCut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">applause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"鼓掌！鼓掌！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们就需要定义我们的spring配置文件了。我们选择<strong>Java配置</strong>的方式来配置Spring。</p><p>清单3. Spring配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.archerie.aop.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.EnableAspectJAutoProxy;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(basePackages = &#123;<span class="string">"org.archerie.aop"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AopJavaConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上，切面就准备好了，现在就差使用了。下面，使用JUnit来进行测试：</p><p>清单4. JUnit测试切面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.archerie.aop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.archerie.aop.bean.MyBean;</span><br><span class="line"><span class="keyword">import</span> org.archerie.aop.bean.MyOtherBean;</span><br><span class="line"><span class="keyword">import</span> org.archerie.aop.config.AopJavaConfig;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.ContextConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringJUnit4ClassRunner;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner.class)</span><br><span class="line"><span class="meta">@ContextConfiguration</span>(classes = AopJavaConfig.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AspectTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    MyBean myBean;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    MyOtherBean otherBean;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAspect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        myBean.sayHello(<span class="string">"我要把你做成一个玩偶！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上，就是完成的代码示例。现在运行查看结果：</p><blockquote><p>MyBean将要说的是：我要把你做成一个玩偶！<br>手机静音！<br>我要把你做成一个玩偶！<br>鼓掌！鼓掌！</p></blockquote><h3 id="4-术语详解"><a href="#4-术语详解" class="headerlink" title="4. 术语详解"></a>4. 术语详解</h3><p>Spring AOP主要由<strong>连接点</strong>、<strong>切入点</strong>和<strong>通知</strong>组成切面。而切入点是用来选择某一范围的连接点的，所以我们首先讨论如何定义<strong>切入点</strong>。这里要说明一点的就是：Spring AOP只支持一种<strong>Join point</strong>，就是<strong>方法的执行</strong>。所以，以下<strong>切入点（Pointcut）</strong>只能选取方法执行的<strong>连接点（Join Point）</strong>。看我：:happy:</p><h4 id="4-1-切入点（Pointcuts）"><a href="#4-1-切入点（Pointcuts）" class="headerlink" title="4.1. 切入点（Pointcuts）"></a><strong>4.1. 切入点（Pointcuts）</strong></h4><p>以下是SpringAOP支持的AspectJ切入点：</p><table><thead><tr><th>AspectJ表达式</th><th>描述</th></tr></thead><tbody><tr><td>execution</td><td>匹配方法执行的连接点，这是使用Spring AOP时主要使用的切入点</td></tr><tr><td>within</td><td>匹配特定<strong>类型</strong>中的连接点（在Spring AOP中则限制为<strong>匹配类型</strong>中的方法执行）</td></tr><tr><td>this</td><td>匹配Spring AOP代理对象中的连接点（在Spring AOP中为方法的执行），注意匹配的是spring aop代理对象为指定的类型。this表达式必须使用完整的限定类名，不能使用通配符。</td></tr><tr><td>target</td><td>匹配目标对象中的连接点（在Spring AOP中为方法的执行），但是目标对象得为特定的类型。target表达式必须使用完整的限定类名，不能使用通配符。</td></tr><tr><td>args</td><td>匹配参数为特定类型实例的连接点（Spring AOP中为方法的执行）</td></tr><tr><td>@target</td><td>匹配特定的连接点（Spring AOP中为方法执行），执行方法的类拥有指定类型的注解</td></tr><tr><td>@args</td><td>匹配特定的连接点（Spring AOP中为方法的执行），运行时传入的参数必须拥有特定类型的注解</td></tr><tr><td>@within</td><td>用于匹配拥有特定注解的类型中的连接点</td></tr><tr><td>@annotation</td><td>用于匹配拥有特定注解的连接点（Spring AOP中为方法的执行）</td></tr><tr><td>bean</td><td>Spring AOP扩展的切入点，可以匹配特定的类名中的连接点（方法的执行）</td></tr></tbody></table><h5 id="4-1-1-通配符（Wildcards）"><a href="#4-1-1-通配符（Wildcards）" class="headerlink" title="4.1.1 通配符（Wildcards）"></a>4.1.1 通配符（Wildcards）</h5><p>在使用切入点表达式的时候，有些时候我们可以使用通配符：*、..、+。</p><table><thead><tr><th>符号</th><th>含义</th></tr></thead><tbody><tr><td>..</td><td>在类型匹配时，匹配任何以 <strong>.</strong>，以 <strong>.</strong> 结尾的包名。在方法定义时匹配任意数量的参数。</td></tr><tr><td>+</td><td>匹配给定类型的任意子类型。</td></tr><tr><td>*</td><td>匹配数量的任意字符，除了*字符。</td></tr></tbody></table><h5 id="4-1-2-类型（Type）指示符"><a href="#4-1-2-类型（Type）指示符" class="headerlink" title="4.1.2 类型（Type）指示符"></a>4.1.2 类型（Type）指示符</h5><p>通过类型来过滤方法，比如<em>接口</em>、<em>类名</em>或者是<em>包名</em>。Spring提供<strong>within</strong>切入点，使用方式如下。<code>type name</code>可以被替换为<code>package name</code>或者<code>class name</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">within(&lt;type name&gt;)</span><br></pre></td></tr></table></figure><p>以下是一些例子：</p><ul><li><code>within(com.xyz.web..*)</code>：匹配<code>com.xyz.web</code>包下面的所有类中方法的执行，而且因为使用了 <strong>..</strong> 通配符，所以可以匹配<code>com.xyz.web</code>的所有子包。*通配符匹配所有的类名，所以可以匹配所有类中方法的执行。</li><li><code>with(com.xyz.web.*)</code>：匹配<code>com.xyz.web</code>包下面所有类中方法的执行。因为没有使用..通配符，所有只是匹配到<code>web</code>包，不包括子包。*一样匹配所有的类名。</li><li><code>with(com.xyz.service.AccountService)</code>：匹配<code>AccountService</code>类下面所有方法的执行。</li><li><code>with(com.xyz.interface.MyServiceInterface+)</code>：匹配所有实现了<code>MyServiceInterface</code>接口的类中的所有方法的执行。</li><li><code>with(com.xyz.service.MyBaseService+)</code>：匹配<code>MyBaseService</code>类和它的子类。</li></ul><h5 id="4-1-3-方法（Method）指示符"><a href="#4-1-3-方法（Method）指示符" class="headerlink" title="4.1.3 方法（Method）指示符"></a>4.1.3 方法（Method）指示符</h5><p>匹配特定方法的执行，可以使用<code>execution</code>关键字。execution表达式的格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">execution(modifiers-pattern? ret-type-pattern </span><br><span class="line">        declaring-type-pattern?name-pattern(param-pattern)</span><br><span class="line">            throws-pattern?)123</span><br></pre></td></tr></table></figure><p>其中，所有的部分除了返回值类型（ret-type-pattern）、方法名（name-pattern）和参数（param-pattern）都是可选的。 <strong>修饰符（modifiers-pattern）</strong> <code>public</code>、<code>protected</code>或<code>private</code>，也可以使用<code>*</code>匹配所有的修饰符。<strong>返回值类型（ret-type-pattern）</strong> 匹配特定的返回类型。大多数情况都是使用<code>*</code>通配符匹配所有的返回类型。<strong>方法名（name-pattern）</strong> 匹配执行方法的名称，可以使用<code>*</code>通配符匹配任意数量够的字符。如果要匹配特定类中方法的执行，就必须指定 <strong>类名（declaring-type-pattern）</strong> 部分，这部分使用的格式参考 <strong>4.1.2 类型指示符</strong>。<strong>参数列表（param-pattern）</strong> 部分，指定方法的参数必须满足的格式。<code>()</code>匹配没有参数的方法，<code>(..)</code>匹配任意数量的参数。当然你也可以使用<code>*</code>匹配任意一个参数的类型，比如<code>(\*, String)</code>匹配第二个参数为<code>String</code>类型，第一个参数为任意类型的情况。<strong>异常列表（throws-pattern）</strong> 匹配全限定类名异常类型，如果有多个异常，使用<code>,</code>分割，比如<code>throws java.lang.IllegalArgumentException, java.lang.ArrayIndexOutOfBoundsException</code>。</p><p>示例如下：</p><ul><li><code>execution(public * *(..))</code>：匹配所有的<code>public</code>方法的执行。</li><li><code>execution(* set*(..))</code>：匹配所有方法名以set开头的方法的执行。</li><li><code>execution(* com.xyz.service.AccountService.*(..))</code>：匹配<code>AccountService</code>接口下所有方法的执行。</li><li><code>execution(* com.xyz.service.*.*(..))</code>：匹配包<code>com.xyz.service</code>下所有类（或接口）下的所有方法的执行。</li><li><code>execution(* com.xyz.service..*.*(..))</code>：匹配包<code>com.xyz.service</code>和其子包中的类（或接口）下的所有方法的执行。</li><li><code>execution(* *(.., String)</code>：匹配所有最后一个参数为<code>String</code>的方法的执行。</li><li><code>execution(* ..Sample+.sampleGenericCollectionMethod(*))</code>：匹配任意以.Sample结尾的包，以及其子包中的<code>sampleGenericCollectionMethod</code>方法的执行，且具有唯一的任意类型的参数。</li><li><code>execution(* *(*, String, ..)</code>：匹配第一个参数为任意类型，第二个参数为<code>String</code>，后面可拥有任意个参数的方法的执行。</li></ul><h5 id="4-1-4-其他的切入点指示符"><a href="#4-1-4-其他的切入点指示符" class="headerlink" title="4.1.4 其他的切入点指示符"></a>4.1.4 其他的切入点指示符</h5><ul><li><code>bean(*Service)</code>：所有bean名称以Service结尾的bean。</li><li><code>@annotation(org.springframework.transaction.annotation.Transactional)</code>：匹配所有连接点（Spring AOP中方法的执行）拥有<code>@Transaction</code>注解在方法上。</li><li><code>this(com.xyz.service.AccountService)</code>：匹配实现了<code>AccountService</code>接口的代理类中的所有连接点（Spring AOP中方法的执行）</li><li><code>target(com.xyz.service.AccountService)</code>：匹配实现了<code>AccountService</code>接口的目标类的所有连接点（Spring AOP中方法的执行）</li></ul><h5 id="4-1-5-组合多个切入点"><a href="#4-1-5-组合多个切入点" class="headerlink" title="4.1.5 组合多个切入点"></a>4.1.5 组合多个切入点</h5><p>很多时候可能一个切入点并不能满足我们的需求，这时候就需要组合使用切入点来限制匹配的切入点。在Spring AOP中可以使用<code>and</code>(<code>&amp;&amp;</code>)、<code>or</code>(<code>||</code>)和<code>not</code>(<code>!</code>)。既可以使用文字的形式也可以使用符号的形式。比如 <code>execution(* concert.Performance.perform(..)) &amp;&amp; within(concert.*))</code>。</p><h4 id="4-2-定义切面（-Aspect）"><a href="#4-2-定义切面（-Aspect）" class="headerlink" title="4.2 定义切面（@Aspect）"></a>4.2 定义切面（@Aspect）</h4><p>现在，我们可以使用我们学到的来定义切面了。在Spring中可以使用XML和注解的方式来定义切面，本文将只讨论使用注解定义切面的方式。Spring支持使用<strong>AspectJ</strong>的注解<code>@Aspect</code>来定义切面，就像<strong>清单2</strong>所使用的那样。但是，如果我们要让Spring知道我们定义了一个<strong>切面</strong>的话，还必须把这个切面声明为一个<strong>Bean</strong>。所以我们使用<code>@Component</code>注解，这样Spring就会识别它，并把它当做<strong>切面</strong>来看待了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdviceExampleAspect</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="4-3-定义切点（-Pointcut）"><a href="#4-3-定义切点（-Pointcut）" class="headerlink" title="4.3 定义切点（@Pointcut）"></a><strong>4.3 定义切点（@Pointcut）</strong></h4><p><strong>切点（Pointcut）</strong>定义使用<code>@Pointcut</code>注解。注解中我们就可以使用<strong>4.1 切点</strong>中的表达式来选择连接点。定义切点时，可以组合多个切点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"execution(public * *(..))"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">anyPublicOperation</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"within(com.xyz.someapp.trading..*)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inTrading</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组合切点</span></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"anyPublicOperation() &amp;&amp; inTrading()"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">tradingOperation</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="4-4-定义通知"><a href="#4-4-定义通知" class="headerlink" title="4.4 定义通知"></a><strong>4.4 定义通知</strong></h4><p>在<strong>清单2</strong>中我们已经定义了<code>@Before</code>和<code>@After</code>通知，也可以使用其他类型的通知。这里主要介绍如何使用<code>@Around</code>注解，定义 <strong>环绕（Around）</strong> 通知类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.archerie.aop.aspect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Around;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Pointcut;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdviceAroundAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(** org.archerie..*Bean.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beanPointCut</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"beanPointCut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">watchBean</span><span class="params">(ProceedingJoinPoint jp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"手机静音！"</span>);</span><br><span class="line">            jp.proceed();</span><br><span class="line">            System.out.println(<span class="string">"鼓掌！鼓掌！"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"投诉！投诉！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Around通知类型中，我们可以定义具体方法运行前或者后的逻辑。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-参考&quot;&gt;&lt;a href=&quot;#1-参考&quot; class=&quot;headerlink&quot; title=&quot;1. 参考&quot;&gt;&lt;/a&gt;1. 参考&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/w1196726224/article/details/50535659&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Spring 4 学习笔记5：Spring AOP&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;《Spring实战 第四版》&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/wangpeng047/article/details/8556800&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;SpringAop 详尽教程&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="SSM框架" scheme="https://caoler.cn/categories/SSM%E6%A1%86%E6%9E%B6/"/>
    
      <category term="Spring" scheme="https://caoler.cn/categories/SSM%E6%A1%86%E6%9E%B6/Spring/"/>
    
    
      <category term="Spring" scheme="https://caoler.cn/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot配置RestTemplate的代理和超时时间</title>
    <link href="https://caoler.cn//post/2018/SpringBoot-RestTemplate.html"/>
    <id>https://caoler.cn//post/2018/SpringBoot-RestTemplate.html</id>
    <published>2018-06-30T07:07:34.000Z</published>
    <updated>2018-06-30T07:08:57.574Z</updated>
    
    <content type="html"><![CDATA[<p>对于某些特殊需求需要使用代理的时候，使用此方法进行配置</p><a id="more"></a><p>application.properties：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#代理设置</span></span><br><span class="line">proxy.<span class="attribute">enabled</span>=<span class="literal">false</span></span><br><span class="line">proxy.<span class="attribute">host</span>=192.168.18.233</span><br><span class="line">proxy.<span class="attribute">port</span>=8888</span><br><span class="line"></span><br><span class="line"><span class="comment">#REST超时配置</span></span><br><span class="line">rest.<span class="attribute">ReadTimeout</span>=35000</span><br><span class="line">rest.<span class="attribute">ConnectTimeout</span>=5000</span><br></pre></td></tr></table></figure></p><p>代理配置类：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 网络代理设置</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @author yangzhilong</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">@<span class="type">Component</span></span><br><span class="line">@<span class="type">ConfigurationProperties</span>(<span class="keyword">prefix</span>=<span class="string">"proxy"</span>)</span><br><span class="line">@<span class="type">Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否启用代理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Boolean</span> enabled;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代理主机地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> host;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代理端口    </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Integer</span> port;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>SpringBoot的Configuration：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.net.SocketAddress;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.<span class="keyword">annotation</span>.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.<span class="keyword">annotation</span>.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.condition.ConditionalOnClass;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.<span class="keyword">annotation</span>.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.<span class="keyword">annotation</span>.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.client.SimpleClientHttpRequestFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.client.RestTemplate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.yzl.vo.ProxyConfig;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(ProxyConfig.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RestConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value(<span class="meta-string">"<span class="subst">$&#123;rest.ReadTimeout&#125;</span>"</span>)</span></span><br><span class="line">    <span class="keyword">private</span> int readTimeout;</span><br><span class="line">    <span class="meta">@Value(<span class="meta-string">"<span class="subst">$&#123;rest.ConnectTimeout&#125;</span>"</span>)</span></span><br><span class="line">    <span class="keyword">private</span> int connectionTimeout;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ProxyConfig proxyConfig;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SimpleClientHttpRequestFactory httpClientFactory() &#123;</span><br><span class="line">        SimpleClientHttpRequestFactory httpRequestFactory = new SimpleClientHttpRequestFactory();</span><br><span class="line">        httpRequestFactory.setReadTimeout(readTimeout);</span><br><span class="line">        httpRequestFactory.setConnectTimeout(connectionTimeout);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(proxyConfig.getEnabled())&#123;</span><br><span class="line">            SocketAddress address = new InetSocketAddress(proxyConfig.getHost(), proxyConfig.getPort());</span><br><span class="line">            Proxy proxy = new Proxy(Proxy.Type.HTTP, address);</span><br><span class="line">            httpRequestFactory.setProxy(proxy);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> httpRequestFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate restTemplate(SimpleClientHttpRequestFactory httpClientFactory) &#123;</span><br><span class="line">        RestTemplate restTemplate = new RestTemplate(httpClientFactory);</span><br><span class="line">        <span class="keyword">return</span> restTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> 如果不希望这种全局的超时时间污染正常的SpringCloud中restTemplate的时间设置，可以使用如下方法：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yzl.autoconfig;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.<span class="keyword">annotation</span>.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.<span class="keyword">annotation</span>.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.<span class="keyword">annotation</span>.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.client.HttpComponentsClientHttpRequestFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.client.RestTemplate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.yzl.util.RestClient;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 工具类引导装配类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yangzhilong</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RestClientAutoConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value(<span class="meta-string">"<span class="subst">$&#123;rest.config.connectTimeout:<span class="number">10000</span>&#125;</span>"</span>)</span></span><br><span class="line">    <span class="keyword">private</span> int connectTimeout;</span><br><span class="line">    <span class="meta">@Value(<span class="meta-string">"<span class="subst">$&#123;rest.config.readTimeout:<span class="number">30000</span>&#125;</span>"</span>)</span></span><br><span class="line">    <span class="keyword">private</span> int readTimeout;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用Bootstrap来装配RestClient中的RestTemplate属性，</span></span><br><span class="line"><span class="comment">     * 避免直接装配RestTemplate来污染了正常的spring Cloud的调用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RestClientBootstrap bootstrap()&#123;</span><br><span class="line">        HttpComponentsClientHttpRequestFactory httpRequestFactory = new HttpComponentsClientHttpRequestFactory();</span><br><span class="line">        httpRequestFactory.setConnectTimeout(connectTimeout);</span><br><span class="line">        httpRequestFactory.setReadTimeout(readTimeout);</span><br><span class="line">        RestTemplate restTemplate = new RestTemplate(httpRequestFactory);</span><br><span class="line">        RestClient.setRestTemplate(restTemplate);</span><br><span class="line">        <span class="keyword">return</span> new RestClientBootstrap();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 空的引导类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> yangzhilong</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    static <span class="class"><span class="keyword">class</span> <span class="title">RestClientBootstrap</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>RestClient工具类：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yzl.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.http.HttpEntity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.HttpHeaders;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.HttpMethod;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.MediaType;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.LinkedMultiValueMap;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.MultiValueMap;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.client.RestTemplate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * HTTP请求帮助类</span></span><br><span class="line"><span class="comment"> * @author yangzhilong</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RestClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注入实现类</span></span><br><span class="line"><span class="comment">     * @param client</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void setRestTemplate(RestTemplate client) &#123;</span><br><span class="line">        restTemplate = client;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 无参数或者参数附带在url中</span></span><br><span class="line"><span class="comment">     * @param url</span></span><br><span class="line"><span class="comment">     * @return</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">String</span> <span class="keyword">get</span>(<span class="keyword">String</span> url) &#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(url , <span class="keyword">String</span>.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * json格式的post提交</span></span><br><span class="line"><span class="comment">     * @param obj</span></span><br><span class="line"><span class="comment">     * @param url</span></span><br><span class="line"><span class="comment">     * @return</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">String</span> postJson(<span class="keyword">String</span> url, Object obj) &#123;</span><br><span class="line">        HttpHeaders headers = <span class="keyword">new</span> <span class="type">HttpHeaders</span>();</span><br><span class="line">        MediaType type = MediaType.parseMediaType(<span class="string">"application/json; charset=UTF-8"</span>);</span><br><span class="line">        headers.setContentType(type);</span><br><span class="line">        headers.add(<span class="string">"Accept"</span>, MediaType.APPLICATION_JSON.toString());</span><br><span class="line">        <span class="keyword">String</span> result = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(obj == <span class="literal">null</span>)&#123;</span><br><span class="line">            result = <span class="string">"&#123;&#125;"</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            result = JSON.toJSONString(obj);</span><br><span class="line">        &#125;</span><br><span class="line">        HttpEntity&lt;<span class="keyword">String</span>&gt; formEntity = <span class="keyword">new</span> <span class="type">HttpEntity</span>&lt;<span class="keyword">String</span>&gt;(result,headers);</span><br><span class="line">        <span class="keyword">return</span> restTemplate.postForObject(url , formEntity, <span class="keyword">String</span>.class);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * form格式的post提交</span></span><br><span class="line"><span class="comment">     * @param map</span></span><br><span class="line"><span class="comment">     * @param url</span></span><br><span class="line"><span class="comment">     * @return</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">String</span> postForm(<span class="keyword">String</span> url, Map&lt;<span class="keyword">String</span> , <span class="keyword">String</span>&gt; map)&#123;</span><br><span class="line">        HttpHeaders headers = <span class="keyword">new</span> <span class="type">HttpHeaders</span>();</span><br><span class="line">        headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED);</span><br><span class="line">        MultiValueMap&lt;<span class="keyword">String</span>, <span class="keyword">String</span>&gt; params= <span class="keyword">new</span> <span class="type">LinkedMultiValueMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;<span class="keyword">String</span> ,<span class="keyword">String</span>&gt; me : <span class="type">map</span>.entrySet())&#123;</span><br><span class="line">            params.add(me.getKey() , me.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        HttpEntity&lt;MultiValueMap&lt;<span class="keyword">String</span>, <span class="keyword">String</span>&gt;&gt; requestEntity = <span class="keyword">new</span> <span class="type">HttpEntity</span>&lt;&gt;(params, headers);</span><br><span class="line">        <span class="keyword">return</span> restTemplate.exchange(url, HttpMethod.POST, requestEntity, <span class="keyword">String</span>.class).getBody();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后实际发起HTTP请求的时候使用上面的工具类即可！</p><p>参考：<br><a href="https://www.cnblogs.com/yangzhilong/p/6640207.html" target="_blank" rel="external">https://www.cnblogs.com/yangzhilong/p/6640207.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于某些特殊需求需要使用代理的时候，使用此方法进行配置&lt;/p&gt;
    
    </summary>
    
      <category term="SSM框架" scheme="https://caoler.cn/categories/SSM%E6%A1%86%E6%9E%B6/"/>
    
      <category term="SpringBoot" scheme="https://caoler.cn/categories/SSM%E6%A1%86%E6%9E%B6/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="https://caoler.cn/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>利用maven分环境打包SpringBoot项目</title>
    <link href="https://caoler.cn//post/2018/SpringBootMavenPackage.html"/>
    <id>https://caoler.cn//post/2018/SpringBootMavenPackage.html</id>
    <published>2018-06-11T14:13:22.000Z</published>
    <updated>2018-06-11T14:13:34.887Z</updated>
    
    <content type="html"><![CDATA[<p>一个应用系统需要在不同的阶段以不同的配置文件来进行部署，在开发阶段需要开发时的配置文件启动服务，测试阶段或者生产阶段都是不同的配置，所以我们需要利用maven按照环境来将不同环境的配置文件按环境打包，减少我们的维护成本。</p><a id="more"></a><ol><li><p>在pom文件中进行如下配置：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="params">&lt;profiles&gt;</span>  </span><br><span class="line">    <span class="params">&lt;profile&gt;</span>  </span><br><span class="line">        <span class="params">&lt;id&gt;</span>dev<span class="params">&lt;/id&gt;</span>  </span><br><span class="line">        <span class="params">&lt;properties&gt;</span>  </span><br><span class="line">            <span class="params">&lt;profileActive&gt;</span>dev<span class="params">&lt;/profileActive&gt;</span>  </span><br><span class="line">        <span class="params">&lt;/properties&gt;</span>  </span><br><span class="line">        <span class="params">&lt;activation&gt;</span>  </span><br><span class="line">            <span class="params">&lt;activeByDefault&gt;</span>false<span class="params">&lt;/activeByDefault&gt;</span>  </span><br><span class="line">        <span class="params">&lt;/activation&gt;</span>  </span><br><span class="line">    <span class="params">&lt;/profile&gt;</span>  </span><br><span class="line">    <span class="params">&lt;profile&gt;</span>  </span><br><span class="line">        <span class="params">&lt;id&gt;</span>test<span class="params">&lt;/id&gt;</span>  </span><br><span class="line">        <span class="params">&lt;properties&gt;</span>  </span><br><span class="line">            <span class="params">&lt;profileActive&gt;</span>test<span class="params">&lt;/profileActive&gt;</span>  </span><br><span class="line">        <span class="params">&lt;/properties&gt;</span>  </span><br><span class="line">        <span class="params">&lt;activation&gt;</span>  </span><br><span class="line">            <span class="params">&lt;activeByDefault&gt;</span>false<span class="params">&lt;/activeByDefault&gt;</span>  </span><br><span class="line">        <span class="params">&lt;/activation&gt;</span>  </span><br><span class="line">    <span class="params">&lt;/profile&gt;</span>  </span><br><span class="line"><span class="params">&lt;/profiles&gt;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="params">&lt;build&gt;</span>  </span><br><span class="line"><span class="params">&lt;resources&gt;</span>  </span><br><span class="line">    <span class="params">&lt;resource&gt;</span>  </span><br><span class="line">        <span class="params">&lt;directory&gt;</span>src<span class="meta-keyword">/main/</span>resources<span class="params">&lt;/directory&gt;</span>  </span><br><span class="line">        <span class="params">&lt;includes&gt;</span>  </span><br><span class="line">            <span class="params">&lt;include&gt;</span>application-$&#123;profileActive&#125;.properties<span class="params">&lt;/include&gt;</span>  </span><br><span class="line">            <span class="params">&lt;include&gt;</span>application.properties<span class="params">&lt;/include&gt;</span>  </span><br><span class="line">        <span class="params">&lt;/includes&gt;</span>  </span><br><span class="line">        <span class="params">&lt;filtering&gt;</span>true<span class="params">&lt;/filtering&gt;</span>  </span><br><span class="line">    <span class="params">&lt;/resource&gt;</span>  </span><br><span class="line"><span class="params">&lt;/resources&gt;</span>  </span><br><span class="line"><span class="params">&lt;plugins&gt;</span>  </span><br><span class="line">    <span class="params">&lt;plugin&gt;</span>  </span><br><span class="line">        <span class="params">&lt;groupId&gt;</span>org.apache.maven.plugins<span class="params">&lt;/groupId&gt;</span>  </span><br><span class="line">        <span class="params">&lt;artifactId&gt;</span>maven-resources-plugin<span class="params">&lt;/artifactId&gt;</span>  </span><br><span class="line">        <span class="params">&lt;configuration&gt;</span>  </span><br><span class="line">            <span class="params">&lt;delimiters&gt;</span>  </span><br><span class="line">                <span class="params">&lt;delimiter&gt;</span>@<span class="params">&lt;/delimiter&gt;</span>  </span><br><span class="line">            <span class="params">&lt;/delimiters&gt;</span>  </span><br><span class="line">            <span class="params">&lt;useDefaultDelimiters&gt;</span>false<span class="params">&lt;/useDefaultDelimiters&gt;</span>  </span><br><span class="line">        <span class="params">&lt;/configuration&gt;</span>  </span><br><span class="line">    <span class="params">&lt;/plugin&gt;</span>  </span><br><span class="line"><span class="params">&lt;/plugins&gt;</span>  </span><br><span class="line"><span class="params">&lt;/build&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>application.yml中添加如下配置</p></li></ol><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sprin<span class="variable">g:</span></span><br><span class="line">    <span class="keyword">profile</span><span class="variable">s:</span></span><br><span class="line">        active=@profileActive@</span><br></pre></td></tr></table></figure><ol><li>通过mvn package -P dev进行打包就会只将开发环境的配置文件扔到对应的jar包或者war包中</li></ol><p>踩坑经历：</p><p>在我按照上述文件配置完成之后，多环境的文件已经生效了，但是！</p><p>我的所有方法都报这样的错误：<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invalid bound statement (<span class="name">not</span> found)</span><br></pre></td></tr></table></figure></p><p>网上查阅许久得知</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 如果不添加此节点mybatis的mapper.xml文件都会被漏掉。 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">resource</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">includes</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">includes</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">resource</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个应用系统需要在不同的阶段以不同的配置文件来进行部署，在开发阶段需要开发时的配置文件启动服务，测试阶段或者生产阶段都是不同的配置，所以我们需要利用maven按照环境来将不同环境的配置文件按环境打包，减少我们的维护成本。&lt;/p&gt;
    
    </summary>
    
      <category term="SSM框架" scheme="https://caoler.cn/categories/SSM%E6%A1%86%E6%9E%B6/"/>
    
      <category term="SpringBoot" scheme="https://caoler.cn/categories/SSM%E6%A1%86%E6%9E%B6/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="https://caoler.cn/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>《Spring实战》读书笔记2-高级装配</title>
    <link href="https://caoler.cn//post/2018/SpringInAction-2.html"/>
    <id>https://caoler.cn//post/2018/SpringInAction-2.html</id>
    <published>2018-06-11T14:12:00.000Z</published>
    <updated>2018-06-11T14:12:04.543Z</updated>
    
    <content type="html"><![CDATA[<p>在Spring装配Bean一文中，我们探讨了Spring的三种管理bean的方式：自动装配、基于JavaConfig、基于XML文件。本篇（对应《Spring实战第三章》）将探讨一些Spring中关于bean的管理的高级知识，这些技能你可能不会每天都用，但是非常重要。</p><a id="more"></a><h2 id="环境-and-profiles"><a href="#环境-and-profiles" class="headerlink" title="环境 and profiles"></a>环境 and profiles</h2><p>在软件开发中，常常设置不同的运行环境：开发环境、预发环境、性能测试环境和生产环境等等。</p><p>不同的环境下，应用程序的配置项也不同，例如数据库配置、远程服务地址等。以数据库配置为例子，在开发环境中你可能使用一个嵌入式的内存数据库，并将测试数据放在一个脚本文件中。例如，在一个Spring的配置类中，可能需要定义如下的bean：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">Bean</span>(<span class="keyword">destroyMethod</span> = <span class="string">"shutdown"</span>)</span><br><span class="line">public DataSource dataSource() &#123;</span><br><span class="line">    <span class="selector-tag">return</span> <span class="selector-tag">new</span> <span class="selector-tag">EmbeddedDatabaseBuilder</span>()</span><br><span class="line">            <span class="selector-class">.addScript</span>("<span class="selector-tag">classpath</span><span class="selector-pseudo">:schema.sql")</span></span><br><span class="line">            <span class="selector-class">.addScript</span>("<span class="selector-tag">classpath</span><span class="selector-pseudo">:test-data.sql")</span></span><br><span class="line">            <span class="selector-class">.build</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用EmbeddedDatabaseBuilder这个构建器可以建立一个内存数据库，通过指定路径下的schema.sql文件中的内容可以建立数据库的表定义，通过test-data.sql可以准备好测试数据。</p><p>开发环境下可以这么用，但是在生产环境下不可以。在生产环境下，你可能需要从容器中使用JNDI获取DataSource对象，这中情况下，对应的创建代码是：<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">Bean</span></span><br><span class="line"><span class="keyword">public </span>DataSource dataSource() &#123;</span><br><span class="line">    <span class="keyword">JndiObjectFactoryBean </span><span class="keyword">jndiObjectFactoryBean </span>=</span><br><span class="line">             new <span class="keyword">JndiObjectFactoryBean();</span></span><br><span class="line"><span class="keyword"> </span>   <span class="keyword">jndiObjectFactoryBean.setJndiName("jdbc/myDS");</span></span><br><span class="line"><span class="keyword"> </span>   <span class="keyword">jndiObjectFactoryBean.setResourceRef(true);</span></span><br><span class="line"><span class="keyword"> </span>   <span class="keyword">jndiObjectFactoryBean.setProxyInterface(javax.sql.DataSource.class);</span></span><br><span class="line"><span class="keyword"> </span>   return (DataSource) <span class="keyword">jndiObjectFactoryBean.getObject();</span></span><br><span class="line"><span class="keyword">&#125;</span></span><br></pre></td></tr></table></figure></p><p>使用JNDI管理DataSource对象，很适合生产环境，但是对于日常开发环境来说太复杂了。</p><p>另外，在QA环境下你也可以选择另外一种DataSource配置，可以选择使用普通的DBCP连接池，例如：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">Bean(destroyMethod </span>= <span class="string">"close"</span>)</span><br><span class="line">public DataSource dataSource() &#123;</span><br><span class="line">    <span class="keyword">BasicDataSource </span>dataSource = new <span class="keyword">BasicDataSource();</span></span><br><span class="line"><span class="keyword"> </span>   dataSource.setUrl(<span class="string">"jdbc:h2:tcp://dbserver/~/test"</span>)<span class="comment">;</span></span><br><span class="line">    dataSource.setDriverClassName(<span class="string">"org.h2.Driver"</span>)<span class="comment">;</span></span><br><span class="line">    dataSource.setUsername(<span class="string">"sa"</span>)<span class="comment">;</span></span><br><span class="line">    dataSource.setPassword(<span class="string">"password"</span>)<span class="comment">;</span></span><br><span class="line">    dataSource.setInitialSize(<span class="number">20</span>)<span class="comment">;</span></span><br><span class="line">    dataSource.setMaxActive(<span class="number">30</span>)<span class="comment">;</span></span><br><span class="line">    return dataSource<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述三种办法可以为不同环境创建各自需要的javax.sql.DataSource实例，这个例子很适合介绍不同环境下创建bean，那么有没有一种办法：只需要打包应用一次，然后部署到不同的开发环境下就会自动选择不同的bean创建策略。一种方法是创建三个独立的配置文件，然后利用Maven profiles的预编译命令处理在特定的环境下打包哪个配置文件到最终的应用中。这种解决方法有一个问题，即在切换到不同环境时，需要重新构建应用——从开发环境到测试环境没有问题，但是从测试环境到生产环境也需要重新构建则可能引入一定风险。</p><p>Spring提供了对应的方法，使得在环境切换时不需要重新构建整个应用。</p><h3 id="配置profile-beans"><a href="#配置profile-beans" class="headerlink" title="配置profile beans"></a>配置profile beans</h3><p>Spring提供的方法不是在构件时针对不同的环境决策，而是在运行时，这样，一个应用只需要构建一次，就可以在开发、QA和生产环境运行。</p><p>在Spring 3.1之中，可以使用@Profile注解来修饰JavaConfig类，当某个环境对应的profile被激活时，就使用对应环境下的配置类。</p><p>在Spring3.2之后，则可以在函数级别使用@Profile注解（是的，跟@Bean注解同时作用在函数上），这样就可以将各个环境的下的bean定义都放在同一个配置类中，还是以之前的例子：</p><p>利用注解配置</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.<span class="keyword">annotation</span>.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.<span class="keyword">annotation</span>.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.<span class="keyword">annotation</span>.Profile;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseType;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jndi.JndiObjectFactoryBean;</span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean(destroyMethod = <span class="meta-string">"shutdown"</span>)</span></span><br><span class="line">    <span class="meta">@Profile(<span class="meta-string">"dev"</span>)</span>                  <span class="comment">//为dev peofile装配的bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource embeddedDataSource() &#123;</span><br><span class="line">        <span class="keyword">return</span> new EmbeddedDatabaseBuilder()</span><br><span class="line">                .setType(EmbeddedDatabaseType.H2)</span><br><span class="line">                .addScript(<span class="string">"classpath:schema.sql"</span>)</span><br><span class="line">                .addScript(<span class="string">"classpath:test-data.sql"</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Profile(<span class="meta-string">"prod"</span>)</span>                  <span class="comment">//为prod peofile装配的bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource dataSource() &#123;</span><br><span class="line">        JndiObjectFactoryBean jndiObjectFactoryBean =</span><br><span class="line">                new JndiObjectFactoryBean();</span><br><span class="line">        jndiObjectFactoryBean.setJndiName(<span class="string">"jdbc/myDS"</span>);</span><br><span class="line">        jndiObjectFactoryBean.setResourceRef(<span class="literal">true</span>); </span><br><span class="line">        jndiObjectFactoryBean.setProxyInterface(javax.sql.DataSource.<span class="keyword">class</span>);</span><br><span class="line">        <span class="keyword">return</span> (DataSource) jndiObjectFactoryBean.getObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了被@Profile修饰的其他bean，无论在什么开发环境下都会被创建。</p><p>利用XML文件配置<br>和在JavaConfig的用法一样，可以从文件级别定义环境信息，也可以将各个环境的bean放在一个XML配置文件中。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:jdbc</span>=<span class="string">"http://www.springframework.org/schema/jdbc"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:jee</span>=<span class="string">"http://www.springframework.org/schema/jee"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">       <span class="tag">&lt;<span class="name">beans</span> <span class="attr">profile</span>=<span class="string">"dev"</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">jdbc:embedded-database</span> <span class="attr">id</span>=<span class="string">"dataSource"</span>&gt;</span></span><br><span class="line">                     <span class="tag">&lt;<span class="name">jdbc:script</span> <span class="attr">location</span>=<span class="string">"classpath:schema.sql"</span>/&gt;</span></span><br><span class="line">                     <span class="tag">&lt;<span class="name">jdbc:script</span> <span class="attr">location</span>=<span class="string">"classpath:test-data.sql"</span>/&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">jdbc:embedded-database</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line"></span><br><span class="line">       <span class="tag">&lt;<span class="name">beans</span> <span class="attr">profile</span>=<span class="string">"qa"</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">class</span>=<span class="string">"org.apache.commons.dbcp.BasicDataSource"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">destroy-method</span>=<span class="string">"close"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">p:url</span>=<span class="string">"jdbc:h2:tcp://dbserver/~/test"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">p:driverClassName</span>=<span class="string">"org.h2.Driver"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">p:username</span>=<span class="string">"sa"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">p:password</span>=<span class="string">"password"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">p:initialSize</span>=<span class="string">"20"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">p:maxActive</span>=<span class="string">"30"</span> /&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line"></span><br><span class="line">       <span class="tag">&lt;<span class="name">beans</span> <span class="attr">profile</span>=<span class="string">"prod"</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">jee:jndi-lookup</span> <span class="attr">id</span>=<span class="string">"dataSource"</span></span></span><br><span class="line"><span class="tag">                               <span class="attr">jndi-name</span>=<span class="string">"jdbc/MyDatabase"</span></span></span><br><span class="line"><span class="tag">                               <span class="attr">resource-ref</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">                               <span class="attr">proxy-interface</span>=<span class="string">"javax.sql.DataSource"</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上述三个javax.sql.DataSource的bean，ID都是dataSource，但是在运行的时候只会创建一个bean。</p><h3 id="激活profiles"><a href="#激活profiles" class="headerlink" title="激活profiles"></a>激活profiles</h3><p>Spring提供了spring.profiles.active和spring.profiles.default这两个配置项定义激活哪个profile。如果应用中设置了spring.profiles.active选项，则Spring根据该配置项的值激活对应的profile，如果没有设置spring.profiles.active，则Spring会再查看spring.profiles.default这个配置项的值，如果这两个变量都没有设置，则Spring只会创建没有被profile修饰的bean。</p><p>有下列几种方法设置上述两个变量的值：</p><ul><li>DispatcherServlet的初始化参数</li><li>web应用的上下文参数(context parameters)</li><li>JNDI项</li><li>环境变量</li><li>JVM系统属性</li><li>在集成测试类上使用@ActiveProfiles注解</li></ul><p>开发人员可以按自己的需求设置<code>spring.profiles.active</code>和<code>spring.profiles.default</code>这两个属性的组合。</p><p>作者推荐在web应用的web.xml文件中设置spring.profiles.default属性——通过设置DispatcherServlet的初始参数和<code>&lt;context-param&gt;</code>标签。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">"3.1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/spring-mvc-context.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--为上下文设置的默认profile--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>spring.profiles.default<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>dev<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>appServletName<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span>        </span><br><span class="line">        <span class="comment">&lt;!--为servlet设置的默认profile--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>spring.profiles.default<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>dev<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>appServletName<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>按照上述方法设置spring.profiles.default属性，任何开发人员只需要下载源码就可以在开发环境中运行程序以及测试。</p><p>然后，当应用需要进入QA、生产环境时，负责部署的开发者只需要通过系统属性、环境变量或者JNDI等方法设置spring.profiles.active属性即可，因为spring.profiles.active优先级更高。</p><p>TESTING WITH PROFILES<br>在运行集成测试时，可能希望运行跟生产环境下相同的配置；但是，如果配置重需要的beans被profiles修饰的，则需要在跑单元测试之前激活对应的profiles。</p><p>Spring提供了@ActiveProfiles注解来激活指定的profiles，用法如下：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@RunWith</span>(SpringJUnit4ClassRunner.class)</span><br><span class="line"><span class="variable">@ContextConfiguration</span>(classes = SoundSystemConfig.class)</span><br><span class="line"><span class="variable">@ActiveProfiles</span>(<span class="string">"dev"</span>)</span><br><span class="line">public class SoundSystemTest &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="条件化的bean"><a href="#条件化的bean" class="headerlink" title="条件化的bean"></a>条件化的bean</h2><p>假设你希望只有在项目中引入特定的依赖库时、或者只有当特定的bean已经被创建时、或者是设置了某个环境变量时，某个bean才被创建。</p><p>Spring 4之前很难实现这种需求，不过在Spring 4中提出了一个新的注解——@Conditional，该注解作用于@Bean注解修饰的方法上，通过判断指定的条件是否满足来决定是否创建该bean。</p><p>举个例子，工程中有一个MagicBean，你希望只有当magic环境变量被赋值时才创建MagicBean，否则该Bean的创建函数被忽略。<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Bean</span></span><br><span class="line"><span class="variable">@Conditional</span>(MagicExistsCondition.class)</span><br><span class="line">public MagicBean magicBean() &#123;</span><br><span class="line">    <span class="selector-tag">return</span> <span class="selector-tag">new</span> <span class="selector-tag">MagicBean</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个例子表示：只有当<em>MagicExistsCondition</em>类已经存在时，才会创建<em>MagicBean</em>。</p><p><em>@Conditional</em>注解的源码列举如下<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">package</span> <span class="selector-tag">org</span><span class="selector-class">.springframework</span><span class="selector-class">.context</span><span class="selector-class">.annotation</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">import</span> <span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.annotation</span><span class="selector-class">.ElementType</span>;</span><br><span class="line"><span class="selector-tag">import</span> <span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.annotation</span><span class="selector-class">.Retention</span>;</span><br><span class="line"><span class="selector-tag">import</span> <span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.annotation</span><span class="selector-class">.RetentionPolicy</span>;</span><br><span class="line"><span class="selector-tag">import</span> <span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.annotation</span><span class="selector-class">.Target</span>;</span><br><span class="line"><span class="selector-tag">import</span> <span class="selector-tag">org</span><span class="selector-class">.springframework</span><span class="selector-class">.context</span><span class="selector-class">.annotation</span><span class="selector-class">.Condition</span>;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">Retention</span>(<span class="keyword">RetentionPolicy</span>.<span class="keyword">RUNTIME</span>)</span><br><span class="line">@<span class="keyword">Target</span>(&#123;<span class="selector-tag">ElementType</span><span class="selector-class">.TYPE</span>, <span class="selector-tag">ElementType</span><span class="selector-class">.METHOD</span>&#125;)</span><br><span class="line"><span class="selector-tag">public</span> @<span class="keyword">interface</span> Conditional &#123;</span><br><span class="line">    <span class="selector-tag">Class</span>&lt;? <span class="selector-tag">extends</span> <span class="selector-tag">Condition</span>&gt;<span class="selector-attr">[]</span> <span class="selector-tag">value</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看出，<strong>传入@Conditional注解的类一定要实现Condition接口</strong>，该接口提供matchs()方法——如果matches()方法返回true，则被@Conditional注解修饰的bean就会创建，否则对应的bean不会创建。</p><p>在这个例子中，MagicExistsCondition类应该实现Condition接口，并在matches()方法中实现具体的判断条件，代码如下所示：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="meta-keyword">import</span> org.springframework.context.annotation.Condition;</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">import</span> org.springframework.context.annotation.ConditionContext;</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">import</span> org.springframework.core.env.Environment;</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">import</span> org.springframework.core.type.AnnotatedTypeMetadata;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MagicExistsCondition</span> <span class="keyword">implements</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> boolean matches(ConditionContext conditionContext, AnnotatedTypeMetadata annotatedTypeMetadata) &#123;</span><br><span class="line">        Environment env = conditionContext.getEnvironment();</span><br><span class="line">        <span class="keyword">return</span> env.containsProperty(<span class="string">"magic"</span>); <span class="comment">//检查magic环境变量是否被设置</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述代码中的matchs()方法简单且有效：它首先获取Environment变量，然后再判断环境变量中是否存在magic属性。在这个例子中，magic的值是多少并不重要，它只要存在就好。</p><p>MagicExistsCondition的matchs()方法是通过ConditionContext获取了Environment实例。matchs()方法的参数有两个：ConditionContext和AnnotatedTypeMetadata，分别看下这两个接口的源码：</p><ul><li><p>ConditionContext</p>  <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public<span class="built_in"> interface </span>ConditionContext &#123;</span><br><span class="line">    BeanDefinitionRegistry getRegistry();</span><br><span class="line">    ConfigurableListableBeanFactory getBeanFactory();</span><br><span class="line">    Environment getEnvironment();</span><br><span class="line">    ResourceLoader getResourceLoader();</span><br><span class="line">    ClassLoader getClassLoader();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  利用ConditionContext接口可做的事情很多，列举如下：</p><ul><li>通过getRegistry()方法返回的BeanDefinitionRegistry实例，可以检查bean的定义；</li><li>通过getBeanFactory()方法返回的ConfigurableListableBeanFactory实例，- 可以检查某个bean是否存在于应用上下文中，还可以获得该bean的属性；</li><li>通过getEnvironment()方法返回的Environment实例，可以检查指定环境变量是否被设置，还可以获得该环境变量的值；</li><li>通过getResourceLoader()方法返回的ResourceLoader实例，可以得到应用加载的资源包含的内容；</li><li>通过getClassLoader()方法返回的ClassLoader实例，可以检查某个类是否存在。</li></ul></li><li><p>AnnotatedTypeMetadata</p>  <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> AnnotatedTypeMetadata &#123;</span><br><span class="line">    <span class="built_in">boolean</span> isAnnotated(<span class="built_in">String</span> var1);</span><br><span class="line">    Map&lt;<span class="built_in">String</span>, <span class="built_in">Object</span>&gt; getAnnotationAttributes(<span class="built_in">String</span> var1);</span><br><span class="line">    Map&lt;<span class="built_in">String</span>, <span class="built_in">Object</span>&gt; getAnnotationAttributes(<span class="built_in">String</span> var1, <span class="built_in">boolean</span> var2);</span><br><span class="line">    MultiValueMap&lt;<span class="built_in">String</span>, <span class="built_in">Object</span>&gt; getAllAnnotationAttributes(<span class="built_in">String</span> var1);</span><br><span class="line">    MultiValueMap&lt;<span class="built_in">String</span>, <span class="built_in">Object</span>&gt; getAllAnnotationAttributes(<span class="built_in">String</span> var1, <span class="built_in">boolean</span> var2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  通过isAnnotated()方法可以检查@Bean方法是否被指定的注解类型修饰；通过其他方法可以获得修饰@Bean方法的注解的属性。</p></li></ul><p>从Spring 4开始，@Profile注解也利用@Conditional注解和Condition接口进行了重构。作为分析@Conditional注解和Condition接口的另一个例子，我们可以看下在Spring 4中@Profile注解的实现。<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="variable">@Target</span>(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span><br><span class="line"><span class="variable">@Documented</span></span><br><span class="line"><span class="variable">@Conditional</span>(&#123;ProfileCondition.class&#125;)</span><br><span class="line">public <span class="variable">@interface</span> Profile &#123;</span><br><span class="line">    <span class="selector-tag">String</span><span class="selector-attr">[]</span> <span class="selector-tag">value</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看出，@Profile注解的实现被@Conditional注解修饰，并且依赖于ProfileCondition类——该类是Condition接口的实现。如下列代码所示，ProfileCondition利用ConditionContext和AnnotatedTypeMetadata两个接口提供的方法进行决策。<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProfileCondition</span> <span class="keyword">implements</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line">    ProfileCondition() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) &#123;</span><br><span class="line">        <span class="keyword">if</span>(context.getEnvironment() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            MultiValueMap attrs = metadata.getAllAnnotationAttributes(Profile.<span class="keyword">class</span>.getName());</span><br><span class="line">            <span class="keyword">if</span>(attrs != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="built_in">Iterator</span> var4 = ((<span class="built_in">List</span>)attrs.<span class="keyword">get</span>(<span class="string">"value"</span>)).iterator();</span><br><span class="line"></span><br><span class="line">                <span class="built_in">Object</span> value;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span>(!var4.hasNext()) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    value = var4.next();</span><br><span class="line">                &#125; <span class="keyword">while</span>(!context.getEnvironment().acceptsProfiles((<span class="built_in">String</span>[])((<span class="built_in">String</span>[])value)));</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">//传给@Profile注解的参数对应的环境profiles已激活</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">//默认为true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看出，这代码写得不太好理解:ProfileCondition通过AnnotatedTypeMetadata实例获取与@Profile注解相关的所有注解属性；然后检查每个属性的值（存放在value实例中），对应的profiles别激活——即context.getEnvironment().acceptsProfiles(((String[]) value))的返回值是true，则matchs()方法返回true。</p><p>Environment类提供了可以检查profiles的相关方法，用于检查哪个profile被激活：</p><ul><li>String[] getActiveProfiles()——返回被激活的profiles数组；</li><li>String[] getDefaultProfiles()——返回默认的profiles数组；</li><li>boolean acceptsProfiles(String…profiles)——如果某个profiles被激活，则返回true。</li></ul><h2 id="处理自动装配中的歧义性"><a href="#处理自动装配中的歧义性" class="headerlink" title="处理自动装配中的歧义性"></a>处理自动装配中的歧义性</h2><p>在上文中介绍了如何通过自动装配让Spring自动简历bean之间的依赖关系——自动装配非常有用，通过自动装配可以减少大量显式配置代码。不过，自动装配（autowiring）要求bean的匹配具备唯一性，否则就会产生歧义，从而抛出异常。</p><p>举个例子说明自动装配的歧义性，假设你有如下自动装配的代码：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">setDessert</span><span class="params">(Dessert dessert)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.dessert = dessert;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Dessert是一个接口，有三个对应的实现：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Component</span></span><br><span class="line">public class Cake implements Dessert &#123; ... &#125;</span><br><span class="line"><span class="variable">@Component</span></span><br><span class="line">public class Cookies implements Dessert &#123; ... &#125;</span><br><span class="line"><span class="variable">@Component</span></span><br><span class="line">public class IceCream implements Dessert &#123; ... &#125;</span><br></pre></td></tr></table></figure></p><p>因为上述三个类都被@Component注解修饰，因此都会被component-scanning发现并在应用上下文中创建类型为Dessert的bean；然后，当Spring试图为setDessert()方法装配对应的Dessert参数时，就会面临多个选择；然后Spring就会抛出异常——<code>NoUniqueBeanDefinitionException</code>。</p><p>虽然在实际开发中并不会经常遇到这种歧义性，但是它确实是个问题，幸运的是Spring也提供了对应的解决办法。</p><h3 id="Primary指定优先bean"><a href="#Primary指定优先bean" class="headerlink" title="@Primary指定优先bean"></a>@Primary指定优先bean</h3><p>在定义bean时，可以通过指定一个优先级高的bean来消除自动装配过程中遇到的歧义问题。</p><p>在上述例子中，可以选择一个最重要的Bean，用@Primary注解修饰：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Component</span></span><br><span class="line"><span class="variable">@Primary</span></span><br><span class="line">public class IceCream implements Dessert &#123; ... &#125;</span><br></pre></td></tr></table></figure></p><p>如果你没有使用自动扫描，而是使用基于Java的显式配置文件，则如下定义@Bean方法：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Bean</span></span><br><span class="line"><span class="variable">@Primary</span></span><br><span class="line">public Dessert iceCream() &#123;</span><br><span class="line">  <span class="selector-tag">return</span> <span class="selector-tag">new</span> <span class="selector-tag">IceCream</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果使用基于XML文件的显式配置，则如下定义：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean <span class="attribute">id</span>=<span class="string">"iceCream"</span></span><br><span class="line">             <span class="attribute">class</span>=<span class="string">"com.dasserteater.IceCream"</span></span><br><span class="line">             <span class="attribute">primary</span>=<span class="string">"true"</span> /&gt;</span><br></pre></td></tr></table></figure></p><p>不论哪种形式，效果都一样：告诉Spring选择primary bean来消除歧义。不过，当应用中指定多个Primary bean时，Spring又不会选择了，再次遇到歧义。Spring还提供了功能更强大的歧义消除机制——@Qualifiers注解。</p><h3 id="Qualifier指定bean的ID"><a href="#Qualifier指定bean的ID" class="headerlink" title="@Qualifier指定bean的ID"></a>@Qualifier指定bean的ID</h3><p>由于在实际开发中，这种情况的出现实在是太罕见了，所以跳过这一小节，当实际遇到了再来回头看吧。</p><h2 id="bean的作用域"><a href="#bean的作用域" class="headerlink" title="bean的作用域"></a>bean的作用域</h2><p>默认情况下，Spring应用上下文中的bean都是单例对象，也就是说，无论给某个bean被多少次装配给其他bean，都是指同一个实例。</p><p>大部分情况下，单例bean很好用：如果一个对象没有状态并且可以在应用中重复使用，那么针对该对象的初始化和内存管理开销非常小。</p><p>但是，有些情况下你必须使用某中可变对象来维护几种不同的状态，因此形成非线程安全。在这种情况下，把类定义为单例并不是一个好主意——该对象在重入使用的时候可能遇到线程安全问题。</p><p>Spring定义了几种bean的作用域，列举如下：</p><ul><li>(单例)Singleton——在整个应用中只有一个bean的实例；</li><li>(原型)Prototype——每次某个bean被装配给其他bean时，都会创建一个新的实例；</li><li>(会话)Session——在web应用中，在每次会话过程中只创建一个bean的实例；</li><li>(请求)Request——在web应用中，在每次http请求中创建一个bean的实例。</li></ul><p>Singleton域是默认的作用域，如前所述，对于可变类型来说并不理想。我们可以使用@Scope注解——和@Component或@Bean注解都可以使用。</p><p>例如，如果你依赖component-scanning发现和定义bean，则可以用如下代码定义prototype bean：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Component</span></span><br><span class="line"><span class="variable">@Scope</span>(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span><br><span class="line">public class Notepad&#123; ... &#125;</span><br></pre></td></tr></table></figure></p><p>除了使用SCOPE_PROTOTYPE字符串指定bean的作用域，还可以使用@Scope(“prototype”)，但使用ConfigurableBeanFactory.SCOPE_PROTOTYPE更安全，不容易遇到拼写错误。</p><p>另外，如果你使用JavaConfig定义Notepad的bean，也可以给出下列定义：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Bean</span></span><br><span class="line"><span class="variable">@Scope</span>(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span><br><span class="line">public Notepad notepad() &#123;</span><br><span class="line">    <span class="selector-tag">return</span> <span class="selector-tag">new</span> <span class="selector-tag">Notepad</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果你使用xml文件定义Notepad的bean，则有如下定义：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean <span class="attribute">id</span>=<span class="string">"notepad"</span></span><br><span class="line">            <span class="attribute">class</span>=<span class="string">"com.myapp.Notepad"</span></span><br><span class="line">            <span class="attribute">scope</span>=<span class="string">"prototype"</span> /&gt;</span><br></pre></td></tr></table></figure></p><p>无论你最后采取上述三种定义方式的哪一种定义prototype类型的bean，每次Notepad被装配到其他bean时，都会重新创建一个新的实例。</p><h3 id="使用会话和请求作用域"><a href="#使用会话和请求作用域" class="headerlink" title="使用会话和请求作用域"></a>使用会话和请求作用域</h3><p>在Web应用中，有时需要在某个request或者session的作用域范围内共享同一个bean的实例。举个例子，在一个典型的电子商务应用中，可能会有一个bean代表用户的购物车，如果购物车是单例对象，则所有的用户会把自己要买的商品添加到同一个购物车中；另外，如果购物车bean设置为prototype，则在应用中某个模块中添加的商品在另一个模块中将不能使用。</p><p>对于这个例子，使用session scope更合适，因为一个会话（session）唯一对应一个用户，可以通过下列代码使用session scope:<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Bean</span></span><br><span class="line"><span class="variable">@Scope</span>(value=WebApplicationContext.SCOPE_SESSION,</span><br><span class="line">                proxyMode=ScopedProxyMode.INTERFACES)</span><br><span class="line">public ShoppingCart cart() &#123; ... &#125;</span><br></pre></td></tr></table></figure></p><p>在这里你通过value属性设置了WebApplicationContext.SCOPE_SESSION，这告诉Spring为web应用中的每个session创建一个ShoppingCartbean的实例。在整个应用中会有多个ShoppingCart实例，但是在某个会话的作用域中ShoppingCart是单例的。</p><p>这里还用proxyMode属性设置了ScopedProxyMode.INTERFACES值，这涉及到另一个问题：把request/session scope的bean装配到singleton scope的bean时会遇到。首先看下这个问题的表现。</p><p>假设在应用中需要将ShoppingCartbean装配给单例StoreServicebean的setter方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StoreService</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setShoppingCart</span><span class="params">(ShoppingCart shoppingCart)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.shoppingCart = shoppingCart;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>因为StoreService是单例bean，因此在Spring应用上下文加载时该bean就会被创建。在创建这个bean时 ，Spring会试图装配对应的ShoppingCartbean，但是这个bean是session scope的，目前还没有创建——只有在用户访问时并创建session时，才会创建ShoppingCartbean。</p><p>而且，之后肯定会有多个ShoppingCartbean：每个用户一个。理想的情景是：在需要StoreService操作购物车时，StoreService能够和ShoppingCartbean正常工作。</p><p>针对这种需求，Spring应该给StoreServicebean装配一个ShoppingCartbean的代理，如下图所示。代理类对外暴露的接口和ShoppingCart中的一样，用于告诉StoreService关于ShoppingCart的接口信息——当StoreService调用对应的接口时，代理采取延迟解析策略，并把调用委派给实际的session-scoped ShoppingCartbean。</p><p><img src="https://upload-images.jianshu.io/upload_images/44770-c117d67ea67a9f2a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/676" alt="Scoped proxies enable deferred injected of request- and session-coped beans"></p><p>因为ShoppingCart是一个接口，因此这里工作正常，但是，如果ShoppingCart是具体的类，则Spring不能创建基于接口的代理。这里必须使用CGLib创建class-based的bean，即使用ScopedProxyMode.TARGET_CLASS指示代理类应该基础自目标类。</p><p>这里使用session scope作为例子，在request scope中也有同样的问题，当然解决办法也相同。</p><h2 id="运行时值注入"><a href="#运行时值注入" class="headerlink" title="运行时值注入"></a>运行时值注入</h2><p>一般而言，讨论依赖注入和装配时，我们多关注的是如何（how）实现依赖注入（构造函数、setter方法），即如何建立对象之间的联系。</p><p>依赖注入的另一个方面是何时（when）将值装配给bean的属性或者构造函数。在上篇（Spring装配Bean）一文中，我们执行了很多值装配的任务，例如有如下代码：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> <span class="function">CompactDisc <span class="title">sgtPeppers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> BlankDisc(</span><br><span class="line">             <span class="string">"Sgt. Pepper's Lonely Hearts Club Band"</span>,</span><br><span class="line">             <span class="string">"The Beatles"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这种硬编码的方式有时可以，有时却需要避免硬编码——在运行时决定需要注入的值。Spring提供以下两种方式实现运行时注入：</p><ul><li>Property placeholders</li><li>The Spring Expression Language(SpEL)</li></ul><h3 id="Property-placeholders"><a href="#Property-placeholders" class="headerlink" title="Property placeholders"></a>Property placeholders</h3><p>在Spring中解析外部值的最好方法是定义一个配置文件，然后通过Spring的Environment实例获取配置文件中的配置项的值。例如，下列代码展示如何在Spring 配置文件中使用外部配置项的值。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="selector-tag">import</span> <span class="selector-tag">com</span><span class="selector-class">.spring</span><span class="selector-class">.sample</span><span class="selector-class">.soundsystem</span><span class="selector-class">.CompactDisc</span>;</span><br><span class="line"><span class="selector-tag">import</span> <span class="selector-tag">org</span><span class="selector-class">.springframework</span><span class="selector-class">.beans</span><span class="selector-class">.factory</span><span class="selector-class">.annotation</span><span class="selector-class">.Autowired</span>;</span><br><span class="line"><span class="selector-tag">import</span> <span class="selector-tag">org</span><span class="selector-class">.springframework</span><span class="selector-class">.context</span><span class="selector-class">.annotation</span><span class="selector-class">.Bean</span>;</span><br><span class="line"><span class="selector-tag">import</span> <span class="selector-tag">org</span><span class="selector-class">.springframework</span><span class="selector-class">.context</span><span class="selector-class">.annotation</span><span class="selector-class">.Configuration</span>;</span><br><span class="line"><span class="selector-tag">import</span> <span class="selector-tag">org</span><span class="selector-class">.springframework</span><span class="selector-class">.context</span><span class="selector-class">.annotation</span><span class="selector-class">.PropertySource</span>;</span><br><span class="line"><span class="selector-tag">import</span> <span class="selector-tag">org</span><span class="selector-class">.springframework</span><span class="selector-class">.core</span><span class="selector-class">.env</span><span class="selector-class">.Environment</span>;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">Configuration</span></span><br><span class="line">@PropertySource("classpath:/app.properties")</span><br><span class="line"><span class="selector-tag">public</span> <span class="selector-tag">class</span> <span class="selector-tag">ExpressiveConfig</span> &#123;</span><br><span class="line">        @Autowired</span><br><span class="line">        <span class="selector-tag">Environment</span> <span class="selector-tag">env</span>; </span><br><span class="line"></span><br><span class="line">       @<span class="keyword">Bean</span></span><br><span class="line">        public CompactDisc disc() &#123;</span><br><span class="line">              <span class="selector-tag">return</span> <span class="selector-tag">new</span> <span class="selector-tag">BlankDisc</span>(<span class="selector-tag">env</span><span class="selector-class">.getProperty</span>("<span class="selector-tag">disc</span><span class="selector-class">.title</span>"),</span><br><span class="line">                <span class="selector-tag">env</span><span class="selector-class">.getProperty</span>("<span class="selector-tag">disc</span><span class="selector-class">.artist</span>"));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，@PropertySource注解引用的配置文件内容如下：<br><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">disc.<span class="built_in">title</span>=Sgt. Pepper's Lonely Hearts Club <span class="built_in">Band</span></span><br><span class="line">disc.artist=The Beatles</span><br></pre></td></tr></table></figure></p><p>属性文件被加载到Spring的Environment实例中，然后通过getProperty()方法解析对应配置项的值。</p><h4 id="DIGGING-INTO-SPRING’S-ENVIRONMENT"><a href="#DIGGING-INTO-SPRING’S-ENVIRONMENT" class="headerlink" title="DIGGING INTO SPRING’S ENVIRONMENT"></a>DIGGING INTO SPRING’S ENVIRONMENT</h4><p>在Environment类中，getProperty()方法有如下几种重载形式：</p><ul><li>String getProperty(String var1);</li><li>String getProperty(String var1, String var2);</li><li><t> T getProperty(String var1, Class<t> var2);</t></t></li><li><t> T getProperty(String var1, Class<t> var2, T var3);</t></t></li></ul><p>前两个方法都是返回String值，利用第二个参数，可以设置默认值；后两个方法可以指定返回值的类型，举个例子：假设你需要从连接池中获取连接个数，如果你使用前两个方法，则返回的值是String，你需要手动完成类型转换；但是使用后两个方法，可以由Spring自动完成这个转换：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int<span class="built_in"> connection </span>= env.getProperty(<span class="string">"db.connection.count"</span>, Integer.class, 30)</span><br></pre></td></tr></table></figure></p><p>除了getProperty()方法，还有其他方法可以获得配置项的值，如果不设置默认值参数，则在对应的配置项不存在的情况下对应的属性会配置为null，如果你不希望这种情况发生——即要求每个配置项必须存在，则可以使用getRequiredProperty()方法：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> <span class="function">CompactDisc <span class="title">disc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> BlankDisc(</span><br><span class="line">            env.getRequiredProperty(<span class="string">"disc.title"</span>),</span><br><span class="line">            env.getRequiredProperty(<span class="string">"disc.artist"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在上述代码中，如果disc.title或者disc.artist配置项不存在，Spring都会抛出IllegalStateException异常。</p><p>如果你希望检查某个配置项是否存在，则可以调用containsProperty()方法：boolean titleExists = env.containsProperty(“disc.title”);。如果你需要将一个属性解析成某个类，则可以使用getPropertyAsClass()方法：Class<compactdisc> cdClass = env.getPropertyAsClass(“disc.class”, CompactDisc.class);</compactdisc></p><h4 id="RESOLVING-PROPERTY-PLACEHOLDER"><a href="#RESOLVING-PROPERTY-PLACEHOLDER" class="headerlink" title="RESOLVING PROPERTY PLACEHOLDER"></a>RESOLVING PROPERTY PLACEHOLDER</h4><p>在Spring中，可以使用${ … }将占位符包裹起来，例如，在XML文件中可以定义如下代码从配置文件中解析对应配置项的值：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean <span class="attribute">id</span>=<span class="string">"sgtPeppers"</span></span><br><span class="line">             <span class="attribute">class</span>=<span class="string">"soundsystem.BlankDisc"</span></span><br><span class="line">             c:<span class="attribute">_title</span>=<span class="string">"<span class="variable">$&#123;disc.title&#125;</span>"</span></span><br><span class="line">             c:<span class="attribute">_artist</span>=<span class="string">"<span class="variable">$&#123;disc.artist&#125;</span>"</span> /&gt;</span><br></pre></td></tr></table></figure></p><p>如果你使用component-scanning和自动装配创建和初始化应用组件，则可以使用@Value注解获取配置文件中配置项的值，例如BlankDisc的构造函数可以定义如下：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> BlankDisc(</span><br><span class="line">            <span class="meta">@Value(<span class="meta-string">"<span class="subst">$&#123;disc.title&#125;</span>"</span>)</span> String title,</span><br><span class="line">            <span class="meta">@Value(<span class="meta-string">"<span class="subst">$&#123;disc.artist&#125;</span>"</span>)</span> String artist) &#123;</span><br><span class="line">      <span class="keyword">this</span>.title = title;</span><br><span class="line">      <span class="keyword">this</span>.artist = artist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>为了使用占位符的值，需要配置PropertyPlaceholderConfigerbean或者PropertySourcesPlaceholderConfigurerbean。从Spring 3.1之后，更推荐使用PropertySourcesPlaceholderConfigurer，因为这个bean和Spring 的Environment的来源一样，例子代码如下：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function">PropertySourcesPlaceholderConfigurer <span class="title">placeholderConfigurer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PropertySourcesPlaceholderConfigurer();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果使用XML配置文件，则通过<context:property-placeholder>元素可以获得PropertySourcesPlaceholderConfigurerbean：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span>       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"classpath:/app.properties"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></context:property-placeholder></p><h3 id="使用SpEL装配"><a href="#使用SpEL装配" class="headerlink" title="使用SpEL装配"></a>使用SpEL装配</h3><p>Spring 3引入了Spring Expression Language（SpEL），这是一种在运行时给bean的属性或者构造函数参数注入值的方法。</p><p>SpEL有很多优点，简单列举如下：</p><ul><li>可以通过bean的ID引用bean；</li><li>可以调用某个对象的方法或者访问它的属性；</li><li>支持数学、关系和逻辑操作；</li><li>正则表达式匹配；</li><li>支持集合操作</li></ul><p>在后续的文章中，可以看到SpEL被用到依赖注入的其他方面，例如在Spring Security中，可以使用SpEL表达式定义安全限制；如果在Spring MVC中使用Thymeleaf模板，在模板中可以使用SpEL表达式获取模型数据。</p><h4 id="A-FEW-SpEL-EXAMPLES"><a href="#A-FEW-SpEL-EXAMPLES" class="headerlink" title="A FEW SpEL EXAMPLES"></a>A FEW SpEL EXAMPLES</h4><p>SpEL是一门非常灵活的表达式语言，在这里不准备花大量篇幅来涵盖它的所有方面，可以通过一些例子来感受一下它的强大能力。</p><p>首先，SpEL表达式被#{ … }包围，跟placeholders中的${ … }非常像，最简单的SpEL表达式可以写作#{1}。在应用中，你可能回使用更加有实际含义的SpEL表达式，例如#{T(System).currentTimeMillis()}——这个表达式负责获得当前的系统时间，而T()操作符负责将java.lang.System解析成类，以便可以调用currentTimeMillis()方法。</p><p>SpEL表达式可以引用指定ID的bean或者某个bean的属性，例如下面这个例子可以获得ID为sgtPeppers的bean的artist属性的值：#{sgtPeppers.artist}；也可以通过#{systemProperties[‘disc.title’]}引用系统属性。</p><p>上述这些例子都非常简单，我们接下来看下如何在bean装配中使用SpEL表达式，之前提到过，如果你使用component-scanning和自动装配创建应用组件，则可以使用@Value注解获得配置文件中配置项的值；除了使用placeholder表达式，还可以使用SpEL表达式，例如BlankDisc的构造函数可以按照下面这种方式来写：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> BlankDisc(</span><br><span class="line">            <span class="meta">@Value(<span class="meta-string">"#&#123;systemProperties['disc.title']&#125;"</span>)</span> String title,</span><br><span class="line">            <span class="meta">@Value(<span class="meta-string">"#&#123;systemProperties['disc.artist']&#125;"</span>)</span> String artist) &#123;</span><br><span class="line">      <span class="keyword">this</span>.title = title;</span><br><span class="line">      <span class="keyword">this</span>.artist = artist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="EXPRESSING-LITERAL-VALUES"><a href="#EXPRESSING-LITERAL-VALUES" class="headerlink" title="EXPRESSING LITERAL VALUES"></a>EXPRESSING LITERAL VALUES</h4><p>SpEL表达式可以表示整数值，也可以表示浮点数、String值和Boolean值。例如可以使用#{3.14159}表式浮点数3.14159，并且还支持科学计数法——#{9.87E4}表示98700；#{‘Hello’}可以表示字符串值、#{false}可以表示Boolean值。</p><p>单独使用字面值是乏味的，一般不会使用到只包含有字面值的SpEL表达式，不过在构造更有趣、更复杂的表达式时支持字面值这个特性非常有用。</p><p>REFERENCING BEANS, PROPERTIES, AND METHODS<br>SpEL表达式可以通过bean的ID引用bean，例如#{sgtPeppers}；也可以引用指定bean的属性，例如#{sgtPeppers.artist}；还可以调用某个bean的方法，例如#{artistSelector.selectArtist()}表达式可以调用artistSelector这个bean的selectArtist()方法。</p><p>SpEL表达式也支持方法的连续调用，例如#{artistSelector.selectArtist().toUpperCase()},为了防止出现NullPointerException异常，最好使用类型安全的操作符，例如#{artistSelector.selectArtist()?.toUpperCase()}。?.操作符在调用右边的函数之前，会确保左边的函数返回的值不为null。</p><p>WORKING WITH TYPES IN EXPRESSIONS<br>在SpEL中能够调用类的方法或者常量的关键是T()操作符，例如通过T(java.lang.Math)可以访问Math类中的方法和属性——#{(java.lang.Math).random()}和#{T(java.lang.Math).PI}。</p><h4 id="SpEL-OPERATORS"><a href="#SpEL-OPERATORS" class="headerlink" title="SpEL OPERATORS"></a>SpEL OPERATORS</h4><p>SpEL提供了不同种类的操作符，如下表所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/44770-f782a5a9727720d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/516" alt="SpEL operators for manipulating expression values"></p><h4 id="EVALUATING-REGULAR-EXPRESSIONS"><a href="#EVALUATING-REGULAR-EXPRESSIONS" class="headerlink" title="EVALUATING REGULAR EXPRESSIONS"></a>EVALUATING REGULAR EXPRESSIONS</h4><p>在操作文本字符串时，最常用的是检查某个文本是否符合某种格式。SpEL通过matches操作符支持正则表达式匹配。例如：#{admin.email matches ‘[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.com’}可以检查admin.email表示的邮件地址是否正确。</p><h4 id="EVALUATING-COLLECTIONS"><a href="#EVALUATING-COLLECTIONS" class="headerlink" title="EVALUATING COLLECTIONS"></a>EVALUATING COLLECTIONS</h4><p>通过SpEL表达式还可以操作集合和数组，例如#{jukebox.songs[4].title}这个表达式可以访问jukebox的songs数组的第5个元素。</p><p>也可以实现更复杂的功能：随机选择一首歌——#{jukebox.songs[T(java.lang.Math).random() * jukebox.songs.size()].title}。</p><p>SpEL提供了一个选择操作符——.?[]，可以获得某个集合的子集，举个例子，假设你获得jukebox中所有artist为Aerosmith的歌，则可以使用这个表达式：#{jukebox.songs.?[artist eq ‘Aerosmith’]}。可以看出，.?[]操作符支持在[]中嵌套另一个SpEL表达式。</p><p>SpEL还提供了其他两个选择操作符：.^ [ ]用于选择第一个匹配的元素；.$[]用于选择最后一个匹配的元素。</p><p>最后，SpEL还提供了一个提取操作符：.![]，可以根据指定的集合新建一个符合某个条件的新集合，例如#{jukebox.songs.![title]}可以将songs的title都提取出来构成一个新的字符串集合。</p><p>OK，SpEL的功能非常强大，但是这里需要给开发人员提个醒：别让你的SpEL表达式过于智能。你的表达式越智能，就越难对它们进行单元测试，因此，尽量保证你的SpEL表达式简单易理解。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这一章干货十足，我们基于第二章介绍的bean装配技术开始讨论，陆续介绍了关于bean装配的一些进阶知识。</p><p>首先我们介绍了通过Spring的profiles解决多环境部署的问题，通过在运行时根据代表指定环境的profile选择性创建某个bean，Spring可以实现无需重新构建就可以在多个环境下部署同一个应用。</p><p>Profiles bean是运行时创建bean的一种解决方案，不过Spring 4提供了一个更普遍的解决方案：利用@Conditional注解和Condition接口实现条件性创建bean。</p><p>我们还介绍了两种机制来解决自动装配时可能遇到的歧义性问题：primary beans和qualifiers。尽管定义一个primary bean非常简单，但它仍然有局限，因此我们需要利用qualifier缩小自动装配的bean的范围，而且，我们也演示了如何创建自己的qualifiers。</p><p>尽管大多数Spring bean是单例对象，但是在某些情况下具备其他作用域的对象更加合适。Spring 应用中可以创建singletons、prototypes、request-scoped或session-scoped。在使用request-scoped或者session-scoped类型的bean时，还需要解决将非单例对象注入到单例对象时遇到的问题——利用代理接口或代理类。</p><p>最后，我们也介绍了Spring表达式语言（SpEL），利用SpEL可以实现在运行时给bean注入值。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Spring装配Bean一文中，我们探讨了Spring的三种管理bean的方式：自动装配、基于JavaConfig、基于XML文件。本篇（对应《Spring实战第三章》）将探讨一些Spring中关于bean的管理的高级知识，这些技能你可能不会每天都用，但是非常重要。&lt;/p&gt;
    
    </summary>
    
      <category term="SSM框架" scheme="https://caoler.cn/categories/SSM%E6%A1%86%E6%9E%B6/"/>
    
      <category term="Spring" scheme="https://caoler.cn/categories/SSM%E6%A1%86%E6%9E%B6/Spring/"/>
    
    
      <category term="Spring" scheme="https://caoler.cn/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>《Spring实战》读书笔记1-Spring装配Bean</title>
    <link href="https://caoler.cn//post/2018/SpringInAction-1.html"/>
    <id>https://caoler.cn//post/2018/SpringInAction-1.html</id>
    <published>2018-06-08T16:41:28.000Z</published>
    <updated>2018-06-11T14:13:38.446Z</updated>
    
    <content type="html"><![CDATA[<p>Spring容器负责创建应用程序中的bean并通过DI来协调这些对象之间的关系。但是，作为开发人员，你需要告诉Spring要创建哪些bean并且如何将其装配在一起。当描述bean如何进行装配时，Spring具有非常大的灵活性，它提供了三种主要的装配机制：</p><a id="more"></a><ul><li>在XML中进行显式配置。</li><li>在Java中进行显式配置。</li><li>隐式的bean发现机制和自动装配。</li></ul><p>这三种配置方式既可以单独使用也可以根据实际情况组合使用。作者建议：尽可能地使用自动配置的机制。</p><h2 id="自动化装配Bean"><a href="#自动化装配Bean" class="headerlink" title="自动化装配Bean"></a>自动化装配Bean</h2><p>Spring从两个角度来实现自动化装配：</p><ul><li>组件扫描（component scanning）：Spring会自动发现应用上下文中所创建的bean。</li><li>自动装配（autowiring）：Spring自动满足bean之间的依赖。</li></ul><h3 id="创建可被发现的Bean"><a href="#创建可被发现的Bean" class="headerlink" title="创建可被发现的Bean"></a>创建可被发现的Bean</h3><p>这里举一个例子：CD和播放器，如果你不将CD插入（注入）到CD播放器中，那么CD播放器其实是没有太大用处的。所以，可以这样说，CD播放器依赖于CD才能完成它的使命。</p><p>创建接口CompactDisc<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public<span class="built_in"> interface </span>CompactDisc&#123;</span><br><span class="line">    void play();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后创建这个接口的实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SgtPeppers</span> <span class="keyword">implements</span> <span class="title">CompactDisc</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String title = <span class="string">"Sgt. Perppers' Lonely Hearts Club Band"</span>;</span><br><span class="line">    <span class="keyword">private</span> String artist = <span class="string">"The Beatles"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Playing "</span> + title + <span class="string">" by "</span> + artist);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>需要注意的就是SgtPeppers类上使用了 <strong>@Component注解</strong>。这个简单的注解表明该类会作为组件类，并告知Spring要为这个类创建bean。</p><p>但是组件扫描默认是不启用的，我们需要手动设置一下：<br>有两种方式</p><ol><li><p>@ComponentScan注解启用扫描</p><p> 在config包中创建</p> <figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Configuration</span></span><br><span class="line"><span class="variable">@ComponentScan</span>(basePackages = <span class="string">"cn.caoler.spring.service.impl"</span>)</span><br><span class="line">public class CDPlayerConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 在这个Java配置文件中有两个注解值得注意：<strong>@Configuration</strong>表示这个.java文件是一个配置文件；<strong>@ComponentScan</strong>表示开启Component扫描，并且可以设置basePackages属性——Spring将会设置该目录以及子目录下所有被@Component注解修饰的类。</p></li><li><p>通过XML启用组件扫描</p> <figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">context</span>:<span class="keyword">component</span>-scan base-<span class="keyword">package</span>=<span class="string">"com.spring.sample.soundsystem"</span> /&gt;</span><br></pre></td></tr></table></figure></li></ol><p>配置完成之后写一个测试类：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@RunWith</span>(SpringJUnit4ClassRunner.class)</span><br><span class="line"><span class="variable">@ContextConfiguration</span>(classes = CDPlayerConfig.class)</span><br><span class="line">public class CDPlayerTest &#123;</span><br><span class="line">    <span class="variable">@Autowired</span></span><br><span class="line">    private CompactDisc cd;</span><br><span class="line"></span><br><span class="line">    <span class="variable">@Test</span></span><br><span class="line">    public void cdShouldNotBeNull() &#123;</span><br><span class="line">        <span class="selector-tag">Assert</span><span class="selector-class">.assertNotNull</span>(cd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试通过，说明@Autowired注解起作用了，就意味着Spring能够发现CompactDisc类，自动在Spring上下文中将其创建为bean并将其注入到测试代码之中。</p><h3 id="为组件扫描的bean命名"><a href="#为组件扫描的bean命名" class="headerlink" title="为组件扫描的bean命名"></a>为组件扫描的bean命名</h3><p>Spring应用上下文中所有的bean都会给定一个ID。如果没有指定名字，那么spring会自动为该Bean命名，就是将类名的第一个字母变为小写。</p><p>如果需要指定bean名字的话，在@Component(“指定的名字”)即可。</p><h3 id="设置组件扫描的基础包"><a href="#设置组件扫描的基础包" class="headerlink" title="设置组件扫描的基础包"></a>设置组件扫描的基础包</h3><p>如果@ComponentScan没有设置任何属性，那么spring会默认扫描被@ComponentScan标注的类所在包。</p><p>如果你想更加清晰地表明你所设置的是基础包，那么你可以通过basePackages属性进行配置：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Configuration</span></span><br><span class="line"><span class="variable">@ComponentScan</span>(basePackages = &#123;<span class="string">"cn.caoler.spring.service1"</span>, <span class="string">"cn.caoler.spring.service2"</span>&#125;)</span><br><span class="line">public class SoundSystemConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这种字符串形式的表示虽然可以，但是不具备“类型安全”，因此Spring也提供了更加类型安全的机制，即通过类或者接口来设置扫描机制的目标目录，例如：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Configuration</span></span><br><span class="line"><span class="variable">@ComponentScan</span>(basePackageClasses = &#123;CDPlayer.class, DVDPlayer.class&#125;)</span><br><span class="line">public class SoundSystemConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="通过为bean添加注解实现自动装配"><a href="#通过为bean添加注解实现自动装配" class="headerlink" title="通过为bean添加注解实现自动装配"></a>通过为bean添加注解实现自动装配</h3><p>简单来说，自动装配的意思是让Spring从应用上下文中找到对应的bean的引用，并将它们注入到指定的bean。通过@Autowired注解可以完成自动装配。</p><p>例如，考虑下面代码中的CDPlayer类，它的构造函数被@Autowired修饰，表明当Spring创建CDPlayer的bean时，会给这个构造函数传入一个CompactDisc的bean对应的引用。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CDPlayer</span> <span class="keyword">implements</span> <span class="title">MediaPlayer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> CompactDisc cd;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CDPlayer</span><span class="params">(CompactDisc cd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cd = cd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cd.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>还有别的实现方法，例如将@Autowired注解作用在setCompactDisc()方法上:<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">setCd</span><span class="params">(CompactDisc cd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.cd = cd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>或者是其他名字的方法上，例如：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">insertCD</span><span class="params">(CompactDisc cd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.cd = cd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>更简单的用法是，可以将@Autowired注解直接作用在成员变量之上，例如：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> CompactDisc cd;</span><br></pre></td></tr></table></figure></p><p>只要对应类型的bean有且只有一个，则会自动装配到该属性上。如果没有找到对应的bean，应用会抛出对应的异常，如果想避免抛出这个异常，则需要设置@Autowired(required=false)。不过，在应用程序设计中，应该谨慎设置这个属性，因为这会使得你必须面对NullPointerException的问题。</p><p>如果存在多个同一类型的bean，则Spring会抛出异常，表示装配有歧义，解决办法有两个：<br>（1）通过@Qualifier注解指定需要的bean的ID；</p><p>（2）通过@Resource注解指定注入特定ID的bean；</p><h3 id="验证自动配置"><a href="#验证自动配置" class="headerlink" title="验证自动配置"></a>验证自动配置</h3><p>通过下列代码，可以验证：CompactDisc的bean已经注入到CDPlayer的bean中，同时在测试用例中是将CDPlayer的bean注入到当前测试用例。<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner.<span class="keyword">class</span>)</span><br><span class="line"><span class="meta">@ContextConfiguration</span>(classes = SoundSystemConfig.<span class="keyword">class</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CDPlayerTest</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(CDPlayerTest.<span class="keyword">class</span>);</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MediaPlayer player;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> playTest() &#123;</span><br><span class="line">        player.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="通过Java代码装配Bean"><a href="#通过Java代码装配Bean" class="headerlink" title="通过Java代码装配Bean"></a>通过Java代码装配Bean</h2><p>有时候 你想要将第三方库中的组件装配到你的应用中，在这种情况下，是没有办法在它的类上添加@Component和@Autowired注解的，因此就不能使用自动化装配的方案了。</p><p>这种情况下就只能通过显示装配的方式去装配，可选方式有两种，先学习通过Java代码去装配。</p><p>在进行显式配置时，JavaConfig是更好的方案，因为它更为强大、类型安全<br>并且对重构友好。</p><p>JavaConfig不同于其他用于实现业务逻辑的Java代码，因此不能将JavaConfig业务逻辑代码混在一起。一般都会给Java配置文件新建一个单独的package。</p><h3 id="创建配置类"><a href="#创建配置类" class="headerlink" title="创建配置类"></a>创建配置类</h3><p>实际上在之前的例子中我们已经实践过基于Java的配置文件，看如下代码：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Configuration</span></span><br><span class="line"><span class="variable">@ComponentScan</span>(basePackageClasses = &#123;CDPlayer.class, DVDPlayer.class&#125;)</span><br><span class="line">public class SoundSystemConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>@Configuration注解表示这个类是配置类，之前我们是通过@ComponentScan注解实现bean的自动扫描和创建，这里我们重点是学习如何显式创建bean，因此首先将<code>@ComponentScan(basePackageClasses = {CDPlayer.class, DVDPlayer.class})</code>这行代码去掉。</p><p>让我们看一下如何使用JavaConfig装配CDPlayer和CompactDisc。</p><h3 id="声明简单的bean"><a href="#声明简单的bean" class="headerlink" title="声明简单的bean"></a>声明简单的bean</h3><p>通过@Bean注解创建一个Spring bean，该bean的默认ID和函数的方法名相同，即sgtPeppers。例如：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> <span class="function">CompactDisc <span class="title">sgtPeppers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SgtPeppers();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>同样，可以指定bean的ID，例如：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span>(name = <span class="string">"lonelyHeartsClub"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="function">CompactDisc <span class="title">sgtPeppers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SgtPeppers();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="借助JavaConfig实现注入"><a href="#借助JavaConfig实现注入" class="headerlink" title="借助JavaConfig实现注入"></a>借助JavaConfig实现注入</h3><p>最简单的办法是将被引用的bean的生成函数传入到构造函数或者set函数中，例如：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> <span class="function">CDPlayer <span class="title">cdPlayer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CDPlayer(sgtPeppers());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看起来是函数调用，实际上不是：由于sgtPeppers()方法被@Bean注解修饰，所以Spring会拦截这个函数调用，并返回之前已经创建好的bean——确保该SgtPeppers bean为单例。</p><p>假如有下列代码：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> <span class="function">CDPlayer <span class="title">cdPlayer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CDPlayer(sgtPeppers());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> <span class="function">CDPlayer <span class="title">anotherCDPlayer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CDPlayer(sgtPeppers());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果把sgtPeppers()方法当作普通Java方法对待，则cdPlayerbean和anotherCDPlayerbean会持有不同的SgtPeppers实例——结合CDPlayer的业务场景看：就相当于将一片CD同时装入两个CD播放机中，显然这不可能。</p><p>默认情况下，Spring中所有的bean都是单例模式，因此cdPlayer和anotherCDPlayer这俩bean持有相同的SgtPeppers实例。</p><p>当然，还有一种更清楚的写法：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> <span class="function">CDPlayer <span class="title">cdPlayer</span><span class="params">(CompactDisc compactDisc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CDPlayer(compactDisc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> <span class="function">CDPlayer <span class="title">anotherCDPlayer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CDPlayer(sgtPeppers());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这种情况下，cdPlayer和anotherCDPlayer这俩bean持有相同的SgtPeppers实例，该实例的ID为lonelyHeartsClub。这种方法最值得使用，因为它不要求CompactDisc bean在同一个配置文件中定义——只要在应用上下文容器中即可（不管是基于自动扫描发现还是基于XML配置文件定义）。</p><h3 id="通过XML装配bean"><a href="#通过XML装配bean" class="headerlink" title="通过XML装配bean"></a>通过XML装配bean</h3><p>这里暂时略过</p><h3 id="混合使用多种配置方法"><a href="#混合使用多种配置方法" class="headerlink" title="混合使用多种配置方法"></a>混合使用多种配置方法</h3><h4 id="在JavaConfig中解析XML配置"><a href="#在JavaConfig中解析XML配置" class="headerlink" title="在JavaConfig中解析XML配置"></a>在JavaConfig中解析XML配置</h4><p>通过@Import注解导入其他的JavaConfig，并且支持同时导入多个配置文件；</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Configuration</span></span><br><span class="line"><span class="variable">@Import</span>(&#123;CDPlayerConfig.class, CDConfig.class&#125;)</span><br><span class="line">public class SoundSystemConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过@ImportResource注解导入XML配置文件；</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Configuration</span></span><br><span class="line"><span class="variable">@Import</span>(CDPlayerConfig.class)</span><br><span class="line"><span class="variable">@ImportResource</span>(<span class="string">"classpath: cd-config.xml"</span>)</span><br><span class="line">public class SoundSystemConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="在XML配置文件中应用JavaConfig"><a href="#在XML配置文件中应用JavaConfig" class="headerlink" title="在XML配置文件中应用JavaConfig"></a>在XML配置文件中应用JavaConfig</h4><p>通过<code>&lt;import&gt;</code>标签引入其他的XML配置文件；<br>通过<code>&lt;bean&gt;</code>标签导入Java配置文件到XML配置文件，例如<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean <span class="keyword">class</span>=<span class="string">"soundsystem.CDConfig"</span> /&gt;</span><br></pre></td></tr></table></figure></p><p>通常的做法是：无论使用JavaConfig或者XML装配，都要创建一个root configuration，即模块化配置定义；并且在这个配置文件中开启自动扫描机制：<code>&lt;context:component-scan&gt;</code>或者<code>@ComponentScan</code>。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Spring框架的核心是Spring容器。容器负责管理应用中组件的生命周期，它会创建这些组件并保证它们的依赖能够得到满足，这样的话，组件才能完成预定的任务。</p><p>在本章中，我们看到了在Spring中装配bean的三种主要方式：自动化配置、基于Java的显式配置以及基于XML的显式配置。不管你采用什么方式，这些技术都描述了Spring应用中的组件以及这些组件之间的关系。</p><p>我同时建议尽可能使用自动化配置，以避免显式配置所带来的维护成本。但是，如果你确实需要显式配置Spring的话，应该优先选择基于Java的配置，它比基于XML的配置更加强大、类型安全并且易于重构。在本书中的例子中，当决定如何装配组件时，我都会遵循这样的指<br>导意见。</p><p>因为依赖注入是Spring中非常重要的组成部分，所以本章中介绍的技术在本书中所有的地方都会用到。基于这些基础知识，下一章将会介绍一些更为高级的bean装配技术，这些技术能够让你更加充分地发挥Spring容器的威力。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Spring容器负责创建应用程序中的bean并通过DI来协调这些对象之间的关系。但是，作为开发人员，你需要告诉Spring要创建哪些bean并且如何将其装配在一起。当描述bean如何进行装配时，Spring具有非常大的灵活性，它提供了三种主要的装配机制：&lt;/p&gt;
    
    </summary>
    
      <category term="SSM框架" scheme="https://caoler.cn/categories/SSM%E6%A1%86%E6%9E%B6/"/>
    
      <category term="Spring" scheme="https://caoler.cn/categories/SSM%E6%A1%86%E6%9E%B6/Spring/"/>
    
    
      <category term="Spring" scheme="https://caoler.cn/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot整合MyBatis实战总结</title>
    <link href="https://caoler.cn//post/2018/SpringBoot-MyBaits-summary.html"/>
    <id>https://caoler.cn//post/2018/SpringBoot-MyBaits-summary.html</id>
    <published>2018-06-02T15:13:53.000Z</published>
    <updated>2018-06-02T15:14:32.555Z</updated>
    
    <content type="html"><![CDATA[<p>以下为此次项目中遇到的值得总结的问题</p><a id="more"></a><h3 id="1-表名为关键字的解决方法"><a href="#1-表名为关键字的解决方法" class="headerlink" title="1. 表名为关键字的解决方法"></a>1. 表名为关键字的解决方法</h3><p>数据库表明为index与关键字冲突，导致SQL语句执行出错，在改表名上加上’单引号即可避免该情况，举例如下：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line"><span class="selector-tag">i</span><span class="selector-class">.id</span>, <span class="selector-tag">i</span><span class="selector-class">.name</span>, <span class="selector-tag">i</span><span class="selector-class">.source</span>,</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-class">.id</span>, <span class="selector-tag">a</span>.name</span><br><span class="line">FROM <span class="string">'index'</span> i</span><br><span class="line">LEFT JOIN area a</span><br><span class="line">ON <span class="selector-tag">i</span>.id=<span class="selector-tag">a</span>.id</span><br></pre></td></tr></table></figure></p><p>感谢昌炬哥的指导！</p><h3 id="2-使用collection标签查询时结果仅有一条"><a href="#2-使用collection标签查询时结果仅有一条" class="headerlink" title="2. 使用collection标签查询时结果仅有一条"></a>2. 使用collection标签查询时结果仅有一条</h3><p>在进行多表级联查询时，一对多关系（如上述SQL，一条index表数据对应多条area表数据），使用collection标签对两张表进行关联时导致查询结果仅有一条，查阅论坛得知，<del>将互相关联的表的主键字段改为不相同即可，上述两表中主键均为id，修改表结构后，执行SQL如下：</del><br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line"><span class="selector-tag">i</span><span class="selector-class">.id</span>, <span class="selector-tag">i</span><span class="selector-class">.name</span>, <span class="selector-tag">i</span><span class="selector-class">.source</span>,</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-class">.aid</span>, <span class="selector-tag">a</span>.name</span><br><span class="line">FROM <span class="string">'index'</span> i</span><br><span class="line">LEFT JOIN area a</span><br><span class="line">ON <span class="selector-tag">i</span>.id=<span class="selector-tag">a</span>.aid</span><br></pre></td></tr></table></figure></p><p>上述方法也是一种解决办法，但是修改数据库表结构代价太大，解决方法如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resulrMap</span> <span class="attr">id</span>=<span class="string">"IndexArea"</span> <span class="attr">typr</span>=<span class="string">"com.myhexin.kiv.model.Index"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">extend</span>=<span class="string">"BaseResultMap"</span>&gt;</span></span><br><span class="line">    //此处BaseResultMap为1-n关系中“1”这一方的resultMap</span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"areaList"</span> <span class="attr">ofType</span>=<span class="string">"com.myhexin.kiv.model.IndexArea"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">property</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"index_id"</span> <span class="attr">property</span>=<span class="string">"indexId"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"area"</span> <span class="attr">property</span>=<span class="string">"area"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>扎眼看，上述代码并无任何差错，但是执行的时候对应结果却只有一条</p><p>将<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;id <span class="attribute">column</span>=<span class="string">"id"</span> <span class="attribute">property</span>=<span class="string">"id"</span>/&gt;</span><br></pre></td></tr></table></figure></p><p>修改为<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;result <span class="attribute">column</span>=<span class="string">"id"</span> <span class="attribute">property</span>=<span class="string">"id"</span>/&gt;</span><br></pre></td></tr></table></figure></p><p>即可不用通过修改数据库表结构解决对应问题。</p><p>原因是因为被关联表的id和关联表的id（唯一主键）冲突导致，所以将被关联表的id属性设置为属性值即可解决问题</p><p>再次感谢昌炬哥！</p><h3 id="3-Mybatis传入参数为多种类型时"><a href="#3-Mybatis传入参数为多种类型时" class="headerlink" title="3. Mybatis传入参数为多种类型时"></a>3. Mybatis传入参数为多种类型时</h3><h4 id="基本数据类型int-string-long-Date"><a href="#基本数据类型int-string-long-Date" class="headerlink" title="基本数据类型int,string,long,Date;"></a>基本数据类型int,string,long,Date;</h4><p>案例</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;sql <span class="built_in">id</span>=<span class="string">"Base_Column_List"</span> &gt;  </span><br><span class="line">    <span class="built_in">id</span>, car_dept_name, car_maker_name, icon,car_maker_py,hot_type  </span><br><span class="line">&lt;/sql&gt;  </span><br><span class="line">&lt;select <span class="built_in">id</span>=<span class="string">"selectByPrimaryKey"</span> resultMap=<span class="string">"BaseResultMap"</span> parameterType=<span class="string">"java.lang.Long"</span> &gt;  </span><br><span class="line">    select   </span><br><span class="line">    &lt;include refid=<span class="string">"Base_Column_List"</span> /&gt;  </span><br><span class="line">    <span class="keyword">from</span> common_car_make  </span><br><span class="line">    <span class="keyword">where</span> <span class="built_in">id</span> = <span class="comment">#&#123;id,jdbcType=BIGINT&#125;  </span></span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><h4 id="复杂数据类型-class-map"><a href="#复杂数据类型-class-map" class="headerlink" title="复杂数据类型 class,map"></a>复杂数据类型 class,map</h4><p>map类型案例</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">select</span> id=<span class="string">"queryCarMakerList"</span> resultMap=<span class="string">"BaseResultMap"</span> parameterType=<span class="string">"java.util.Map"</span>&gt;  </span><br><span class="line">    <span class="keyword">select</span>  </span><br><span class="line">    &lt;include refid=<span class="string">"Base_Column_List"</span> /&gt;  </span><br><span class="line">    <span class="keyword">from</span> common_car_make cm  </span><br><span class="line">    <span class="keyword">where</span> <span class="number">1</span>=<span class="number">1</span>  </span><br><span class="line">    &lt;<span class="keyword">if</span> test=<span class="string">"id != null"</span>&gt;  </span><br><span class="line">        <span class="keyword">and</span>  cm.id = <span class="meta">#&#123;id,jdbcType=DECIMAL&#125;  </span></span><br><span class="line">    &lt;/<span class="keyword">if</span>&gt;  </span><br><span class="line">    &lt;<span class="keyword">if</span> test=<span class="string">"carDeptName != null"</span>&gt;  </span><br><span class="line">        <span class="keyword">and</span>  cm.car_dept_name = <span class="meta">#&#123;carDeptName,jdbcType=VARCHAR&#125;  </span></span><br><span class="line">    &lt;/<span class="keyword">if</span>&gt;  </span><br><span class="line">    &lt;<span class="keyword">if</span> test=<span class="string">"carMakerName != null"</span>&gt;  </span><br><span class="line">        <span class="keyword">and</span>  cm.car_maker_name = <span class="meta">#&#123;carMakerName,jdbcType=VARCHAR&#125;  </span></span><br><span class="line">    &lt;/<span class="keyword">if</span>&gt;  </span><br><span class="line">    &lt;<span class="keyword">if</span> test=<span class="string">"hotType != null"</span> &gt;  </span><br><span class="line">       <span class="keyword">and</span>  cm.hot_type = <span class="meta">#&#123;hotType,jdbcType=BIGINT&#125;  </span></span><br><span class="line">    &lt;/<span class="keyword">if</span>&gt;  </span><br><span class="line">    <span class="keyword">ORDER</span> <span class="keyword">BY</span> cm.id  </span><br><span class="line">&lt;/<span class="keyword">select</span>&gt;</span><br></pre></td></tr></table></figure><p>类类型</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;update id=<span class="string">"updateByPrimaryKeySelective"</span> parameterType=<span class="string">"com.epeit.api.model.CommonCarMake"</span> &gt;  </span><br><span class="line">   update common_car_make  </span><br><span class="line">   &lt;<span class="built_in">set</span> &gt;  </span><br><span class="line">     &lt;<span class="keyword">if</span> <span class="built_in">test</span>=<span class="string">"carDeptName != null"</span> &gt;  </span><br><span class="line">       car_dept_name = <span class="comment">#&#123;carDeptName,jdbcType=VARCHAR&#125;,  </span></span><br><span class="line">     &lt;/<span class="keyword">if</span>&gt;  </span><br><span class="line">     &lt;<span class="keyword">if</span> <span class="built_in">test</span>=<span class="string">"carMakerName != null"</span> &gt;  </span><br><span class="line">       car_maker_name = <span class="comment">#&#123;carMakerName,jdbcType=VARCHAR&#125;,  </span></span><br><span class="line">     &lt;/<span class="keyword">if</span>&gt;  </span><br><span class="line">     &lt;<span class="keyword">if</span> <span class="built_in">test</span>=<span class="string">"icon != null"</span> &gt;  </span><br><span class="line">       icon = <span class="comment">#&#123;icon,jdbcType=VARCHAR&#125;,  </span></span><br><span class="line">     &lt;/<span class="keyword">if</span>&gt;  </span><br><span class="line">     &lt;<span class="keyword">if</span> <span class="built_in">test</span>=<span class="string">"carMakerPy != null"</span> &gt;  </span><br><span class="line">           car_maker_py = <span class="comment">#&#123;carMakerPy,jdbcType=VARCHAR&#125;,  </span></span><br><span class="line">     &lt;/<span class="keyword">if</span>&gt;  </span><br><span class="line">     &lt;<span class="keyword">if</span> <span class="built_in">test</span>=<span class="string">"hotType != null"</span> &gt;  </span><br><span class="line">           hot_type = <span class="comment">#&#123;hotType,jdbcType=BIGINT&#125;,  </span></span><br><span class="line">     &lt;/<span class="keyword">if</span>&gt;  </span><br><span class="line">   &lt;/<span class="built_in">set</span>&gt;  </span><br><span class="line">   <span class="built_in">where</span> id = <span class="comment">#&#123;id,jdbcType=BIGINT&#125;  </span></span><br><span class="line"> &lt;/update&gt;</span><br></pre></td></tr></table></figure><p><strong>map中包含数组的情况</strong></p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">select</span> id=<span class="string">"selectProOrderByOrderId"</span> resultType=<span class="string">"com.epeit.api.model.ProOrder"</span> parameterType=<span class="string">"java.util.HashMap"</span> &gt;  </span><br><span class="line">    <span class="function"><span class="keyword">select</span> <span class="title">sum</span>(<span class="params">pro_order_num</span>) proOrderNum,product_id productId,promotion_id promotionId  </span></span><br><span class="line"><span class="function">    <span class="keyword">from</span> pro_order  </span></span><br><span class="line"><span class="function">    <span class="keyword">where</span> 1</span>=<span class="number">1</span>  </span><br><span class="line">    &lt;<span class="keyword">if</span> test=<span class="string">"orderIds != null"</span>&gt;  </span><br><span class="line">      and  </span><br><span class="line">        &lt;<span class="keyword">foreach</span> collection=<span class="string">"orderIds"</span> item=<span class="string">"item"</span> open=<span class="string">"order_id IN("</span> separator=<span class="string">","</span> close=<span class="string">")"</span>&gt;  </span><br><span class="line">            <span class="meta">#&#123;item,jdbcType=BIGINT&#125;  </span></span><br><span class="line">        &lt;/<span class="keyword">foreach</span>&gt;  </span><br><span class="line">    &lt;/<span class="keyword">if</span>&gt;  </span><br><span class="line">    GROUP BY product_id,promotion_id  </span><br><span class="line">&lt;/<span class="keyword">select</span>&gt;</span><br></pre></td></tr></table></figure><p>在DAO层，如多有多个参数传入，那么一定要使用@Param注解，List类型也需要使用，否则mapping.xml将无法识别该参数</p><h3 id="4-控制台SQL语句的打印"><a href="#4-控制台SQL语句的打印" class="headerlink" title="4. 控制台SQL语句的打印"></a>4. 控制台SQL语句的打印</h3><p>直接application.properties里面定义 </p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logging<span class="selector-class">.level</span><span class="selector-class">.com</span><span class="selector-class">.abc</span>=DEBUG</span><br></pre></td></tr></table></figure><p>设置为开发级别即可</p><h3 id="5-spring-中自定义工具类需要注入service"><a href="#5-spring-中自定义工具类需要注入service" class="headerlink" title="5. spring 中自定义工具类需要注入service"></a>5. spring 中自定义工具类需要注入service</h3><p>在SpringMVC框架中，我们经常要使用@Autowired注解注入Service或者Mapper接口，我们也知道，在controller层中注入service接口，在service层中注入其它的service接口或者mapper接口都是可以的，但是如果我们要在我们自己封装的Utils工具类中或者非controller普通类中使用@Autowired注解注入Service或者Mapper接口，直接注入是不可能的，因为Utils使用了静态的方法，我们是无法直接使用非静态接口的，当我们遇到这样的问题，我们就要想办法解决了。</p><p>我们有两种方法解决这个问题，第一种是注解方式，第二种是xml配置方式，下面是我们在utils中使用@Autowired注解的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>   </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestUtils</span> </span>&#123;  </span><br><span class="line">    <span class="meta">@Autowired</span>  </span><br><span class="line">    <span class="keyword">private</span> ItemService itemService;  </span><br><span class="line">      </span><br><span class="line">    <span class="meta">@Autowired</span>  </span><br><span class="line">    <span class="keyword">private</span> ItemMapper itemMapper;  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> TestUtils testUtils;  </span><br><span class="line">      </span><br><span class="line">    <span class="meta">@PostConstruct</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;      </span><br><span class="line">        testUtils = <span class="keyword">this</span>;  </span><br><span class="line">    &#125;   </span><br><span class="line">      </span><br><span class="line">    <span class="comment">//utils工具类中使用service和mapper接口的方法例子，用"testUtils.xxx.方法" 就可以了        </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Item record)</span></span>&#123;  </span><br><span class="line">        testUtils.itemMapper.insert(record);  </span><br><span class="line">        testUtils.itemService.queryAll();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在init方法中使用以下注解就可以了，时间上这个init()的方法是可以自己随便定义的，注意：inti()方法里面不用写任何东西，跟我这样的就绝对ok了，不用看网上其他人瞎掰！</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostConstruct</span></span><br></pre></td></tr></table></figure><h3 id="6-使用clooection标签时报错Cause-org-apache-ibatis-reflection-ReflectionException-Could-not-set-property-‘xx’-of-‘class-xx’-with-value-‘xx’"><a href="#6-使用clooection标签时报错Cause-org-apache-ibatis-reflection-ReflectionException-Could-not-set-property-‘xx’-of-‘class-xx’-with-value-‘xx’" class="headerlink" title="6. 使用clooection标签时报错Cause: org.apache.ibatis.reflection.ReflectionException: Could not set property ‘xx’ of ‘class xx’ with value ‘xx’"></a>6. 使用clooection标签时报错Cause: org.apache.ibatis.reflection.ReflectionException: Could not set property ‘xx’ of ‘class xx’ with value ‘xx’</h3><p>当时这个问题折磨了我整整半天时间，对应的类，以及设置的值都是完全符合类型的，但是一直报错，总结如下：</p><p>出错时collection标签配置如下：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;collection <span class="keyword">property</span>=<span class="string">"orderdetails"</span> javaType=<span class="string">"com.luchao.mybatis.first.po.Orderdetail"</span>&gt;</span><br><span class="line">            &lt;<span class="literal">result</span> column=<span class="string">"id"</span> <span class="keyword">property</span>=<span class="string">"id"</span>/&gt;</span><br><span class="line">            &lt;<span class="literal">result</span> column=<span class="string">"items_id"</span> <span class="keyword">property</span>=<span class="string">"itemsId"</span>/&gt;</span><br><span class="line">            &lt;<span class="literal">result</span> column=<span class="string">"items_num"</span> <span class="keyword">property</span>=<span class="string">"itemsNum"</span>/&gt;</span><br><span class="line">            &lt;<span class="literal">result</span> column=<span class="string">"orders_id"</span> <span class="keyword">property</span>=<span class="string">"ordersId"</span>/&gt;</span><br><span class="line">&lt;/collection&gt;</span><br></pre></td></tr></table></figure></p><p>通过各种查找资料得知：上面的==javaType==属性的问题，因为这个是一对多，通过反射应该映射为List，但是使用javaType会让MyBatis认为orderdetails属性为Orderdetail，所以出错，将javaType改为ofType，只是指定泛型的类型为Orderdetail。</p><h3 id="7-Spring-MVC-Boot接收并返回简单JSON-数据（不定义对应pojo情况下）"><a href="#7-Spring-MVC-Boot接收并返回简单JSON-数据（不定义对应pojo情况下）" class="headerlink" title="7. Spring MVC /Boot接收并返回简单JSON 数据（不定义对应pojo情况下）"></a>7. Spring MVC /Boot接收并返回简单JSON 数据（不定义对应pojo情况下）</h3><p>前端json类型如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"name"</span>:<span class="string">"caole"</span>&#125;</span><br></pre></td></tr></table></figure><p>在控制器接受参数时，单个属性没有必要再去创建一个pojo对象来接收，这里可以使用map</p><p>举例如下<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">String</span> xxxxx(@RequestBody <span class="built_in">Map</span> <span class="built_in">map</span>) &#123;</span><br><span class="line">        <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; <span class="built_in">list</span> = (<span class="built_in">List</span>) <span class="built_in">map</span>.get(<span class="string">"xxxxx"</span>);</span><br></pre></td></tr></table></figure></p><p>且，使用Map接收参数时，注解需为@RequestBody</p><h3 id="8-使用SpringBoot框架PageHelper插件无法启用"><a href="#8-使用SpringBoot框架PageHelper插件无法启用" class="headerlink" title="8. 使用SpringBoot框架PageHelper插件无法启用"></a>8. 使用SpringBoot框架PageHelper插件无法启用</h3><p>由于网上有一大半的教程都是有误导性的，在这里重新总结一下</p><ol><li><p>导包，使用springBoot框架时，不能使用pageHelper的基础包，需要使用针对springboot的jar包</p><p> 网上大多数说法如下：<br> <del>有两种方式，我们这里只使用原生的PageHelper导入Maven</del></p><p> 在这里我们要使用如下JAR：</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>具体使用</p><p> 参考作者的使用方法</p><p> <a href="https://github.com/pagehelper/Mybatis-PageHelper/blob/master/wikis/zh/HowToUse.md" target="_blank" rel="external">pagehelper/Mybatis-PageHelper/HowToUse.md</a></p><p> <a href="https://github.com/pagehelper/pagehelper-spring-boot" target="_blank" rel="external">PageHelper integration with Spring Boot</a></p></li></ol><h3 id="9-一对多，多对多关联查询的总结"><a href="#9-一对多，多对多关联查询的总结" class="headerlink" title="9. 一对多，多对多关联查询的总结"></a>9. 一对多，多对多关联查询的总结</h3><p>在使用pagehelper插件对查询结果进行分页时，对于单表查询效率是极高的，且分页结果会让人很满意，但是进行多表级联查询的时候，效果就不那么理想了。由于开发时间有限，没有太多时间去创建适合开发环境的分页插件，所以就只能对SQL或者resultMap加以改装去使用pagehelper插件了。</p><p>分页插件作者的方法介绍如下： <a href="https://my.oschina.net/flags/blog/274000" target="_blank" rel="external">Mybatis关联结果查询分页方法</a></p><p>总结：</p><p>我们需要达到的目的：对于关联嵌套查询，使用分页的时候，只会对主SQL进行分页查询，嵌套的查询不会被分页。</p><p>对于<strong>关联结果查询</strong>，使用分页得不到正常的结果，因为只有把数据全部查询出来，才能得到最终的结果，对这个结果进行分页才有效。因而如果是这种情况，必然要先全部查询，在对结果处理，这样就体现不出分页的作用了。</p><p>对于<strong>关联嵌套查询</strong>，使用分页的时候，只会对主SQL进行分页查询，嵌套的查询不会被分页。</p><h4 id="如何对关联结果进行分页？"><a href="#如何对关联结果进行分页？" class="headerlink" title="如何对关联结果进行分页？"></a>如何对关联结果进行分页？</h4><ul><li>针对这种情况最好的方法就是手写分页，针对主要语句进行分页，对连接的表不进行分页查询</li><li>针对主要语句写count查询（不需要管连接的表）</li><li>这样一来，对嵌套的结果就没有影响了</li></ul><p>举例：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- lang: sql --&gt;</span><br><span class="line"><span class="keyword">select</span> *</span><br><span class="line">  <span class="keyword">from</span> (<span class="keyword">select</span> *</span><br><span class="line">          <span class="keyword">from</span> (<span class="keyword">select</span> a.*, rownum rw <span class="keyword">from</span> sys_role a <span class="keyword">where</span> rownum &lt;= <span class="number">4</span>)</span><br><span class="line">         <span class="keyword">where</span> rw &gt; <span class="number">0</span>) a</span><br><span class="line">  <span class="keyword">left</span> <span class="keyword">join</span> sys_role_function b <span class="keyword">on</span> a.roleid = b.roleid;</span><br></pre></td></tr></table></figure><h4 id="关于关联嵌套查询"><a href="#关于关联嵌套查询" class="headerlink" title="关于关联嵌套查询"></a>关于关联嵌套查询</h4><p>嵌套查询由于都是独立的sql，主sql和分支sql都是分离的，所以使用Mybatis分页插件可以正常分页。如果你还想对关联查询的分支sql进行分页查询，基本上是不可能的，但是通过column={}这种方式传递分页参数也能实现，估计有些人看不懂这里了，就到此为止吧，不需要做这么费力不讨好的事。</p><p>然而我们就要使用别人看不懂的这个方法</p><p>举例如下：</p><ol><li><p>一对多关系：</p><p> 有两张表，一张teacher，一张group，一个teacher对应多个group</p><p> teacher的model中包括List<group>对象</group></p><p> teachermapping.xml</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.oasis.test.mapper.TeacherMapper"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"teacherResultMap"</span> <span class="attr">type</span>=<span class="string">"com.oasis.test.entity.Teacher"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">property</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"teacher_name"</span> <span class="attr">property</span>=<span class="string">"name"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"age"</span> <span class="attr">property</span>=<span class="string">"age"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"groupList"</span> <span class="attr">ofType</span>=<span class="string">"com.oasis.test.entity.Group"</span> <span class="attr">column</span>=<span class="string">"id"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">select</span>=<span class="string">"com.oasis.test.mapper.GroupMapper.getGroupListByTeacherId"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getTeacherList"</span> <span class="attr">parameterType</span>=<span class="string">"java.lang.Long"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">resultMap</span>=<span class="string">"teacherResultMap"</span>&gt;</span></span><br><span class="line">        SELECT</span><br><span class="line">        ID,TEACHER_NAME,AGE</span><br><span class="line">        FROM</span><br><span class="line">        t_teacher limit 0,5</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p> GroupMapper.xml</p> <figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.oasis.test.mapper.GroupMapper"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"groupResultMap"</span> <span class="attr">type</span>=<span class="string">"com.oasis.test.entity.Group"</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">property</span>=<span class="string">"id"</span>/&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"group_name"</span> <span class="attr">property</span>=<span class="string">"name"</span>/&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"number"</span> <span class="attr">property</span>=<span class="string">"number"</span>/&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getGroupListByTeacherId"</span> <span class="attr">parameterType</span>=<span class="string">"java.lang.Long"</span></span></span></span><br><span class="line"><span class="xml">            resultMap="groupResultMap"&gt;</span></span><br><span class="line"><span class="xml">        SELECT</span></span><br><span class="line"><span class="xml">       ID,GROUP_NAME,NUMBER</span></span><br><span class="line"><span class="xml">        FROM</span></span><br><span class="line"><span class="xml">        t_group WHERE teacher_id=#</span><span class="template-variable">&#123;id&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p> 对应DAO中书写对应方法即可实现功能。</p></li><li><p>多对多关系</p><p> 一个指标组对应多个指标，一个指标也可能属于多个指标组</p><p> 三张表：index、index_recommend、recommend</p><p> 其中index_recommend表中仅有两个字段：index_id、recommend_id</p><p> recommendMapper.xml</p> <figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;resultMap <span class="built_in">id</span>=<span class="string">"selectAll"</span> type=<span class="string">"cn.caoler.model.Recommend"</span>&gt;</span><br><span class="line">    &lt;<span class="built_in">id</span> column=<span class="string">"id"</span> <span class="keyword">property</span>=<span class="string">"id"</span>/&gt;</span><br><span class="line">    &lt;<span class="literal">result</span> column=<span class="string">"name"</span> <span class="keyword">property</span>=<span class="string">"name"</span>/&gt;</span><br><span class="line">    &lt;<span class="literal">result</span> column=<span class="string">"number"</span> <span class="keyword">property</span>=<span class="string">"number"</span>/&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;collection <span class="keyword">property</span>=<span class="string">"indexList"</span> ofType=<span class="string">"cn.caoler.model.Index"</span></span><br><span class="line">                colum=<span class="string">"id"</span> select=<span class="string">"cn.caoler.mapper.IndexMapper.getIndexByRecommend"</span>&gt;</span><br><span class="line">    &lt;/collection&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br><span class="line">&lt;select <span class="built_in">id</span>=<span class="string">"selectAll"</span> resultMap=<span class="string">"selectAll"</span>&gt;</span><br><span class="line">    SELECT *</span><br><span class="line">    FROM</span><br><span class="line">    recommend</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><p> indexMapper.xml</p> <figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;resultMap <span class="built_in">id</span>=<span class="string">"selectAll"</span> type=<span class="string">"cn.caoler.model.Index"</span>&gt;</span><br><span class="line">    &lt;<span class="built_in">id</span> column=<span class="string">"id"</span> <span class="keyword">property</span>=<span class="string">"id"</span>/&gt;</span><br><span class="line">    &lt;<span class="literal">result</span> column=<span class="string">"name"</span> <span class="keyword">property</span>=<span class="string">"name"</span>/&gt;</span><br><span class="line">    &lt;<span class="literal">result</span> column=<span class="string">"number"</span> <span class="keyword">property</span>=<span class="string">"number"</span>/&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br><span class="line">&lt;select <span class="built_in">id</span>=<span class="string">"getIndexByRecommend"</span> resultMap=<span class="string">"selectAll"</span>&gt;</span><br><span class="line">    SELECT *</span><br><span class="line">    FROM</span><br><span class="line">    `index` <span class="keyword">as</span> i</span><br><span class="line">    <span class="keyword">where</span> i.<span class="built_in">id</span> <span class="keyword">in</span>(</span><br><span class="line">        select index_id <span class="keyword">from</span> index_recommend</span><br><span class="line">        <span class="keyword">where</span> recommend_id=<span class="comment">#&#123;id&#125;</span></span><br><span class="line">    )</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><p> 通过上述嵌套查询即可实现功能。</p></li></ol><h3 id="传入参数既有RequestParam，还有RequestBody的处理"><a href="#传入参数既有RequestParam，还有RequestBody的处理" class="headerlink" title="传入参数既有RequestParam，还有RequestBody的处理"></a>传入参数既有RequestParam，还有RequestBody的处理</h3><p>举例：</p><p>post 一个json数据到<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">http:</span><span class="comment">//www.google.com?code=1024</span></span><br></pre></td></tr></table></figure></p><p>RequestParams 就是 code=1024</p><p>RequestBody 就是你的json数据(题外话：注意content-type)</p><h3 id="参考博客："><a href="#参考博客：" class="headerlink" title="参考博客："></a>参考博客：</h3><ul><li><a href="https://www.oschina.net/question/154489_141658" target="_blank" rel="external">mybatis一对多返回结果集问题</a></li><li><a href="http://www.cnblogs.com/zemliu/archive/2013/08/16/3263053.html" target="_blank" rel="external">MyBatis使用Collection查询多对多或一对多结果集bug</a></li><li><a href="https://blog.csdn.net/u010235716/article/details/51698422" target="_blank" rel="external">MyBatis的传入参数parameterType类型</a></li><li><a href="https://segmentfault.com/q/1010000004951891" target="_blank" rel="external">Spring boot＋mybatis 打印sql</a></li><li><a href="https://blog.csdn.net/michael_hm/article/details/77885353" target="_blank" rel="external">spring 中自定义工具类 解决@Autowired为null</a></li><li><a href="http://www.cnblogs.com/lcngu/p/5476178.html" target="_blank" rel="external">Cause: org.apache.ibatis.reflection.ReflectionException</a></li><li><a href="https://onecoder.site/archives/968" target="_blank" rel="external">SpringBoot 接收并返回 JSON 数据</a></li><li><a href="https://blog.csdn.net/baidu_38116275/article/details/78622669" target="_blank" rel="external">关于mybatis中collection一对多关联查询分页出错问题总结</a></li><li><a href="https://www.cnblogs.com/shuaifing/p/7811110.html" target="_blank" rel="external">mybatis映射文件select<em>resultMap</em>关联查询_collection定义关联集合</a></li><li><a href="https://blog.csdn.net/xinluke/article/details/52710706" target="_blank" rel="external">@RequestBody和@RequestParam区别</a></li><li><a href="https://segmentfault.com/q/1010000005119927" target="_blank" rel="external">Springmvc中@RequestBody和@RequestParam能够同时使用吗</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以下为此次项目中遇到的值得总结的问题&lt;/p&gt;
    
    </summary>
    
      <category term="SSM框架" scheme="https://caoler.cn/categories/SSM%E6%A1%86%E6%9E%B6/"/>
    
      <category term="SpringBoot" scheme="https://caoler.cn/categories/SSM%E6%A1%86%E6%9E%B6/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="https://caoler.cn/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>统一异常处理</title>
    <link href="https://caoler.cn//post/2018/exception.html"/>
    <id>https://caoler.cn//post/2018/exception.html</id>
    <published>2018-05-30T15:12:29.000Z</published>
    <updated>2018-05-30T15:13:25.316Z</updated>
    
    <content type="html"><![CDATA[<p>在用spring Boot做web后台时，经常会出现异常，如果每个异常都自己去处理很麻烦，所以我们创建一个全局异常处理类来统一处理异常</p><a id="more"></a><p>代码:</p><p>Result.java</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Result</span>&lt;T&gt; &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 错误码. */</span></span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 提示信息. */</span></span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 具体的内容. */</span></span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCode</span><span class="params">(Integer code)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMsg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMsg</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ResultUtil .java<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ResultUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title">success</span>(<span class="params">Object <span class="keyword">object</span></span>) </span>&#123;</span><br><span class="line">        Result result = <span class="keyword">new</span> Result();</span><br><span class="line">        result.setCode(<span class="number">0</span>);</span><br><span class="line">        result.setMsg(<span class="string">"成功"</span>);</span><br><span class="line">        result.setData(<span class="keyword">object</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title">success</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> success(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title">error</span>(<span class="params">Integer code, String msg</span>) </span>&#123;</span><br><span class="line">        Result result = <span class="keyword">new</span> Result();</span><br><span class="line">        result.setCode(code);</span><br><span class="line">        result.setMsg(msg);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Gril</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span></span><br><span class="line">    <span class="meta">@NotNull(message = <span class="meta-string">"这个id必传"</span>)</span></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer getId(Integer id) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> void setId(Integer id) &#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用:<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@RestController</span></span><br><span class="line">public class GrilController &#123;   </span><br><span class="line">    <span class="comment">//添加女生</span></span><br><span class="line">    <span class="variable">@PostMapping</span>(value = <span class="string">"/grils/&#123;id&#125;"</span>)</span><br><span class="line">    public Result&lt;Gril&gt; grilAdd(<span class="variable">@Valid</span> Gril gril, BindingResult bindingResult)&#123; </span><br><span class="line">    </span><br><span class="line">        <span class="selector-tag">if</span>(bindingResult.hasErrors())&#123; </span><br><span class="line">            <span class="comment">//这个是把gril里面的这个id必传返回给前端</span></span><br><span class="line">            <span class="selector-tag">return</span> <span class="selector-tag">ResultUtil</span><span class="selector-class">.error</span>(<span class="number">1</span>,bindingResult.getFieldError().getDefaultMessage());</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="selector-tag">return</span> <span class="selector-tag">ResultUtil</span><span class="selector-class">.success</span>(grilpepository.save(gril));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>访问<a href="http://127.0.0.1:8081/grils" target="_blank" rel="external">http://127.0.0.1:8081/grils</a></p><p>返回<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"code"</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">"msg"</span>: <span class="string">"这个id必传"</span>,</span><br><span class="line">  <span class="attr">"data"</span>: <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>访问<a href="http://127.0.0.1:8081/grils/2" target="_blank" rel="external">http://127.0.0.1:8081/grils/2</a></p><p>返回<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"id"</span>: <span class="number">21</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>统一异常处理</strong><br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">GrilException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Integer</span> code;</span><br><span class="line"></span><br><span class="line">    public <span class="type">GrilException</span>(<span class="type">Integer</span> code,<span class="type">String</span> message) &#123;</span><br><span class="line">        <span class="keyword">super</span>(message);</span><br><span class="line">        <span class="keyword">this</span>.code = code();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="type">Integer</span> getCode() &#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCode(<span class="type">Integer</span> code) &#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionHandle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(ExceptionHandle.class);</span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(value = Exception.class)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function">Result <span class="title">Handle</span><span class="params">(Exception e)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (e <span class="keyword">instanceof</span> GrilException)&#123;</span><br><span class="line">            GrilException grilException = (GrilException) e;</span><br><span class="line">            <span class="keyword">return</span> ResultUtil.<span class="keyword">error</span>(grilException.getCode(),grilException.getMessage());</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">　　　　　　<span class="comment">//将系统异常以打印出来</span></span><br><span class="line">            logger.info(<span class="string">"[系统异常]&#123;&#125;"</span>,e);</span><br><span class="line">            <span class="function"><span class="keyword">return</span> ResultUtil.<span class="title">error</span><span class="params">(<span class="number">-1</span>,<span class="string">"未知错误"</span>)</span></span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GirlService</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getAge</span><span class="params">(Integer id)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Girl girl = girlRepository.findOne(id);</span><br><span class="line">        Integer age = girl.getAge();</span><br><span class="line">        <span class="keyword">if</span> (age &lt; <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="comment">//返回"你还在上小学吧" code=100</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> GirlException(<span class="number">100</span>,<span class="string">"你还在上小学吧"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (age &gt; <span class="number">10</span> &amp;&amp; age &lt; <span class="number">16</span>) &#123;</span><br><span class="line">            <span class="comment">//返回"你可能在上初中" code=101</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> GirlException(<span class="number">101</span>,<span class="string">"你可能在上初中"</span> );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@RestController</span></span><br><span class="line">public class GirlController &#123;</span><br><span class="line"></span><br><span class="line">    <span class="variable">@Autowired</span></span><br><span class="line">    private GirlService girlService;</span><br><span class="line">   <span class="variable">@GetMapping</span>(value = <span class="string">"girls/getAge/&#123;id&#125;"</span>)</span><br><span class="line">    public void getAge(<span class="variable">@PathVariable</span>(<span class="string">"id"</span>) Integer id) throws Exception&#123;</span><br><span class="line">        <span class="selector-tag">girlService</span><span class="selector-class">.getAge</span>(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://images2017.cnblogs.com/blog/1027049/201711/1027049-20171109171151669-1830164285.png" alt="image"></p><p><strong>异常是统一维护</strong><br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">GirlException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Integer</span> code;</span><br><span class="line"></span><br><span class="line">    public <span class="type">GirlException</span>(<span class="type">ResultEnum</span> resultEnum) &#123;</span><br><span class="line">        <span class="keyword">super</span>(resultEnum.getMsg());</span><br><span class="line">        <span class="keyword">this</span>.code = resultEnum.getCode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="type">Integer</span> getCode() &#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCode(<span class="type">Integer</span> code) &#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionHandle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(ExceptionHandle.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(value = Exception.class)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function">Result <span class="title">handle</span><span class="params">(Exception e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (e <span class="keyword">instanceof</span> GirlException) &#123;</span><br><span class="line">            GirlException girlException = (GirlException) e;</span><br><span class="line">            <span class="keyword">return</span> ResultUtil.<span class="keyword">error</span>(girlException.getCode(), girlException.getMessage());</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            logger.<span class="keyword">error</span>(<span class="string">"【系统异常】&#123;&#125;"</span>, e);</span><br><span class="line">            <span class="function"><span class="keyword">return</span> ResultUtil.<span class="title">error</span><span class="params">(<span class="number">-1</span>, <span class="string">"未知错误"</span>)</span></span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个就是统一维护的文件,采用枚举<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">ResultEnum</span> &#123;</span></span><br><span class="line">    UNKONW_ERROR(<span class="number">-1</span>, <span class="string">"未知错误"</span>),</span><br><span class="line">    SUCCESS(<span class="number">0</span>, <span class="string">"成功"</span>),</span><br><span class="line">    PRIMARY_SCHOOL(<span class="number">100</span>, <span class="string">"我猜你可能还在上小学"</span>),</span><br><span class="line">    MIDDLE_SCHOOL(<span class="number">101</span>, <span class="string">"你可能在上初中"</span>),</span><br><span class="line"></span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> msg;</span><br><span class="line"></span><br><span class="line">    ResultEnum(Integer code, <span class="keyword">String</span> msg) &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">        <span class="built_in">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer getCode() &#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">String</span> getMsg() &#123;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GirlService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> GirlRepository girlRepository;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getAge</span><span class="params">(Integer id)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Girl girl = girlRepository.findOne(id);</span><br><span class="line">        Integer age = girl.getAge();</span><br><span class="line">        <span class="keyword">if</span> (age &lt; <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="comment">//返回"你还在上小学吧" code=100</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> GirlException(ResultEnum.PRIMARY_SCHOOL);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (age &gt; <span class="number">10</span> &amp;&amp; age &lt; <span class="number">16</span>) &#123;</span><br><span class="line">            <span class="comment">//返回"你可能在上初中" code=101</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> GirlException(ResultEnum.MIDDLE_SCHOOL);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果&gt;16岁,加钱</span></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@RestController</span></span><br><span class="line">public class GirlController &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="variable">@Autowired</span></span><br><span class="line">    private GirlService girlService;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="variable">@GetMapping</span>(value = <span class="string">"girls/getAge/&#123;id&#125;"</span>)</span><br><span class="line">    public void getAge(<span class="variable">@PathVariable</span>(<span class="string">"id"</span>) Integer id) throws Exception&#123;</span><br><span class="line">        <span class="selector-tag">girlService</span><span class="selector-class">.getAge</span>(id);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>后记：在使用枚举类的时候<code>ResultUtil.error(ResultEnum.UNKONW_ERROR)</code>报错，具体原因待总结</p><p>参考：<br><a href="https://www.cnblogs.com/renshengruozhiruchujian/p/7810463.html" target="_blank" rel="external">springboot统一异常处理及返回数据的处理</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在用spring Boot做web后台时，经常会出现异常，如果每个异常都自己去处理很麻烦，所以我们创建一个全局异常处理类来统一处理异常&lt;/p&gt;
    
    </summary>
    
      <category term="SSM框架" scheme="https://caoler.cn/categories/SSM%E6%A1%86%E6%9E%B6/"/>
    
      <category term="SpringBoot" scheme="https://caoler.cn/categories/SSM%E6%A1%86%E6%9E%B6/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="https://caoler.cn/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Swagger2-生成RESTful接口文档</title>
    <link href="https://caoler.cn//post/2018/springboot-swagger2.html"/>
    <id>https://caoler.cn//post/2018/springboot-swagger2.html</id>
    <published>2018-05-29T15:11:37.000Z</published>
    <updated>2018-05-30T15:13:24.019Z</updated>
    
    <content type="html"><![CDATA[<p>Swagger 是一个规范和完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务。总体目标是使客户端和文件系统作为服务器以同样的速度来更新。文件的方法，参数和模型紧密集成到服务器端的代码，允许API来始终保持同步。</p><a id="more"></a><h3 id="1-引入依赖"><a href="#1-引入依赖" class="headerlink" title="1. 引入依赖"></a>1. 引入依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-配置Swagger2"><a href="#2-配置Swagger2" class="headerlink" title="2.配置Swagger2"></a>2.配置Swagger2</h3><p>在 Application.java 同级创建 Swagger2.java（同级创建该文件会导致项目目录结构不整洁，在config目录下创建呢？）</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Configuration</span></span><br><span class="line"><span class="variable">@EnableSwagger2</span></span><br><span class="line">public class Swagger2 &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="variable">@Bean</span></span><br><span class="line">    public Docket createRestApi() &#123;</span><br><span class="line">        <span class="selector-tag">return</span> <span class="selector-tag">new</span> <span class="selector-tag">Docket</span>(DocumentationType.SWAGGER_2)</span><br><span class="line">                <span class="selector-class">.apiInfo</span>(apiInfo())</span><br><span class="line">                <span class="selector-class">.select</span>()</span><br><span class="line">                <span class="selector-class">.apis</span>(RequestHandlerSelectors.basePackage(<span class="string">"cn.caoler.kiv.controller"</span>))</span><br><span class="line">                <span class="selector-class">.paths</span>(PathSelectors.any())</span><br><span class="line">                <span class="selector-class">.build</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="selector-tag">private</span> <span class="selector-tag">ApiInfo</span> <span class="selector-tag">apiInfo</span>() &#123;</span><br><span class="line">        <span class="selector-tag">return</span> <span class="selector-tag">new</span> <span class="selector-tag">ApiInfoBuilder</span>()</span><br><span class="line">                <span class="selector-class">.title</span>(<span class="string">"Spring Boot添加Swagger2组件"</span>)</span><br><span class="line">                <span class="selector-class">.description</span>(<span class="string">"Spring Boot添加Swagger2组件"</span>)</span><br><span class="line">                <span class="selector-class">.version</span>(<span class="string">"1.0"</span>)</span><br><span class="line">                <span class="selector-class">.build</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 .apis(RequestHandlerSelectors.basePackage(“cn.caoler.kiv.controller”)) 指定了以扫描包的方式进行，会把cn.caoler.kiv.controller包下的controller都扫描到。</p><p>@configration 标识这是一个配置类</p><p>@EnableSwagger2开启swagger2</p><p>PathSelectors.any()表示路径选择器匹配所有路径</p><p>apiInfo() swagger页面上的一些展示信息</p><h3 id="3-举例"><a href="#3-举例" class="headerlink" title="3.举例"></a>3.举例</h3><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@ApiOperation</span>(value = <span class="string">"新建用户"</span>, notes = <span class="string">"新建一个用户"</span>)</span><br><span class="line"><span class="variable">@ApiImplicitParams</span>(&#123;</span><br><span class="line">    <span class="variable">@ApiImplicitParam</span>(name = <span class="string">"user"</span>, value = <span class="string">"用户数据"</span>, required = true,dataType = <span class="string">"User"</span>) </span><br><span class="line">    <span class="variable">@ApiImplicitParam</span>(name = <span class="string">"page"</span>, value = <span class="string">"页码"</span>, required = true,dataType = <span class="string">"Integer"</span>) </span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable">@RequestMapping</span>(value = <span class="string">"/create"</span>, method = RequestMethod.POST)</span><br><span class="line">public Object create(<span class="variable">@RequestBody</span> User user</span><br><span class="line">                    <span class="variable">@RequsstParam</span>(value = <span class="string">"page"</span>) Integer page) &#123;</span><br><span class="line">    <span class="selector-tag">System</span><span class="selector-class">.out</span><span class="selector-class">.println</span>(<span class="string">"user : "</span> + user.getName());</span><br><span class="line">    <span class="selector-tag">System</span><span class="selector-class">.out</span><span class="selector-class">.println</span>(page);</span><br><span class="line">    <span class="selector-tag">return</span> <span class="selector-tag">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-常用注释"><a href="#4-常用注释" class="headerlink" title="4.常用注释"></a>4.常用注释</h3><p>@Api() 用于类；表示标识这个类是swagger的资源 </p><ul><li>tags–表示说明 </li><li>value–也是说明，可以使用tags替代 </li></ul><p>@ApiOperation() 用于方法；表示一个http请求的操作 </p><ul><li>value用于方法描述 </li><li>notes用于提示内容 </li></ul><p>@ApiParam() 用于方法，参数，字段说明；表示对参数的添加元数据（说明或是否必填等） </p><ul><li>name–参数名 </li><li>value–参数说明 </li><li>required–是否必填</li></ul><p>@ApiModel()用于类 ；表示对类进行说明，用于参数用实体类接收 </p><ul><li>value–表示对象名 </li></ul><p>@ApiModelProperty()用于方法，字段； 表示对model属性的说明或者数据操作更改 </p><ul><li>value–字段说明 </li><li>name–重写属性名字 </li><li>dataType–重写属性类型 </li><li>required–是否必填 </li><li>example–举例说明 </li><li>hidden–隐藏</li></ul><p>@ApiImplicitParam() 用于方法 </p><ul><li>表示单独的请求参数</li></ul><p>@ApiImplicitParams() 用于方法，包含多个 @ApiImplicitParam </p><ul><li>name–参数ming </li><li>value–参数说明 </li><li>dataType–数据类型 </li><li>paramType–参数类型 </li><li>example–举例说明</li></ul><p>@ApiIgnore</p><ul><li>作用于方法上，使用这个注解swagger将忽略这个接口</li></ul><h3 id="5-SwaggerUI访问404错误"><a href="#5-SwaggerUI访问404错误" class="headerlink" title="5. SwaggerUI访问404错误"></a>5. SwaggerUI访问404错误</h3><p>在按照网上教程配置好Swagger之后，在localhost:8080/swagger-ui.html 访问即可看到swagger页面了。</p><p>但是我第一次按照这样的方法配置却提示如下错误：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Whitelabel <span class="builtin-name">Error</span> Page</span><br><span class="line"></span><br><span class="line">This application has <span class="literal">no</span> explicit mapping <span class="keyword">for</span> /error, so you are seeing this as a fallback.</span><br><span class="line"></span><br><span class="line">Thu Nov 24 19:57:13 CST 2016</span><br><span class="line">There was an unexpected <span class="builtin-name">error</span> (<span class="attribute">type</span>=Not Found, <span class="attribute">status</span>=404).</span><br><span class="line"><span class="literal">No</span> message available</span><br></pre></td></tr></table></figure><p>出现404不是说文件没有，而是映射出现了问题，特别是静态文件映射。</p><p>解决方法：</p><p>在WebMvcConfig下添加如下代码：（若没有创建此拦截器，创建并extends WebMvcConfigurerAdapter）</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Override</span></span><br><span class="line">public void addResourceHandlers(ResourceHandlerRegistry registry) &#123;</span><br><span class="line">    <span class="selector-tag">registry</span><span class="selector-class">.addResourceHandler</span>(<span class="string">"/**"</span>)<span class="selector-class">.addResourceLocations</span>(<span class="string">"classpath:/static/"</span>);</span><br><span class="line">    <span class="selector-tag">registry</span><span class="selector-class">.addResourceHandler</span>(<span class="string">"swagger-ui.html"</span>)</span><br><span class="line">    <span class="selector-class">.addResourceLocations</span>(<span class="string">"classpath:/META-INF/resources/"</span>);</span><br><span class="line">    <span class="selector-tag">registry</span><span class="selector-class">.addResourceHandler</span>(<span class="string">"/webjars/**"</span>)</span><br><span class="line">    <span class="selector-class">.addResourceLocations</span>(<span class="string">"classpath:/META-INF/resources/webjars/"</span>);</span><br><span class="line">    <span class="selector-tag">super</span><span class="selector-class">.addResourceHandlers</span>(registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/6083940-81a5c81de98bff9f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="6-参考"><a href="#6-参考" class="headerlink" title="6.参考"></a>6.参考</h3><ul><li><a href="https://www.cnblogs.com/magicalSam/p/7197533.html" target="_blank" rel="external">Spring Boot 系列（七）Swagger2-生成RESTful接口文档</a></li><li><a href="https://www.cnblogs.com/cmyxn/p/8028134.html" target="_blank" rel="external">springboot添加swagger2组件</a></li><li><a href="https://www.cnblogs.com/moncat/p/7218061.html" target="_blank" rel="external">SpringBoot配置SwaggerUI访问404错误</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Swagger 是一个规范和完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务。总体目标是使客户端和文件系统作为服务器以同样的速度来更新。文件的方法，参数和模型紧密集成到服务器端的代码，允许API来始终保持同步。&lt;/p&gt;
    
    </summary>
    
      <category term="SSM框架" scheme="https://caoler.cn/categories/SSM%E6%A1%86%E6%9E%B6/"/>
    
      <category term="SpringBoot" scheme="https://caoler.cn/categories/SSM%E6%A1%86%E6%9E%B6/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="https://caoler.cn/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>生活总是那么戏剧</title>
    <link href="https://caoler.cn//post/2018/10jqka.html"/>
    <id>https://caoler.cn//post/2018/10jqka.html</id>
    <published>2018-04-26T15:09:28.000Z</published>
    <updated>2018-05-27T10:47:18.008Z</updated>
    
    <content type="html"><![CDATA[<p>题目来自于找工作时百般焦虑时室友口中的一句话，就直接借用了。</p><a id="more"></a><p><img src="https://ws1.sinaimg.cn/large/005DnJLEgy1fqqemdefvdj31hc0q3e82.jpg" alt="开局一张图 内容全靠编~~~哈哈"></p><p>粗略的算起，找工作到今天拿到同花顺offer已经过去了46天，由一开始的兴奋，到自信，再到将就，再到崩溃，再到满心欢喜。实话说46天过的实在煎熬，它不像高考 最终只有两个答案，但是三年的努力让我又不想将就。期间有拿到武汉小公司的offer，但是感觉实在跟自己的实力不太匹配，所以到最终还是放弃了。回到标题，为什么要说生活总是那么戏剧，因为在面试同花顺之前我做了一个特别大的决定：我放弃了学习了近三年的Java 而去转战PHP。其实到今天拿到offer的那一刻 还是心有余悸，有那么一份不舍。我不知道我的决定是否正确，是否会对我的以后产生太大的影响，严重到就像青春的赌注，不说赌赢了，起码我不想输。一回头，努力学了三年的Java就这样突然没了 没了 了。。。</p><p>我相信在我的努力之下时间会给我答案，尽管这句话听起来那么的不靠谱。</p><p>我为自己感到欣慰，因为2018年的初步目标我已经完成了一半了。</p><p>写到这里 我很想感谢几个人。谢谢室友三年的陪伴，谢谢王峻洋平常一起的愉快玩耍和在找工作路上对我的指点和参谋。谢谢9栋508的小伙伴，谢谢梁壮董博和我在项目里的合作，谢谢你们在我找工作时候的指导。谢谢FJY和AYS一年多的陪伴。</p><p>同花顺的工作时光我会更加努力，在PHP的道路上勇往直前！</p><p>像迎新系统第一屏说的那样，祝我在同花顺度过开心充实的美好时光！</p><p>有感而发，就写到这里。</p><p>2018年4月26日23:07:02</p><p>时隔一月，更新一下。</p><p>我逐渐适应了在杭州的生活，由一开始的期待到焦躁不安再到现在的无法形容。值得庆幸的是就是回归单身了，还有我赶上组内转型了，我又可以继续写我的JAVA代码了。</p><p>昨天终于看了一直想看的肖申克的救赎，满分10分我打9.9分，因为中间上厕所打断了一下，哈</p><p><img src="https://ws1.sinaimg.cn/large/005DnJLEgy1frq359qdfej30e6073gls.jpg" alt=""></p><p>感觉这张图是最符合我现在的处境的一张，待我爬出那根下水道再来更新它。</p><p>还有就是希望自己能开心一点，不要太压抑了。</p><p>更新于：2018年5月27日18:46:52</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目来自于找工作时百般焦虑时室友口中的一句话，就直接借用了。&lt;/p&gt;
    
    </summary>
    
      <category term="CodingLife" scheme="https://caoler.cn/categories/CodingLife/"/>
    
    
      <category term="CodingLife" scheme="https://caoler.cn/tags/CodingLife/"/>
    
  </entry>
  
  <entry>
    <title>Spring Bean生命周期</title>
    <link href="https://caoler.cn//post/2018/SpringBeanLife.html"/>
    <id>https://caoler.cn//post/2018/SpringBeanLife.html</id>
    <published>2018-04-07T11:13:48.000Z</published>
    <updated>2018-04-07T11:15:06.818Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring-Bean-生命周期"><a href="#Spring-Bean-生命周期" class="headerlink" title="Spring Bean 生命周期"></a>Spring Bean 生命周期</h1><p>BeanFactory和ApplicationContext是Spring两种很重要的容器,前者提供了最基本的依赖注入的支持，而后者在继承前者的基础进行了功能的拓展，例如增加了事件传播，资源访问和国际化的消息访问等功能。</p><p>概括来说主要有四个阶段：实例化，初始化，使用，销毁。</p><a id="more"></a><h2 id="Bean-作用范围"><a href="#Bean-作用范围" class="headerlink" title="Bean 作用范围"></a>Bean 作用范围</h2><p>常用的Bean作用范围：singleton和prototype</p><h3 id="singleton"><a href="#singleton" class="headerlink" title="singleton"></a>singleton</h3><p>在默认情况下,Spring的ApplicationContext容器在启动时,自动实例化所有singleton的Bean并缓存于容器中.虽然启动时会花费一些时间,但带来两个好处:首先对Bean提前的实例化操作会及早发现一些潜在的配置问题.其次Bean以缓存的方式保存,当运行时使用到该Bean时就无须再实例化了,加快了运行效率.如果用户不希望在容器启动时提前实例化singleton的Bean,可以通过lazy-init属性进行控制.</p><h3 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h3><p>在默认情况下,Spring容器在启动时不实例化prototype的Bean.此外,Spring容器将prototype的Bean交给调用者后,就不再管理它的生命周期.</p><h2 id="ApplicationContext-Bean生命周期"><a href="#ApplicationContext-Bean生命周期" class="headerlink" title="ApplicationContext Bean生命周期"></a>ApplicationContext Bean生命周期</h2><p>Spring Bean的完整生命周期从创建Spring容器开始，直到最终Spring容器销毁Bean，这其中包含了一系列关键点。</p><h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p><img src="https://ws1.sinaimg.cn/large/005DnJLEly1fq4aidk8uij30ko0e2dgb.jpg" alt=""></p><h3 id="各种接口方法分类"><a href="#各种接口方法分类" class="headerlink" title="各种接口方法分类"></a>各种接口方法分类</h3><p>Bean的完整生命周期经历了各种方法调用，这些方法可以划分为以下几类：</p><ol><li><p>Bean自身的方法：这个包括了Bean本身调用的方法和通过配置文件中<bean>的init-method和destroy-method指定的方法</bean></p></li><li><p>Bean级生命周期接口方法：这个包括了BeanNameAware、BeanFactoryAware、InitializingBean和DiposableBean这些接口的方法</p></li><li><p>容器级生命周期接口方法：这个包括了InstantiationAwareBeanPostProcessor和 BeanPostProcessor这两个接口实现，一般称它们的实现类为“后处理器”。容器中每个bean初始化都要经过这一步。</p></li><li><p>工厂后处理器接口BeanFactoryPostProcessor方法：这个包括了AspectJWeavingEnabler, ConfigurationClassPostProcessor, CustomAutowireConfigurer等等非常有用的工厂后处理器接口的方法。工厂后处理器也是容器级的，在应用上下文装配配置文件之后立即调用。</p></li></ol><h3 id="流程说明"><a href="#流程说明" class="headerlink" title="流程说明"></a>流程说明</h3><p>ApplicationContext容器中，Bean的生命周期流程如上图所示，流程大致如下：</p><ol><li><p>首先容器启动后，会对scope为singleton且非懒加载的bean进行实例化，</p></li><li><p>按照Bean定义信息配置信息，注入所有的属性，</p></li><li><p>如果Bean实现了BeanNameAware接口，会回调该接口的setBeanName()方法，传入该Bean的id，此时该Bean就获得了自己在配置文件中的id，</p></li><li><p>如果Bean实现了BeanFactoryAware接口,会回调该接口的setBeanFactory()方法，传入该Bean的BeanFactory，这样该Bean就获得了自己所在的BeanFactory，</p></li><li><p>如果Bean实现了ApplicationContextAware接口,会回调该接口的setApplicationContext()方法，传入该Bean的ApplicationContext，这样该Bean就获得了自己所在的ApplicationContext，</p></li><li><p>如果有Bean实现了BeanPostProcessor接口，则会回调该接口的postProcessBeforeInitialzation()方法，</p></li><li><p>如果Bean实现了InitializingBean接口，则会回调该接口的afterPropertiesSet()方法，</p></li><li><p>如果Bean配置了init-method方法，则会执行init-method配置的方法，</p></li><li><p>如果有Bean实现了BeanPostProcessor接口，则会回调该接口的postProcessAfterInitialization()方法，</p></li><li><p>经过流程9之后，就可以正式使用该Bean了,对于scope为singleton的Bean,Spring的ioc容器中会缓存一份该bean的实例，而对于scope为prototype的Bean,每次被调用都会new一个新的对象，期生命周期就交给调用方管理了，不再是Spring容器进行管理了</p></li><li><p>容器关闭后，如果Bean实现了DisposableBean接口，则会回调该接口的destroy()方法，</p></li><li><p>如果Bean配置了destroy-method方法，则会执行destroy-method配置的方法，至此，整个Bean的生命周期结束</p></li></ol><h2 id="BeanFactory-Bean生命周期"><a href="#BeanFactory-Bean生命周期" class="headerlink" title="BeanFactory Bean生命周期"></a>BeanFactory Bean生命周期</h2><p>BeanFactoty容器中, Bean的生命周期如下图所示，与ApplicationContext相比，有如下几点不同:</p><ol><li><p>BeanFactory容器中，不会调用ApplicationContextAware接口的setApplicationContext()方法</p></li><li><p>BeanPostProcessor接口的postProcessBeforeInitialzation()方法和postProcessAfterInitialization()方法不会自动调用，必须自己通过代码手动注册</p></li><li><p>BeanFactory容器启动的时候，不会去实例化所有Bean,包括所有scope为singleton且非懒加载的Bean也是一样，而是在调用的时候去实例化。</p></li></ol><h3 id="流程图-1"><a href="#流程图-1" class="headerlink" title="流程图"></a>流程图</h3><p><img src="https://ws1.sinaimg.cn/large/005DnJLEly1fq4amcingnj30kq0cw0t7.jpg" alt=""></p><h3 id="流程说明-1"><a href="#流程说明-1" class="headerlink" title="流程说明"></a>流程说明</h3><ol><li>当调用者通过 getBean(name)向 容器寻找Bean时，如果容器注册了org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessor接口，在实例bean之前，将调用该接口的 postProcessBeforeInstantiation()方法</li><li>容器寻找Bean的定义信息，并将其实例化</li><li>使用依赖注入，Spring按照Bean定义信息配置Bean的所有属性</li><li>如果Bean实现了BeanNameAware接口，工厂调用Bean的setBeanName()方法传递Bean的id</li><li>如果实现了BeanFactoryAware接口，工厂调用setBeanFactory()方法传入工厂自身</li><li>如果BeanPostProcessor和Bean关联，那么它们的postProcessBeforeInitialization()方法将被调用（需要手动进行注册！）</li><li>如果Bean实现了InitializingBean接口，则会回调该接口的afterPropertiesSet()方法</li><li>如果Bean指定了init-method方法，就会调用init-method方法</li><li>如果BeanPostProcessor和Bean关联，那么它的postProcessAfterInitialization()方法将被调用（需要手动注册！）</li><li>现在Bean已经可以使用了<ol><li>scope为singleton的Bean缓存在Spring IOC容器中</li><li>scope为prototype的Bean生命周期交给客户端</li></ol></li><li>销毁<ol><li>如果Bean实现了DisposableBean接口，destory()方法将会被调用</li><li>如果配置了destory-method方法，就调用这个方法</li></ol></li></ol><h2 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h2><p>用一个简单的Spring Bean来演示一下Spring Bean的生命周期。</p><p>1、首先是一个简单的Spring Bean，调用Bean自身的方法和Bean级生命周期接口方法，为了方便演示，它实现了BeanNameAware、ApplicationContextAware、BeanFactoryAware、InitializingBean和DiposableBean这5个接口，同时有2个方法，对应配置文件中<bean>的init-method和destroy-method。如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.BeanFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.BeanFactoryAware;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.BeanNameAware;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.DisposableBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.InitializingBean;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">BeanFactoryAware</span>, <span class="title">BeanNameAware</span>, <span class="title">InitializingBean</span>, <span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> String address;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> phone;</span><br><span class="line">  <span class="keyword">private</span> BeanFactory beanFactory;</span><br><span class="line">  <span class="keyword">private</span> String beanName;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"【构造器】调用Person的构造器实例化"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"【注入属性】注入属性name"</span>);</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> address;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAddress</span><span class="params">(String address)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"【注入属性】注入属性address"</span>);</span><br><span class="line">    <span class="keyword">this</span>.address = address;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPhone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> phone;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPhone</span><span class="params">(<span class="keyword">int</span> phone)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"【注入属性】注入属性phone"</span>);</span><br><span class="line">    <span class="keyword">this</span>.phone = phone;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Person [address="</span> + address + <span class="string">", name="</span> + name + <span class="string">", phone="</span> + phone + <span class="string">"]"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 这是BeanFactoryAware接口方法</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanFactory</span><span class="params">(BeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"【BeanFactoryAware接口】调用BeanFactoryAware.setBeanFactory()"</span>);</span><br><span class="line">    <span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 这是BeanNameAware接口方法</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"【BeanNameAware接口】调用BeanNameAware.setBeanName()"</span>);</span><br><span class="line">    <span class="keyword">this</span>.beanName = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 这是InitializingBean接口方法</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"【InitializingBean接口】调用InitializingBean.afterPropertiesSet()"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 这是DiposibleBean接口方法</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"【DiposibleBean接口】调用DiposibleBean.destory()"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 通过&lt;bean&gt;的init-method属性指定的初始化方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myInit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"【init-method】调用&lt;bean&gt;的init-method属性指定的初始化方法"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 通过&lt;bean&gt;的destroy-method属性指定的初始化方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myDestory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"【destroy-method】调用&lt;bean&gt;的destroy-method属性指定的初始化方法"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></bean></p><p>2、接下来是演示BeanPostProcessor接口的方法，如下：<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.BeanPostProcessor;</span><br><span class="line"><span class="keyword">public</span> class MyBeanPostProcessor implements BeanPostProcessor &#123;</span><br><span class="line">  <span class="keyword">public</span> MyBeanPostProcessor() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"这是BeanPostProcessor实现类构造器！！"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  @Override</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">Object</span> postProcessBeforeInitialization(<span class="keyword">Object</span> bean, <span class="keyword">String</span> beanName) <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"BeanPostProcessor接口方法postProcessBeforeInitialization对属性进行更改！"</span>);</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">Object</span> postProcessAfterInitialization(<span class="keyword">Object</span> bean, <span class="keyword">String</span> beanName) <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"BeanPostProcessor接口方法postProcessAfterInitialization对属性进行更改！"</span>);</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如上，BeanPostProcessor接口包括2个方法postProcessAfterInitialization和postProcessBeforeInitialization，这两个方法的第一个参数都是要处理的Bean对象，第二个参数都是Bean的name。返回值也都是要处理的Bean对象。</p><p>3、InstantiationAwareBeanPostProcessor 接口本质是BeanPostProcessor的子接口，一般我们继承Spring为其提供的适配器类InstantiationAwareBeanPostProcessorAdapter来使用它，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.beans.PropertyDescriptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.PropertyValues;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessorAdapter;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInstantiationAwareBeanPostProcessor</span> <span class="keyword">extends</span> <span class="title">InstantiationAwareBeanPostProcessorAdapter</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MyInstantiationAwareBeanPostProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    System.out.println(<span class="string">"这是InstantiationAwareBeanPostProcessorAdapter实现类构造器！！"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 接口方法、实例化Bean之前调用</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInstantiation</span><span class="params">(Class beanClass, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"InstantiationAwareBeanPostProcessor调用postProcessBeforeInstantiation方法"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 接口方法、实例化Bean之后调用</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"InstantiationAwareBeanPostProcessor调用postProcessAfterInitialization方法"</span>);</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 接口方法、设置某个属性时调用</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> PropertyValues <span class="title">postProcessPropertyValues</span><span class="params">(PropertyValues pvs, PropertyDescriptor[] pds, Object bean,</span></span></span><br><span class="line"><span class="function"><span class="params">      String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"InstantiationAwareBeanPostProcessor调用postProcessPropertyValues方法"</span>);</span><br><span class="line">    <span class="keyword">return</span> pvs;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个有3个方法，其中第二个方法postProcessAfterInitialization就是重写了BeanPostProcessor的方法。第三个方法postProcessPropertyValues用来操作属性，返回值也应该是PropertyValues对象。</p><p>4、工厂后处理器接口方法，如下：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="meta-keyword">import</span> org.springframework.beans.BeansException;</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">import</span> org.springframework.beans.factory.config.BeanDefinition;</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">import</span> org.springframework.beans.factory.config.BeanFactoryPostProcessor;</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">import</span> org.springframework.beans.factory.config.ConfigurableListableBeanFactory;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanFactoryPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanFactoryPostProcessor</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> MyBeanFactoryPostProcessor() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    System.out.println(<span class="string">"这是BeanFactoryPostProcessor实现类构造器！！"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  @Override</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException &#123;</span><br><span class="line">    System.out.println(<span class="string">"BeanFactoryPostProcessor调用postProcessBeanFactory方法"</span>);</span><br><span class="line">    BeanDefinition bd = arg0.getBeanDefinition(<span class="string">"person"</span>);</span><br><span class="line">    bd.getPropertyValues().addPropertyValue(<span class="string">"phone"</span>, <span class="string">"110"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>BeanFactoryPostProcessor 可以修改 bean 的配置信息而 BeanPostProcessor 不能<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanFactoryPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanFactoryPostProcessor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="comment">//BeanFactoryPostProcessor可以修改BEAN的配置信息而BeanPostProcessor不能</span></span><br><span class="line">        <span class="comment">//我们在这里修改postProcessorBean的username注入属性</span></span><br><span class="line">        BeanDefinition bd = beanFactory.getBeanDefinition(<span class="string">"postProcessorBean"</span>);</span><br><span class="line">        MutablePropertyValues pv =  bd.getPropertyValues();</span><br><span class="line">        <span class="keyword">if</span>(pv.contains(<span class="string">"username"</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            pv.addPropertyValue(<span class="string">"username"</span>, <span class="string">"xiaojun"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>5、配置文件如下beans.xml，使用ApplicationContext,处理器不用手动注册：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span> <span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">            http://www.springframework.org/schema/beans </span></span></span><br><span class="line"><span class="tag"><span class="string">            http://www.springframework.org/schema/beans/spring-beans-3.2.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"beanPostProcessor"</span> <span class="attr">class</span>=<span class="string">"springBeanTest.MyBeanPostProcessor"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"instantiationAwareBeanPostProcessor"</span> <span class="attr">class</span>=<span class="string">"springBeanTest.MyInstantiationAwareBeanPostProcessor"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"beanFactoryPostProcessor"</span> <span class="attr">class</span>=<span class="string">"springBeanTest.MyBeanFactoryPostProcessor"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"person"</span> <span class="attr">class</span>=<span class="string">"springBeanTest.Person"</span> <span class="attr">init-method</span>=<span class="string">"myInit"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">destroy-method</span>=<span class="string">"myDestory"</span> <span class="attr">scope</span>=<span class="string">"singleton"</span> <span class="attr">p:name</span>=<span class="string">"张三"</span> <span class="attr">p:address</span>=<span class="string">"广州"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">p:phone</span>=<span class="string">"15900000000"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>6、测试<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanLifeCycleTest</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="type">String</span>[] args) &#123;</span><br><span class="line">    <span class="type">System</span>.out.<span class="built_in">println</span>(<span class="string">"现在开始初始化容器"</span>);</span><br><span class="line">    <span class="type">ApplicationContext</span> factory = new <span class="type">ClassPathXmlApplicationContext</span>(<span class="string">"beans.xml"</span>);</span><br><span class="line">    <span class="type">System</span>.out.<span class="built_in">println</span>(<span class="string">"容器初始化成功"</span>);</span><br><span class="line">    <span class="comment">// 得到Preson，并使用</span></span><br><span class="line">    <span class="type">Person</span> person = factory.getBean(<span class="string">"person"</span>, <span class="type">Person</span>.<span class="keyword">class</span>);</span><br><span class="line">    <span class="type">System</span>.out.<span class="built_in">println</span>(person);</span><br><span class="line">    <span class="type">System</span>.out.<span class="built_in">println</span>(<span class="string">"现在开始关闭容器！"</span>);</span><br><span class="line">    ((<span class="type">ClassPathXmlApplicationContext</span>) factory).registerShutdownHook();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>关闭容器使用的是实际是AbstractApplicationContext的钩子方法。</p><p>7、结果：<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">现在开始初始化容器</span><br><span class="line">[location]<span class="number">15</span>:<span class="number">15</span>:<span class="number">33</span> <span class="number">100</span>  INFO (<span class="keyword">org.springframework.context.support.ClassPathXmlApplicationContext:510) </span>- Refreshing <span class="keyword">org.springframework.context.support.ClassPathXmlApplicationContext@75a70476: </span>startup date [Mon May <span class="number">08</span> <span class="number">15</span>:<span class="number">15</span>:<span class="number">33</span> CST <span class="number">2017</span>]<span class="comment">; root of context hierarchy</span></span><br><span class="line">[location]<span class="number">15</span>:<span class="number">15</span>:<span class="number">33</span> <span class="number">194</span>  INFO (<span class="keyword">org.springframework.beans.factory.xml.XmlBeanDefinitionReader:315) </span>- Loading XML <span class="keyword">bean </span>definitions from class path resource [<span class="keyword">beans.xml]</span></span><br><span class="line"><span class="keyword">这是BeanFactoryPostProcessor实现类构造器！！</span></span><br><span class="line"><span class="keyword">BeanFactoryPostProcessor调用postProcessBeanFactory方法</span></span><br><span class="line"><span class="keyword">这是BeanPostProcessor实现类构造器！！</span></span><br><span class="line"><span class="keyword">这是InstantiationAwareBeanPostProcessorAdapter实现类构造器！！</span></span><br><span class="line"><span class="keyword">[location]15:15:33 </span><span class="number">695</span>  INFO (<span class="keyword">org.springframework.beans.factory.support.DefaultListableBeanFactory:596) </span>- Pre-<span class="keyword">instantiating </span>singletons in <span class="keyword">org.springframework.beans.factory.support.DefaultListableBeanFactory@461d434f: </span>defining <span class="keyword">beans </span>[<span class="keyword">beanPostProcessor,instantiationAwareBeanPostProcessor,beanFactoryPostProcessor,person]; </span>root of factory hierarchy</span><br><span class="line"><span class="keyword">InstantiationAwareBeanPostProcessor调用postProcessBeforeInstantiation方法</span></span><br><span class="line"><span class="keyword">【构造器】调用Person的构造器实例化</span></span><br><span class="line"><span class="keyword">InstantiationAwareBeanPostProcessor调用postProcessPropertyValues方法</span></span><br><span class="line"><span class="keyword">【注入属性】注入属性address</span></span><br><span class="line"><span class="keyword">【注入属性】注入属性name</span></span><br><span class="line"><span class="keyword">【注入属性】注入属性phone</span></span><br><span class="line"><span class="keyword">【BeanNameAware接口】调用BeanNameAware.setBeanName()</span></span><br><span class="line"><span class="keyword">【BeanFactoryAware接口】调用BeanFactoryAware.setBeanFactory()</span></span><br><span class="line"><span class="keyword">BeanPostProcessor接口方法postProcessBeforeInitialization对属性进行更改！</span></span><br><span class="line"><span class="keyword">【InitializingBean接口】调用InitializingBean.afterPropertiesSet()</span></span><br><span class="line"><span class="keyword">【init-method】调用&lt;bean&gt;的init-method属性指定的初始化方法</span></span><br><span class="line"><span class="keyword">BeanPostProcessor接口方法postProcessAfterInitialization对属性进行更改！</span></span><br><span class="line"><span class="keyword">InstantiationAwareBeanPostProcessor调用postProcessAfterInitialization方法</span></span><br><span class="line"><span class="keyword">容器初始化成功</span></span><br><span class="line"><span class="keyword">Person </span>[<span class="keyword">address=广州, </span>name=张三, phone=<span class="number">110</span>]</span><br><span class="line">现在开始关闭容器！</span><br><span class="line">[location]<span class="number">15</span>:<span class="number">15</span>:<span class="number">33</span> <span class="number">752</span>  INFO (<span class="keyword">org.springframework.context.support.ClassPathXmlApplicationContext:1042) </span>- <span class="keyword">Closing </span><span class="keyword">org.springframework.context.support.ClassPathXmlApplicationContext@75a70476: </span>startup date [Mon May <span class="number">08</span> <span class="number">15</span>:<span class="number">15</span>:<span class="number">33</span> CST <span class="number">2017</span>]<span class="comment">; root of context hierarchy</span></span><br><span class="line">[location]<span class="number">15</span>:<span class="number">15</span>:<span class="number">33</span> <span class="number">752</span>  INFO (<span class="keyword">org.springframework.beans.factory.support.DefaultListableBeanFactory:444) </span>- Destroying singletons in <span class="keyword">org.springframework.beans.factory.support.DefaultListableBeanFactory@461d434f: </span>defining <span class="keyword">beans </span>[<span class="keyword">beanPostProcessor,instantiationAwareBeanPostProcessor,beanFactoryPostProcessor,person]; </span>root of factory hierarchy</span><br><span class="line">【<span class="keyword">DiposibleBean接口】调用DiposibleBean.destory()</span></span><br><span class="line"><span class="keyword">【destroy-method】调用&lt;bean&gt;的destroy-method属性指定的初始化方法</span></span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Bean的完整生命周期从 spring 容器开始实例化 bean 开始，到销毁。可以从三点来理解</p><ol><li>bean自身的方法：包括构造方法、 set 方法、 init-method 指定的方法、 destroy-method 指定的方法</li><li>bean级生命周期接口方法：如BeanNameAware 、 BeanFactoryAware 等这些接口方法由 bean类实现</li><li>容器级生命周期接口方法：有InstantiationAwareBeanPostProcessor 、 BeanPostProcessor等。一般称为后处理器。他们一般不由bean 本身实现，独立存在，注册到 spring 容器中。 Spring 通过接口反射预先知道，当 spring 容器创建任何 bean 时，这些后处理器都会发生作用。所以他们是全局的，用户可以通过编码对只感兴趣的 bean 进行处理</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.jianshu.com/p/3944792a5fff" target="_blank" rel="external">简书 - SpringBean生命周期</a></li><li><a href="https://www.cnblogs.com/zrtqsk/p/3735273.html" target="_blank" rel="external">博客园 - Spring Bean的生命周期（非常详细）</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Spring-Bean-生命周期&quot;&gt;&lt;a href=&quot;#Spring-Bean-生命周期&quot; class=&quot;headerlink&quot; title=&quot;Spring Bean 生命周期&quot;&gt;&lt;/a&gt;Spring Bean 生命周期&lt;/h1&gt;&lt;p&gt;BeanFactory和ApplicationContext是Spring两种很重要的容器,前者提供了最基本的依赖注入的支持，而后者在继承前者的基础进行了功能的拓展，例如增加了事件传播，资源访问和国际化的消息访问等功能。&lt;/p&gt;
&lt;p&gt;概括来说主要有四个阶段：实例化，初始化，使用，销毁。&lt;/p&gt;
    
    </summary>
    
      <category term="SSM框架" scheme="https://caoler.cn/categories/SSM%E6%A1%86%E6%9E%B6/"/>
    
      <category term="Spring" scheme="https://caoler.cn/categories/SSM%E6%A1%86%E6%9E%B6/Spring/"/>
    
    
      <category term="Spring" scheme="https://caoler.cn/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>《深入理解Java虚拟机》读书笔记2 - 垃圾收集器与内存分配策略</title>
    <link href="https://caoler.cn//post/2018/deep-in-jvm-part2.html"/>
    <id>https://caoler.cn//post/2018/deep-in-jvm-part2.html</id>
    <published>2018-03-07T13:17:43.000Z</published>
    <updated>2018-03-08T08:33:04.714Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第三章-垃圾收集器与内存分配策略"><a href="#第三章-垃圾收集器与内存分配策略" class="headerlink" title="第三章 垃圾收集器与内存分配策略"></a>第三章 垃圾收集器与内存分配策略</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>思考GC需要完成的3件事情：</p><ul><li>哪些内存需要回收？</li><li>什么时候回收？</li><li>如何回收？<br>再回头看看第二章介绍的Java内存运行时区域的各个部分：</li></ul><a id="more"></a><ul><li>程序计时器、虚拟机栈、本地方法栈：随线程而灭，栈帧随方法而进行出栈和入栈，每一个栈帧分配的内存在类结构确定就已知，因此这几个区域不需要考虑回收；</li><li>对于Java堆和方法区，只有程序运行期间才知道会创建哪些对象，内存的分配和回收都是动态的，垃圾收集器所关注的是这部分内存；<h3 id="对象已死吗？"><a href="#对象已死吗？" class="headerlink" title="对象已死吗？"></a>对象已死吗？</h3>在垃圾收集器进行回收前，第一件事就是确定这些对象哪些还存活，哪些已经死去。</li></ul><h3 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h3><p>给对象添加引用计数器，当有地方引用它时就加1，引用失效就减1，为0时就认为对象不再被使用可回收。该算法失效简单，判断高效，但并不被主流虚拟机采用，主要原因是它很难解决对象之间相互循环引用的问题。</p><h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>通过一系列的称为“GC Roots”的对象作为起点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），如果一个对象到GC Roots没有引用链相连，则该对象是不可用的。</p><p><img src="https://ws1.sinaimg.cn/large/005DnJLEly1fp4h76x2l2j30nm0ekdia.jpg" alt=""></p><p>在Java语言中，可作为GC Roots的对象包括：</p><ul><li>虚拟机栈（栈帧中的本地变量表）中引用的对象；</li><li>方法区中类静态属性引用的对象；</li><li>方法区中常量引用的对象；</li><li>本地方法栈中JNI（即一般说的Native方法）引用的对象；</li></ul><h4 id="再谈引用"><a href="#再谈引用" class="headerlink" title="再谈引用"></a>再谈引用</h4><p>在JDK 1.2之后，Java对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用和虚引用，这4种引用强度依次减弱。</p><h4 id="生存还是死亡"><a href="#生存还是死亡" class="headerlink" title="生存还是死亡"></a>生存还是死亡</h4><p>要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize方法（如没有重写finalize方法或者已经被调用过则认为没有必要执行）；如果有必要执行则将该对象放置在F-Queue队列中，并在稍后由一个由虚拟机自己建立的、低优先级的Finalizer线程去执行它；稍后GC将对F-Queue中的对象进行第二次标记，如果对象还是没有被引用，则会被回收。</p><p>但是作者不建议通过finalize方法“拯救”对象，因为它运行代价高、不确定性大、无法保证各个对象的调用顺序。</p><h4 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h4><p>永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类。</p><p>一个无用的类需要满足以下三个条件：</p><ul><li>该类的所有实例都已经被回收；</li><li>加载该类的ClassLoader已经被回收；</li><li>该类对象的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法；</li><li>在大量使用反射、动态代理、CGLib等ByteCode框架、动态生成JSP以及OSGI这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能（HotSpot提供-Xnoclassgc参数控制），以保证永久代不会溢出。</li></ul><h4 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h4><ul><li>标记-清除算法：首先标记出所有需要回收的对象，然后统一回收所有被标记的对象；缺点是效率不高且容易产生大量不连续的内存碎片；</li><li>复制算法：将可用内存分为大小相等的两块，每次只使用其中一块；当这一块用完了，就将还活着的对象复制到另一块上，然后把已使用过的内存清理掉。在HotSpot里，考虑到大部分对象存活时间很短将内存分为Eden和两块Survivor，默认比例为8:1:1。代价是存在部分内存空间浪费，适合在新生代使用；</li><li>标记-整理算法：首先标记出所有需要回收的对象，然后让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。适用于老年代。</li><li>分代收集算法：一般把Java堆分新生代和老年代，在新生代用复制算法，在老年代用标记-清理或标记-整理算法，是现代虚拟机通常采用的算法。</li></ul><h3 id="HotSpot的算法实现"><a href="#HotSpot的算法实现" class="headerlink" title="HotSpot的算法实现"></a>HotSpot的算法实现</h3><h4 id="枚举根节点"><a href="#枚举根节点" class="headerlink" title="枚举根节点"></a>枚举根节点</h4><p>由于要确保在一致性的快照中进行可达性分析，从而导致GC进行时必须要停顿所有Java执行线程；<br>在HotSpot里通过一组OopMap数据结构来知道哪些地方存放着对象引用；</p><h4 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h4><p>HotSpot只在特定的位置记录了OopMap，这些位置称为安全点（SafePoint）；<br>即程序执行时并非在所有地方都能停顿下来开始GC，只有到达安全点时才能暂停；<br>对于安全点基本上是以程序“是否具有让程序长时间执行的特征”（比如方法调用、循环跳转、异常跳转等）为标准进行选定的；<br>另外还需要考虑如果在GC时让所有线程都跑到最近的安全点上，有两种方案：抢先式中断和主动式中断（主流选择）；</p><h4 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h4><p>如果程序没有分配CPU时间（如线程处于Sleep或Blocked），此时就需要安全区域（Safe Region），其是指在一段代码片段之中，引用关系不会发生变化；<br>线程执行到安全区域时，首先标识自己已经进入了安全区域，这样JVM在GC时就不管这些线程了；</p><h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><p>垃圾收集算法是内存回收的方法论，垃圾收集器就是内存回收的具体实现。<br>这里讨论JDK 1.7 Update 14之后的HotSpot虚拟机（此时G1仍处于实验状态），包含的虚拟机如下图所示（存在连线的表示可以搭配使用）：</p><p><img src="https://ws1.sinaimg.cn/large/005DnJLEly1fp5hg0ke6qj30el0dt75o.jpg" alt=""></p><h3 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h3><p><img src="https://ws1.sinaimg.cn/large/005DnJLEly1fp5hg21nftj30pm05jgmv.jpg" alt=""></p><ul><li>最基本、发展历史最悠久，在JDK 1.3之前是新生代收集的唯一选择；</li><li>是一个单线程（并非指一个收集线程，而是会暂停所有工作线程）的收集器，采用的是复制算法；</li><li>现在依然是虚拟机运行在Client模式下的默认新生代收集器，主要就是因为它简单而高效（没有线程交互的开销）；</li></ul><h4 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h4><p><img src="https://ws1.sinaimg.cn/large/005DnJLEly1fp5hg1ygpnj30r005idha.jpg" alt=""></p><ul><li>其实就是Serial收集器的多线程版本；</li><li>ParNew收集器在单CPU环境中绝对不会有比Serial收集器更好的效果；</li><li>是许多运行在Server模式下虚拟机首选的新生代收集器，重要原因就是除了Serial收集器外，只有它能与CMS收集器配合工作；</li><li>并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态；</li><li>并发（Concurrent）：指用户线程与垃圾收集线程同时执行，用户线程在继续执行而垃圾收集程序运行在另外一个CPU上；</li></ul><h4 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h4><ul><li>新生代收集器，使用复制算法，并行的多线程收集器；</li><li>与其他收集器关注于尽可能缩短垃圾收集时用户线程停顿时间不同，它的目标是达到一个可控制的吞吐量；</li><li>高吞吐量可以高效率利用CPU时间，适合在后台运算而不需要太多交互的任务；</li><li>-XX:MaxGCPauseMillis参数可以设置最大停顿时间，而停顿时间缩短是以牺牲吞吐量和新生代空间来换取的；</li><li>另外它还支持GC自适应的调节策略；</li></ul><h4 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h4><p><img src="https://ws1.sinaimg.cn/large/005DnJLEly1fp5hg21nftj30pm05jgmv.jpg" alt=""></p><ul><li>是Serial收集器的老年代版本，同样是单线程，使用标记-整理算法；</li><li>主要是给Client模式下的虚拟机使用的；</li><li>在Server模式下主要是给JDK 1.5及之前配合Parallel Scavenge使用或作为CMS收集器的后备预案；</li></ul><h4 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h4><p><img src="https://ws1.sinaimg.cn/large/005DnJLEly1fp5hg5t46ej30pr05o3zy.jpg" alt=""></p><ul><li>是Parallel Scavenge的老年代版本，使用多线程和标记-整理算法；</li><li>是JDK 1.6中才开始提供的；</li></ul><h4 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h4><p><img src="https://ws1.sinaimg.cn/large/005DnJLEly1fp5hg42u69j30qi05omz2.jpg" alt=""></p><ul><li>是一种以获取最短回收停顿时间为目标的收集器，特别适合互联网站或者B/S的服务端；</li><li>它是基于标记-清除 算法实现的，主要包括4个步骤：初始标记（STW，只是初始标记一下GC Roots能直接关联到的对象，速度很快）、并发标记（非STW，执行GC RootsTracing，耗时比较长）、重新标记（STW，修正并发标记期间因用户程序继续导致变动的那一部分对象标记）和并发清除（非STW，耗时较长）；</li><li>还有3个明显的缺点：CMS收集器对CPU非常敏感（占用部分线程及CPU资源，影响总吞吐量）、无法处理浮动垃圾（默认达到92%就触发垃圾回收）、大量内存碎片产生（可以通过参数启动压缩）；</li></ul><h4 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h4><p><img src="https://ws1.sinaimg.cn/large/005DnJLEly1fp5hg3af3bj30p905g40q.jpg" alt=""></p><ul><li>一款面向服务端应用的垃圾收集器，后续会替换掉CMS垃圾收集器；</li><li>特点：并行与并发（充分利用多核多CPU缩短Stop-The-World时间）、分代收集（独立管理整个Java堆，但针对不同年龄的对象采取不同的策略）、空间整合（基于标记-整理）、可预测的停顿（将堆分为大小相等的独立区域，避免全区域的垃圾收集）；</li><li>关于Region：新生代和老年代不再物理隔离，只是部分Region的集合；G1跟踪各个Region垃圾堆积的价值大小，在后台维护一个优先列表，根据允许的收集时间优先回收价值最大的Region；Region之间的对象引用以及其他收集器中的新生代与老年代之间的对象引用，采用Remembered Set来避免全堆扫描；</li><li>分为几个步骤：初始标记（标记一下GC Roots能直接关联的对象并修改TAMS值，需要STW但耗时很短）、并发标记（从GC Root从堆中对象进行可达性分析找存活的对象，耗时较长但可以与用户线程并发执行）、最终标记（为了修正并发标记期间产生变动的那一部分标记记录，这一期间的变化记录在Remembered Set Log里，然后合并到Remembered Set里，该阶段需要STW但是可并行执行）、筛选回收（对各个Region回收价值排序，根据用户期望的GC停顿时间制定回收计划来回收）；</li></ul><h4 id="理解GC日志"><a href="#理解GC日志" class="headerlink" title="理解GC日志"></a>理解GC日志</h4><p><img src="https://ws1.sinaimg.cn/large/005DnJLEly1fp5hpklzkhj30x303s3yn.jpg" alt=""></p><ul><li>最前面的数字代表GC发生的时间（虚拟机启动以后的秒杀）；</li><li>“[GC”和“[Full GC”说明停顿类型，有Full代表的是Stop-The-World的；</li><li>“[DefNew”、“[Tenured”和“[Perm”表示GC发生的区域；</li><li>方括号内部的“3324K -&gt; 152K(3712K)” 含义是 “GC前该内存已使用容量 -&gt; GC后该内存区域已使用容量(该区域总容量)”;</li><li>方括号之外的“3324K -&gt; 152K(11904)” 含义是 “GC前Java堆已使用容量 -&gt; GC后Java堆已使用容量(Java堆总容量)”;</li><li>再往后“0.0025925 secs”表示该内存区域GC所占用的时间；</li></ul><h4 id="垃圾收集器参数总结"><a href="#垃圾收集器参数总结" class="headerlink" title="垃圾收集器参数总结"></a>垃圾收集器参数总结</h4><p><img src="https://ws1.sinaimg.cn/large/005DnJLEly1fp5hqutlicj30rs0g5wmc.jpg" alt=""><br><img src="https://ws1.sinaimg.cn/large/005DnJLEly1fp5hr56tv9j30rs087adj.jpg" alt=""></p><h4 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h4><ul><li>对象优先在新生代分配</li><li>大对象直接进入老年代</li><li>长期存活的对象将进入老年代</li><li>动态对象年龄判断：如果在Survivor空间中相同年龄所有对象大小总和大于Survivor空间的一半，大于或等于该年龄的对象直接进入老年代；</li><li>空间分配担保：发生Minor GC前，虚拟机会先检查老年代最大可用连续空间是否大于新生代所有对象总空间，如果不成立，虚拟机会查看HandlePromotionFailure设置值是否允许担保失败，如果允许继续检查老年代最大可用的连续空间是否大于历次晋升到老年代的平均大小，如果大于会尝试进行一次Minor GC；如果小于或者不允许冒险，会进行一次Full GC；</li></ul><h3 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h3><p>本章介绍了垃圾回收算法、几款JDK 1.7中提供的垃圾收集器特点以及运作原理。内存回收与垃圾收集器在很多时候都是影响系统性能、并发能力的主要因素之一，然而没有固定收集器和参数组合，也没有最优的调优方法，需要根据实践了解各自的行为、优势和劣势。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;第三章-垃圾收集器与内存分配策略&quot;&gt;&lt;a href=&quot;#第三章-垃圾收集器与内存分配策略&quot; class=&quot;headerlink&quot; title=&quot;第三章 垃圾收集器与内存分配策略&quot;&gt;&lt;/a&gt;第三章 垃圾收集器与内存分配策略&lt;/h2&gt;&lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;思考GC需要完成的3件事情：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;哪些内存需要回收？&lt;/li&gt;
&lt;li&gt;什么时候回收？&lt;/li&gt;
&lt;li&gt;如何回收？&lt;br&gt;再回头看看第二章介绍的Java内存运行时区域的各个部分：&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="JVM" scheme="https://caoler.cn/categories/JVM/"/>
    
    
      <category term="JVM" scheme="https://caoler.cn/tags/JVM/"/>
    
      <category term="读书笔记" scheme="https://caoler.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>一个小程序员的2017年年度总结</title>
    <link href="https://caoler.cn//post/2018/summary_for_2017.html"/>
    <id>https://caoler.cn//post/2018/summary_for_2017.html</id>
    <published>2018-01-24T03:03:24.000Z</published>
    <updated>2018-01-24T03:22:02.181Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一个小程序员2017年的进步、收获与成长。"><a href="#一个小程序员2017年的进步、收获与成长。" class="headerlink" title="一个小程序员2017年的进步、收获与成长。"></a>一个小程序员2017年的进步、收获与成长。</h3><p>今天是腊八，新历新年已经过去了两个月。在很早之前就打算写一篇年终总结，但是因为考试一直拖延。放假之后愉快的玩♂耍了一周 决定在这个安静的早晨动笔写起。</p><p>2017年是上大学以来最有收获的一年，大概学习了一整个JavaWeb的框架部分，而且还通过参加服务外包比赛让自己的学习成功付诸实现，虽然和组里的DB、HJ比起来自己的实力和别人还有不小差距。但是作为一个容易满足的人，我的2017也算是很完美了。</p><a id="more"></a><h3 id="回顾总结与展望"><a href="#回顾总结与展望" class="headerlink" title="回顾总结与展望"></a>回顾总结与展望</h3><h4 id="学习部分"><a href="#学习部分" class="headerlink" title="学习部分"></a>学习部分</h4><ol><li>学习Spring，刚开学的三月份翻起Spring的教程，从头至尾学习了一遍。</li><li>Hibernate初体验，当时学习的目标就是SSH框架，所以在Spring学习结束之后就直接开始学习Hibernate了。了解到了一个很方便很牛逼的技能–<a href="http://blog.csdn.net/qq_34197553/article/details/77718925" target="_blank" rel="external">IntelliJ IDEA下自动生成Hibernate映射文件以及实体类</a></li><li>遇到了一个国产轻量级的框架——JFinal，一个小提问还得到了框架作者(波总)的回复 <a href="https://www.oschina.net/question/3479290_2245223" target="_blank" rel="external">点我查看</a> 但是问题到现在都没有解决。头晕</li><li>7月，大二的学习生活结束，留校参加了第八届服务外包比赛，用了半个月的时间学习了MyBatis。虽然这个框架学习的时间很短，但是我觉的这个框架是自己吃的最透的一个（其中一部分原因是时间紧迫做项目马上就要用到，逃~）当时用到的几个好工具：<ul><li><a href="http://blog.csdn.net/baidu_32877851/article/details/53959268" target="_blank" rel="external">代码生成器Generator</a></li><li><a href="https://gitee.com/free/Mybatis_PageHelper" target="_blank" rel="external">MyBatis的分页插件–MyBaits_PageHelper</a></li><li><a href="http://baomidou.oschina.io/mybatis-plus-doc/#/" target="_blank" rel="external">MyBatisPlus</a></li></ul></li><li>新学期，再学Spring，这次的学习一部分是为了回顾，另一部分是为了之后的SpringMVC做准备。这次的学习时间比较仓促，也只用了不到半个月，对控制反转IOC 依赖注入DI 面向切面编程有了更深入的了解，跟第一次的学习比较起来收获更大。</li><li>SpringMVC的学习。一直到9月26日，SSM框架整合完毕。框架部分的学习也算告一段落。</li><li>10月，我接触了一部分前端的知识。包括JavaScriptDOM、jQuery，但是这部分的学习学的比较潦草，跟读书一样 只能称作是泛读。</li><li>精读《图解HTTP》，插画风格的书阅读起来很轻松，也很容易理解，虽然书的内容很少，但是我了解了网络协议的传输过程，手里还有一本《图解TCP/IP》也打算好好啃一啃。</li><li>阅读《Core Java》，大一下对JAVASE部分的学习实在是太粗略了，在学习JAVAWEB部分的时候我甚至不知道泛型、迭代器、集合、map。学习《Core Java》这段时间学习很多，以前似懂非懂的东西那段时间里都得到了解决。对Java集合框架部分的内容进行了深入的研究，用四个字来表达，那就是收获颇多！</li><li>JAVA并发编程的学习，这段时间 我一改以前的看视频学习方法，转为看博客，看书。一直通过<a href="http://ifeve.com/" target="_blank" rel="external">并发编程网</a>来进行学习，同时也借鉴了不少博客的内容，包括CSDN 博客园。</li><li>阅读《JAVA并发编程的艺术》《深入理解JVM》，第五部分的内容也就是之前学的并发部分的内容，我的侧重点是第二章和第三章，还没开始看，希望通过这本书我能够深入的了解JAVA内存模型和它的垃圾回收机制。</li><li>做项目之前，学习了Git，项目的过程中和DB同学进行了深入的交♂流。对Git的协作开发有了一定的认识和理解。</li><li>升级了自己的IDE，由之前的Eclipse到现在的IntelliJ IDEA，编程环境更舒适了，代码写作的效率也变高了。</li><li>学习了通过MAVEN编程，抛弃了之前导包的过程，使开发更加方便轻松。</li><li>适应了MarkDown的写作，基本丢弃了以前Word的写作方式，也算是一个进步.</li></ol><p>emmm..学习部分就这些。想到了再补充。</p><h4 id="生活部分"><a href="#生活部分" class="headerlink" title="生活部分"></a>生活部分</h4><ol><li><p>最有成就的就是拿到了驾照，虽然前前后后花了快一年的时间，但是拿到证的那一刻还是非常开心的哈哈哈哈(即使照片其丑无比！！！垃圾摄影师)。下面下面：<br> <img src="https://ws1.sinaimg.cn/large/005DnJLEly1fnrh7pj5xcj30uo0h9gq1.jpg" alt=""></p></li><li><p>认识了我的两个好好好朋友FJY,AYS。<br><img src="https://ws1.sinaimg.cn/large/005DnJLEly1fnrhqcc0evj30qo0qojtn.jpg" alt=""></p></li><li><p>这一年没有经常去外面玩，除了端午节去长沙玩的几天。但是吃了无数次小龙坎 刘一手！最好吃的还算长沙吃的井格。<br><img src="https://ws1.sinaimg.cn/large/005DnJLEly1fnrhr7yo6yj31400u042k.jpg" alt=""></p></li><li><p>看了17年所有自己想看的电影，没有遗憾！（照片没拍，我觉得有二三十张）</p></li><li><p>去夜店蹦迪，去酒吧喝到失去知觉，体验了以前没有体验到的东西。<br><img src="https://ws1.sinaimg.cn/large/005DnJLEly1fnrhswxzm8j30u0140acb.jpg" alt=""></p></li><li><p>平时还有不菲的收入，除了必要的生活费没有向父母额外多要一分钱，我很自豪。</p></li><li><p>和几千人一起跨年！！！<br><img src="https://ws1.sinaimg.cn/large/005DnJLEly1fnrhtt935oj32io1w0npd.jpg" alt=""></p></li><li><p>生活很规律，每天都有吃早饭，除了玩每天12点前睡觉，喝水很多，也很爱喝水。</p></li><li><p>养了三只小乌龟，其中一个跳楼了。还有三颗富贵竹，希望寒假这段时间不要被冻死。</p></li><li><p>还有就是以前念想的博客，我也按照自己喜欢的风格搭建好了，每一篇学习记录我也都会在这里坚持写下来！–<a href="https://caoler.cn">Caole’s Blog</a></p></li></ol><h4 id="遗憾"><a href="#遗憾" class="headerlink" title="遗憾"></a>遗憾</h4><ol><li>CET-4！！！！！头晕</li><li>没有找到女朋友！！</li></ol><p>我自己很感谢这些点点滴滴的积累带来的变化，并且坚信在新的一年会变得更好。<br><img src="https://ws1.sinaimg.cn/large/005DnJLEly1fnrj68gv66j30ih0rhabd.jpg" alt=""><br>为了自拍专门下载的相机哈哈！！</p><p>知乎：<a href="https://www.zhihu.com/question/263416941/answer/302598812" target="_blank" rel="external">https://www.zhihu.com/question/263416941/answer/302598812</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一个小程序员2017年的进步、收获与成长。&quot;&gt;&lt;a href=&quot;#一个小程序员2017年的进步、收获与成长。&quot; class=&quot;headerlink&quot; title=&quot;一个小程序员2017年的进步、收获与成长。&quot;&gt;&lt;/a&gt;一个小程序员2017年的进步、收获与成长。&lt;/h3&gt;&lt;p&gt;今天是腊八，新历新年已经过去了两个月。在很早之前就打算写一篇年终总结，但是因为考试一直拖延。放假之后愉快的玩♂耍了一周 决定在这个安静的早晨动笔写起。&lt;/p&gt;
&lt;p&gt;2017年是上大学以来最有收获的一年，大概学习了一整个JavaWeb的框架部分，而且还通过参加服务外包比赛让自己的学习成功付诸实现，虽然和组里的DB、HJ比起来自己的实力和别人还有不小差距。但是作为一个容易满足的人，我的2017也算是很完美了。&lt;/p&gt;
    
    </summary>
    
      <category term="CodingLife" scheme="https://caoler.cn/categories/CodingLife/"/>
    
    
      <category term="CodingLife" scheme="https://caoler.cn/tags/CodingLife/"/>
    
  </entry>
  
  <entry>
    <title>《深入理解Java虚拟机》读书笔记1 - Java技术体系、Java内存区域和内存溢出异常</title>
    <link href="https://caoler.cn//post/2017/deep-in-jvm-part1.html"/>
    <id>https://caoler.cn//post/2017/deep-in-jvm-part1.html</id>
    <published>2017-12-01T08:18:22.000Z</published>
    <updated>2018-04-09T03:16:40.259Z</updated>
    
    <content type="html"><![CDATA[<p>世界上并没有完美的程序，但我们并不因此而沮丧，因为写程序本来就是一个不断追求完美的过程。</p><p>笔记第一部分对应原书的第一章，主要介绍了Java的技术体系、Java虚拟机的发展历史。第二部分对应原书的第二章，主要介绍了Java运行时区域的划分、对象的创建和访问以及内存溢出的实战。</p><a id="more"></a><h1 id="Part-1-走进Java"><a href="#Part-1-走进Java" class="headerlink" title="Part 1: 走进Java"></a>Part 1: 走进Java</h1><h2 id="第一章-走进Java"><a href="#第一章-走进Java" class="headerlink" title="第一章 走进Java"></a>第一章 走进Java</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Java的优点</p><ul><li>结构严谨、面向对象</li><li>摆脱平台的束缚，一次编写到处运行</li><li>提供了相对安全的内存管理和访问机制</li><li>实现了热点代码检测和运行时编译及优化</li><li>一套完善的应用程序接口以及无数的第三方类库</li></ul><h3 id="Java技术体系"><a href="#Java技术体系" class="headerlink" title="Java技术体系"></a>Java技术体系</h3><p>Sun官方所定义的Java技术体系包括：</p><ul><li>Java程序设计语言</li><li>各种硬件平台上的Java虚拟机</li><li>Class文件格式</li><li>Java API类库</li><li>来自商业机构和开源社区的第三方Java类库<br>JDK是用于支持Java开发的最小环境，JRE是支持Java程序运行的标准环境，整个Java体系如下所示：<br><img src="https://ws1.sinaimg.cn/large/005DnJLEgy1fm1c7gqhv6j30nt0e6dkt.jpg" alt=""></li></ul><h3 id="Java发展史"><a href="#Java发展史" class="headerlink" title="Java发展史"></a>Java发展史</h3><p><img src="https://ws1.sinaimg.cn/large/005DnJLEgy1fm1c7x19lnj30ps09mjt7.jpg" alt=""></p><ul><li>JDK 1.0: Java虚拟机、Applet、AWT等；</li><li>JDK 1.1：JAR文件格式、JDBC、JavaBeans、RMI、内部类、反射；</li><li>JDK 1.2：拆分为J2SE/J2EE/J2ME、内置JIT编译器、一系列Collections集合类；</li><li>JDK 1.3：JNDI服务、使用CORBA IIOP实现RMI通信协议、Java 2D改进；</li><li>JDK 1.4：正则表达式、异常链、NIO、日志类、XML解析器和XSLT转换器；</li><li>JDK 1.5：自动装箱、泛型、动态注解、枚举、可变参数、遍历循环、改进了Java内存模型、提供了java.util.concurrent并发包；</li><li>JDK 1.6：提供动态语言支持、提供编译API和微型HTTP服务器API、虚拟机优化（锁与同步、垃圾收集、类加载等）；</li><li>JDK 1.7：G1收集器、加强对Java语言的调用支持、升级类加载架构；</li><li>JDK 1.8：Lambda表达式等；</li></ul><h3 id="Java虚拟机发展史"><a href="#Java虚拟机发展史" class="headerlink" title="Java虚拟机发展史"></a>Java虚拟机发展史</h3><ul><li>Sun Classic/Exact VM：Classic VM是第一款商用虚拟机，纯解析器方式来执行Java代码，如果要使用JIT编译器就必须进行外挂，解析器和编译器不能配合工作，编译器执行效率非常差；Exact VM是Sun虚拟机团队曾在Solaris平台发布的虚拟机，支持两级即时编译器、编译器和解释器混合工作、使用准确内存管理（虚拟机可以知道内存中某个位置的数据具体是什么类型），但很快就被HotSpot VM所取代；</li><li>Sun HotSpot VM：Sun JDK和OpenJDK所带的虚拟机，目前使用范围最广；继承了前两款虚拟机的优点，还支持热点代码探测技术（通过计数器找出最具编译价值的代码）；2006年Sun公司宣布JDK包括HotSpot VM开源，在此基础上建立OpenJDK；</li><li>Sun Mobile-Embedded VM/Meta-Circular VM：还有一些Sun开发的面对移动和嵌入式发布的和实验性质的虚拟机；</li><li>BEA JRockit/IBM J9 VM：JRockit VM号称是世界上最快的Java虚拟机，专注于服务器端应用，不包含解析器实现，全部靠即时编译器编译执行；J9 VM定位于HotSpot比较接近，主要目的是作为IBM公司各种Java产品的执行平台；</li><li>Azul VM/BEA Liquid VM：特定硬件平台专有的高性能虚拟机；</li><li>Apache Harmony/Google Android Dalvik VM：Apache Harmony包含自己的虚拟机和Java库，但没有通过TCK认证；Dalvik VM是Android平台的核心组成部分，其并没有遵循Java虚拟机规范，不能直接执行Class文件，使用的是寄存器架构而不是JVM常见的栈架构；</li><li>Microsoft JVM及其他：微软曾经是Java技术的铁杆支持者，开发过Windows下性能最好的Java虚拟机，但后来被Sun起诉终止其发展；</li></ul><h3 id="展望Java技术的未来"><a href="#展望Java技术的未来" class="headerlink" title="展望Java技术的未来"></a>展望Java技术的未来</h3><ul><li>模块化</li><li>混合语言</li><li>多核并行</li><li>进一步丰富语法</li><li>64位虚拟机</li></ul><h3 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h3><p>本章介绍了Java技术体系的过去、现在以及未来的一些发展趋势，并独立编译一个OpenJDK 7的版本。</p><h1 id="Part-2-自动内存管理机制"><a href="#Part-2-自动内存管理机制" class="headerlink" title="Part 2:自动内存管理机制"></a>Part 2:自动内存管理机制</h1><h2 id="第二章-Java内存区域与内存溢出异常"><a href="#第二章-Java内存区域与内存溢出异常" class="headerlink" title="第二章 Java内存区域与内存溢出异常"></a>第二章 Java内存区域与内存溢出异常</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>对于JAVA程序员，在虚拟机自动内存管理机制下，不需要为new操作去写配对的delete/free代码，不容易出现内存泄漏。但是如果出现内存泄漏问题，如果不了解虚拟机的机制，便难以定位。</p><h3 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h3><p><img src="https://ws1.sinaimg.cn/large/005DnJLEgy1fm1c863056j30em0bhtar.jpg" alt=""></p><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><ul><li>一块较小的内存，可以看作是当前线程所执行的字节码的行号指示器；</li><li>在虚拟机概念模型（各种虚拟机实现可能不一样）中，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令；</li><li>程序计数器是属于线程私有的内存；</li><li>如果执行的是Java方法，该计数器记录的是正在执行的虚拟机字节码指令的地址；如果是Native方法则为空；</li></ul><h4 id="JAVA虚拟机栈"><a href="#JAVA虚拟机栈" class="headerlink" title="JAVA虚拟机栈"></a>JAVA虚拟机栈</h4><ul><li>Java虚拟机栈也是线程私有的；</li><li>描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机中入栈到出栈的过程；</li><li>局部变量表存放了编译器可知的各种基本数据类型(int、double…)、对象引用和returnAddress类型；其所需的内存空间在编辑期完成分配，不会再运行期改变；<br>可能存在两种异常：StackOverflowError（栈深度大于所允许深度）和OutOfMemoryError（无法申请到足够的内存时）；</li></ul><h4 id="JAVA堆"><a href="#JAVA堆" class="headerlink" title="JAVA堆"></a>JAVA堆</h4><ul><li>JAVA堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。</li><li>这里的主要目的就是存放对象和实例，几乎所有的对象实例都在这里分配内存。</li><li>JAVA堆是垃圾收集器管理的主要区域，而且还可以细分为新生代和老年代。</li><li>JAVA堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。</li><li>在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutofMemoryError异常。</li></ul><h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><ul><li>是线程共享的区域；</li><li>用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据；</li><li>该区域对于垃圾收集来说条件比较苛刻，但是还是非常有必要要进行回收处理，回收目标主要是针对常量池的回收和对类型的卸载；</li><li>当无法满足内存分配需求时，将抛出OutOfMemoryError异常；</li></ul><h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><ul><li>是方法区的一部分；</li><li>Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译器生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放；</li><li>Java虚拟机规范要求较少，通常还会把翻译出来的直接引用也存储在此；</li><li>另外一个重要特征是具备动态性，可以在运行期间将新的常量放入池中，如String的intern方法；</li><li>可能存在的异常：OutOfMemoryError；</li></ul><h4 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h4><ul><li>并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域；</li><li>JDK 1.4的NIO引入了基于通道（Channel）和缓冲区（Buffer）的IO方法，可以使用Native函数库直接分配对外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作以提升性能；</li></ul><h3 id="HotSpot虚拟机对象探秘"><a href="#HotSpot虚拟机对象探秘" class="headerlink" title="HotSpot虚拟机对象探秘"></a>HotSpot虚拟机对象探秘</h3><p>进一步了解虚拟机内存中数据的其他细节，比如它们是如何创建、如何布局以及如何访问的。下面以虚拟机HotSpot和常用的内存区域Java堆为例，深入探讨HotSpot虚拟机在Java堆中对象分配、布局和访问的全过程。</p><h4 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h4><ol><li>虚拟机遇到一条new指令时，先检查指令的参数是否能在常量池中定位到一个类的符号，并且检查这个符号引用代码的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程；</li><li>接下来虚拟机将为新生对象分配内存。对象所需的内存大小在类加载完成后便完全确定，为对象分配空间等同于把一块确定大小的内存从Java堆中划分出来。在使用Serial、ParNew等带Compact过程的收集器时，系统采用的分配算法是指针碰撞（内存绝对规整，只要通过指针作为分界点标识）；而使用CMS这种基于Mark-Sweep算法收集器时，通常使用空闲列表（内存不规整，通过维护一个列表记录那块内存是可用的）；</li><li>另外一个需要考虑的并发下的线程安全问题，有两种方案：一是分配内存空间的动作进行同步处理（实际上虚拟机采用CAS配上失败重试的方式保证更新操作的原子性）；二是为每个线程分配一小块内存（称为本地线程分配缓冲，TLAB），各个线程独立分配，只有TLAB用完需要分配新的才需要同步锁定，虚拟机通过-XX:+/-UseTLAB参数来设定；<br>内存分配完后，虚拟机将分配到的内存空间都初始化为零值（不包括对象头），这保证了对象的实例字段在Java代码中可以不赋值就直接使用，程序能访问到这些字段数据类型对应的零值；</li><li>接下来设置对象的对象头（Object Header）信息，包括对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象GC分代年龄等；</li><li>接着执行方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来；</li><li>HotSpot解释器的代码片段：略</li></ol><h4 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h4><ul><li>对象在内存中存储的布局可以分为3块区域：对象头（Object Header）、实例数据（Instance Data）和对齐填充（Padding）；<br>对象头包括两部分信息：第一部分用于存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等；另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例（并不是所有虚拟机都必须在对象数据上保留类型指针）。另外如果对象是一个Java数组，对象头中还必须有一块用于记录数组长度的数据。</li><li>实例数据部分是真正存储的有效信息，也是在代码中所定义的各种类型字段内容。无论是父类继承的还是子类中定义的都需要记录下来。这部分存储的顺序会受到虚拟机分配策略参数和字段在Java源码中定义顺序的影响。</li><li>对齐填充不是必然存在的，主要是由于HotSpot </li><li>VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍。</li></ul><h4 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h4><ul><li>栈上的reference类型在虚拟机规范中只规定了一个指向对象的引用，并没有定义这个引用应该通过何种方式去定位、访问堆栈对象的具体位置，目前主流的方式方式有句柄和直接直接两种。</li><li><p>通过句柄：Java堆中划出一块内存作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。其最大好处就是reference存储的是稳定的句柄地址，在对象被移到（垃圾收集时移到）只改变实例数据指针，而reference不需要修改；</p></li><li><p><img src="https://ws1.sinaimg.cn/large/005DnJLEly1fp4gn2h74pj30lv09ymyx.jpg" alt=""></p></li><li><p>通过直接指针：Java堆对象的布局中必须考虑如果放置访问类型数据的相关信息，而reference中存在的直接就是对象地址。其最大好处在于速度更快，节省了一次指针定位的时机开销。HotSpot采用该方式进行对象访问，但其他语言和框架采用句柄的也非常常见。</p></li></ul><p><img src="https://ws1.sinaimg.cn/large/005DnJLEly1fp4go1uhbuj30mu09twg2.jpg" alt=""></p><h3 id="实战：OutOfMemoryError异常"><a href="#实战：OutOfMemoryError异常" class="headerlink" title="实战：OutOfMemoryError异常"></a>实战：OutOfMemoryError异常</h3><ul><li>通过代码验证Java虚拟机规范中描述各个运行时区域存储的内容；</li><li>在实际遇到内存溢出异常时，能根据异常的信息快速判断是哪个区域内存溢出；</li></ul><h4 id="Java堆溢出"><a href="#Java堆溢出" class="headerlink" title="Java堆溢出"></a>Java堆溢出</h4><p><img src="https://ws1.sinaimg.cn/large/005DnJLEly1fp4gpop763j30jc0d0mxm.jpg" alt=""><br>解决思路：先通过内存映像分析工具对dump出来的堆转储快照进行分析，先分清楚是内存泄漏还是内存溢出；如果是内存泄漏，进一步查看泄漏对象到GC Roots的引用链，从而确认为什么无法回收；如果是内存溢出，则应当检查虚拟机堆参数（-Xmx与-Xmx）或检查是否存在对象生命周期过长、持有状态时间过长的情况；</p><h4 id="虚拟机栈和本地方法栈溢出"><a href="#虚拟机栈和本地方法栈溢出" class="headerlink" title="虚拟机栈和本地方法栈溢出"></a>虚拟机栈和本地方法栈溢出</h4><ul><li>HotSpot不区分虚拟机栈和本地方法栈；</li><li>StackOverflowError和OutOfMemoryError存在互相重叠的地方；<br>栈容量由-Xss参数设定；</li></ul><p><img src="https://ws1.sinaimg.cn/large/005DnJLEly1fp4gqkuwx7j30jw0j9t9w.jpg" alt=""><br>虚拟机的默认参数对于通常的方法调用（1000~2000层）完全够用，通常根据异常的堆栈日志就可以很容易定位问题。</p><h4 id="方法区和运行时常量池溢出"><a href="#方法区和运行时常量池溢出" class="headerlink" title="方法区和运行时常量池溢出"></a>方法区和运行时常量池溢出</h4><p>对于这个区域的测试，基本思路是运行时产生大量的类去填满方法区（比如使用反射和动态代理），这里我们借助CGLib直接操作字节码运行时产生大量的动态类（很对主流框架如Spring、Hibernate都会采用类似的字节码技术）。在这里需要特别注意垃圾回收的状况。<br><img src="https://ws1.sinaimg.cn/large/005DnJLEly1fp4grjfqt6j30vy05jq33.jpg" alt=""></p><p><img src="https://ws1.sinaimg.cn/large/005DnJLEly1fp4gs11oazj30vy0ffmy2.jpg" alt=""></p><h4 id="本机直接内存溢出"><a href="#本机直接内存溢出" class="headerlink" title="本机直接内存溢出"></a>本机直接内存溢出</h4><p><img src="https://ws1.sinaimg.cn/large/005DnJLEly1fp4gstzep0j30m80badgg.jpg" alt=""></p><p><img src="https://ws1.sinaimg.cn/large/005DnJLEly1fp4gtcldwmj30m8025aa2.jpg" alt=""><br>DirectMemory导致的内存溢出，在Heap Dump里不会看见明显的异常。如果发现OouOfMemory之后Dump文件很小，程序又使用了NIO，那就可以检查下是否这方面的原因。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;世界上并没有完美的程序，但我们并不因此而沮丧，因为写程序本来就是一个不断追求完美的过程。&lt;/p&gt;
&lt;p&gt;笔记第一部分对应原书的第一章，主要介绍了Java的技术体系、Java虚拟机的发展历史。第二部分对应原书的第二章，主要介绍了Java运行时区域的划分、对象的创建和访问以及内存溢出的实战。&lt;/p&gt;
    
    </summary>
    
      <category term="JVM" scheme="https://caoler.cn/categories/JVM/"/>
    
    
      <category term="JVM" scheme="https://caoler.cn/tags/JVM/"/>
    
      <category term="读书笔记" scheme="https://caoler.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>有趣</title>
    <link href="https://caoler.cn//post/2017/goole-birthday.html"/>
    <id>https://caoler.cn//post/2017/goole-birthday.html</id>
    <published>2017-11-29T03:48:43.000Z</published>
    <updated>2017-11-29T03:50:32.940Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws1.sinaimg.cn/large/005DnJLEly1flytamyqqvj30j30aw74l.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/005DnJLEly1flytamyqqvj30j30aw74l.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="CodingLife" scheme="https://caoler.cn/categories/CodingLife/"/>
    
    
      <category term="CodingLife" scheme="https://caoler.cn/tags/CodingLife/"/>
    
  </entry>
  
  <entry>
    <title>join()方法和TheadLocal类</title>
    <link href="https://caoler.cn//post/2017/join-and-threadlocal.html"/>
    <id>https://caoler.cn//post/2017/join-and-threadlocal.html</id>
    <published>2017-11-27T05:37:00.000Z</published>
    <updated>2017-11-28T05:37:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Thread-join"><a href="#Thread-join" class="headerlink" title="Thread.join()"></a>Thread.join()</h1><h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><figure class="highlight pony"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> t = <span class="function"><span class="keyword">new</span> <span class="title">AThread</span>();</span></span><br><span class="line"><span class="function"><span class="title">t</span>.<span class="title">start</span>();</span></span><br><span class="line"><span class="function"><span class="title">t</span>.<span class="title">join</span>();</span></span><br></pre></td></tr></table></figure><h2 id="为什么要用join-方法"><a href="#为什么要用join-方法" class="headerlink" title="为什么要用join()方法"></a>为什么要用join()方法</h2><p>在很多情况下，主线程生成并起动了子线程，如果子线程里要进行大量的耗时的运算，主线程往往将于子线程之前结束，但是如果主线程处理完其他的事务后，需要用到子线程的处理结果，也就是主线程需要等待子线程执行完成之后再结束，这个时候就要用到join()方法了。</p><h2 id="join方法的作用"><a href="#join方法的作用" class="headerlink" title="join方法的作用"></a>join方法的作用</h2><p>JDK中对join方法解释为：“等待该线程终止”，换句话说就是：”当前线程等待子线程的终止“。也就是在子线程调用了join()方法后面的代码，只有等到子线程结束了当前线程才能执行。</p><h2 id="用实例来理解"><a href="#用实例来理解" class="headerlink" title="用实例来理解"></a>用实例来理解</h2><ol><li>简单了解join()的用法：</li></ol><a id="more"></a><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BThread</span> <span class="title">extends</span> <span class="title">Thread</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BThread</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">        super(<span class="string">"[BThread] Thread"</span>);  </span><br><span class="line">    &#125;;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">        String threadName = Thread.currentThread().getName();  </span><br><span class="line">        System.<span class="keyword">out</span>.println(threadName + <span class="string">" start."</span>);  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;  </span><br><span class="line">                System.<span class="keyword">out</span>.println(threadName + <span class="string">" loop at "</span> + i);  </span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);  </span><br><span class="line">            &#125;  </span><br><span class="line">            System.<span class="keyword">out</span>.println(threadName + <span class="string">" end."</span>);  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"Exception from "</span> + threadName + <span class="string">".run"</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AThread</span> <span class="title">extends</span> <span class="title">Thread</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    BThread bt;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AThread</span>(<span class="params">BThread bt</span>) </span>&#123;  </span><br><span class="line">        super(<span class="string">"[AThread] Thread"</span>);  </span><br><span class="line">        <span class="keyword">this</span>.bt = bt;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">        String threadName = Thread.currentThread().getName();  </span><br><span class="line">        System.<span class="keyword">out</span>.println(threadName + <span class="string">" start."</span>);  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            bt.<span class="keyword">join</span>();  </span><br><span class="line">            System.<span class="keyword">out</span>.println(threadName + <span class="string">" end."</span>);  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"Exception from "</span> + threadName + <span class="string">".run"</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestDemo</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;  </span><br><span class="line">        String threadName = Thread.currentThread().getName();  </span><br><span class="line">        System.<span class="keyword">out</span>.println(threadName + <span class="string">" start."</span>);  </span><br><span class="line">        BThread bt = <span class="keyword">new</span> BThread();  </span><br><span class="line">        AThread at = <span class="keyword">new</span> AThread(bt);  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            bt.start();  </span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);  </span><br><span class="line">            at.start();  </span><br><span class="line">            at.<span class="keyword">join</span>();  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"Exception from main"</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        System.<span class="keyword">out</span>.println(threadName + <span class="string">" end!"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">main start.                  <span class="comment">-- 主线程启动, 因为主线程中调用了at.join(), 所以主线程要等到 AThread线程结束之后才能执行  </span></span><br><span class="line">[BThread] <span class="keyword">Thread</span> start.  </span><br><span class="line">[BThread] <span class="keyword">Thread</span> <span class="keyword">loop</span> <span class="keyword">at</span> <span class="number">0</span>  </span><br><span class="line">[BThread] <span class="keyword">Thread</span> <span class="keyword">loop</span> <span class="keyword">at</span> <span class="number">1</span>  </span><br><span class="line">[AThread] <span class="keyword">Thread</span> start.      <span class="comment">-- AThread线程启动, 因为AThread线程中调用了bt.join(), 所以AThread线程要等到BThread线程结束之后才能执行  </span></span><br><span class="line">[BThread] <span class="keyword">Thread</span> <span class="keyword">loop</span> <span class="keyword">at</span> <span class="number">2</span>  </span><br><span class="line">[BThread] <span class="keyword">Thread</span> <span class="keyword">loop</span> <span class="keyword">at</span> <span class="number">3</span>  </span><br><span class="line">[BThread] <span class="keyword">Thread</span> <span class="keyword">loop</span> <span class="keyword">at</span> <span class="number">4</span>  </span><br><span class="line">[BThread] <span class="keyword">Thread</span> end.        <span class="comment">-- BThread线程结束了, AThread线程执行  </span></span><br><span class="line">[AThread] <span class="keyword">Thread</span> end.        <span class="comment">-- AThread线程结束了, 主线程执行  </span></span><br><span class="line"><span class="keyword">main</span> <span class="keyword">end</span>!</span><br></pre></td></tr></table></figure><ol><li>深入的了解join()的用法：</li></ol><p>网上有很多人是这样解释 join()的用法的：”主线程等待子线程的终止“ ，相信有很多人都会这么说，但是这个说法是完全错误的，为什么呢？<br>请看例子，在上边代码的基础上，我们对TestDemo类做一下改动：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestDemo</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;  </span><br><span class="line">        String threadName = Thread.currentThread().getName();  </span><br><span class="line">        System.<span class="keyword">out</span>.println(threadName + <span class="string">" start."</span>);  </span><br><span class="line">        BThread bt = <span class="keyword">new</span> BThread();  </span><br><span class="line">        AThread at = <span class="keyword">new</span> AThread(bt);  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            bt.start();  </span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);  </span><br><span class="line">            at.start();  </span><br><span class="line">            <span class="comment">// at.join();  //这里注释掉  </span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"Exception from main"</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        System.<span class="keyword">out</span>.println(threadName + <span class="string">" end!"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">main start.                     <span class="comment">-- 主线程启动  </span></span><br><span class="line">[BThread] <span class="keyword">Thread</span> start.         <span class="comment">-- BThread线程启动  </span></span><br><span class="line">[BThread] <span class="keyword">Thread</span> <span class="keyword">loop</span> <span class="keyword">at</span> <span class="number">0</span>  </span><br><span class="line">[BThread] <span class="keyword">Thread</span> <span class="keyword">loop</span> <span class="keyword">at</span> <span class="number">1</span>  </span><br><span class="line"><span class="keyword">main</span> <span class="keyword">end</span>!                       <span class="comment">-- 主线程结束，（也就是说AThread线程中调用了bt.join()并不会影响到主线程）  </span></span><br><span class="line">[AThread] <span class="keyword">Thread</span> start.         <span class="comment">-- AThread线程启动, 因为AThread线程中调用了bt.join(), 所以AThread线程要等到BThread线程结束之后才能执行  </span></span><br><span class="line">[BThread] <span class="keyword">Thread</span> <span class="keyword">loop</span> <span class="keyword">at</span> <span class="number">2</span>  </span><br><span class="line">[BThread] <span class="keyword">Thread</span> <span class="keyword">loop</span> <span class="keyword">at</span> <span class="number">3</span>  </span><br><span class="line">[BThread] <span class="keyword">Thread</span> <span class="keyword">loop</span> <span class="keyword">at</span> <span class="number">4</span>       </span><br><span class="line">[BThread] <span class="keyword">Thread</span> end.           <span class="comment">-- BThread线程结束了, AThread线程执行  </span></span><br><span class="line">[AThread] <span class="keyword">Thread</span> end.</span><br></pre></td></tr></table></figure><p>相信聪明的读者已经猜到为什么说 ”主线程等待子线程的终止 “ 的错误原因了吧，正确的说法应该是：”当前线程等待子线程的终止“</p><h2 id="从源码看join-方法"><a href="#从源码看join-方法" class="headerlink" title="从源码看join()方法"></a>从源码看join()方法</h2><p>在AThread的run方法里，执行了<code>bt.join();</code>，进入看一下它的JDK源码：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="keyword">join</span>() <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">join</span>(<span class="number">0</span>L);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后进入join(0L)方法：<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="built_in">join</span>(<span class="keyword">long</span> <span class="built_in">millis</span>)</span><br><span class="line"><span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">long</span> base = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">long</span> now = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">millis</span> &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout value is negative"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">millis</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果线程被生成了，但还未被起动，isAlive()将返回false，调用它的join()方法是没有作用的，将直接继续向下执行。 </span></span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            wait(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            <span class="keyword">long</span> delay = <span class="built_in">millis</span> - now;</span><br><span class="line">            <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            wait(delay);</span><br><span class="line">            now = System.currentTimeMillis() - base;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>单纯从代码上看：在AThread类中的run方法中，bt.join()是判断bt的active状态，如果bt的isActive()方法返回false，在bt.join(),这一点就不用等待BThread线程结束，AThread就可以继续向下进行。</p><p>isAlive()方法的签名是：public final native boolean isAlive()，也就是说isAlive()是判断当前线程的状态。</p><h1 id="TheadLocal"><a href="#TheadLocal" class="headerlink" title="TheadLocal"></a>TheadLocal</h1><p>Java中的ThreadLocal类可以让你创建的变量只被同一个线程进行读和写操作。因此，尽管有两个线程同时执行一段相同的代码，而且这段代码又有一个指向同一个ThreadLocal变量的引用，但是这两个线程依然不能看到彼此的ThreadLocal变量域。</p><h2 id="创建一个ThreadLocal对象"><a href="#创建一个ThreadLocal对象" class="headerlink" title="创建一个ThreadLocal对象"></a>创建一个ThreadLocal对象</h2><p>如下所示，创建一个ThreadLocal变量：<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ThreadLocal myThreadLocal = <span class="keyword">new</span> <span class="type">ThreadLocal</span>();</span><br></pre></td></tr></table></figure></p><p>你实例化了一个ThreadLocal对象。每个线程仅需要实例化一次即可。虽然不同的线程执行同一段代码时，访问同一个ThreadLocal变量，但是每个线程只能看到私有的ThreadLocal实例。所以不同的线程在给ThreadLocal对象设置不同的值时，他们也不能看到彼此的修改。</p><h2 id="访问ThreadLocal对象"><a href="#访问ThreadLocal对象" class="headerlink" title="访问ThreadLocal对象"></a>访问ThreadLocal对象</h2><p>一旦创建了一个ThreadLocal对象，你就可以通过以下方式来存储此对象的值：<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myThreadLocal<span class="meta">.set</span>(<span class="string">"A thread local value"</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure></p><p>也可以直接读取一个ThreadLocal对象的值：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">String</span> threadLocalValue = (<span class="keyword">String</span>) myThreadLocal.<span class="built_in">get</span>();</span><br></pre></td></tr></table></figure></p><p>get()方法会返回一个Object对象，而set()方法则依赖一个Object对象参数。</p><h2 id="ThreadLocal泛型"><a href="#ThreadLocal泛型" class="headerlink" title="ThreadLocal泛型"></a>ThreadLocal泛型</h2><p>为了使get()方法返回值不用做强制类型转换，通常可以创建一个泛型化的ThreadLocal对象。以下就是一个泛型化的ThreadLocal示例：<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ThreadLocal myThreadLocal1 = <span class="keyword">new</span> <span class="type">ThreadLocal</span>&lt;<span class="keyword">String</span>&gt;();</span><br></pre></td></tr></table></figure></p><p>现在你可以存储一个字符串到ThreadLocal实例里，此外，当你从此ThreadLocal实例中获取值的时候，就不必要做强制类型转换。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">myThreadLocal1.<span class="builtin-name">set</span>(<span class="string">"Hello ThreadLocal"</span>);</span><br><span class="line"></span><br><span class="line">String threadLocalValues = myThreadLocal.<span class="builtin-name">get</span>();</span><br></pre></td></tr></table></figure></p><h2 id="初始化ThreadLocal"><a href="#初始化ThreadLocal" class="headerlink" title="初始化ThreadLocal"></a>初始化ThreadLocal</h2><p>由于ThreadLocal对象的set()方法设置的值只对当前线程可见，那有什么方法可以为ThreadLocal对象设置的值对所有线程都可见。</p><p>为此，我们可以通过ThreadLocal子类的实现，并覆写initialValue()方法，就可以为ThreadLocal对象指定一个初始化值。如下所示:<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ThreadLocal myThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;<span class="built_in">String</span>&gt;() &#123;</span><br><span class="line">   <span class="meta">@Override</span> <span class="keyword">protected</span> <span class="built_in">String</span> initialValue() &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="string">"This is the initial value"</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>此时，在set()方法调用前，当调用get()方法的时候，所有线程都可以看到同一个初始化值。</p><h2 id="Full-ThreadLocal-Example"><a href="#Full-ThreadLocal-Example" class="headerlink" title="Full ThreadLocal Example"></a>Full ThreadLocal Example</h2><p>以下是一个完整的ThreadLocal示例：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">package cn.caoler.ThreadTest2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: Caole</span></span><br><span class="line"><span class="comment"> * CreateDateTime: 2017/11/27 13:21</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ThreadLocalExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="title">implements</span> <span class="title">Runnable</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> ThreadLocal&lt;Integer&gt; threadLocal =</span><br><span class="line">               <span class="keyword">new</span> ThreadLocal&lt;Integer&gt;();</span><br><span class="line">        @Override</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            threadLocal.<span class="keyword">set</span>( (<span class="keyword">int</span>) (Math.random() * <span class="number">100</span>D) );</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            System.<span class="keyword">out</span>.println(threadLocal.<span class="keyword">get</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) throws InterruptedException </span>&#123;</span><br><span class="line">        MyRunnable sharedRunnableInstance = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(sharedRunnableInstance);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(sharedRunnableInstance);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread1.<span class="keyword">join</span>(); <span class="comment">//wait for thread 1 to terminate</span></span><br><span class="line">        thread2.<span class="keyword">join</span>(); <span class="comment">//wait for thread 2 to terminate</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面创建了两个线程共享一个MyRunnable实例。每个线程执行run()方法的时候，会给同一个ThreadLocal实例设置不同的值。如果调用set()方法的时候用synchronized关键字同步，而不是ThreadLocal对象的实例，那么第二个线程将会覆盖第一个线程所设置的值。</p><p>然而，由于是ThreadLocal对象，所以两个线程无法看到彼此的值。因此，可以设置或者获取不同的值。</p><h2 id="InheritableThreadLocal"><a href="#InheritableThreadLocal" class="headerlink" title="InheritableThreadLocal"></a>InheritableThreadLocal</h2><p>InheritableThreadLocal类是ThreadLocal的子类。为了解决ThreadLocal实例内部每个线程都只能看到自己的私有值，所以InheritableThreadLocal允许一个线程创建的所有子线程访问其父线程的值。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li>CSDN:<a href="http://blog.csdn.net/dabing69221/article/details/17472901" target="_blank" rel="external">Java Thread.join详解</a></li><li>并发编程网：<a href="http://ifeve.com/java-theadlocal/" target="_blank" rel="external">《Java并发性和多线程介绍》-Java TheadLocal</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Thread-join&quot;&gt;&lt;a href=&quot;#Thread-join&quot; class=&quot;headerlink&quot; title=&quot;Thread.join()&quot;&gt;&lt;/a&gt;Thread.join()&lt;/h1&gt;&lt;h2 id=&quot;使用方式&quot;&gt;&lt;a href=&quot;#使用方式&quot; class=&quot;headerlink&quot; title=&quot;使用方式&quot;&gt;&lt;/a&gt;使用方式&lt;/h2&gt;&lt;figure class=&quot;highlight pony&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;Thread&lt;/span&gt; t = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;AThread&lt;/span&gt;();&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;t&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;start&lt;/span&gt;();&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;t&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;join&lt;/span&gt;();&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;为什么要用join-方法&quot;&gt;&lt;a href=&quot;#为什么要用join-方法&quot; class=&quot;headerlink&quot; title=&quot;为什么要用join()方法&quot;&gt;&lt;/a&gt;为什么要用join()方法&lt;/h2&gt;&lt;p&gt;在很多情况下，主线程生成并起动了子线程，如果子线程里要进行大量的耗时的运算，主线程往往将于子线程之前结束，但是如果主线程处理完其他的事务后，需要用到子线程的处理结果，也就是主线程需要等待子线程执行完成之后再结束，这个时候就要用到join()方法了。&lt;/p&gt;
&lt;h2 id=&quot;join方法的作用&quot;&gt;&lt;a href=&quot;#join方法的作用&quot; class=&quot;headerlink&quot; title=&quot;join方法的作用&quot;&gt;&lt;/a&gt;join方法的作用&lt;/h2&gt;&lt;p&gt;JDK中对join方法解释为：“等待该线程终止”，换句话说就是：”当前线程等待子线程的终止“。也就是在子线程调用了join()方法后面的代码，只有等到子线程结束了当前线程才能执行。&lt;/p&gt;
&lt;h2 id=&quot;用实例来理解&quot;&gt;&lt;a href=&quot;#用实例来理解&quot; class=&quot;headerlink&quot; title=&quot;用实例来理解&quot;&gt;&lt;/a&gt;用实例来理解&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;简单了解join()的用法：&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="并发编程" scheme="https://caoler.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="线程通信" scheme="https://caoler.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/"/>
    
    
      <category term="并发编程" scheme="https://caoler.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="转载" scheme="https://caoler.cn/tags/%E8%BD%AC%E8%BD%BD/"/>
    
      <category term="线程通信" scheme="https://caoler.cn/tags/%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>死锁以及如何避免死锁</title>
    <link href="https://caoler.cn//post/2017/deadlock.html"/>
    <id>https://caoler.cn//post/2017/deadlock.html</id>
    <published>2017-11-27T02:30:00.000Z</published>
    <updated>2017-11-27T12:40:22.311Z</updated>
    
    <content type="html"><![CDATA[<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>锁是两个或更多线程阻塞着等待其它处于死锁状态的线程所持有的锁。死锁通常发生在多个线程同时但以不同的顺序请求同一组锁的时候。</p><p>例如，如果线程1锁住了A，然后尝试对B进行加锁，同时线程2已经锁住了B，接着尝试对A进行加锁，这时死锁就发生了。线程1永远得不到B，线程2也永远得不到A，并且它们永远也不会知道发生了这样的事情。为了得到彼此的对象（A和B），它们将永远阻塞下去。这种情况就是一个死锁。</p><p>该情况如下：</p><blockquote><p>Thread 1  locks A, waits for B<br>Thread 2  locks B, waits for A</p></blockquote><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.caoler.DeadLockDemo;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: Caole</span></span><br><span class="line"><span class="comment"> * CreateDateTime: 2017/11/23 11:56</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String A = <span class="string">"A"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String B = <span class="string">"B"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> DeadLockDemo().deadLock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deadLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span>(A)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.currentThread().sleep(<span class="number">20</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">synchronized</span>(B)&#123;</span><br><span class="line">                        System.out.println(<span class="string">"1"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span>(B)&#123;</span><br><span class="line">                    <span class="keyword">synchronized</span>(A)&#123;</span><br><span class="line">                        System.out.println(<span class="string">"2"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h2><p>常见方法有如下几个：</p><ul><li>避免一个线程同时获取多个锁。</li><li>避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源。</li><li>尝试使用定时锁，使用lock.tryLock(timeout)来代替使用内部锁机制。</li><li>对于数据库锁，加锁和解锁必须在同一个数据库连接里，否则会出现解锁异常的情况。</li></ul><p>具体解释详见<a href="http://ifeve.com/deadlock-prevention/" target="_blank" rel="external">并发编程网-避免死锁</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;死锁&quot;&gt;&lt;a href=&quot;#死锁&quot; class=&quot;headerlink&quot; title=&quot;死锁&quot;&gt;&lt;/a&gt;死锁&lt;/h2&gt;&lt;p&gt;锁是两个或更多线程阻塞着等待其它处于死锁状态的线程所持有的锁。死锁通常发生在多个线程同时但以不同的顺序请求同一组锁的时候。&lt;/p&gt;
&lt;p&gt;例如，如果线程1锁住了A，然后尝试对B进行加锁，同时线程2已经锁住了B，接着尝试对A进行加锁，这时死锁就发生了。线程1永远得不到B，线程2也永远得不到A，并且它们永远也不会知道发生了这样的事情。为了得到彼此的对象（A和B），它们将永远阻塞下去。这种情况就是一个死锁。&lt;/p&gt;
&lt;p&gt;该情况如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Thread 1  locks A, waits for B&lt;br&gt;Thread 2  locks B, waits for A&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h3&gt;
    
    </summary>
    
      <category term="并发编程" scheme="https://caoler.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="锁" scheme="https://caoler.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E9%94%81/"/>
    
    
      <category term="并发编程" scheme="https://caoler.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="转载" scheme="https://caoler.cn/tags/%E8%BD%AC%E8%BD%BD/"/>
    
      <category term="死锁" scheme="https://caoler.cn/tags/%E6%AD%BB%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>线程通信</title>
    <link href="https://caoler.cn//post/2017/thread-signaling.html"/>
    <id>https://caoler.cn//post/2017/thread-signaling.html</id>
    <published>2017-11-22T10:31:00.000Z</published>
    <updated>2017-11-27T12:37:56.861Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>线程通信的目标是使线程间能够互相发送信号。另一方面，线程通信使线程能够等待其他线程的信号。</p><p>例如，线程B可以等待线程A的一个信号，这个信号会通知线程B数据已经准备好了。本文将讲解以下几个JAVA线程间通信的主题：</p><h3 id="通过共享对象通信"><a href="#通过共享对象通信" class="headerlink" title="通过共享对象通信"></a>通过共享对象通信</h3><p>线程间发送信号的一个简单方式是在共享对象的变量里设置信号值。线程A在一个同步块里设置boolean型成员变量hasDataToProcess为true，线程B也在同步块里读取hasDataToProcess这个成员变量。这个简单的例子使用了一个持有信号的对象，并提供了set和check方法:</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySignal</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">boolean</span> hasDataToProcess = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">hasDataToProcess</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.hasDataToProcess;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setHasDataToProcess</span><span class="params">(<span class="keyword">boolean</span> hasData)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.hasDataToProcess = hasData;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程A和B必须获得指向一个MySignal共享实例的引用，以便进行通信。如果它们持有的引用指向不同的MySingal实例，那么彼此将不能检测到对方的信号。需要处理的数据可以存放在一个共享缓存区里，它和MySignal实例是分开存放的。</p><h3 id="忙等待"><a href="#忙等待" class="headerlink" title="忙等待"></a>忙等待</h3><p>准备处理数据的线程B正在等待数据变为可用。换句话说，它在等待线程A的一个信号，这个信号使hasDataToProcess()返回true。线程B运行在一个循环里，以等待这个信号：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> MySignal sharedSignal = <span class="params">...</span></span><br><span class="line"></span><br><span class="line"><span class="params">...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(!sharedSignal.hasDataToProcess())&#123;</span><br><span class="line">  <span class="comment">//do nothing... busy waiting</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="wait-notify-和notifyAll"><a href="#wait-notify-和notifyAll" class="headerlink" title="wait(),notify()和notifyAll()"></a>wait(),notify()和notifyAll()</h3><p>忙等待没有对运行等待线程的CPU进行有效的利用，除非平均等待时间非常短。否则，让等待线程进入睡眠或者非运行状态更为明智，直到它接收到它等待的信号。</p><p>Java有一个内建的等待机制来允许线程在等待信号的时候变为非运行状态。java.lang.Object 类定义了三个方法，wait()、notify()和notifyAll()来实现这个等待机制。</p><p>一个线程一旦调用了任意对象的wait()方法，就会变为非运行状态，直到另一个线程调用了<strong>同一个对象</strong> 的notify()方法。为了调用wait()或者notify()，线程必须先获得那个对象的锁。也就是说，线程必须在同步块里调用wait()或者notify()。以下是MySingal的修改版本——使用了wait()和notify()的MyWaitNotify：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MonitorObject</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyWaitNotify</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  MonitorObject myMonitorObject = <span class="keyword">new</span> MonitorObject();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWait</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(myMonitorObject)&#123;</span><br><span class="line">      <span class="keyword">try</span>&#123;</span><br><span class="line">        myMonitorObject.wait();</span><br><span class="line">      &#125; <span class="keyword">catch</span>(InterruptedException e)&#123;...&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doNotify</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(myMonitorObject)&#123;</span><br><span class="line">      myMonitorObject.notify();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>等待线程将调用doWait()，而唤醒线程将调用doNotify()。当一个线程调用一个对象的notify()方法，正在等待该对象的所有线程中将有一个线程被唤醒并允许执行 <em>（校注：这个将被唤醒的线程是随机的，不可以指定唤醒哪个线程）。</em> 同时也提供了一个notifyAll()方法来唤醒正在等待一个给定对象的所有线程。</p><p>如你所见，不管是等待线程还是唤醒线程都在同步块里调用wait()和notify()。这是强制性的！<strong>一个线程如果没有持有对象锁，将不能调用wait()，notify()或者notifyAll()。</strong> 否则，会抛出IllegalMonitorStateException异常。</p><p><em>（校注：JVM是这么实现的，当你调用wait时候它首先要检查下当前线程是否是锁的拥有者，不是则抛出IllegalMonitorStateExcept，参考JVM源码的 1422行。）</em></p><p>但是，这怎么可能？等待线程在同步块里面执行的时候，不是一直持有监视器对象（myMonitor对象）的锁吗？等待线程不能阻塞唤醒线程进入doNotify()的同步块吗？答案是：的确不能。<strong>一旦线程调用了wait()方法，它就释放了所持有的监视器对象上的锁。这将允许其他线程也可以调用wait()或者notify()。</strong></p><p>一旦一个线程被唤醒，不能立刻就退出wait()的方法调用，直到调用notify()的线程退出了它自己的同步块。换句话说：被唤醒的线程必须重新获得监视器对象的锁，才可以退出wait()的方法调用，因为wait方法调用运行在同步块里面。如果多个线程被notifyAll()唤醒，那么在同一时刻将只有一个线程可以退出wait()方法，因为每个线程在退出wait()前必须获得监视器对象的锁。</p><h3 id="丢失的信号"><a href="#丢失的信号" class="headerlink" title="丢失的信号"></a>丢失的信号</h3><p>notify()和notifyAll()方法不会保存调用它们的方法，因为当这两个方法被调用时，有可能没有线程处于等待状态。通知信号过后便丢弃了。因此，如果一个线程先于被通知线程调用wait()前调用了notify()，等待的线程将错过这个信号。这可能是也可能不是个问题。不过，在某些情况下，这可能使等待线程永远在等待，不再醒来，因为线程错过了唤醒信号。</p><p>为了避免丢失信号，必须把它们保存在信号类里。在MyWaitNotify的例子中，通知信号应被存储在MyWaitNotify实例的一个成员变量里。以下是MyWaitNotify的修改版本：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyWaitNotify2</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  MonitorObject myMonitorObject = <span class="keyword">new</span> MonitorObject();</span><br><span class="line">  <span class="keyword">boolean</span> wasSignalled = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWait</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(myMonitorObject)&#123;</span><br><span class="line">      <span class="keyword">if</span>(!wasSignalled)&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">          myMonitorObject.wait();</span><br><span class="line">         &#125; <span class="keyword">catch</span>(InterruptedException e)&#123;...&#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//clear signal and continue running.</span></span><br><span class="line">      wasSignalled = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doNotify</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(myMonitorObject)&#123;</span><br><span class="line">      wasSignalled = <span class="keyword">true</span>;</span><br><span class="line">      myMonitorObject.notify();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>留意doNotify()方法在调用notify()前把wasSignalled变量设为true。同时，留意doWait()方法在调用wait()前会检查wasSignalled变量。事实上，如果没有信号在前一次doWait()调用和这次doWait()调用之间的时间段里被接收到，它将只调用wait()。</p><p><em>（校注：为了避免信号丢失， 用一个变量来保存是否被通知过。在notify前，设置自己已经被通知过。在wait后，设置自己没有被通知过，需要等待通知。）</em></p><p><strong>自己的理解，wasSignalled标注的功能就是限制Wait和Notify的顺序</strong></p><h3 id="假唤醒"><a href="#假唤醒" class="headerlink" title="假唤醒"></a>假唤醒</h3><p>由于莫名其妙的原因，线程有可能在没有调用过notify()和notifyAll()的情况下醒来。这就是所谓的假唤醒（spurious wakeups）。无端端地醒过来了。</p><p>如果在MyWaitNotify2的doWait()方法里发生了假唤醒，等待线程即使没有收到正确的信号，也能够执行后续的操作。这可能导致你的应用程序出现严重问题。</p><p>为了防止假唤醒，保存信号的成员变量将在一个while循环里接受检查，而不是在if表达式里。这样的一个while循环叫做自旋锁 <em>（校注：这种做法要慎重，目前的JVM实现自旋会消耗CPU，如果长时间不调用doNotify方法，doWait方法会一直自旋，CPU会消耗太大）。</em> 被唤醒的线程会自旋直到自旋锁(while循环)里的条件变为false。以下MyWaitNotify2的修改版本展示了这点：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyWaitNotify3</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">  MonitorObject myMonitorObject = <span class="keyword">new</span> MonitorObject();</span><br><span class="line">  <span class="keyword">boolean</span> wasSignalled = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWait</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(myMonitorObject)&#123;</span><br><span class="line">      <span class="keyword">while</span>(!wasSignalled)&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">          myMonitorObject.wait();</span><br><span class="line">         &#125; <span class="keyword">catch</span>(InterruptedException e)&#123;...&#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//clear signal and continue running.</span></span><br><span class="line">      wasSignalled = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doNotify</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(myMonitorObject)&#123;</span><br><span class="line">      wasSignalled = <span class="keyword">true</span>;</span><br><span class="line">      myMonitorObject.notify();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>留意wait()方法是在while循环里，而不在if表达式里。如果等待线程没有收到信号就唤醒，wasSignalled变量将变为false,while循环会再执行一次，促使醒来的线程回到等待状态。</p><h3 id="多线程等待相同信号"><a href="#多线程等待相同信号" class="headerlink" title="多线程等待相同信号"></a>多线程等待相同信号</h3><p>如果你有多个线程在等待，被notifyAll()唤醒，但只有一个被允许继续执行，使用while循环也是个好方法。每次只有一个线程可以获得监视器对象锁，意味着只有一个线程可以退出wait()调用并清除wasSignalled标志（设为false）。一旦这个线程退出doWait()的同步块，其他线程退出wait()调用，并在while循环里检查wasSignalled变量值。但是，这个标志已经被第一个唤醒的线程清除了，所以其余醒来的线程将回到等待状态，直到下次信号到来。</p><h3 id="不要对常量字符串或全局对象调用wait"><a href="#不要对常量字符串或全局对象调用wait" class="headerlink" title="不要对常量字符串或全局对象调用wait()"></a>不要对常量字符串或全局对象调用wait()</h3><p><em>（校注：本章说的字符串常量指的是值为常量的变量）</em></p><p>本文早期的一个版本在MyWaitNotify例子里使用字符串常量（””）作为管程对象。以下是那个例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyWaitNotify3</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">  String myMonitorObject = <span class="string">""</span>;</span><br><span class="line">  <span class="keyword">boolean</span> wasSignalled = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWait</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(myMonitorObject)&#123;</span><br><span class="line">      <span class="keyword">while</span>(!wasSignalled)&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">          myMonitorObject.wait();</span><br><span class="line">         &#125; <span class="keyword">catch</span>(InterruptedException e)&#123;...&#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//clear signal and continue running.</span></span><br><span class="line">      wasSignalled = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doNotify</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(myMonitorObject)&#123;</span><br><span class="line">      wasSignalled = <span class="keyword">true</span>;</span><br><span class="line">      myMonitorObject.notify();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在空字符串作为锁的同步块(或者其他常量字符串)里调用wait()和notify()产生的问题是，JVM/编译器内部会把常量字符串转换成同一个对象。这意味着，即使你有2个不同的MyWaitNotify实例，它们都引用了相同的空字符串实例。同时也意味着存在这样的风险：在第一个MyWaitNotify实例上调用doWait()的线程会被在第二个MyWaitNotify实例上调用doNotify()的线程唤醒。这种情况可以画成以下这张图：</p><p><img src="https://ws1.sinaimg.cn/large/005DnJLEgy1flr17ajfdjj30a4083t8r.jpg" alt=""></p><h2 id="等待-通知机制-总结"><a href="#等待-通知机制-总结" class="headerlink" title="等待/通知机制 总结"></a>等待/通知机制 总结</h2><h3 id="相关方法"><a href="#相关方法" class="headerlink" title="相关方法"></a>相关方法</h3><table><thead><tr><th>方法名称</th><th>描述</th></tr></thead><tbody><tr><td>notify()</td><td>通知一个在对象上等待的线程，由WAITING状态变为BLOCKING状态，从等待队列移动到同步队列，等待CPU调度获取该对象的锁，当该线程获取到了对象的锁后，该线程从wait()方法返回</td></tr><tr><td>notifyAll()</td><td>通知所有等待在该对象上的线程，由WAITING状态变为BLOCKING状态，等待CPU调度获取该对象的锁</td></tr><tr><td>wait()</td><td>调用该方法的线程进入WAITING状态，并将当前线程放置到对象的等待队列，只有等待另外线程的通知或被中断才会返回，需要注意，调用wait()方法后，会释放对象的锁</td></tr><tr><td>wait(long)</td><td>超时等待一段时间，这里的参数时间是毫秒，也就是等待长达n毫秒，如果没有通知就超时返回</td></tr><tr><td>wait(long，int)</td><td>对于超时时间更细力度的控制，可以达到纳秒</td></tr></tbody></table><h3 id="代码清单"><a href="#代码清单" class="headerlink" title="代码清单"></a>代码清单</h3><p>如下代码本人觉得更加清晰<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.caoler.WaitNotify;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: Caole</span></span><br><span class="line"><span class="comment"> * CreateDateTime: 2017/11/23 12:43</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNotify</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">static</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread waitThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Wait(), <span class="string">"WaitThread"</span>);</span><br><span class="line">        waitThread.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        Thread notifyThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Notify(), <span class="string">"NotifyThread"</span>);</span><br><span class="line">        notifyThread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Wait</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//加锁，拥有lock的Monitor</span></span><br><span class="line">            <span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">                <span class="comment">//当条件不满足时继续wait，同时释放了lock的锁</span></span><br><span class="line">                <span class="keyword">while</span> (flag)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread() + <span class="string">"flag is true .wait@"</span></span><br><span class="line">                         + <span class="keyword">new</span> SimpleDateFormat(<span class="string">"HH:mm:ss"</span>).format(<span class="keyword">new</span> Date()));</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//条件满足时，完成工作</span></span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"flag is false .running@"</span></span><br><span class="line">                 + <span class="keyword">new</span> SimpleDateFormat(<span class="string">"HH:mm:ss"</span>).format(<span class="keyword">new</span> Date()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Notify</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//加锁，拥有lock的Monitor</span></span><br><span class="line">            <span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">                <span class="comment">//获取lock的锁，然后进行通知，通知时不会释放lock的锁</span></span><br><span class="line">                <span class="comment">//直到当前线程释放了lock锁之后，WaitThread才能从wait方法中返回</span></span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"hold lock .notify @"</span></span><br><span class="line">                        + <span class="keyword">new</span> SimpleDateFormat(<span class="string">"HH:mm:ss"</span>).format(<span class="keyword">new</span> Date()));</span><br><span class="line">                lock.notifyAll();</span><br><span class="line">                flag = <span class="keyword">false</span>;</span><br><span class="line">                SleepUtils.second(<span class="number">5</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//再次加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"hold lock again .sleep @"</span></span><br><span class="line">                        + <span class="keyword">new</span> SimpleDateFormat(<span class="string">"HH:mm:ss"</span>).format(<span class="keyword">new</span> Date()));</span><br><span class="line">                SleepUtils.second(<span class="number">5</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出如下：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">Thread</span><span class="selector-attr">[WaitThread,5,main]</span><span class="selector-tag">flag</span> <span class="selector-tag">is</span> <span class="selector-tag">true</span> <span class="selector-class">.wait</span>@<span class="selector-tag">15</span><span class="selector-pseudo">:54</span><span class="selector-pseudo">:24</span></span><br><span class="line"><span class="selector-tag">Thread</span><span class="selector-attr">[NotifyThread,5,main]</span><span class="selector-tag">hold</span> <span class="selector-tag">lock</span> <span class="selector-class">.notify</span> @<span class="selector-tag">15</span><span class="selector-pseudo">:54</span><span class="selector-pseudo">:24</span></span><br><span class="line"><span class="selector-tag">Thread</span><span class="selector-attr">[NotifyThread,5,main]</span><span class="selector-tag">hold</span> <span class="selector-tag">lock</span> <span class="selector-tag">again</span> <span class="selector-class">.sleep</span> @<span class="selector-tag">15</span><span class="selector-pseudo">:54</span><span class="selector-pseudo">:30</span></span><br><span class="line"><span class="selector-tag">Thread</span><span class="selector-attr">[WaitThread,5,main]</span><span class="selector-tag">flag</span> <span class="selector-tag">is</span> <span class="selector-tag">false</span> <span class="selector-class">.running</span>@<span class="selector-tag">15</span><span class="selector-pseudo">:54</span><span class="selector-pseudo">:35</span></span><br></pre></td></tr></table></figure><h3 id="使用wait-notify注意事项和问题"><a href="#使用wait-notify注意事项和问题" class="headerlink" title="使用wait/notify注意事项和问题"></a>使用wait/notify注意事项和问题</h3><ul><li><p>执行完wait后会释放锁， 在执行notify()方法后，当前线程不会立刻释放该对象锁。呈wait状态的线程并不能马上获取该对象锁，要等执行notify()方法的线程将程序执行完，也就是退出synchronized代码块后，当前线程才会释放锁。</p></li><li><p>在调用wait()或notify()方法之前，必须获得该对象的对象级别锁，即只能在同步方法或者同步块中调用wait()方法，在执行wait()方法之后，当前线程释放锁。</p></li><li><p>在调用notify通知某线程后，该线程不会立即进入Running状态，而是先进入Runnable状态。</p></li><li><p>notify每次仅通知一个线程，多次调用可将wait线程全部唤醒。</p></li><li><p>当线程呈wait状态时，调用线程对象的interrupt方法会抛出InterruptedException异常。</p></li><li><p>通知过早: 如果通知过早，会打乱程序正常运行逻辑。</p></li></ul><h3 id="等待-通知的经典范式"><a href="#等待-通知的经典范式" class="headerlink" title="等待/通知的经典范式"></a>等待/通知的经典范式</h3><p>从前断示例中可以提炼出等待/通知经典范式，该范式分为两部分，分别为等待方(消费者)和通知方（生产者）。</p><ul><li><p>等待方遵循如下原则。</p><ol><li>获取对象的锁</li><li>如果条件不满足，那么调用对象的<code>wait()</code>方法，被通知后仍要检查条件。</li><li><p>条件满足则执行对应的逻辑。</p><p>对应的伪代码如下</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">synchronized</span>(对象)&#123;</span><br><span class="line">    <span class="selector-tag">while</span>(不满足)&#123;</span><br><span class="line">        对象<span class="selector-class">.wait</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    对应的处理逻辑</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>通知方遵循如下原则</p><ol><li>获得对象的锁</li><li>改变条件</li><li><p>通知所有等待在对象上的线程</p><p>对应的伪代码如下：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">synchronized</span>(对象)&#123;</span><br><span class="line">    改变条件</span><br><span class="line">    对象<span class="selector-class">.notifyAll</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>自并发编程网 – <a href="http://ifeve.com" target="_blank" rel="external">ifeve.com</a>本文链接地址: <a href="http://ifeve.com/java-concurrency-thread-directory/" target="_blank" rel="external">strings-wait-notify</a></li><li>JAVA并发编程的艺术（方腾飞） 4.3.2节</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;线程通信的目标是使线程间能够互相发送信号。另一方面，线程通信使线程能够等待其他线程的信号。&lt;/p&gt;
&lt;p&gt;例如，线程B可以等待线程A的一个信号，这个信号会通知线程B数据已经准备好了。本文将讲解以下几个JAVA线程间通信的主题：&lt;/p&gt;
&lt;h3 id=&quot;通过共享对象通信&quot;&gt;&lt;a href=&quot;#通过共享对象通信&quot; class=&quot;headerlink&quot; title=&quot;通过共享对象通信&quot;&gt;&lt;/a&gt;通过共享对象通信&lt;/h3&gt;&lt;p&gt;线程间发送信号的一个简单方式是在共享对象的变量里设置信号值。线程A在一个同步块里设置boolean型成员变量hasDataToProcess为true，线程B也在同步块里读取hasDataToProcess这个成员变量。这个简单的例子使用了一个持有信号的对象，并提供了set和check方法:&lt;/p&gt;
    
    </summary>
    
      <category term="并发编程" scheme="https://caoler.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="线程通信" scheme="https://caoler.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/"/>
    
    
      <category term="并发编程" scheme="https://caoler.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="转载" scheme="https://caoler.cn/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>线程安全及其实现方法</title>
    <link href="https://caoler.cn//post/2017/thread-safety-realize.html"/>
    <id>https://caoler.cn//post/2017/thread-safety-realize.html</id>
    <published>2017-11-22T10:28:00.000Z</published>
    <updated>2017-11-27T12:39:29.112Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>线程安全：当多个对象访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方法进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那么这个对象是线程安全的。</p><h3 id="互斥同步"><a href="#互斥同步" class="headerlink" title="互斥同步"></a>互斥同步</h3><p>互斥同步是常见的一种并发正确性保障手段。<strong>同步是指多个线程并发访问共享数据时，保障数据在同一时刻只被一个（或者是一些，使用信号量的时候）线程使用。</strong> 而互斥是实现同步的一种手段，临界区、互斥量、信号量都是主要的互斥实现方式、因此在这4个字里面，互斥是因、同步是果；互斥是方法，同步是目的。</p><h4 id="synchronied关键字"><a href="#synchronied关键字" class="headerlink" title="synchronied关键字"></a>synchronied关键字</h4><a id="more"></a><p>synchronized是java中最基本的同步手段，他在经过编译之后，会在同步前后分别形成monitorenter和monitorexit这两个字节码，这两个字节码都需要一个reference类型的参数来指明要锁定和解锁的对象。<strong>如果java程序中的synchronized明确指定了对象参数，那就是这个对象的reference；如果没有明确指定，那就根据synchronized修饰的是实例还是类方法去取对应的对象实例或class对象来作为锁对象。</strong></p><p>在虚拟机规范对monitorenter和monitorexit的行为描述中有2点是特别要注意的。</p><ul><li>synchronized同步块对同一条线程来说是可重入的，不会出现自己把自己锁死的问题。</li><li>同步块在已进入的线程执行完之前，会阻塞后面其他线程的进入。</li></ul><p>java线程是映射到操作系统的原生线程之上的，如果要阻塞或者唤醒一个线程都需要操作系统来帮忙完成，这就需要从用户态转到核心态中，因此状态转换需要耗费很多的处理时间。对于代码简单的同步块（如被synchronized修饰的set和get方法），状态转换消耗的时间比用户代码执行的时间还要长，所以synchronized是java语言中一个重量级的操作。</p><h4 id="ReentrantLock重入锁"><a href="#ReentrantLock重入锁" class="headerlink" title="ReentrantLock重入锁"></a>ReentrantLock重入锁</h4><p>基本用法上重入锁和synchronized很相似，他们都具备一样的线程重入特性，只是在代码写法上有点区别，一个表现为API层面的互斥锁，另一个表现在语法层面的互斥锁。不过相比较synchronized，ReetrantLock增加了一些高级功能，主要有以下3项：等待可中断、可实现公平锁，以及锁可以绑定多个条件。</p><ul><li>等待可中断是指当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情，可中断特性对处理执行时间非常长的同步块很有帮助。</li><li>公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁；而非公平锁则不保证这一点，在锁被释放时，任何一个等待锁的线程都有机会获得锁。synchronized中的锁是非公平的，ReentrantLock默认情况下也是非公平的，但可以通过带布尔值的构造函数要求使用公平锁。</li><li>锁绑定多个条件是指一个ReentrantLock对象可以同时绑定多个Condition对象，而在synchronized中，锁对象的wait（）和notify（）或notifyAll（）方法可以实现一个隐含的条件，如果要和多于一个的条件关联的时候，就不得不额外地添加一个锁，而ReentrantLock则无需这样做，只需要多次调用newCondition()方法即可。   </li></ul><p>通过对比两种锁的吞吐量可知：<br> 1.6中加入了很多针对锁的优化措施，JDK 1.6发布之后，人们就发现synchronized与ReentrantLock的性能基本上是完全持平了。因此，如果读者的程序是使用JDK 1.6或以上部署的话，性能因素就不再是选择ReentrantLock的理由了，虚拟机在未来的性能改进中肯定也会更加偏向于原生的synchronized，所以还是提倡在synchronized能实现需求的情况下，优先考虑使用synchronized来进行同步。</p><h3 id="非阻塞同步"><a href="#非阻塞同步" class="headerlink" title="非阻塞同步"></a>非阻塞同步</h3><p>互斥同步最主要的问题就是进行线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步（Blocking Synchronization）。从处理问题的方式上说，互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施（例如加锁），那就肯定会出现问题，无论共享数据是否真的会出现竞争，它都要进行加锁（这里讨论的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁）、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。随着硬件指令集的发展，我们有了另外一个选择：基于冲突检测的乐观并发策略，通俗地说，就是先进行操作，如果没有其他线程争用共享数据，那操作就成功了；如果共享数据有争用，产生了冲突，那就再采取其他的补偿措施（最常见的补偿措施就是不断地重试，直到成功为止），这种乐观的并发策略的许多实现都不需要把线程挂起，因此这种同步操作称为非阻塞同步（Non-Blocking Synchronization）。</p><h3 id="无同步方案"><a href="#无同步方案" class="headerlink" title="无同步方案"></a>无同步方案</h3><p>要保证线程安全，并不是一定就要进行同步，两者没有因果关系。同步只是保证共享数据争用时的正确性的手段，如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性，因此会有一些代码天生就是线程安全的，笔者简单地介绍其中的两类。</p><h4 id="可重入代码（Reentrant-Code）"><a href="#可重入代码（Reentrant-Code）" class="headerlink" title="可重入代码（Reentrant Code）"></a>可重入代码（Reentrant Code）</h4><p>这种代码也叫做纯代码（Pure Code），可以在代码执行的任何时刻中断它，转而去执行另外一段代码（包括递归调用它本身），而在控制权返回后，原来的程序不会出现任何错误。相对线程安全来说，可重入性是更基本的特性，它可以保证线程安全，<strong>即所有的可重入的代码都是线程安全的，但是并非所有的线程安全的代码都是可重入的。</strong></p><p>可重入代码有一些共同的特征，例如不依赖存储在堆上的数据和公用的系统资源、用到的状态量都由参数中传入、不调用非可重入的方法等。我们可以通过一个简单的原则来判断代码是否具备可重入性：<strong>如果一个方法，它的返回结果是可以预测的，只要输入了相同的数据，就都能返回相同的结果，那它就满足可重入性的要求，当然也就是线程安全的。</strong></p><h4 id="线程本地存储（Thread-Local-Storage）"><a href="#线程本地存储（Thread-Local-Storage）" class="headerlink" title="线程本地存储（Thread Local Storage）"></a>线程本地存储（Thread Local Storage）</h4><p>如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行？如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。<br>符合这种特点的应用并不少见，大部分使用消费队列的架构模式（如“生产者-消费者”模式）都会将产品的消费过程尽量在一个线程中消费完，其中最重要的一个应用实例就是经典Web交互模型中的“一个请求对应一个服务器线程”（Thread-per-Request）的处理方式，这种处理方式的广泛应用使得很多Web服务端应用都可以使用线程本地存储来解决线程安全问题。<br>Java语言中，如果一个变量要被多线程访问，可以使用volatile关键字声明它为“易变的”；如果一个变量要被某个线程独享，Java中就没有类似C++中__declspec（thread）[3]这样的关键字，不过还是可以通过java.lang.ThreadLocal类来实现线程本地存储的功能。每一个线程的Thread对象中都有一个ThreadLocalMap对象，这个对象存储了一组以ThreadLocal.threadLocalHashCode为键，以本地线程变量为值的K-V值对，ThreadLocal对象就是当前线程的ThreadLocalMap的访问入口，每一个ThreadLocal对象都包含了一个独一无二的threadLocalHashCode值，使用这个值就可以在线程K-V值对中找回对应的本地线程变量。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>本文内容摘自周志明老师的深入理解Java虚拟机第十三章线程安全与锁优化。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;线程安全&quot;&gt;&lt;a href=&quot;#线程安全&quot; class=&quot;headerlink&quot; title=&quot;线程安全&quot;&gt;&lt;/a&gt;线程安全&lt;/h2&gt;&lt;p&gt;线程安全：当多个对象访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方法进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那么这个对象是线程安全的。&lt;/p&gt;
&lt;h3 id=&quot;互斥同步&quot;&gt;&lt;a href=&quot;#互斥同步&quot; class=&quot;headerlink&quot; title=&quot;互斥同步&quot;&gt;&lt;/a&gt;互斥同步&lt;/h3&gt;&lt;p&gt;互斥同步是常见的一种并发正确性保障手段。&lt;strong&gt;同步是指多个线程并发访问共享数据时，保障数据在同一时刻只被一个（或者是一些，使用信号量的时候）线程使用。&lt;/strong&gt; 而互斥是实现同步的一种手段，临界区、互斥量、信号量都是主要的互斥实现方式、因此在这4个字里面，互斥是因、同步是果；互斥是方法，同步是目的。&lt;/p&gt;
&lt;h4 id=&quot;synchronied关键字&quot;&gt;&lt;a href=&quot;#synchronied关键字&quot; class=&quot;headerlink&quot; title=&quot;synchronied关键字&quot;&gt;&lt;/a&gt;synchronied关键字&lt;/h4&gt;
    
    </summary>
    
      <category term="并发编程" scheme="https://caoler.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="线程安全" scheme="https://caoler.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="并发编程" scheme="https://caoler.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="转载" scheme="https://caoler.cn/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>使用WMITool解决浏览器主页被hao123劫持问题</title>
    <link href="https://caoler.cn//post/2017/wmitools.html"/>
    <id>https://caoler.cn//post/2017/wmitools.html</id>
    <published>2017-11-21T06:50:00.000Z</published>
    <updated>2017-11-27T12:40:43.002Z</updated>
    
    <content type="html"><![CDATA[<p>最近一段时间发现，无论Chrome 还是 Firefox 主页都被流氓(hao123)劫持了。</p><p>一些具体症状：</p><ul><li>删掉原先的快捷方式以后再重新创建一个，问题依然存在；</li><li>快捷方式属性没有问题，没有后缀网址；</li><li>直接启动exe文件没有异常；</li><li>chrome主页设置也没有问题，但是如果重新设置一遍主页，从快捷方式就可以正常启动chrome，但再次启动电脑又会恢复原样；</li><li>改exe文件名可解决但我不想用这种回避的方式。</li></ul><p>本人又没有安装360，电脑管家等流氓软件的习惯，于是通过Google找到了解决办法，具体如下：</p><a id="more"></a><h3 id="一、下载-WIM-Tools"><a href="#一、下载-WIM-Tools" class="headerlink" title="一、下载 WIM Tools"></a>一、下载 WIM Tools</h3><p>官网连接：<a href="https://www.adremsoft.com/wmitools/" target="_blank" rel="external">https://www.adremsoft.com/wmitools/</a> 软件体积较大(不推荐)</p><p>百度云链接: <a href="https://pan.baidu.com/s/1slJU2Rz" target="_blank" rel="external">https://pan.baidu.com/s/1slJU2Rz</a> 密码: o400</p><h3 id="二、安装完成之后按照如下操作"><a href="#二、安装完成之后按照如下操作" class="headerlink" title="二、安装完成之后按照如下操作"></a>二、安装完成之后按照如下操作</h3><p><img src="https://ws1.sinaimg.cn/large/005DnJLEgy1flpp9oiwtbj30gy0a2wep.jpg" alt=""></p><p><img src="https://ws1.sinaimg.cn/large/005DnJLEgy1flppcbyy6xj30hm09cjrk.jpg" alt=""></p><p><img src="https://ws1.sinaimg.cn/large/005DnJLEgy1flppa2i3z2j30hm09caah.jpg" alt=""></p><p><img src="https://ws1.sinaimg.cn/large/005DnJLEgy1flppa2irogj30b907k74i.jpg" alt=""></p><p><strong>在右侧选中后右击——&gt;选择view instant properties</strong></p><p><img src="https://ws1.sinaimg.cn/large/005DnJLEgy1flppa2iv4cj30ki0aswev.jpg" alt=""></p><p>至此查看ScriptText项可知，这是一段VBScript调用系统服务间隔30分钟执行一次，将所有浏览器调用加上如下糟糕链接</p><p><img src="https://ws1.sinaimg.cn/large/005DnJLEgy1flppa2j33uj30lb0c0jsn.jpg" alt=""></p><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>选中左侧选项，点击上面的X按钮。 删不掉？ 到WMITool安装路径（例如：C:\Program Files (x86)\WMI Tools）下，右键点击wbemeventviewer.exe，选择以管理员身份运行！删之！<br><img src="https://ws1.sinaimg.cn/large/005DnJLEgy1flppfl3r75j30d106cglv.jpg" alt=""><br><img src="https://ws1.sinaimg.cn/large/005DnJLEgy1flppa2iaeij30hm09c3yz.jpg" alt=""></p><p>还没完，还要手动将快速启动栏中，将各个浏览器快捷命令中的<a href="http://hk.jtsh123.com/?r=b&amp;m=10去掉！" target="_blank" rel="external">http://hk.jtsh123.com/?r=b&amp;m=10去掉！</a></p><p><img src="https://ws1.sinaimg.cn/large/005DnJLEgy1flppgo35m6j30c307n3yp.jpg" alt=""></p><p>大功告成！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近一段时间发现，无论Chrome 还是 Firefox 主页都被流氓(hao123)劫持了。&lt;/p&gt;
&lt;p&gt;一些具体症状：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;删掉原先的快捷方式以后再重新创建一个，问题依然存在；&lt;/li&gt;
&lt;li&gt;快捷方式属性没有问题，没有后缀网址；&lt;/li&gt;
&lt;li&gt;直接启动exe文件没有异常；&lt;/li&gt;
&lt;li&gt;chrome主页设置也没有问题，但是如果重新设置一遍主页，从快捷方式就可以正常启动chrome，但再次启动电脑又会恢复原样；&lt;/li&gt;
&lt;li&gt;改exe文件名可解决但我不想用这种回避的方式。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本人又没有安装360，电脑管家等流氓软件的习惯，于是通过Google找到了解决办法，具体如下：&lt;/p&gt;
    
    </summary>
    
      <category term="实用教程" scheme="https://caoler.cn/categories/%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B/"/>
    
      <category term="浏览器" scheme="https://caoler.cn/categories/%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
      <category term="原创" scheme="https://caoler.cn/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="实用教程" scheme="https://caoler.cn/tags/%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
</feed>
