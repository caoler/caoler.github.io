<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[join()方法和TheadLocal类]]></title>
    <url>%2F%2Fpost%2F2017%2Fjoin()%E6%96%B9%E6%B3%95%E5%92%8CTheadLocal%E7%B1%BB.html</url>
    <content type="text"><![CDATA[Thread.join()使用方式123Thread t = new AThread();t.start();t.join(); 为什么要用join()方法在很多情况下，主线程生成并起动了子线程，如果子线程里要进行大量的耗时的运算，主线程往往将于子线程之前结束，但是如果主线程处理完其他的事务后，需要用到子线程的处理结果，也就是主线程需要等待子线程执行完成之后再结束，这个时候就要用到join()方法了。 join方法的作用JDK中对join方法解释为：“等待该线程终止”，换句话说就是：”当前线程等待子线程的终止“。也就是在子线程调用了join()方法后面的代码，只有等到子线程结束了当前线程才能执行。 用实例来理解 简单了解join()的用法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class BThread extends Thread &#123; public BThread() &#123; super("[BThread] Thread"); &#125;; public void run() &#123; String threadName = Thread.currentThread().getName(); System.out.println(threadName + " start."); try &#123; for (int i = 0; i &lt; 5; i++) &#123; System.out.println(threadName + " loop at " + i); Thread.sleep(1000); &#125; System.out.println(threadName + " end."); &#125; catch (Exception e) &#123; System.out.println("Exception from " + threadName + ".run"); &#125; &#125; &#125; public class AThread extends Thread &#123; BThread bt; public AThread(BThread bt) &#123; super("[AThread] Thread"); this.bt = bt; &#125; public void run() &#123; String threadName = Thread.currentThread().getName(); System.out.println(threadName + " start."); try &#123; bt.join(); System.out.println(threadName + " end."); &#125; catch (Exception e) &#123; System.out.println("Exception from " + threadName + ".run"); &#125; &#125; &#125; public class TestDemo &#123; public static void main(String[] args) &#123; String threadName = Thread.currentThread().getName(); System.out.println(threadName + " start."); BThread bt = new BThread(); AThread at = new AThread(bt); try &#123; bt.start(); Thread.sleep(2000); at.start(); at.join(); &#125; catch (Exception e) &#123; System.out.println("Exception from main"); &#125; System.out.println(threadName + " end!"); &#125; &#125; 运行结果： 1234567891011main start. -- 主线程启动, 因为主线程中调用了at.join(), 所以主线程要等到 AThread线程结束之后才能执行 [BThread] Thread start. [BThread] Thread loop at 0 [BThread] Thread loop at 1 [AThread] Thread start. -- AThread线程启动, 因为AThread线程中调用了bt.join(), 所以AThread线程要等到BThread线程结束之后才能执行 [BThread] Thread loop at 2 [BThread] Thread loop at 3 [BThread] Thread loop at 4 [BThread] Thread end. -- BThread线程结束了, AThread线程执行 [AThread] Thread end. -- AThread线程结束了, 主线程执行 main end! 深入的了解join()的用法： 网上有很多人是这样解释 join()的用法的：”主线程等待子线程的终止“ ，相信有很多人都会这么说，但是这个说法是完全错误的，为什么呢？请看例子，在上边代码的基础上，我们对TestDemo类做一下改动： 123456789101112131415161718public class TestDemo &#123; public static void main(String[] args) &#123; String threadName = Thread.currentThread().getName(); System.out.println(threadName + " start."); BThread bt = new BThread(); AThread at = new AThread(bt); try &#123; bt.start(); Thread.sleep(2000); at.start(); // at.join(); //这里注释掉 &#125; catch (Exception e) &#123; System.out.println("Exception from main"); &#125; System.out.println(threadName + " end!"); &#125; &#125; 运行结果： 1234567891011main start. -- 主线程启动 [BThread] Thread start. -- BThread线程启动 [BThread] Thread loop at 0 [BThread] Thread loop at 1 main end! -- 主线程结束，（也就是说AThread线程中调用了bt.join()并不会影响到主线程） [AThread] Thread start. -- AThread线程启动, 因为AThread线程中调用了bt.join(), 所以AThread线程要等到BThread线程结束之后才能执行 [BThread] Thread loop at 2 [BThread] Thread loop at 3 [BThread] Thread loop at 4 [BThread] Thread end. -- BThread线程结束了, AThread线程执行 [AThread] Thread end. 相信聪明的读者已经猜到为什么说 ”主线程等待子线程的终止 “ 的错误原因了吧，正确的说法应该是：”当前线程等待子线程的终止“ 从源码看join()方法在AThread的run方法里，执行了bt.join();，进入看一下它的JDK源码： 123public final void join() throws InterruptedException &#123; join(0L);&#125; 然后进入join(0L)方法：12345678910111213141516171819202122232425public final synchronized void join(long millis)throws InterruptedException &#123; long base = System.currentTimeMillis(); long now = 0; if (millis &lt; 0) &#123; throw new IllegalArgumentException("timeout value is negative"); &#125; if (millis == 0) &#123; // 如果线程被生成了，但还未被起动，isAlive()将返回false，调用它的join()方法是没有作用的，将直接继续向下执行。 while (isAlive()) &#123; wait(0); &#125; &#125; else &#123; while (isAlive()) &#123; long delay = millis - now; if (delay &lt;= 0) &#123; break; &#125; wait(delay); now = System.currentTimeMillis() - base; &#125; &#125;&#125; 单纯从代码上看：在AThread类中的run方法中，bt.join()是判断bt的active状态，如果bt的isActive()方法返回false，在bt.join(),这一点就不用等待BThread线程结束，AThread就可以继续向下进行。 isAlive()方法的签名是：public final native boolean isAlive()，也就是说isAlive()是判断当前线程的状态。 TheadLocalJava中的ThreadLocal类可以让你创建的变量只被同一个线程进行读和写操作。因此，尽管有两个线程同时执行一段相同的代码，而且这段代码又有一个指向同一个ThreadLocal变量的引用，但是这两个线程依然不能看到彼此的ThreadLocal变量域。 创建一个ThreadLocal对象如下所示，创建一个ThreadLocal变量：1private ThreadLocal myThreadLocal = new ThreadLocal(); 你实例化了一个ThreadLocal对象。每个线程仅需要实例化一次即可。虽然不同的线程执行同一段代码时，访问同一个ThreadLocal变量，但是每个线程只能看到私有的ThreadLocal实例。所以不同的线程在给ThreadLocal对象设置不同的值时，他们也不能看到彼此的修改。 访问ThreadLocal对象一旦创建了一个ThreadLocal对象，你就可以通过以下方式来存储此对象的值：1myThreadLocal.set("A thread local value"); 也可以直接读取一个ThreadLocal对象的值：1String threadLocalValue = (String) myThreadLocal.get(); get()方法会返回一个Object对象，而set()方法则依赖一个Object对象参数。 ThreadLocal泛型为了使get()方法返回值不用做强制类型转换，通常可以创建一个泛型化的ThreadLocal对象。以下就是一个泛型化的ThreadLocal示例：1private ThreadLocal myThreadLocal1 = new ThreadLocal&lt;String&gt;(); 现在你可以存储一个字符串到ThreadLocal实例里，此外，当你从此ThreadLocal实例中获取值的时候，就不必要做强制类型转换。123myThreadLocal1.set("Hello ThreadLocal");String threadLocalValues = myThreadLocal.get(); 初始化ThreadLocal由于ThreadLocal对象的set()方法设置的值只对当前线程可见，那有什么方法可以为ThreadLocal对象设置的值对所有线程都可见。 为此，我们可以通过ThreadLocal子类的实现，并覆写initialValue()方法，就可以为ThreadLocal对象指定一个初始化值。如下所示:12345private ThreadLocal myThreadLocal = new ThreadLocal&lt;String&gt;() &#123; @Override protected String initialValue() &#123; return "This is the initial value"; &#125;&#125;; 此时，在set()方法调用前，当调用get()方法的时候，所有线程都可以看到同一个初始化值。 Full ThreadLocal Example以下是一个完整的ThreadLocal示例：123456789101112131415161718192021222324252627282930313233package cn.caoler.ThreadTest2;/** * Author: Caole * CreateDateTime: 2017/11/27 13:21 * Description: */public class ThreadLocalExample &#123; public static class MyRunnable implements Runnable &#123; private ThreadLocal&lt;Integer&gt; threadLocal = new ThreadLocal&lt;Integer&gt;(); @Override public void run() &#123; threadLocal.set( (int) (Math.random() * 100D) ); try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; &#125; System.out.println(threadLocal.get()); &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; MyRunnable sharedRunnableInstance = new MyRunnable(); Thread thread1 = new Thread(sharedRunnableInstance); Thread thread2 = new Thread(sharedRunnableInstance); thread1.start(); thread2.start(); thread1.join(); //wait for thread 1 to terminate thread2.join(); //wait for thread 2 to terminate &#125;&#125; 上面创建了两个线程共享一个MyRunnable实例。每个线程执行run()方法的时候，会给同一个ThreadLocal实例设置不同的值。如果调用set()方法的时候用synchronized关键字同步，而不是ThreadLocal对象的实例，那么第二个线程将会覆盖第一个线程所设置的值。 然而，由于是ThreadLocal对象，所以两个线程无法看到彼此的值。因此，可以设置或者获取不同的值。 InheritableThreadLocalInheritableThreadLocal类是ThreadLocal的子类。为了解决ThreadLocal实例内部每个线程都只能看到自己的私有值，所以InheritableThreadLocal允许一个线程创建的所有子线程访问其父线程的值。 参考 CSDN:Java Thread.join详解 并发编程网：《Java并发性和多线程介绍》-Java TheadLocal]]></content>
      <categories>
        <category>并发编程</category>
        <category>线程通信</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
        <tag>转载</tag>
        <tag>线程通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[死锁以及如何避免死锁]]></title>
    <url>%2F%2Fpost%2F2017%2F%E6%AD%BB%E9%94%81%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81.html</url>
    <content type="text"><![CDATA[死锁锁是两个或更多线程阻塞着等待其它处于死锁状态的线程所持有的锁。死锁通常发生在多个线程同时但以不同的顺序请求同一组锁的时候。 例如，如果线程1锁住了A，然后尝试对B进行加锁，同时线程2已经锁住了B，接着尝试对A进行加锁，这时死锁就发生了。线程1永远得不到B，线程2也永远得不到A，并且它们永远也不会知道发生了这样的事情。为了得到彼此的对象（A和B），它们将永远阻塞下去。这种情况就是一个死锁。 该情况如下： Thread 1 locks A, waits for BThread 2 locks B, waits for A 示例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package cn.caoler.DeadLockDemo;/** * Author: Caole * CreateDateTime: 2017/11/23 11:56 * Description: */public class DeadLockDemo &#123; private static String A = "A"; private static String B = "B"; public static void main(String[] args) &#123; new DeadLockDemo().deadLock(); &#125; private void deadLock() &#123; Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; synchronized(A)&#123; try &#123; Thread.currentThread().sleep(20); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized(B)&#123; System.out.println("1"); &#125; &#125; &#125; &#125;); Thread t2 = new Thread(new Runnable() &#123; @Override public void run() &#123; synchronized(B)&#123; synchronized(A)&#123; System.out.println("2"); &#125; &#125; &#125; &#125;); t1.start(); t2.start(); &#125;&#125; 避免死锁常见方法有如下几个： 避免一个线程同时获取多个锁。 避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源。 尝试使用定时锁，使用lock.tryLock(timeout)来代替使用内部锁机制。 对于数据库锁，加锁和解锁必须在同一个数据库连接里，否则会出现解锁异常的情况。 具体解释详见并发编程网-避免死锁]]></content>
      <categories>
        <category>并发编程</category>
        <category>锁</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
        <tag>转载</tag>
        <tag>死锁</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于SSR的科学上网教程(置顶至12月1日)]]></title>
    <url>%2F%2Fpost%2F2017%2F%E5%9F%BA%E4%BA%8ESSR%E7%9A%84%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B.html</url>
    <content type="text"><![CDATA[PC客户端下载链接: https://pan.baidu.com/s/1dFzus4h 密码: bfrd 添加服务器将压缩包内文件解压到一个固定位置会后，选择ShadowsocksR-dotnet4.0.exe 打开客户端。 这时候，右下角托盘图标会出现一个纸飞机，然后右键 纸飞机 图标，弹出菜单并选择 服务器 —— 编辑服务器。 然后就会出现 编辑服务器的窗口，默认是有一个节点配置示例的，你可以 直接改 或者 删掉 新添加一个服务器。 然后就是填写Shadowsocks账号信息。 依次填写 服务器 IP、服务器端口、密码、加密方式，如果你的账号是原版Shadowsocks，那么写到这里就行了。 注意：协议 : auth_sha1_v4_compatible客户端中选择：auth_sha1_v4混淆 : tls1.2_ticket_auth_compatible客户端中选择：tls1.2_ticket_auth 如果你的账号是ShadowsocksR账号，那么根据ShadowsocksR账号信息，选择对应的协议和混淆（origin/plain是原版SS的意思） 根据需要，你可以填写 备注 和 Group（分组） ，具体效果自己试一下就知道了。 密码前面的 选择框 是明文显示密码的意思。 然后一些人会问为什么右边显示二维码的地方老是显示一个图片却不显示二维码？ 实际上主要是很多人截图不知道打码，暴露了自己的Shadowsocks账号所有信息，所以默认都是不显示二维码的，只要点击 下图蓝条选中的SSR链接输入框，就会显示二维码了。 而SSR链接前面的 选择框 ，勾选代表是显示SSR的二维码，不勾选则显示SS的二维码。 填写完毕后，点击 确定 按钮，继续下一步。 选择服务器右键 纸飞机 图标，出现菜单并选择 服务器 —— 分组(empty group) —— 要使用的Shadowsocks账号。(如果没有设置分组，直接选择要连接的服务器即可) 右键 纸飞机 图标弹出菜单并选择系统代理模式 —— PAC模式 代理规则选 用户自定义 目前ShadowsocksR客户端的国内外分流规则分两种，PAC规则（系统代理模式） 和 代理规则PAC规则 是根据PAC文件中的黑白地址名单来判断那些网站走代理，也就是判断 流量数据是进入SSR客户端还是直连。代理规则 是根据IP判断，分 绕过局域网/绕过局域网和大陆/绕过局域网和非大陆 ，用于判断 进入SSR客户端的数据流量是走代理还是直连。 至此，PC端设置完毕。点击试试看：https://www.google.com 附加设置右键选择选项设置 选择开机自启，设置开机自启后，只要电脑一开机就可以直接访问google了 iOS客户端下载 方式一：登录美区AppStore，购买并下载shadowrocket（18RMB） 方式二：使用电脑下载PP助手并安装，官网：https://pro.25pp.com/ 连接手机之后搜索shadowrocket并安装 使用打开shadowrocket，点击右上角加号 类型选择shadowrocksR 输入账号密码，以及混淆参数等等。 注意：协议 : auth_sha1_v4_compatible客户端中选择：auth_sha1_v4混淆 : tls1.2_ticket_auth_compatible客户端中选择：tls1.2_ticket_auth 在首页全局路由处选择配置 点击连接即可。 至此iOS端设置完毕，点击试试：https://www.google.com 安卓客户端下载链接: https://pan.baidu.com/s/1i5vi3tz 密码: 9y9t 使用安装之后配置你的服务器信息，远程端口为我给你的端口，本地端口为默认1080 注意：协议 : auth_sha1_v4_compatible客户端中选择：auth_sha1_v4混淆 : tls1.2_ticket_auth_compatible客户端中选择：tls1.2_ticket_auth 路由处选择如图所示绕过局域网和大陆，如果不能上网，再设置为全局 当处于全局状态时，手机消耗的所有数据将使用那50G流量，也可切换为仅代理为中国大陆无法访问的网址 点击右上角小飞机，同意连接之后，即可成功FQ 至此，安卓客户端设置完毕，点击试试：https://www.google.com 说明设置切记按照文章中所说的一步一步操作，尤其是PC端的选择PAC，iOS端的配置，还有安卓客户端的路由选项]]></content>
      <categories>
        <category>实用教程</category>
        <category>科学上网</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>科学上网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程通信]]></title>
    <url>%2F%2Fpost%2F2017%2F%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1.html</url>
    <content type="text"><![CDATA[概述线程通信的目标是使线程间能够互相发送信号。另一方面，线程通信使线程能够等待其他线程的信号。 例如，线程B可以等待线程A的一个信号，这个信号会通知线程B数据已经准备好了。本文将讲解以下几个JAVA线程间通信的主题： 通过共享对象通信线程间发送信号的一个简单方式是在共享对象的变量里设置信号值。线程A在一个同步块里设置boolean型成员变量hasDataToProcess为true，线程B也在同步块里读取hasDataToProcess这个成员变量。这个简单的例子使用了一个持有信号的对象，并提供了set和check方法: 12345678910111213public class MySignal&#123; protected boolean hasDataToProcess = false; public synchronized boolean hasDataToProcess()&#123; return this.hasDataToProcess; &#125; public synchronized void setHasDataToProcess(boolean hasData)&#123; this.hasDataToProcess = hasData; &#125;&#125; 线程A和B必须获得指向一个MySignal共享实例的引用，以便进行通信。如果它们持有的引用指向不同的MySingal实例，那么彼此将不能检测到对方的信号。需要处理的数据可以存放在一个共享缓存区里，它和MySignal实例是分开存放的。 忙等待准备处理数据的线程B正在等待数据变为可用。换句话说，它在等待线程A的一个信号，这个信号使hasDataToProcess()返回true。线程B运行在一个循环里，以等待这个信号： 1234567protected MySignal sharedSignal = ......while(!sharedSignal.hasDataToProcess())&#123; //do nothing... busy waiting&#125; wait(),notify()和notifyAll()忙等待没有对运行等待线程的CPU进行有效的利用，除非平均等待时间非常短。否则，让等待线程进入睡眠或者非运行状态更为明智，直到它接收到它等待的信号。 Java有一个内建的等待机制来允许线程在等待信号的时候变为非运行状态。java.lang.Object 类定义了三个方法，wait()、notify()和notifyAll()来实现这个等待机制。 一个线程一旦调用了任意对象的wait()方法，就会变为非运行状态，直到另一个线程调用了同一个对象 的notify()方法。为了调用wait()或者notify()，线程必须先获得那个对象的锁。也就是说，线程必须在同步块里调用wait()或者notify()。以下是MySingal的修改版本——使用了wait()和notify()的MyWaitNotify： 123456789101112131415161718192021public class MonitorObject&#123;&#125;public class MyWaitNotify&#123; MonitorObject myMonitorObject = new MonitorObject(); public void doWait()&#123; synchronized(myMonitorObject)&#123; try&#123; myMonitorObject.wait(); &#125; catch(InterruptedException e)&#123;...&#125; &#125; &#125; public void doNotify()&#123; synchronized(myMonitorObject)&#123; myMonitorObject.notify(); &#125; &#125;&#125; 等待线程将调用doWait()，而唤醒线程将调用doNotify()。当一个线程调用一个对象的notify()方法，正在等待该对象的所有线程中将有一个线程被唤醒并允许执行 （校注：这个将被唤醒的线程是随机的，不可以指定唤醒哪个线程）。 同时也提供了一个notifyAll()方法来唤醒正在等待一个给定对象的所有线程。 如你所见，不管是等待线程还是唤醒线程都在同步块里调用wait()和notify()。这是强制性的！一个线程如果没有持有对象锁，将不能调用wait()，notify()或者notifyAll()。 否则，会抛出IllegalMonitorStateException异常。 （校注：JVM是这么实现的，当你调用wait时候它首先要检查下当前线程是否是锁的拥有者，不是则抛出IllegalMonitorStateExcept，参考JVM源码的 1422行。） 但是，这怎么可能？等待线程在同步块里面执行的时候，不是一直持有监视器对象（myMonitor对象）的锁吗？等待线程不能阻塞唤醒线程进入doNotify()的同步块吗？答案是：的确不能。一旦线程调用了wait()方法，它就释放了所持有的监视器对象上的锁。这将允许其他线程也可以调用wait()或者notify()。 一旦一个线程被唤醒，不能立刻就退出wait()的方法调用，直到调用notify()的线程退出了它自己的同步块。换句话说：被唤醒的线程必须重新获得监视器对象的锁，才可以退出wait()的方法调用，因为wait方法调用运行在同步块里面。如果多个线程被notifyAll()唤醒，那么在同一时刻将只有一个线程可以退出wait()方法，因为每个线程在退出wait()前必须获得监视器对象的锁。 丢失的信号notify()和notifyAll()方法不会保存调用它们的方法，因为当这两个方法被调用时，有可能没有线程处于等待状态。通知信号过后便丢弃了。因此，如果一个线程先于被通知线程调用wait()前调用了notify()，等待的线程将错过这个信号。这可能是也可能不是个问题。不过，在某些情况下，这可能使等待线程永远在等待，不再醒来，因为线程错过了唤醒信号。 为了避免丢失信号，必须把它们保存在信号类里。在MyWaitNotify的例子中，通知信号应被存储在MyWaitNotify实例的一个成员变量里。以下是MyWaitNotify的修改版本：123456789101112131415161718192021222324public class MyWaitNotify2&#123; MonitorObject myMonitorObject = new MonitorObject(); boolean wasSignalled = false; public void doWait()&#123; synchronized(myMonitorObject)&#123; if(!wasSignalled)&#123; try&#123; myMonitorObject.wait(); &#125; catch(InterruptedException e)&#123;...&#125; &#125; //clear signal and continue running. wasSignalled = false; &#125; &#125; public void doNotify()&#123; synchronized(myMonitorObject)&#123; wasSignalled = true; myMonitorObject.notify(); &#125; &#125;&#125; 留意doNotify()方法在调用notify()前把wasSignalled变量设为true。同时，留意doWait()方法在调用wait()前会检查wasSignalled变量。事实上，如果没有信号在前一次doWait()调用和这次doWait()调用之间的时间段里被接收到，它将只调用wait()。 （校注：为了避免信号丢失， 用一个变量来保存是否被通知过。在notify前，设置自己已经被通知过。在wait后，设置自己没有被通知过，需要等待通知。） 自己的理解，wasSignalled标注的功能就是限制Wait和Notify的顺序 假唤醒由于莫名其妙的原因，线程有可能在没有调用过notify()和notifyAll()的情况下醒来。这就是所谓的假唤醒（spurious wakeups）。无端端地醒过来了。 如果在MyWaitNotify2的doWait()方法里发生了假唤醒，等待线程即使没有收到正确的信号，也能够执行后续的操作。这可能导致你的应用程序出现严重问题。 为了防止假唤醒，保存信号的成员变量将在一个while循环里接受检查，而不是在if表达式里。这样的一个while循环叫做自旋锁 （校注：这种做法要慎重，目前的JVM实现自旋会消耗CPU，如果长时间不调用doNotify方法，doWait方法会一直自旋，CPU会消耗太大）。 被唤醒的线程会自旋直到自旋锁(while循环)里的条件变为false。以下MyWaitNotify2的修改版本展示了这点：123456789101112131415161718192021222324public class MyWaitNotify3&#123; MonitorObject myMonitorObject = new MonitorObject(); boolean wasSignalled = false; public void doWait()&#123; synchronized(myMonitorObject)&#123; while(!wasSignalled)&#123; try&#123; myMonitorObject.wait(); &#125; catch(InterruptedException e)&#123;...&#125; &#125; //clear signal and continue running. wasSignalled = false; &#125; &#125; public void doNotify()&#123; synchronized(myMonitorObject)&#123; wasSignalled = true; myMonitorObject.notify(); &#125; &#125;&#125; 留意wait()方法是在while循环里，而不在if表达式里。如果等待线程没有收到信号就唤醒，wasSignalled变量将变为false,while循环会再执行一次，促使醒来的线程回到等待状态。 多线程等待相同信号如果你有多个线程在等待，被notifyAll()唤醒，但只有一个被允许继续执行，使用while循环也是个好方法。每次只有一个线程可以获得监视器对象锁，意味着只有一个线程可以退出wait()调用并清除wasSignalled标志（设为false）。一旦这个线程退出doWait()的同步块，其他线程退出wait()调用，并在while循环里检查wasSignalled变量值。但是，这个标志已经被第一个唤醒的线程清除了，所以其余醒来的线程将回到等待状态，直到下次信号到来。 不要对常量字符串或全局对象调用wait()（校注：本章说的字符串常量指的是值为常量的变量） 本文早期的一个版本在MyWaitNotify例子里使用字符串常量（””）作为管程对象。以下是那个例子：123456789101112131415161718192021222324public class MyWaitNotify3&#123; String myMonitorObject = ""; boolean wasSignalled = false; public void doWait()&#123; synchronized(myMonitorObject)&#123; while(!wasSignalled)&#123; try&#123; myMonitorObject.wait(); &#125; catch(InterruptedException e)&#123;...&#125; &#125; //clear signal and continue running. wasSignalled = false; &#125; &#125; public void doNotify()&#123; synchronized(myMonitorObject)&#123; wasSignalled = true; myMonitorObject.notify(); &#125; &#125;&#125; 在空字符串作为锁的同步块(或者其他常量字符串)里调用wait()和notify()产生的问题是，JVM/编译器内部会把常量字符串转换成同一个对象。这意味着，即使你有2个不同的MyWaitNotify实例，它们都引用了相同的空字符串实例。同时也意味着存在这样的风险：在第一个MyWaitNotify实例上调用doWait()的线程会被在第二个MyWaitNotify实例上调用doNotify()的线程唤醒。这种情况可以画成以下这张图： 等待/通知机制 总结相关方法 方法名称 描述 notify() 通知一个在对象上等待的线程，由WAITING状态变为BLOCKING状态，从等待队列移动到同步队列，等待CPU调度获取该对象的锁，当该线程获取到了对象的锁后，该线程从wait()方法返回 notifyAll() 通知所有等待在该对象上的线程，由WAITING状态变为BLOCKING状态，等待CPU调度获取该对象的锁 wait() 调用该方法的线程进入WAITING状态，并将当前线程放置到对象的等待队列，只有等待另外线程的通知或被中断才会返回，需要注意，调用wait()方法后，会释放对象的锁 wait(long) 超时等待一段时间，这里的参数时间是毫秒，也就是等待长达n毫秒，如果没有通知就超时返回 wait(long，int) 对于超时时间更细力度的控制，可以达到纳秒 代码清单如下代码本人觉得更加清晰123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package cn.caoler.WaitNotify;import java.text.SimpleDateFormat;import java.util.Date;import java.util.concurrent.TimeUnit;/** * Author: Caole * CreateDateTime: 2017/11/23 12:43 * Description: */public class WaitNotify &#123; static boolean flag = true; static Object lock = new Object(); public static void main(String[] args) throws InterruptedException &#123; Thread waitThread = new Thread(new Wait(), "WaitThread"); waitThread.start(); TimeUnit.SECONDS.sleep(1); Thread notifyThread = new Thread(new Notify(), "NotifyThread"); notifyThread.start(); &#125; static class Wait implements Runnable &#123; @Override public void run() &#123; //加锁，拥有lock的Monitor synchronized(lock)&#123; //当条件不满足时继续wait，同时释放了lock的锁 while (flag)&#123; try &#123; System.out.println(Thread.currentThread() + "flag is true .wait@" + new SimpleDateFormat("HH:mm:ss").format(new Date())); lock.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; //条件满足时，完成工作 System.out.println(Thread.currentThread() + "flag is false .running@" + new SimpleDateFormat("HH:mm:ss").format(new Date())); &#125; &#125; &#125; static class Notify implements Runnable&#123; @Override public void run() &#123; //加锁，拥有lock的Monitor synchronized(lock)&#123; //获取lock的锁，然后进行通知，通知时不会释放lock的锁 //直到当前线程释放了lock锁之后，WaitThread才能从wait方法中返回 System.out.println(Thread.currentThread() + "hold lock .notify @" + new SimpleDateFormat("HH:mm:ss").format(new Date())); lock.notifyAll(); flag = false; SleepUtils.second(5); &#125; //再次加锁 synchronized(lock)&#123; System.out.println(Thread.currentThread() + "hold lock again .sleep @" + new SimpleDateFormat("HH:mm:ss").format(new Date())); SleepUtils.second(5); &#125; &#125; &#125;&#125; 输出如下： 1234Thread[WaitThread,5,main]flag is true .wait@15:54:24Thread[NotifyThread,5,main]hold lock .notify @15:54:24Thread[NotifyThread,5,main]hold lock again .sleep @15:54:30Thread[WaitThread,5,main]flag is false .running@15:54:35 使用wait/notify注意事项和问题 执行完wait后会释放锁， 在执行notify()方法后，当前线程不会立刻释放该对象锁。呈wait状态的线程并不能马上获取该对象锁，要等执行notify()方法的线程将程序执行完，也就是退出synchronized代码块后，当前线程才会释放锁。 在调用wait()或notify()方法之前，必须获得该对象的对象级别锁，即只能在同步方法或者同步块中调用wait()方法，在执行wait()方法之后，当前线程释放锁。 在调用notify通知某线程后，该线程不会立即进入Running状态，而是先进入Runnable状态。 notify每次仅通知一个线程，多次调用可将wait线程全部唤醒。 当线程呈wait状态时，调用线程对象的interrupt方法会抛出InterruptedException异常。 通知过早: 如果通知过早，会打乱程序正常运行逻辑。 等待/通知的经典范式从前断示例中可以提炼出等待/通知经典范式，该范式分为两部分，分别为等待方(消费者)和通知方（生产者）。 等待方遵循如下原则。 获取对象的锁 如果条件不满足，那么调用对象的wait()方法，被通知后仍要检查条件。 条件满足则执行对应的逻辑。 对应的伪代码如下 123456synchronized(对象)&#123; while(不满足)&#123; 对象.wait(); &#125; 对应的处理逻辑&#125; 通知方遵循如下原则 获得对象的锁 改变条件 通知所有等待在对象上的线程 对应的伪代码如下： 1234synchronized(对象)&#123; 改变条件 对象.notifyAll();&#125; 参考 自并发编程网 – ifeve.com本文链接地址: strings-wait-notify JAVA并发编程的艺术（方腾飞） 4.3.2节]]></content>
      <categories>
        <category>并发编程</category>
        <category>线程通信</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程安全及其实现方法]]></title>
    <url>%2F%2Fpost%2F2017%2F%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95.html</url>
    <content type="text"><![CDATA[线程安全线程安全：当多个对象访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方法进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那么这个对象是线程安全的。 互斥同步互斥同步是常见的一种并发正确性保障手段。同步是指多个线程并发访问共享数据时，保障数据在同一时刻只被一个（或者是一些，使用信号量的时候）线程使用。 而互斥是实现同步的一种手段，临界区、互斥量、信号量都是主要的互斥实现方式、因此在这4个字里面，互斥是因、同步是果；互斥是方法，同步是目的。 synchronied关键字 synchronized是java中最基本的同步手段，他在经过编译之后，会在同步前后分别形成monitorenter和monitorexit这两个字节码，这两个字节码都需要一个reference类型的参数来指明要锁定和解锁的对象。如果java程序中的synchronized明确指定了对象参数，那就是这个对象的reference；如果没有明确指定，那就根据synchronized修饰的是实例还是类方法去取对应的对象实例或class对象来作为锁对象。 在虚拟机规范对monitorenter和monitorexit的行为描述中有2点是特别要注意的。 synchronized同步块对同一条线程来说是可重入的，不会出现自己把自己锁死的问题。 同步块在已进入的线程执行完之前，会阻塞后面其他线程的进入。 java线程是映射到操作系统的原生线程之上的，如果要阻塞或者唤醒一个线程都需要操作系统来帮忙完成，这就需要从用户态转到核心态中，因此状态转换需要耗费很多的处理时间。对于代码简单的同步块（如被synchronized修饰的set和get方法），状态转换消耗的时间比用户代码执行的时间还要长，所以synchronized是java语言中一个重量级的操作。 ReentrantLock重入锁基本用法上重入锁和synchronized很相似，他们都具备一样的线程重入特性，只是在代码写法上有点区别，一个表现为API层面的互斥锁，另一个表现在语法层面的互斥锁。不过相比较synchronized，ReetrantLock增加了一些高级功能，主要有以下3项：等待可中断、可实现公平锁，以及锁可以绑定多个条件。 等待可中断是指当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情，可中断特性对处理执行时间非常长的同步块很有帮助。 公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁；而非公平锁则不保证这一点，在锁被释放时，任何一个等待锁的线程都有机会获得锁。synchronized中的锁是非公平的，ReentrantLock默认情况下也是非公平的，但可以通过带布尔值的构造函数要求使用公平锁。 锁绑定多个条件是指一个ReentrantLock对象可以同时绑定多个Condition对象，而在synchronized中，锁对象的wait（）和notify（）或notifyAll（）方法可以实现一个隐含的条件，如果要和多于一个的条件关联的时候，就不得不额外地添加一个锁，而ReentrantLock则无需这样做，只需要多次调用newCondition()方法即可。 通过对比两种锁的吞吐量可知： 1.6中加入了很多针对锁的优化措施，JDK 1.6发布之后，人们就发现synchronized与ReentrantLock的性能基本上是完全持平了。因此，如果读者的程序是使用JDK 1.6或以上部署的话，性能因素就不再是选择ReentrantLock的理由了，虚拟机在未来的性能改进中肯定也会更加偏向于原生的synchronized，所以还是提倡在synchronized能实现需求的情况下，优先考虑使用synchronized来进行同步。 非阻塞同步互斥同步最主要的问题就是进行线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步（Blocking Synchronization）。从处理问题的方式上说，互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施（例如加锁），那就肯定会出现问题，无论共享数据是否真的会出现竞争，它都要进行加锁（这里讨论的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁）、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。随着硬件指令集的发展，我们有了另外一个选择：基于冲突检测的乐观并发策略，通俗地说，就是先进行操作，如果没有其他线程争用共享数据，那操作就成功了；如果共享数据有争用，产生了冲突，那就再采取其他的补偿措施（最常见的补偿措施就是不断地重试，直到成功为止），这种乐观的并发策略的许多实现都不需要把线程挂起，因此这种同步操作称为非阻塞同步（Non-Blocking Synchronization）。 无同步方案要保证线程安全，并不是一定就要进行同步，两者没有因果关系。同步只是保证共享数据争用时的正确性的手段，如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性，因此会有一些代码天生就是线程安全的，笔者简单地介绍其中的两类。 可重入代码（Reentrant Code）这种代码也叫做纯代码（Pure Code），可以在代码执行的任何时刻中断它，转而去执行另外一段代码（包括递归调用它本身），而在控制权返回后，原来的程序不会出现任何错误。相对线程安全来说，可重入性是更基本的特性，它可以保证线程安全，即所有的可重入的代码都是线程安全的，但是并非所有的线程安全的代码都是可重入的。 可重入代码有一些共同的特征，例如不依赖存储在堆上的数据和公用的系统资源、用到的状态量都由参数中传入、不调用非可重入的方法等。我们可以通过一个简单的原则来判断代码是否具备可重入性：如果一个方法，它的返回结果是可以预测的，只要输入了相同的数据，就都能返回相同的结果，那它就满足可重入性的要求，当然也就是线程安全的。 线程本地存储（Thread Local Storage）如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行？如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。符合这种特点的应用并不少见，大部分使用消费队列的架构模式（如“生产者-消费者”模式）都会将产品的消费过程尽量在一个线程中消费完，其中最重要的一个应用实例就是经典Web交互模型中的“一个请求对应一个服务器线程”（Thread-per-Request）的处理方式，这种处理方式的广泛应用使得很多Web服务端应用都可以使用线程本地存储来解决线程安全问题。Java语言中，如果一个变量要被多线程访问，可以使用volatile关键字声明它为“易变的”；如果一个变量要被某个线程独享，Java中就没有类似C++中__declspec（thread）[3]这样的关键字，不过还是可以通过java.lang.ThreadLocal类来实现线程本地存储的功能。每一个线程的Thread对象中都有一个ThreadLocalMap对象，这个对象存储了一组以ThreadLocal.threadLocalHashCode为键，以本地线程变量为值的K-V值对，ThreadLocal对象就是当前线程的ThreadLocalMap的访问入口，每一个ThreadLocal对象都包含了一个独一无二的threadLocalHashCode值，使用这个值就可以在线程K-V值对中找回对应的本地线程变量。 参考本文内容摘自周志明老师的深入理解Java虚拟机第十三章线程安全与锁优化。]]></content>
      <categories>
        <category>并发编程</category>
        <category>线程安全</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用WMITool解决浏览器主页被hao123劫持问题]]></title>
    <url>%2F%2Fpost%2F2017%2F%E4%BD%BF%E7%94%A8WMITool%E8%A7%A3%E5%86%B3%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%BB%E9%A1%B5%E8%A2%ABhao123%E5%8A%AB%E6%8C%81%E9%97%AE%E9%A2%98.html</url>
    <content type="text"><![CDATA[最近一段时间发现，无论Chrome 还是 Firefox 主页都被流氓(hao123)劫持了。 一些具体症状： 删掉原先的快捷方式以后再重新创建一个，问题依然存在； 快捷方式属性没有问题，没有后缀网址； 直接启动exe文件没有异常； chrome主页设置也没有问题，但是如果重新设置一遍主页，从快捷方式就可以正常启动chrome，但再次启动电脑又会恢复原样； 改exe文件名可解决但我不想用这种回避的方式。 本人又没有安装360，电脑管家等流氓软件的习惯，于是通过Google找到了解决办法，具体如下： 一、下载 WIM Tools官网连接：https://www.adremsoft.com/wmitools/ 软件体积较大(不推荐) 百度云链接: https://pan.baidu.com/s/1slJU2Rz 密码: o400 二、安装完成之后按照如下操作 在右侧选中后右击——&gt;选择view instant properties 至此查看ScriptText项可知，这是一段VBScript调用系统服务间隔30分钟执行一次，将所有浏览器调用加上如下糟糕链接 解决办法选中左侧选项，点击上面的X按钮。 删不掉？ 到WMITool安装路径（例如：C:\Program Files (x86)\WMI Tools）下，右键点击wbemeventviewer.exe，选择以管理员身份运行！删之！ 还没完，还要手动将快速启动栏中，将各个浏览器快捷命令中的http://hk.jtsh123.com/?r=b&amp;m=10去掉！ 大功告成！]]></content>
      <categories>
        <category>实用教程</category>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>实用教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java同步块]]></title>
    <url>%2F%2Fpost%2F2017%2FJAVA%E5%90%8C%E6%AD%A5%E5%9D%97.html</url>
    <content type="text"><![CDATA[概述Java 同步块（synchronized block）用来标记方法或者代码块是同步的。Java同步块用来避免竞争。 Java 同步关键字（synchronized）Java中的同步块用synchronized标记。同步块在Java中是同步在某个对象上。所有同步在一个对象上的同步块在同时只能被一个线程进入并执行操作。所有其他等待进入该同步块的线程将被阻塞，直到执行该同步块中的线程退出。 有四种不同的同步块： 实例方法 静态方法 实例方法中的同步块 静态方法中的同步块 上述同步块都同步在不同对象上。实际需要那种同步块视具体情况而定。 实例方法同步下面是一个同步的实例方法：123public synchronized void add(int value)&#123; this.count += value;&#125; 注意在方法声明中同步（synchronized ）关键字。这告诉Java该方法是同步的。 Java实例方法同步是同步在拥有该方法的对象上。 这样，每个实例其方法同步都同步在不同的对象上，即该方法所属的实例。只有一个线程能够在实例方法同步块中运行。如果有多个实例存在，那么一个线程一次可以在一个实例同步块中执行操作。一个实例一个线程。 静态方法同步静态方法同步和实例方法同步方法一样，也使用synchronized 关键字。Java静态方法同步如下示例：123public static synchronized void add(int value)&#123; count += value;&#125; 同样，这里synchronized 关键字告诉Java这个方法是同步的。 静态方法的同步是指同步在该方法所在的类对象上。 因为在Java虚拟机中一个类只能对应一个类对象，所以同时只允许一个线程执行同一个类中的静态同步方法。 对于不同类中的静态同步方法，一个线程可以执行每个类中的静态同步方法而无需等待。不管类中的那个静态同步方法被调用，一个类只能由一个线程同时执行。 实例方法中的同步块有时你不需要同步整个方法，而是同步方法中的一部分。Java可以对方法的一部分进行同步。 在非同步的Java方法中的同步块的例子如下所示：123456public void add(int value)&#123; synchronized(this)&#123; this.count += value; &#125;&#125; 示例使用Java同步块构造器来标记一块代码是同步的。该代码在执行时和同步方法一样。 注意Java同步块构造器用括号将对象括起来。在上例中，使用了“this”，即为调用add方法的实例本身。在同步构造器中用括号括起来的对象叫做监视器对象。上述代码使用监视器对象同步，同步实例方法使用调用方法本身的实例作为监视器对象。 一次只有一个线程能够在同步于同一个监视器对象的Java方法内执行。 下面两个例子都同步他们所调用的实例对象上，因此他们在同步的执行效果上是等效的。1234567891011121314public class MyClass &#123; public synchronized void log1(String msg1, String msg2)&#123; log.writeln(msg1); log.writeln(msg2); &#125; public void log2(String msg1, String msg2)&#123; synchronized(this)&#123; log.writeln(msg1); log.writeln(msg2); &#125; &#125;&#125; 在上例中，每次只有一个线程能够在两个同步块中任意一个方法内执行。 如果第二个同步块不是同步在this实例对象上，那么两个方法可以被线程同时执行。 静态方法中的同步块和上面类似，下面是两个静态方法同步的例子。这些方法同步在该方法所属的类对象上。12345678910111213public class MyClass &#123; public static synchronized void log1(String msg1, String msg2)&#123; log.writeln(msg1); log.writeln(msg2); &#125; public static void log2(String msg1, String msg2)&#123; synchronized(MyClass.class)&#123; log.writeln(msg1); log.writeln(msg2); &#125; &#125;&#125; 这两个方法不允许同时被线程访问。 如果第二个同步块不是同步在MyClass.class这个对象上。那么这两个方法可以同时被线程访问。 Java同步实例在下面例子中，启动了两个线程，都调用Counter类同一个实例的add方法。因为同步在该方法所属的实例上，所以同时只能有一个线程访问该方法。1234567891011121314151617181920212223242526272829303132public class Counter&#123; long count = 0; public synchronized void add(long value)&#123; this.count += value; &#125; &#125; public class CounterThread extends Thread&#123; protected Counter counter = null; public CounterThread(Counter counter)&#123; this.counter = counter; &#125; public void run() &#123; for(int i=0; i&lt;10; i++)&#123; counter.add(i); &#125; &#125; &#125; public class Example &#123; public static void main(String[] args)&#123; Counter counter = new Counter(); Thread threadA = new CounterThread(counter); Thread threadB = new CounterThread(counter); threadA.start(); threadB.start(); &#125;&#125; 创建了两个线程。他们的构造器引用同一个Counter实例。Counter.add方法是同步在实例上，是因为add方法是实例方法并且被标记上synchronized关键字。因此每次只允许一个线程调用该方法。另外一个线程必须要等到第一个线程退出add()方法时，才能继续执行方法。 如果两个线程引用了两个不同的Counter实例，那么他们可以同时调用add()方法。这些方法调用了不同的对象，因此这些方法也就同步在不同的对象上。这些方法调用将不会被阻塞。如下面这个例子所示：123456789101112public class Example &#123; public static void main(String[] args)&#123; Counter counterA = new Counter(); Counter counterB = new Counter(); Thread threadA = new CounterThread(counterA); Thread threadB = new CounterThread(counterB); threadA.start(); threadB.start(); &#125;&#125; 注意这两个线程，threadA和threadB，不再引用同一个counter实例。CounterA和counterB的add方法同步在他们所属的对象上。调用counterA的add方法将不会阻塞调用counterB的add方法。 参考本文转载于并发编程网]]></content>
      <categories>
        <category>并发编程</category>
        <category>线程安全</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA与线程]]></title>
    <url>%2F%2Fpost%2F2017%2FJAVA%E4%B8%8E%E7%BA%BF%E7%A8%8B.html</url>
    <content type="text"><![CDATA[线程的实现方式概述在传统的操作系统中，拥有资源和独立调度的基本单位都是进程。在引入线程的操作系统中，线程是独立调度的基本单位，进程是资源拥有的基本单位。在同一进程中，线程的切换不会引起进程切换。在不同进程中进行线程切换,如从一个进程内的线程切换到另一个进程中的线程时，会引起进程切换 根据操作系统内核是否对线程可感知，可以把线程分为内核线程和用户线程 名称 描述 用户级线程(User-LevelThread, ULT) 由应用程序所支持的线程实现, 内核意识不到用户级线程的实现 内核级线程(Kemel-LevelThread, KLT) 内核级线程又称为内核支持的线程 实现线程主要有3种方式：使用内核线程、使用用户级线程和使用用户线程加轻量级进程混合实现。 使用内核线程实现内核线程就是直接由操作系统内核支持的线程，这种线程有内核来完成线程切换，内核通过调度器(Scheduler) 对线程进行调度，并负责将线程的任务映射到各个处理器上。 轻量级进程(LWP)程序一般不会直接使用内核线程，而是去使用内核线程的一种高级接口———轻量级进程（LWP），轻量级进程就是我们通常意义上所讲的线程，轻量级进程(LWP)是一种由内核支持的用户线程。它是基于内核线程的高级抽象，因此只有先支持内核线程，才能有LWP。 优点 多处理器系统中，内核能够并行执行同一进程内的多个线程 如果进程中的一个线程被阻塞，能够切换同一进程内的其他线程继续执行（用户级线程的一个缺点） 所有能够阻塞线程的调用都以系统调用的形式实现，代价可观 当一个线程阻塞时，内核根据选择可以运行另一个进程的线程，而用户空间实现的线程中，运行时系统始终运行自己进程中的线程 信号是发给进程而不是线程的，当一个信号到达时，应该由哪一个线程处理它？线程可以“注册”它们感兴趣的信号 缺点对于用户的线程切换而言，其模式切换到饿开销较大，在同一个进程中，从一个线程切换到另一个线程时，需要从用户态转到核心态进行，这是因为用户的线程在用户态运行，而线程调度和管理实在内核中实现的，系统开销较大。 使用用户线程实现LWP虽然本质上属于用户线程，但LWP线程库是建立在内核之上的，LWP的许多操作都要进行系统调用，因此效率不高。而这里的用户线程指的是完全建立在用户空间的线程库，用户线程的建立，同步，销毁，调度完全在用户空间完成，不需要内核的帮助。因此这种线程的操作是极其快速的且低消耗的。 从中可以看出，进程中包含线程，用户线程在用户空间中实现，内核并没有直接对用户线程进程调度，内核的调度对象和传统进程一样，还是进程本身，内核并不知道用户线程的存在。用户线程之间的调度由在用户空间实现的线程库实现。 优点 可以在不支持线程的操作系统中实现。 创建和销毁线程、线程切换代价等线程管理的代价比内核线程少得多, 因为保存线程状态的过程和调用程序都只是本地过程 允许每个进程定制自己的调度算法，线程管理比较灵活。这就是必须自己写管理程序，与内核线程的区别 线程能够利用的表空间和堆栈空间比内核级线程多 不需要陷阱，不需要上下文切换，也不需要对内存高速缓存进行刷新，使得线程调用非常快捷 线程的调度不需要内核直接参与，控制简单。 缺点 线程发生I/O或页面故障引起的阻塞时，如果调用阻塞系统调用则内核由于不知道有多线程的存在，而会阻塞整个进程从而阻塞所有线程, 因此同一进程中只能同时有一个线程在运行 页面失效也会产生类似的问题。 一个单独的进程内部，没有时钟中断，所以不可能用轮转调度的方式调度线程 资源调度按照进程进行，多个处理机下，同一个进程中的线程只能在同一个处理机下分时复用 补充在用户级线程中，每个进程里的线程表由运行时系统管理。当一个线程转换到就绪状态或阻塞状态时，在该线程表中存放重新启动该线程所需的信息，与内核在进程表中存放的进程的信息完全一样 使用用户线程加轻量级进程混合实现这种模型对应着恐龙书中多对多模型。用户线程库还是完全建立在用户空间中，因此用户线程的操作还是很廉价，因此可以建立任意多需要的用户线程。操作系统提供了 LWP 作为用户线程和内核线程之间的桥梁。 LWP 还是和前面提到的一样，具有内核线程支持，是内核的调度单元，并且用户线程的系统调用要通过 LWP ，因此进程中某个用户线程的阻塞不会影响整个进程的执行。用户线程库将建立的用户线程关联到 LWP 上， LWP 与用户线程的数量不一定一致。当内核调度到某个 LWP 上时，此时与该 LWP 关联的用户线程就被执行。 JAVA线程调度进程调度属于低级调度，用来决定就绪队列中的那个进程获取处理器，然后有分派程序将执行把处理器分派给该进程的具体操作。进程调度的方式有两个非抢占式调度和抢占式调度 非抢占方式(Non-preemptive Mode)概念: 当某一进程正在处理机上执行时，即使有某个更为重要或紧迫的进程进入就绪队列，该进程仍继续执行，直到其完成或发生某种事件而进入完成或阻 塞状态时，才把处理机分配给更为重要或紧迫的进程 引起进程调度的因素: 正在执行的进程执行完毕， 或因发生某事件而不能再继续执行 执行中的进程因提出I/O请求而暂停执行； 在进程通信或同步过程中执行了某种原语操作，如wait、Block、Wakeup原语 优点: 算法简单，系统开销小 缺点: 紧急任务不能及时响应；短进程到达要等待长进程运行结束适用于大多数批处理系统环境 抢占方式(Preemptive Mode)概念: 当某一进程正在处理机上执行时，若有某个更为重要或紧迫的进程进入就绪队列，则立即暂停正在执行的进程，将处理机分配给这个更为重要或紧迫的进程 抢占式调度主要有以下原则 优先权原则 允许高优先权的新到进程抢占当前进程的处理机 短作业(进程)优先原则允许执行时间短的新到进程抢占当前进程的处理机 时间片原则 时间片用完后停止执行，重新进行调度，适用于分时系统 优点： 适于时间要求严格的实时系统 缺点： 调度算法复杂，系统开销大 状态转换 线程间的状态转换： 新建(new)：新创建了一个线程对象。 可运行(runnable)：线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取cpu 的使用权 。 运行(running)：可运行状态(runnable)的线程获得了cpu 时间片（timeslice） ，执行程序代码。 阻塞(block)：阻塞状态是指线程因为某种原因放弃了cpu 使用权，也即让出了cpu timeslice，暂时停止运行。直到线程进入可运行(runnable)状态，才有机会再次获得cpu timeslice 转到运行(running)状态。阻塞的情况分三种： 等待阻塞：运行(running)的线程执行o.wait()方法，JVM会把该线程放入等待队列(waitting queue)中。 同步阻塞：运行(running)的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池(lock pool)中。 其他阻塞：运行(running)的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。 死亡(dead)：线程run()、main() 方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。 参考 CSDN: linux内核线程、轻量级进程和用户进程 CSDN: 线程的3种实现方式–内核级线程, 用户级线程和混合型线程 计算机操作系统（第四版）2.8.1/3.3.1 深入理解Java虚拟机：JVM高级特性与最佳实践（第二版） CSDN ：进程调度方式 OSChina：一张图让你看懂JAVA线程间的状态转换 今日头条：Java线程状态转换]]></content>
      <categories>
        <category>并发编程</category>
        <category>JAVA与线程</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>并发编程</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[先行并发原则]]></title>
    <url>%2F%2Fpost%2F2017%2F%E5%85%88%E8%A1%8C%E5%8F%91%E7%94%9F%E5%8E%9F%E5%88%99%EF%BC%88Happens-before%EF%BC%89.html</url>
    <content type="text"><![CDATA[先行发生原则（Happens-Before）是判断数据是否存在竞争、线程是否安全的主要依据。 先行发生是Java内存，模型中定义的两项操作之间的偏序关系，如果操作A先行发生于操作B，那么操作A产生的影响能够被操作B观察到,”影响”包括修改了内存中共享变量的值、发送了消息、调用了方法等。 Java内存模型中存在的天然的先行发生关系： 程序次序规则：同一个线程内，按照代码出现的顺序，前面的代码先行于后面的代码，准确的说是控制流顺序，因为要考虑到分支和循环结构。 管程锁定规则：一个unlock操作先行发生于后面（时间上）对同一个锁的lock操作。 volatile变量规则：对一个volatile变量的写操作先行发生于后面（时间上）对这个变量的读操作。 线程启动规则：Thread的start( )方法先行发生于这个线程的每一个操作。 线程终止规则：线程的所有操作都先行于此线程的终止检测。可以通过Thread.join( )方法结束、Thread.isAlive( )的返回值等手段检测线程的终止。 线程中断规则：对线程interrupt( )方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupt( )方法检测线程是否中断 对象终结规则：一个对象的初始化完成先行于发生它的finalize（）方法的开始。 传递性：如果操作A先行于操作B，操作B先行于操作C，那么操作A先行于操作C。 总结：一个操作“时间上的先发生”不代表这个操作先行发生；一个操作先行发生也不代表这个操作在时间上是先发生的（重排序的出现）。时间上的先后顺序对先行发生没有太大的关系，所以衡量并发安全问题的时候不要受到时间顺序的影响，一切以先行发生原则为准。]]></content>
      <categories>
        <category>并发编程</category>
        <category>内存模型</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA的原子性、可见性、有序性]]></title>
    <url>%2F%2Fpost%2F2017%2F%E5%8E%9F%E5%AD%90%E6%80%A7%E3%80%81%E5%8F%AF%E8%A7%81%E6%80%A7%E3%80%81%E6%9C%89%E5%BA%8F%E6%80%A7.html</url>
    <content type="text"><![CDATA[原子性定义是指一个操作或多个操作要么全部执行，且执行的过程不会被任何因素打断，要么都不执行。 原子操作原理（处理器是如何实现原子操作的）处理器实现原子操作有3种方式： 处理器自动保证基本内存操作的原子性 使用总线锁保证原子性 使用缓存锁保证原子性 可见性定义可见性是指：当一个线程修改了线程共享变量的值，其它线程能够立即得知这个修改。 Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方法来实现可见性的，无论是普通变量还是volatile变量都是如此。 普通变量与volatile变量的区别是volatile的特殊规则保证了新值能立即同步到主内存，以及每使用前立即从内存刷新。因为我们可以说volatile保证了线程操作时变量的可见性，而普通变量则不能保证这一点。 有序性定义有序性：即程序执行的顺序按照代码的先后顺序执行。 Java内存模型中的程序天然有序性可以总结为一句话：如果在本线程内观察，所有操作都是有序的；如果在一个线程中观察另一个线程，所有操作都是无序的。 前半句是指“线程内表现为串行语义”，后半句是指“指令重排序”现象和“工作内存主主内存同步延迟”现象。 有序性的语意有几层， 最常见的就是保证多线程运行的串行顺序 防止重排序引起的问题 程序运行的先后顺序。比方JMM定义的一些Happens-before规则 实例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495public class MyClass &#123; private static volatile int count = 0; private static AtomicInteger atomicCount = new AtomicInteger(0); private static int synchronizedCount = 0; public static void main(String[] args) &#123; // 分别调用，打印结果 // volatileCount(); // atomicCount(); synchronizedCount(); &#125; private static void volatileCount() &#123; for (int i = 0; i &lt; 10; i++) &#123; Executors.newFixedThreadPool(3).execute(new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; // 虽然使用volatile关键字修饰int变量，但是对于多线程的环境下，也很难保证没问题，所以一般用来修饰标志位 System.out.println("volatile count: " + ++count); &#125; &#125;); &#125; &#125; // 打印结果：有重复数据，且顺序错乱。表示数据操作不是原子的，线程之间也不是有序的 // volatile count: 1 // volatile count: 5 // volatile count: 4 // volatile count: 3 // volatile count: 1 // volatile count: 2 // volatile count: 6 // volatile count: 7 // volatile count: 8 // volatile count: 9 private static void atomicCount() &#123; for (int i = 0; i &lt; 10; i++) &#123; Executors.newFixedThreadPool(3).execute(new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; // 通过使用Atomic包中的原子类保证数据操作是原子的（数据没有重复，表示是原子操作），但是不能保障有序性 System.out.println("atomic count: " + atomicCount.incrementAndGet()); &#125; &#125;); &#125; &#125; // 打印结果：虽然顺序错乱，但是数据没有重复，也就说明保障了数据的操作是原子的，但是线程间不是有序的 // atomic count: 1 // atomic count: 2 // atomic count: 3 // atomic count: 5 // atomic count: 8 // atomic count: 9 // atomic count: 10 // atomic count: 4 // atomic count: 7 // atomic count: 6 private static void synchronizedCount() &#123; for (int i = 0; i &lt; 10; i++) &#123; Executors.newFixedThreadPool(3).execute(new Runnable() &#123; @Override public void run() &#123; synchronized (MyClass.class) &#123; // 通过synchronized关键字来保证线程之间的有序性 System.out.println("synchronized count: " + ++synchronizedCount); &#125; &#125; &#125;); &#125; &#125; // 打印结果：没有重复数据，也没有错乱现象，说明数据操作是原子的，同时线程操作也是顺序的。同时也说明，有序性可以保障数据操作的原子性 // synchronized count: 1 // synchronized count: 2 // synchronized count: 3 // synchronized count: 4 // synchronized count: 5 // synchronized count: 6 // synchronized count: 7 // synchronized count: 8 // synchronized count: 9 // synchronized count: 10&#125; 参考： CSDN: Java的原子性&amp;&amp;可见性&amp;&amp;有序性 深入理解Java虚拟机：JVM高级特性与最佳实践（第二版）]]></content>
      <categories>
        <category>并发编程</category>
        <category>内存模型</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Volatile型变量的语义解释]]></title>
    <url>%2F%2Fpost%2F2017%2FVolatile%E5%9E%8B%E5%8F%98%E9%87%8F%E7%9A%84%E8%AF%AD%E4%B9%89%E8%A7%A3%E9%87%8A.html</url>
    <content type="text"><![CDATA[关键字volatile可以说是Java虚拟机提供的最轻量级的同步机制，但是它并不容易完全被正确、 完整地理解，以至于许多程序员都习惯不去使用它，遇到需要处理多线程数据竞争问题的时候一律使用synchronized来进行同步。 了解volatile变量的语义对后面了解多线程操作的其他特性很有意义，在这里我们将多花费一些时间去弄清楚volatile的语义到底是什么。 Java内存模型对volatile专门定义了一些特殊的访问规则，在介绍这些比较拗口的规则定义之前，笔者先用不那么正式但通俗易懂的语言来介绍一下这个关键字的作用。 可见性当一个变量定义为volatile之后，它将具备两种特性，第一是保证此变量对所有线程的可见性，这里的“可见性”是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。 而普通变量不能做到这一点，普通变量的值在线程间传递均需要通过主内存来完成，例如，线程A修改一个普通变量的值，然后向主内存进行回写，另外一条线程B在线程A回写完成了之后再从主内存进行读取操作，新变量值才会对线程B可见。 volatile变量在各个线程的工作内存中不存在一致性问题（在各个线程的工作内存中，volatile变量也可以存在不一致的情况，但由于每次使用之前都要先刷新，执行引擎看不到不一致的情况，因此可以认为不存在一致性问题），但是Java里面的运算并非原子操作，导致volatile变量的运算在并发下一样是不安全的. 禁止指令重排序优化使用volatile变量的第二个语义是禁止指令重排序优化，普通的变量仅仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。 因为在一个线程的方法执行过程中无法感知到这点，这也就是Java内存模型中描述的所谓的“线程内表现为串行的语义”（Within-Thread As-If-SerialSemantics）。 总结解决了volatile的语义问题，再来看看在众多保障并发安全的工具中选用volatile的意义——它能让我们的代码比使用其他的同步工具更快吗？在某些情况下，volatile的同步机制的性能确实要优于锁（使用synchronized关键字或java.util.concurrent包里面的锁），但是由于虚拟机对锁实行的许多消除和优化，使得我们很难量化地认为volatile就会比synchronized快多少。 如果让volatile自己与自己比较，那可以确定一个原则：volatile变量读操作的性能消耗与普通变量几乎没有什么差别，但是写操作则可能会慢一些，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行。 不过即便如此，大多数场景下volatile的总开销仍然要比锁低，我们在volatile与锁之中选择的唯一依据仅仅是volatile的语义能否满足使用场景的需求。 需要注意两点 load、read动作相关联，必须连续一起出现。 store、writer动作相关联，必须连续一起出现。]]></content>
      <categories>
        <category>并发编程</category>
        <category>内存模型</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java内存模型]]></title>
    <url>%2F%2Fpost%2F2017%2FJAVA%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.html</url>
    <content type="text"><![CDATA[并发处理的广泛应用是使得Amdahl定律代替摩尔定律成为计算机性能发展源动力的根本原因，也是人类“压榨”计算机运算能力的最有力武器。 概述Java内存模型规范了Java虚拟机与计算机内存是如何协同工作的。Java虚拟机是一个完整的计算机的一个模型，因此这个模型自然也包含一个内存模型——又称为Java内存模型。 如果你想设计表现良好的并发程序，理解Java内存模型是非常重要的。Java内存模型规定了如何和何时可以看到由其他线程修改过后的共享变量的值，以及在必须时如何同步的访问共享变量。 原始的Java内存模型存在一些不足，因此Java内存模型在Java1.5时被重新修订。这个版本的Java内存模型在Java8中仍在使用。 硬件的效率与一致性现代计算机在执行并发任务的时候，为了更充分的利用计算机处理器的效能，所以不得不加入一层读写速度尽可能接近处理器运算速度的高速缓存（Cache） 来作为内存与处理器之间的缓冲：将运算与要用到的数据复制到缓存中，让运算能够快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无须等待缓慢的内存读写了。 每个CPU可能还有一个CPU缓存层。实际上，绝大多数的现代CPU都有一定大小的缓存层。CPU访问缓存层的速度快于访问主存的速度，但通常比访问内部寄存器的速度还要慢一点。一些CPU还有多层缓存，但这些对理解Java内存模型如何和内存交互不是那么重要。只要知道CPU中可以有一个缓存层就可以了。 通常情况下，当一个CPU需要读取主存时，它会将主存的部分读到CPU缓存中。它甚至可能将缓存中的部分内容读到它的内部寄存器中，然后在寄存器中执行操作。当CPU需要将结果写回到主存中去时，它会将内部寄存器的值刷新到缓存中，然后在某个时间点将值刷新回主存。 当CPU需要在缓存层存放一些东西的时候，存放在缓存中的内容通常会被刷新回主存。CPU缓存可以在某一时刻将数据局部写到它的内存中，和在某一时刻局部刷新它的内存。它不会再某一时刻读/写整个缓存。通常，在一个被称作“cache lines”的更小的内存块中缓存被更新。一个或者多个缓存行可能被读到缓存，一个或者多个缓存行可能再被刷新回主存。 “内存模型”一词可以理解为在特定的操作协议下，对特定的内存或者高速缓存进行读写访问的过程抽象。 JAVA内存模型JAVA虚拟机规范中视图定义一种JAVA内存模型(JMM)来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让JAVA程序在各种平台下都能够达到一致的内存访问效果。Java1.5发布后，Java内存模型已经成熟和完善起来了。 JVM内部存储结构—堆、线程栈Java内存模型把Java虚拟机内部划分为线程栈和堆。如下图所示： 栈是运行时的单位，而堆是存储的单位。在Java中每一个运行在Java虚拟机里的线程都拥有自己的线程栈。一个线程仅能访问自己的线程栈。一个线程创建的本地变量对其它线程不可见，即使两个线程执行的是同一段代码，它们也会在各自的线程栈中创建各自的本地变量。 所有的基本类型的本地变量和对象引用都存放在栈中，因此对其它线程不可见。一个线程可能向另一个线程传递一个基本类型变量的拷贝，但是它不能共享这个基本类型变量自身。 对象都存放在堆中，包括基本类型的对象版本。如果一个对象被创建然后赋值给一个局部变量，或者用来作为另一个对象的成员变量，这个对象任然是存放在堆上。 一个本地变量也可能是指向一个对象的一个引用。在这种情况下，引用（这个本地变量）存放在线程栈上，但是对象本身存放在堆上。 一个对象可能包含方法，这些方法可能包含本地变量。这些本地变量任然存放在线程栈上，即使这些方法所属的对象存放在堆上。 一个对象的成员变量可能随着这个对象自身存放在堆上。不管这个成员变量是原始类型还是引用类型。 静态成员变量跟随着类定义一起也存放在堆上。 存放在堆上的对象可以被所有持有对这个对象引用的线程访问。当多个线程通过调用同一个对象的相同方法访问其成员变量的时候，每个线程都将拥有该成员变量的拷贝而不是其自身。 主内存和工作内存Java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存中取出变量这样的底层细节。此处的变量(Variables) 与Java编程中所说的变量有所区别，它包括了实例字段、静态字段和构成数组对象的元素，但不包括局部变量与方法参数，因为后者不是私有的，不会被共享，自然就不会存在竞争问题。 JAVA内存模型规定了所有的变量都存储在主内存中。每条线程还有自己的工作内存(与计算机的高速缓冲类比),线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取、赋值）都必须在工作内存中进行，而不能直接读写主内存中的变量。不同的线程之间也无法访问对方工作内存中的变量，线程间变量值的传递云需要通过主内存来完成。 Java内存模型与硬件内存架构之间存在差异。硬件内存架构没有区分线程栈和堆。对于硬件，所有的线程栈和堆都分布在主内中。部分线程栈和堆可能有时候会出现在CPU缓存中和CPU内部的寄存器中。这种交叉对应关系如下图所示： 当对象和变量被存放在计算机中各种不同的内存区域中时，就可能会出现一些具体的问题。主要包括如下两个方面： 线程对共享变量修改的可见性 当读，写和检查共享变量时出现race conditions 内存间交互操作交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存之间的细节操作。虚拟机保证下列操作都是原子的、不可再分的。 状态 作用内存 功能 lock（锁定） 主 将变量标识为线程独占状态 unlock（解锁） 主 释放锁定的变量，释放后的变量才可以被锁定 read（读取） 主 将变量的值从主内存传输到线程的工作内存中 load（载入） 工作 把read到的变量放入工作内存的变量副本中 use（使用） 工作 将工作内存中的变量值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时会执行这个操作 assign（赋值） 工作 将执行引擎中的变量值传递给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时会执行这个操作 store（存储） 工作 将工作内存中的一个变量的值传递到主内存中 write（写入） 主 将得到的变量的值放入主内存的变量中 线程、工作内存、主内存三者的交互关系如下图所示： JAVA内存模型规定上述操作必须按顺序执行，但是没有保证是连续执行，也就说其中某连续两个操作之间可以插入其他指令，除此之外JAVA内存模型还规定执行上述操作时需要满足较多规则，规则详情查看 这里不做详细说明。 8种内存访问操作以及上述规定以及完全确定了JAVA程序中那些内存访问操作在并发下是安全的。由于过于严谨，实践起来很麻烦，所以 此篇文章 将介绍这种定义的一个等效判断原则————先行发生原则，来确认一个访问在并发环境下是否安全。 参考 并发编程网：Java内存模型 iteye：Java内存模型JMM之一内存交互操作 深入理解Java虚拟机：JVM高级特性与最佳实践（第二版）]]></content>
      <categories>
        <category>并发编程</category>
        <category>内存模型</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[全站开启HTTPS加密模式访问]]></title>
    <url>%2F%2Fpost%2F2017%2F%E5%85%A8%E7%AB%99%E5%BC%80%E5%90%AFHTTPS%E5%8A%A0%E5%AF%86%E6%A8%A1%E5%BC%8F%E8%AE%BF%E9%97%AE.html</url>
    <content type="text"><![CDATA[前言最近发现，各大网站好像已经开始全站使用HTTPS，看着浏览器地址栏左边有着一把绿色的小锁，好像是一件很酷的事情。国内的网络环境好像越来越差，除了学会科学上网之外，好像也难免会遇到通讯服务商在网站上加上小广告的问题。随着不断了解计算机的知识，安全概念也越来越重。看着某某网站又被脱裤，一不小心自己的隐私可能就泄露出去了。在社工库上一查，还真能发现自己小学时候使用过的密码。不过，现在当然已经学会了各种措施，每个网站独立密码，能双重保护地就进行双重保护。1password也是我经常使用的一个密码管理软件……啊，好像扯远了。今天，天气很好，也想给自己的博客加上把绿色的小锁HTTPS。 什么是HTTPS HTTPS全称Hypertext Transfer Protocol Secure 超文本安全协议。也就是HTTP加上安全传输层协议TSL/SSL。介于HTTP层与TCP层之间的一层安全协议。通过安全认证，可以避免HTTP中间人攻击，信息污染，信息劫持等问题。详细信息的话腾讯Bugly的文章全站HTTPS来了介绍得很详细。HTTPS基础原理，通信过程，在这篇文章里都有详细地讲到。 直接进入主题，为博客加上HTTPS吧。 给博客加上HTTPS数字证书通过上述的HTTPS介绍，可以知道如果我们要给让博客的协议变成HTTPS，就需要有CA认可的证书才可以，一般这样子的证书是需要自己进行购买和申请认证的。简单RSA非对称性的加密算法是无法避免中间人攻击的。存在着中间人攻击和信息抵赖的风险。所以我这里所采用的方法是用，Cloudflare所提供的CDN来作为HTTPS的接入口。 CDN什么是CDN? CDN的全称就是Content Delivery Network，内容分发网络。其最基本的思路就是，用户在访问一个网站的时候，不直接访问这个网站的服务器，CDN系统会根据地理位置，将用户重新导向离其最近的CDN服务器。网站的内容在这个CDN服务器上会有相应的缓存，从而使用户更快地访问到所需要的内容，可以减少网络拥堵的情况，也可以减轻网站的服务器承受太大的访问量，以及带宽不足的情况。 主要步骤 注册Cloudflare，添加个人网站 获取Cloudflare的Domain Name Server 在域名提供商处修改自己域名的Domain Name Server为2所获取的DNS 开启SSL加密，选择flexible 开启强制跳转，使http自动跳转到https 步骤1，2在注册cloudflare的过程中，跟着流程一步一步做就好了。步骤3的话我们要先取消掉原有的DNS的解析服务，修改为cloudflare的DNS的地址。然后在Cloudflare的DNS中添加相应的DNS记录即可。可能会用到的DNS record大概有下面几种 A记录: 将一个域名指向一个ipv4的地址AAAA记录: 将一个域名指向一个ipv6的地址CNAME记录: 将一个域名指向另一个域名 步骤4中，我们所使用的是flexible的SSL加密方式。这种加密方式根据cloudflare的解释如下： Flexible SSL: There is an encrypted connection between your website visitors and Cloudflare, but not from Cloudflare to your server.You do not need an SSL certificate on your serverVisitors will see the SSL lock icon in their browser 也就是说这其实不是一种安全的加密方式，因为其实服务器与CDN在通信过程中的信息是没有加密的。但是因为我使用的git page 以及没有购买相应的证书，所以没法再服务器上部署SSL。所以CDN与服务器之间的通信就不是加密的通信。 步骤5共有两种方法 第一种：在cloudflare上的Page Rules设置中，添加上一条规则使得通过http协议的访问也会强制跳转到https上。 第二种：在网站head标签中加入如下代码：12345&lt;script type="text/javascript"&gt; var host = "caoler.cn"; if ((host == window.location.host) &amp;&amp; (window.location.protocol != "https:")) window.location.protocol = "https";&lt;/script&gt; 防跳坑： 上述两种方式只能使用其中一种，不然浏览器会报出循环重定向错误，导致网站无法正常访问。别问我为什么知道~ （逃 全站HTTPS要做到成功让这个博客满足https的要求，在博客所使用所有的图片自然也是要使用https的链接才行的，只要网站上所使用的资源不是全部通过https的就存在着安全的风险。且网站会被chrome等浏览器认为是不安全的。(放弃七牛云作为图床) 这里所使用的是新浪微博的图床，在chrome商店可以找到对应的插件。在左下角有的https的选项，只要勾选上了就可以默认生成https的图片链接了。谷歌商店地址 总结虽然这里所使用的方法，不是安全的一种方法。网站仍然会面临中间人攻击等一系列问题。因为服务器与CDN之间的通信未加密。但是至少用户在访问网站的时候，不会被通信服务商再拦截再什么广告了。刚好在学习计算机网络的过程中，了解了一些https、cdn、dns、ssl的知识。随着chrome,firefox等浏览器和苹果的大力推进。HTTPS肯定是接下去的发展趋势了，而且证书的费用也在下降。所以，各个网站都是很有必要，向这里过渡的。还有，看着自己浏览的网站，有一个绿色的小锁，就是一件很酷的事情啊，哈哈。]]></content>
      <categories>
        <category>博客相关</category>
      </categories>
      <tags>
        <tag>博客相关</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程安全]]></title>
    <url>%2F%2Fpost%2F2017%2F%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8.html</url>
    <content type="text"><![CDATA[竞态条件与临界区在同一程序中运行多个线程本身不会导致问题，问题在于多个线程访问了相同的资源。如，同一内存区（变量，数组，或对象）、系统（数据库，web services等）或文件。实际上，这些问题只有在一或多个线程向这些资源做了写操作时才有可能发生，只要资源没有发生变化,多个线程读取相同的资源就是安全的。 多线程同时执行下面的代码可能会出错：123456public class Counter &#123; protected long count = 0; public void add(long value)&#123; this.count = this.count + value; &#125;&#125; 想象下线程A和B同时执行同一个Counter对象的add()方法，我们无法知道操作系统何时会在两个线程之间切换。JVM并不是将这段代码视为单条指令来执行的，而是按照下面的顺序： 从内存获取 this.count 的值放到寄存器将寄存器中的值增加value将寄存器中的值写回内存 观察线程A和B交错执行会发生什么： this.count = 0; A: 读取 this.count 到一个寄存器 (0) B: 读取 this.count 到一个寄存器 (0) B: 将寄存器的值加2 B: 回写寄存器值(2)到内存. this.count 现在等于 2 A: 将寄存器的值加3 A: 回写寄存器值(3)到内存. this.count 现在等于 3 两个线程分别加了2和3到count变量上，两个线程执行结束后count变量的值应该等于5。然而由于两个线程是交叉执行的，两个线程从内存中读出的初始值都是0。然后各自加了2和3，并分别写回内存。最终的值并不是期望的5，而是最后写回内存的那个线程的值，上面例子中最后写回内存的是线程A，但实际中也可能是线程B。如果没有采用合适的同步机制，线程间的交叉执行情况就无法预料。 竞态条件 &amp; 临界区当两个线程竞争同一资源时，如果对资源的访问顺序敏感，就称存在竞态条件。导致竞态条件发生的代码区称作临界区。上例中add()方法就是一个临界区,它会产生竞态条件。在临界区中使用适当的同步就可以避免竞态条件。 线程安全与共享资源允许被多个线程同时执行的代码称作线程安全的代码。线程安全的代码不包含竞态条件。当多个线程同时更新共享资源时会引发竞态条件。因此，了解Java线程执行时共享了什么资源很重要。 局部变量局部变量存储在线程自己的栈中。也就是说，局部变量永远也不会被多个线程共享。所以，基础类型的局部变量是线程安全的。下面是基础类型的局部变量的一个例子：123456public void someMethod()&#123; long threadSafeInt = 0; threadSafeInt++;&#125; 局部的对象引用对象的局部引用和基础类型的局部变量不太一样。尽管引用本身没有被共享，但引用所指的对象并没有存储在线程的栈内。所有的对象都存在共享堆中。如果在某个方法中创建的对象不会逃逸出（译者注：即该对象不会被其它方法获得，也不会被非局部变量引用到）该方法，那么它就是线程安全的。实际上，哪怕将这个对象作为参数传给其它方法，只要别的线程获取不到这个对象，那它仍是线程安全的。下面是一个线程安全的局部引用样例： 1234567891011public void someMethod()&#123; LocalObject localObject = new LocalObject(); localObject.callMethod(); method2(localObject);&#125;public void method2(LocalObject localObject)&#123; localObject.setValue("value");&#125; 样例中LocalObject对象没有被方法返回，也没有被传递给someMethod()方法外的对象。每个执行someMethod()的线程都会创建自己的LocalObject对象，并赋值给localObject引用。因此，这里的LocalObject是线程安全的。事实上，整个someMethod()都是线程安全的。即使将LocalObject作为参数传给同一个类的其它方法或其它类的方法时，它仍然是线程安全的。当然，如果LocalObject通过某些方法被传给了别的线程，那它就不再是线程安全的了。 对象成员对象成员存储在堆上。如果两个线程同时更新同一个对象的同一个成员，那这个代码就不是线程安全的。下面是一个样例：1234567public class NotThreadSafe&#123; StringBuilder builder = new StringBuilder(); public add(String text)&#123; this.builder.append(text); &#125; &#125; 如果两个线程同时调用同一个NotThreadSafe实例上的add()方法，就会有竞态条件问题。例如：12345678910111213141516NotThreadSafe sharedInstance = new NotThreadSafe();new Thread(new MyRunnable(sharedInstance)).start();new Thread(new MyRunnable(sharedInstance)).start(); public class MyRunnable implements Runnable&#123; NotThreadSafe instance = null; public MyRunnable(NotThreadSafe instance)&#123; this.instance = instance; &#125; public void run()&#123; this.instance.add("some text"); &#125;&#125; 注意两个MyRunnable共享了同一个NotThreadSafe对象。因此，当它们调用add()方法时会造成竞态条件。 当然，如果这两个线程在不同的NotThreadSafe实例上调用call()方法，就不会导致竞态条件。下面是稍微修改后的例子：12new Thread(new MyRunnable(new NotThreadSafe())).start();new Thread(new MyRunnable(new NotThreadSafe())).start(); 现在两个线程都有自己单独的NotThreadSafe对象，调用add()方法时就会互不干扰，再也不会有竞态条件问题了。所以非线程安全的对象仍可以通过某种方式来消除竞态条件。 线程控制逃逸规则线程控制逃逸规则可以帮助你判断代码中对某些资源的访问是否是线程安全的。 如果一个资源的创建，使用，销毁都在同一个线程内完成，且永远不会脱离该线程的控制，则该资源的使用就是线程安全的。 资源可以是对象，数组，文件，数据库连接，套接字等等。Java中你无需主动销毁对象，所以“销毁”指不再有引用指向对象。 即使对象本身线程安全，但如果该对象中包含其他资源（文件，数据库连接），整个应用也许就不再是线程安全的了。比如2个线程都创建了各自的数据库连接，每个连接自身是线程安全的，但它们所连接到的同一个数据库也许不是线程安全的。比如，2个线程执行如下代码： 检查记录X是否存在，如果不存在，插入X 如果两个线程同时执行，而且碰巧检查的是同一个记录，那么两个线程最终可能都插入了记录： 线程1检查记录X是否存在。检查结果：不存在线程2检查记录X是否存在。检查结果：不存在线程1插入记录X线程2插入记录X 同样的问题也会发生在文件或其他共享资源上。因此，区分某个线程控制的对象是资源本身，还是仅仅到某个资源的引用很重要。 线程安全及不可变性当多个线程同时访问同一个资源，并且其中的一个或者多个线程对这个资源进行了写操作，才会产生竞态条件。多个线程同时读同一个资源不会产生竞态条件。 我们可以通过创建不可变的共享对象来保证对象在线程间共享时不会被修改，从而实现线程安全。如下示例： 1234567891011public class ImmutableValue&#123; private int value = 0; public ImmutableValue(int value)&#123; this.value = value; &#125; public int getValue()&#123; return this.value; &#125;&#125; 请注意ImmutableValue类的成员变量value是通过构造函数赋值的，并且在类中没有set方法。这意味着一旦ImmutableValue实例被创建，value变量就不能再被修改，这就是不可变性。但你可以通过getValue()方法读取这个变量的值。 （译者注：注意，“不变”（Immutable）和“只读”（Read Only）是不同的。当一个变量是“只读”时，变量的值不能直接改变，但是可以在其它变量发生改变的时候发生改变。比如，一个人的出生年月日是“不变”属性，而一个人的年龄便是“只读”属性，但是不是“不变”属性。随着时间的变化，一个人的年龄会随之发生变化，而一个人的出生年月日则不会变化。这就是“不变”和“只读”的区别。（摘自《Java与模式》第34章）） 如果你需要对ImmutableValue类的实例进行操作，可以通过得到value变量后创建一个新的实例来实现，下面是一个对value变量进行加法操作的示例： 123456789101112131415public class ImmutableValue&#123; private int value = 0; public ImmutableValue(int value)&#123; this.value = value; &#125; public int getValue()&#123; return this.value; &#125; public ImmutableValue add(int valueToAdd)&#123; return new ImmutableValue(this.value + valueToAdd); &#125;&#125; 请注意add()方法以加法操作的结果作为一个新的ImmutableValue类实例返回，而不是直接对它自己的value变量进行操作。 引用不是线程安全的！ 重要的是要记住，即使一个对象是线程安全的不可变对象，指向这个对象的引用也可能不是线程安全的。看这个例子：12345678910111213141516public void Calculator&#123; private ImmutableValue currentValue = null; public ImmutableValue getValue()&#123; return currentValue; &#125; public void setValue(ImmutableValue newValue)&#123; this.currentValue = newValue; &#125; public void add(int newValue)&#123; this.currentValue = this.currentValue.add(newValue); &#125;&#125; Calculator类持有一个指向ImmutableValue实例的引用。注意，通过setValue()方法和add()方法可能会改变这个引用。因此，即使Calculator类内部使用了一个不可变对象，但Calculator类本身还是可变的，因此Calculator类不是线程安全的。换句话说：ImmutableValue类是线程安全的，但使用它的类不是。当尝试通过不可变性去获得线程安全时，这点是需要牢记的。 要使Calculator类实现线程安全，将getValue()、setValue()和add()方法都声明为同步方法即可。 本文转载于并发编程网来源：http://ifeve.com/java-concurrency-thread-directory/]]></content>
      <categories>
        <category>并发编程</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并发性和多线程介绍]]></title>
    <url>%2F%2Fpost%2F2017%2F%E5%B9%B6%E5%8F%91%E6%80%A7%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BB%8B%E7%BB%8D.html</url>
    <content type="text"><![CDATA[介绍在过去单CPU时代，单任务在一个时间点只能执行单一程序。之后发展到多任务阶段，计算机能在同一时间点并行执行多任务或多进程。虽然并不是真正意义上的“同一时间点”，而是多个任务或进程共享一个CPU，并交由操作系统来完成多任务间对CPU的运行切换，以使得每个任务都有机会获得一定的时间片运行。 随着多任务对软件开发者带来的新挑战，程序不在能假设独占所有的CPU时间、所有的内存和其他计算机资源。一个好的程序榜样是在其不再使用这些资源时对其进行释放，以使得其他程序能有机会使用这些资源。 再后来发展到多线程技术，使得在一个程序内部能拥有多个线程并行执行。一个线程的执行可以被认为是一个CPU在执行该程序。当一个程序运行在多线程下，就好像有多个CPU在同时执行该程序。 多线程比多任务更加有挑战。多线程是在同一个程序内部并行执行，因此会对相同的内存空间进行并发读写操作。这可能是在单线程程序中从来不会遇到的问题。其中的一些错误也未必会在单CPU机器上出现，因为两个线程从来不会得到真正的并行执行。然而，更现代的计算机伴随着多核CPU的出现，也就意味着不同的线程能被不同的CPU核得到真正意义的并行执行。 如果一个线程在读一个内存时，另一个线程正向该内存进行写操作，那进行读操作的那个线程将获得什么结果呢？是写操作之前旧的值？还是写操作成功之后的新值？或是一半新一半旧的值？或者，如果是两个线程同时写同一个内存，在操作完成后将会是什么结果呢？是第一个线程写入的值？还是第二个线程写入的值？还是两个线程写入的一个混合值？因此如没有合适的预防措施，任何结果都是可能的。而且这种行为的发生甚至不能预测，所以结果也是不确定性的。 多线程的优点尽管面临很多挑战，多线程有一些优点使得它一直被使用。这些优点是： 资源利用率更好 程序设计在某些情况下更简单 程序响应更快 资源利用率更好想象一下，一个应用程序需要从本地文件系统中读取和处理文件的情景。比方说，从磁盘读取一个文件需要5秒，处理一个文件需要2秒。处理两个文件则需要： 12345675秒读取文件A2秒处理文件A5秒读取文件B2秒处理文件B--------------总共需要14秒 从磁盘中读取文件的时候，大部分的CPU时间用于等待磁盘去读取数据。在这段时间里，CPU非常的空闲。它可以做一些别的事情。通过改变操作的顺序，就能够更好的使用CPU资源。看下面的顺序：1234565秒读取文件A5秒读取文件B + 2秒处理文件A2秒处理文件B--------------总共需要12秒 CPU等待第一个文件被读取完。然后开始读取第二个文件。当第二文件在被读取的时候，CPU会去处理第一个文件。记住，在等待磁盘读取文件的时候，CPU大部分时间是空闲的。 总的说来，CPU能够在等待IO的时候做一些其他的事情。这个不一定就是磁盘IO。它也可以是网络的IO，或者用户输入。通常情况下，网络和磁盘的IO比CPU和内存的IO慢的多。 程序设计更简单在单线程应用程序中，如果你想编写程序手动处理上面所提到的读取和处理的顺序，你必须记录每个文件读取和处理的状态。相反，你可以启动两个线程，每个线程处理一个文件的读取和操作。线程会在等待磁盘读取文件的过程中被阻塞。在等待的时候，其他的线程能够使用CPU去处理已经读取完的文件。其结果就是，磁盘总是在繁忙地读取不同的文件到内存中。这会带来磁盘和CPU利用率的提升。而且每个线程只需要记录一个文件，因此这种方式也很容易编程实现。 程序响应更快将一个单线程应用程序变成多线程应用程序的另一个常见的目的是实现一个响应更快的应用程序。设想一个服务器应用，它在某一个端口监听进来的请求。当一个请求到来时，它去处理这个请求，然后再返回去监听。 服务器的流程如下所述：1234while(server is active)&#123; listen for request process request&#125; 如果一个请求需要占用大量的时间来处理，在这段时间内新的客户端就无法发送请求给服务端。只有服务器在监听的时候，请求才能被接收。另一种设计是，监听线程把请求传递给工作者线程(worker thread)，然后立刻返回去监听。而工作者线程则能够处理这个请求并发送一个回复给客户端。这种设计如下所述：12345while(server is active)&#123; listen for request hand request to worker thread&#125; 这种方式，服务端线程迅速地返回去监听。因此，更多的客户端能够发送请求给服务端。这个服务也变得响应更快。 桌面应用也是同样如此。如果你点击一个按钮开始运行一个耗时的任务，这个线程既要执行任务又要更新窗口和按钮，那么在任务执行的过程中，这个应用程序看起来好像没有反应一样。相反，任务可以传递给工作者线程（word thread)。当工作者线程在繁忙地处理任务的时候，窗口线程可以自由地响应其他用户的请求。当工作者线程完成任务的时候，它发送信号给窗口线程。窗口线程便可以更新应用程序窗口，并显示任务的结果。对用户而言，这种具有工作者线程设计的程序显得响应速度更快。 多线程的代价从一个单线程的应用到一个多线程的应用并不仅仅带来好处，它也会有一些代价。不要仅仅为了使用多线程而使用多线程。而应该明确在使用多线程时能多来的好处比所付出的代价大的时候，才使用多线程。如果存在疑问，应该尝试测量一下应用程序的性能和响应能力，而不只是猜测。 设计更复杂虽然有一些多线程应用程序比单线程的应用程序要简单，但其他的一般都更复杂。在多线程访问共享数据的时候，这部分代码需要特别的注意。线程之间的交互往往非常复杂。不正确的线程同步产生的错误非常难以被发现，并且重现以修复。 上下文切换的开销当CPU从执行一个线程切换到执行另外一个线程的时候，它需要先存储当前线程的本地的数据，程序指针等，然后载入另一个线程的本地数据，程序指针等，最后才开始执行。这种切换称为“上下文切换”(“context switch”)。CPU会在一个上下文中执行一个线程，然后切换到另外一个上下文中执行另外一个线程。 上下文切换并不廉价。如果没有必要，应该减少上下文切换的发生。 你可以通过维基百科阅读更多的关于上下文切换相关的内容： http://en.wikipedia.org/wiki/Context_switch 增加资源消耗线程在运行的时候需要从计算机里面得到一些资源。除了CPU，线程还需要一些内存来维持它本地的堆栈。它也需要占用操作系统中一些资源来管理线程。我们可以尝试编写一个程序，让它创建100个线程，这些线程什么事情都不做，只是在等待，然后看看这个程序在运行的时候占用了多少内存。 并发编程模型并发系统可以采用多种并发编程模型来实现。并发模型指定了系统中的线程如何通过协作来完成分配给它们的作业。不同的并发模型采用不同的方式拆分作业，同时线程间的协作和交互方式也不相同。这篇并发模型教程将会较深入地介绍目前（2015年，本文撰写时间）比较流行的几种并发模型。 并发模型与分布式系统之间的相似性本文所描述的并发模型类似于分布式系统中使用的很多体系结构。在并发系统中线程之间可以相互通信。在分布式系统中进程之间也可以相互通信（进程有可能在不同的机器中）。线程和进程之间具有很多相似的特性。这也就是为什么很多并发模型通常类似于各种分布式系统架构。 当然，分布式系统在处理网络失效、远程主机或进程宕掉等方面也面临着额外的挑战。但是运行在巨型服务器上的并发系统也可能遇到类似的问题，比如一块CPU失效、一块网卡失效或一个磁盘损坏等情况。虽然出现失效的概率可能很低，但是在理论上仍然有可能发生。 由于并发模型类似于分布式系统架构，因此它们通常可以互相借鉴思想。例如，为工作者们（线程）分配作业的模型一般与分布式系统中的负载均衡系统比较相似。同样，它们在日志记录、失效转移、幂等性等错误处理技术上也具有相似性。【注：幂等性，一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同】 并行工作者第一种并发模型就是我所说的并行工作者模型。传入的作业会被分配到不同的工作者上。下图展示了并行工作者模型： 在并行工作者模型中，委派者（Delegator）将传入的作业分配给不同的工作者。每个工作者完成整个任务。工作者们并行运作在不同的线程上，甚至可能在不同的CPU上。 如果在某个汽车厂里实现了并行工作者模型，每台车都会由一个工人来生产。工人们将拿到汽车的生产规格，并且从头到尾负责所有工作。 在Java应用系统中，并行工作者模型是最常见的并发模型（即使正在转变）。java.util.concurrent包中的许多并发实用工具都是设计用于这个模型的。你也可以在Java企业级（J2EE）应用服务器的设计中看到这个模型的踪迹。 并行工作者模型的优点并行工作者模式的优点是，它很容易理解。你只需添加更多的工作者来提高系统的并行度。 例如，如果你正在做一个网络爬虫，可以试试使用不同数量的工作者抓取到一定数量的页面，然后看看多少数量的工作者消耗的时间最短（意味着性能最高）。由于网络爬虫是一个IO密集型工作，最终结果很有可能是你电脑中的每个CPU或核心分配了几个线程。每个CPU若只分配一个线程可能有点少，因为在等待数据下载的过程中CPU将会空闲大量时间。 并行工作者模型的缺点并行工作者模型虽然看起来简单，却隐藏着一些缺点。接下来的章节中我会分析一些最明显的弱点。 共享状态可能会很复杂在实际应用中，并行工作者模型可能比前面所描述的情况要复杂得多。共享的工作者经常需要访问一些共享数据，无论是内存中的或者共享的数据库中的。下图展示了并行工作者模型是如何变得复杂的： 有些共享状态是在像作业队列这样的通信机制下。但也有一些共享状态是业务数据，数据缓存，数据库连接池等。 一旦共享状态潜入到并行工作者模型中，将会使情况变得复杂起来。线程需要以某种方式存取共享数据，以确保某个线程的修改能够对其他线程可见（数据修改需要同步到主存中，不仅仅将数据保存在执行这个线程的CPU的缓存中）。线程需要避免竟态，死锁以及很多其他共享状态的并发性问题。 此外，在等待访问共享数据结构时，线程之间的互相等待将会丢失部分并行性。许多并发数据结构是阻塞的，意味着在任何一个时间只有一个或者很少的线程能够访问。这样会导致在这些共享数据结构上出现竞争状态。在执行需要访问共享数据结构部分的代码时，高竞争基本上会导致执行时出现一定程度的串行化。 现在的非阻塞并发算法也许可以降低竞争并提升性能，但是非阻塞算法的实现比较困难。 可持久化的数据结构是另一种选择。在修改的时候，可持久化的数据结构总是保护它的前一个版本不受影响。因此，如果多个线程指向同一个可持久化的数据结构，并且其中一个线程进行了修改，进行修改的线程会获得一个指向新结构的引用。所有其他线程保持对旧结构的引用，旧结构没有被修改并且因此保证一致性。Scala编程包含几个持久化数据结构。【注：这里的可持久化数据结构不是指持久化存储，而是一种数据结构，比如Java中的String类，以及CopyOnWriteArrayList类，具体可参考】 虽然可持久化的数据结构在解决共享数据结构的并发修改时显得很优雅，但是可持久化的数据结构的表现往往不尽人意。 比如说，一个可持久化的链表需要在头部插入一个新的节点，并且返回指向这个新加入的节点的一个引用（这个节点指向了链表的剩余部分）。所有其他现场仍然保留了这个链表之前的第一个节点，对于这些线程来说链表仍然是为改变的。它们无法看到新加入的元素。 这种可持久化的列表采用链表来实现。不幸的是链表在现代硬件上表现的不太好。链表中得每个元素都是一个独立的对象，这些对象可以遍布在整个计算机内存中。现代CPU能够更快的进行顺序访问，所以你可以在现代的硬件上用数组实现的列表，以获得更高的性能。数组可以顺序的保存数据。CPU缓存能够一次加载数组的一大块进行缓存，一旦加载完成CPU就可以直接访问缓存中的数据。这对于元素散落在RAM中的链表来说，不太可能做得到。 无状态的工作者共享状态能够被系统中得其他线程修改。所以工作者在每次需要的时候必须重读状态，以确保每次都能访问到最新的副本，不管共享状态是保存在内存中的还是在外部数据库中。工作者无法在内部保存这个状态（但是每次需要的时候可以重读）称为无状态的。 每次都重读需要的数据，将会导致速度变慢，特别是状态保存在外部数据库中的时候。 任务顺序是不确定的并行工作者模式的另一个缺点是，作业执行顺序是不确定的。无法保证哪个作业最先或者最后被执行。作业A可能在作业B之前就被分配工作者了，但是作业B反而有可能在作业A之前执行。 并行工作者模式的这种非确定性的特性，使得很难在任何特定的时间点推断系统的状态。这也使得它也更难（如果不是不可能的话）保证一个作业在其他作业之前被执行。 流水线模式第二种并发模型我们称之为流水线并发模型。我之所以选用这个名字，只是为了配合“并行工作者”的隐喻。其他开发者可能会根据平台或社区选择其他称呼（比如说反应器系统，或事件驱动系统）。下图表示一个流水线并发模型： 类似于工厂中生产线上的工人们那样组织工作者。每个工作者只负责作业中的部分工作。当完成了自己的这部分工作时工作者会将作业转发给下一个工作者。每个工作者在自己的线程中运行，并且不会和其他工作者共享状态。有时也被成为无共享并行模型。 通常使用非阻塞的IO来设计使用流水线并发模型的系统。非阻塞IO意味着，一旦某个工作者开始一个IO操作的时候（比如读取文件或从网络连接中读取数据），这个工作者不会一直等待IO操作的结束。IO操作速度很慢，所以等待IO操作结束很浪费CPU时间。此时CPU可以做一些其他事情。当IO操作完成的时候，IO操作的结果（比如读出的数据或者数据写完的状态）被传递给下一个工作者。 有了非阻塞IO，就可以使用IO操作确定工作者之间的边界。工作者会尽可能多运行直到遇到并启动一个IO操作。然后交出作业的控制权。当IO操作完成的时候，在流水线上的下一个工作者继续进行操作，直到它也遇到并启动一个IO操作。 在实际应用中，作业有可能不会沿着单一流水线进行。由于大多数系统可以执行多个作业，作业从一个工作者流向另一个工作者取决于作业需要做的工作。在实际中可能会有多个不同的虚拟流水线同时运行。这是现实当中作业在流水线系统中可能的移动情况： 作业甚至也有可能被转发到超过一个工作者上并发处理。比如说，作业有可能被同时转发到作业执行器和作业日志器。下图说明了三条流水线是如何通过将作业转发给同一个工作者（中间流水线的最后一个工作者）来完成作业: 流水线有时候比这个情况更加复杂。 反应器，事件驱动系统采用流水线并发模型的系统有时候也称为反应器系统或事件驱动系统。系统内的工作者对系统内出现的事件做出反应，这些事件也有可能来自于外部世界或者发自其他工作者。事件可以是传入的HTTP请求，也可以是某个文件成功加载到内存中等。在写这篇文章的时候，已经有很多有趣的反应器/事件驱动平台可以使用了，并且不久的将来会有更多。比较流行的似乎是这几个： Vert.x AKKa Node.JS(JavaScript)我个人觉得Vert.x是相当有趣的（特别是对于我这样使用Java/JVM的人来说） Actors 和 ChannelsActors 和 channels 是两种比较类似的流水线（或反应器/事件驱动）模型。 在Actor模型中每个工作者被称为actor。Actor之间可以直接异步地发送和处理消息。Actor可以被用来实现一个或多个像前文描述的那样的作业处理流水线。下图给出了Actor模型：而在Channel模型中，工作者之间不直接进行通信。相反，它们在不同的通道中发布自己的消息（事件）。其他工作者们可以在这些通道上监听消息，发送者无需知道谁在监听。下图给出了Channel模型： 在写这篇文章的时候，channel模型对于我来说似乎更加灵活。一个工作者无需知道谁在后面的流水线上处理作业。只需知道作业（或消息等）需要转发给哪个通道。通道上的监听者可以随意订阅或者取消订阅，并不会影响向这个通道发送消息的工作者。这使得工作者之间具有松散的耦合。 流水线模型的优点相比并行工作者模型，流水线并发模型具有几个优点，在接下来的章节中我会介绍几个最大的优点。 无需共享的状态工作者之间无需共享状态，意味着实现的时候无需考虑所有因并发访问共享对象而产生的并发性问题。这使得在实现工作者的时候变得非常容易。在实现工作者的时候就好像是单个线程在处理工作-基本上是一个单线程的实现。 有状态的工作者当工作者知道了没有其他线程可以修改它们的数据，工作者可以变成有状态的。对于有状态，我是指，它们可以在内存中保存它们需要操作的数据，只需在最后将更改写回到外部存储系统。因此，有状态的工作者通常比无状态的工作者具有更高的性能。 较好的硬件整合（Hardware Conformity）单线程代码在整合底层硬件的时候往往具有更好的优势。首先，当能确定代码只在单线程模式下执行的时候，通常能够创建更优化的数据结构和算法。 其次，像前文描述的那样，单线程有状态的工作者能够在内存中缓存数据。在内存中缓存数据的同时，也意味着数据很有可能也缓存在执行这个线程的CPU的缓存中。这使得访问缓存的数据变得更快。 我说的硬件整合是指，以某种方式编写的代码，使得能够自然地受益于底层硬件的工作原理。有些开发者称之为mechanical sympathy。我更倾向于硬件整合这个术语，因为计算机只有很少的机械部件，并且能够隐喻“更好的匹配（match better）”，相比“同情（sympathy）”这个词在上下文中的意思，我觉得“conform”这个词表达的非常好。当然了，这里有点吹毛求疵了，用自己喜欢的术语就行。 合理的作业顺序基于流水线并发模型实现的并发系统，在某种程度上是有可能保证作业的顺序的。作业的有序性使得它更容易地推出系统在某个特定时间点的状态。更进一步，你可以将所有到达的作业写入到日志中去。一旦这个系统的某一部分挂掉了，该日志就可以用来重头开始重建系统当时的状态。按照特定的顺序将作业写入日志，并按这个顺序作为有保障的作业顺序。下图展示了一种可能的设计： 实现一个有保障的作业顺序是不容易的，但往往是可行的。如果可以，它将大大简化一些任务，例如备份、数据恢复、数据复制等，这些都可以通过日志文件来完成。 流水线模型的缺点流水线并发模型最大的缺点是作业的执行往往分布到多个工作者上，并因此分布到项目中的多个类上。这样导致在追踪某个作业到底被什么代码执行时变得困难。 同样，这也加大了代码编写的难度。有时会将工作者的代码写成回调处理的形式。若在代码中嵌入过多的回调处理，往往会出现所谓的回调地狱（callback hell）现象。所谓回调地狱，就是意味着在追踪代码在回调过程中到底做了什么，以及确保每个回调只访问它需要的数据的时候，变得非常困难 使用并行工作者模型可以简化这个问题。你可以打开工作者的代码，从头到尾优美的阅读被执行的代码。当然并行工作者模式的代码也可能同样分布在不同的类中，但往往也能够很容易的从代码中分析执行的顺序。 函数式并行（Functional Parallelism）第三种并发模型是函数式并行模型，这是也最近（2015）讨论的比较多的一种模型。函数式并行的基本思想是采用函数调用实现程序。函数可以看作是”代理人（agents）“或者”actor“，函数之间可以像流水线模型（AKA 反应器或者事件驱动系统）那样互相发送消息。某个函数调用另一个函数，这个过程类似于消息发送。 函数都是通过拷贝来传递参数的，所以除了接收函数外没有实体可以操作数据。这对于避免共享数据的竞态来说是很有必要的。同样也使得函数的执行类似于原子操作。每个函数调用的执行独立于任何其他函数的调用。 一旦每个函数调用都可以独立的执行，它们就可以分散在不同的CPU上执行了。这也就意味着能够在多处理器上并行的执行使用函数式实现的算法。 Java7中的java.util.concurrent包里包含的ForkAndJoinPool能够帮助我们实现类似于函数式并行的一些东西。而Java8中并行streams能够用来帮助我们并行的迭代大型集合。记住有些开发者对ForkAndJoinPool进行了批判（你可以在我的ForkAndJoinPool教程里面看到批评的链接）。 函数式并行里面最难的是确定需要并行的那个函数调用。跨CPU协调函数调用需要一定的开销。某个函数完成的工作单元需要达到某个大小以弥补这个开销。如果函数调用作用非常小，将它并行化可能比单线程、单CPU执行还慢。 我个人认为（可能不太正确），你可以使用反应器或者事件驱动模型实现一个算法，像函数式并行那样的方法实现工作的分解。使用事件驱动模型可以更精确的控制如何实现并行化（我的观点）。 此外，将任务拆分给多个CPU时协调造成的开销，仅仅在该任务是程序当前执行的唯一任务时才有意义。但是，如果当前系统正在执行多个其他的任务时（比如web服务器，数据库服务器或者很多其他类似的系统），将单个任务进行并行化是没有意义的。不管怎样计算机中的其他CPU们都在忙于处理其他任务，没有理由用一个慢的、函数式并行的任务去扰乱它们。使用流水线（反应器）并发模型可能会更好一点，因为它开销更小（在单线程模式下顺序执行）同时能更好的与底层硬件整合。 使用那种并发模型最好？所以，用哪种并发模型更好呢? 通常情况下，这个答案取决于你的系统打算做什么。如果你的作业本身就是并行的、独立的并且没有必要共享状态，你可能会使用并行工作者模型去实现你的系统。虽然许多作业都不是自然并行和独立的。对于这种类型的系统，我相信使用流水线并发模型能够更好的发挥它的优势，而且比并行工作者模型更有优势。 你甚至不用亲自编写所有流水线模型的基础结构。像Vert.x这种现代化的平台已经为你实现了很多。我也会去为探索如何设计我的下一个项目，使它运行在像Vert.x这样的优秀平台上。我感觉Java EE已经没有任何优势了。 注：本文转载于并发编程网来源：Java并发性和多线程介绍]]></content>
      <categories>
        <category>并发编程</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 8系列之重新认识HashMap]]></title>
    <url>%2F%2Fpost%2F2017%2FJava%208%E7%B3%BB%E5%88%97%E4%B9%8B%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86HashMap.html</url>
    <content type="text"><![CDATA[摘要HashMap是Java程序员使用频率最高的用于映射(键值对)处理的数据类型。随着JDK（Java Developmet Kit）版本的更新，JDK1.8对HashMap底层的实现进行了优化，例如引入红黑树的数据结构和扩容的优化等。本文结合JDK1.7和JDK1.8的区别，深入探讨HashMap的结构实现和功能原理。 简介Java为数据结构中的映射定义了一个接口java.util.Map，此接口主要有四个常用的实现类，分别是HashMap、Hashtable、LinkedHashMap和TreeMap，类继承关系如下图所示： 下面针对各个实现类的特点做一些说明： (1) HashMap：它根据键的hashCode值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。 HashMap最多只允许一条记录的键为null，允许多条记录的值为null。 HashMap 非线程安全，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用 Collections的synchronizedMap方法使HashMap具有线程安全的能力，或者使用ConcurrentHashMap。 (2) Hashtable：Hashtable是遗留类，很多映射的常用功能与HashMap类似，不同的是它承自Dictionary类，并且是线程安全的，任一时间只有一个线程能写Hashtable，并发性不如ConcurrentHashMap，因为ConcurrentHashMap引入了分段锁。Hashtable不建议在新代码中使用，不需要线程安全的场合可以用HashMap替换，需要线程安全的场合可以用ConcurrentHashMap替换。 (3) LinkedHashMap：LinkedHashMap是HashMap的一个子类，保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。 (4) TreeMap：TreeMap实现SortedMap接口，能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。如果使用排序的映射，建议使用TreeMap。在使用TreeMap时，key必须实现Comparable接口或者在构造TreeMap传入自定义的Comparator，否则会在运行时抛出java.lang.ClassCastException类型的异常。 对于上述四种Map类型的类，要求映射中的key是不可变对象。不可变对象是该对象在创建后它的哈希值不会被改变。如果对象的哈希值发生变化，Map对象很可能就定位不到映射的位置了。 通过上面的比较，我们知道了HashMap是Java的Map家族中一个普通成员，鉴于它可以满足大多数场景的使用条件，所以是使用频度最高的一个。下文我们主要结合源码，从存储结构、常用方法分析、扩容以及安全性等方面深入讲解HashMap的工作原理。 内部实现搞清楚HashMap，首先需要知道HashMap是什么，即它的存储结构-字段；其次弄明白它能干什么，即它的功能实现-方法。下面我们针对这两个方面详细展开讲解。 一、存储结构-字段从结构实现来讲，HashMap是数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的，如下如所示。 这里需要讲明白两个问题：数据底层具体存储的是什么？这样的存储方式有什么优点呢？ (1) 从源码可知，HashMap类中有一个非常重要的字段，就是 Node[] table，即哈希桶数组，明显它是一个Node的数组。我们来看Node[JDK1.8]是何物。 1234567891011121314static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; //用来定位数组索引位置 final K key; V value; Node&lt;K,V&gt; next; //链表的下一个node Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; ... &#125; public final K getKey()&#123; ... &#125; public final V getValue() &#123; ... &#125; public final String toString() &#123; ... &#125; public final int hashCode() &#123; ... &#125; public final V setValue(V newValue) &#123; ... &#125; public final boolean equals(Object o) &#123; ... &#125;&#125; Node是HashMap的一个内部类，实现了Map.Entry接口，本质是就是一个映射(键值对)。上图中的每个黑色圆点就是一个Node对象。 (2) HashMap就是使用哈希表来存储的。哈希表为解决冲突，可以采用开放地址法和链地址法等来解决问题，Java中HashMap采用了链地址法。链地址法，简单来说，就是数组加链表的结合。在每个数组元素上都一个链表结构，当数据被Hash后，得到数组下标，把数据放在对应下标元素的链表上。例如程序执行下面代码： map.put(“美团”,”小美”); 系统将调用”美团”这个key的hashCode()方法得到其hashCode 值（该方法适用于每个Java对象），然后再通过Hash算法的后两步运算（高位运算和取模运算，下文有介绍）来定位该键值对的存储位置，有时两个key会定位到相同的位置，表示发生了Hash碰撞。当然Hash算法计算结果越分散均匀，Hash碰撞的概率就越小，map的存取效率就会越高。 如果哈希桶数组很大，即使较差的Hash算法也会比较分散，如果哈希桶数组数组很小，即使好的Hash算法也会出现较多碰撞，所以就需要在空间成本和时间成本之间权衡，其实就是在根据实际情况确定哈希桶数组的大小，并在此基础上设计好的hash算法减少Hash碰撞。那么通过什么方式来控制map使得Hash碰撞的概率又小，哈希桶数组（Node[] table）占用空间又少呢？答案就是好的Hash算法和扩容机制。 在理解Hash和扩容流程之前，我们得先了解下HashMap的几个字段。从HashMap的默认构造函数源码可知，构造函数就是对下面几个字段进行初始化，源码如下： int threshold; // 所能容纳的key-value对极限 final float loadFactor; // 负载因子 int modCount; int size; 首先，Node[] table的初始化长度length(默认值是16)，Load factor为负载因子(默认值是0.75)，threshold是HashMap所能容纳的最大数据量的Node(键值对)个数。threshold = length * Load factor。也就是说，在数组定义好长度之后，负载因子越大，所能容纳的键值对个数越多。 结合负载因子的定义公式可知，threshold就是在此Load factor和length(数组长度)对应下允许的最大元素数目，超过这个数目就重新resize(扩容)，扩容后的HashMap容量是之前容量的两倍。默认的负载因子0.75是对空间和时间效率的一个平衡选择，建议大家不要修改，除非在时间和空间比较特殊的情况下，如果内存空间很多而又对时间效率要求很高，可以降低负载因子Load factor的值；相反，如果内存空间紧张而对时间效率要求不高，可以增加负载因子loadFactor的值，这个值可以大于1。 size这个字段其实很好理解，就是HashMap中实际存在的键值对数量。注意和table的长度length、容纳最大键值对数量threshold的区别。而modCount字段主要用来记录HashMap内部结构发生变化的次数，主要用于迭代的快速失败。强调一点，内部结构发生变化指的是结构发生变化，例如put新键值对，但是某个key对应的value值被覆盖不属于结构变化。 在HashMap中，哈希桶数组table的长度length大小必须为2的n次方(一定是合数)，这是一种非常规的设计，常规的设计是把桶的大小设计为素数。相对来说素数导致冲突的概率要小于合数，具体证明可以参考http://blog.csdn.net/liuqiyao_01/…/，Hashtable初始化桶大小为11，就是桶大小设计为素数的应用（Hashtable扩容后不能保证还是素数）。HashMap采用这种非常规设计，主要是为了在取模和扩容时做优化，同时为了减少冲突，HashMap定位哈希桶索引位置时，也加入了高位参与运算的过程。 这里存在一个问题，即使负载因子和Hash算法设计的再合理，也免不了会出现拉链过长的情况，一旦出现拉链过长，则会严重影响HashMap的性能。于是，在JDK1.8版本中，对数据结构做了进一步的优化，引入了红黑树。而当链表长度太长（默认超过8）时，链表就转换为红黑树，利用红黑树快速增删改查的特点提高HashMap的性能，其中会用到红黑树的插入、删除、查找等算法。本文不再对红黑树展开讨论，想了解更多红黑树数据结构的工作原理可以参考。http://blog.csdn.net/v_july_v/…/ 二、功能实现-方法HashMap的内部功能实现很多，本文主要从根据key获取哈希桶数组索引位置、put方法的详细执行、扩容过程三个具有代表性的点深入展开讲解。 1. 确定哈希桶数组索引位置不管增加、删除、查找键值对，定位到哈希桶数组的位置都是很关键的第一步。前面说过HashMap的数据结构是数组和链表的结合，所以我们当然希望这个HashMap里面的元素位置尽量分布均匀些，尽量使得每个位置上的元素数量只有一个，那么当我们用hash算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，不用遍历链表，大大优化了查询的效率。HashMap定位数组索引位置，直接决定了hash方法的离散性能。先看看源码的实现(方法一+方法二): 方法一： 123456static final int hash(Object key) &#123; //jdk1.8 &amp; jdk1.7 int h; // h = key.hashCode() 为第一步 取hashCode值 // h ^ (h &gt;&gt;&gt; 16) 为第二步 高位参与运算 return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125; 方法二： 123static int indexFor(int h, int length) &#123; //jdk1.7的源码，jdk1.8没有这个方法，但是实现原理一样的 return h &amp; (length-1); //第三步 取模运算&#125; 这里的Hash算法本质上就是三步：取key的hashCode值、高位运算、取模运算。 对于任意给定的对象，只要它的hashCode()返回值相同，那么程序调用方法一所计算得到的Hash码值总是相同的。我们首先想到的就是把hash值对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，模运算的消耗还是比较大的，在HashMap中是这样做的：调用方法二来计算该对象应该保存在table数组的哪个索引处。 这个方法非常巧妙，它通过h &amp; (table.length -1)来得到该对象的保存位，而HashMap底层数组的长度总是2的n次方，这是HashMap在速度上的优化。当length总是2的n次方时，h&amp; (length-1)运算等价于对length取模，也就是h%length，但是&amp;比%具有更高的效率。 在JDK1.8的实现中，优化了高位运算的算法，通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的，这么做可以在数组table的length比较小的时候，也能保证考虑到高低Bit都参与到Hash的计算中，同时不会有太大的开销。 下面举例说明下，n为table的长度。 2. 分析HashMap的put方法HashMap的put方法执行过程可以通过下图来理解，自己有兴趣可以去对比源码更清楚地研究学习。 判断键值对数组table[i]是否为空或为null，否则执行resize()进行扩容； 根据键值key计算hash值得到插入的数组索引i，如果table[i]==null，直接新建节点添加，转向⑥，如果table[i]不为空，转向③； 判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，否则转向④，这里的相同指的是hashCode以及equals； 判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向⑤； 遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可； 插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩容。 JDK1.8HashMap的put方法源码如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true);&#125;final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else &#123; Node&lt;K,V&gt; e; K k; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else &#123; for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null;&#125; 3. 扩容机制扩容(resize)就是重新计算容量，向HashMap对象里不停的添加元素，而HashMap对象内部的数组无法装载更多的元素时，对象就需要扩大数组的长度，以便能装入更多的元素。当然Java里的数组是无法自动扩容的，方法是使用一个新的数组代替已有的容量小的数组，就像我们用一个小桶装水，如果想装更多的水，就得换大水桶。 我们分析下resize的源码，鉴于JDK1.8融入了红黑树，较复杂，为了便于理解我们仍然使用JDK1.7的代码，好理解一些，本质上区别不大，具体区别后文再说。 12345678910111213void resize(int newCapacity) &#123; //传入新的容量 Entry[] oldTable = table; //引用扩容前的Entry数组 int oldCapacity = oldTable.length; if (oldCapacity == MAXIMUM_CAPACITY) &#123; //扩容前的数组大小如果已经达到最大(2^30)了 threshold = Integer.MAX_VALUE; //修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了 return; &#125; Entry[] newTable = new Entry[newCapacity]; //初始化一个新的Entry数组 transfer(newTable); //！！将数据转移到新的Entry数组里 table = newTable; //HashMap的table属性引用新的Entry数组 threshold = (int)(newCapacity * loadFactor);//修改阈值 &#125; 这里就是使用一个容量更大的数组来代替已有的容量小的数组，transfer()方法将原有Entry数组的元素拷贝到新的Entry数组里。1234567891011121314151617void transfer(Entry[] newTable) &#123; Entry[] src = table; //src引用了旧的Entry数组 int newCapacity = newTable.length; for (int j = 0; j &lt; src.length; j++) &#123; //遍历旧的Entry数组 Entry&lt;K,V&gt; e = src[j]; //取得旧Entry数组的每个元素 if (e != null) &#123; src[j] = null;//释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象） do &#123; Entry&lt;K,V&gt; next = e.next; int i = indexFor(e.hash, newCapacity); //！！重新计算每个元素在数组中的位置 e.next = newTable[i]; //标记[1] newTable[i] = e; //将元素放在数组上 e = next; //访问下一个Entry链上的元素 &#125; while (e != null); &#125; &#125;&#125; newTable[i]的引用赋给了e.next，也就是使用了单链表的头插入方式，同一位置上新元素总会被放在链表的头部位置；这样先放在一个索引上的元素终会被放到Entry链的尾部(如果发生了hash冲突的话），这一点和Jdk1.8有区别，下文详解。在旧数组中同一条Entry链上的元素，通过重新计算索引位置后，有可能被放到了新数组的不同位置上。 下面举个例子说明下扩容过程。假设了我们的hash算法就是简单的用key mod 一下表的大小（也就是数组的长度）。其中的哈希桶数组table的size=2， 所以key = 3、7、5，put顺序依次为 5、7、3。在mod 2以后都冲突在table[1]这里了。这里假设负载因子 loadFactor=1，即当键值对的实际大小size 大于 table的实际大小时进行扩容。接下来的三个步骤是哈希桶数组 resize成4，然后所有的Node重新rehash的过程。下面我们讲解下JDK1.8做了哪些优化。经过观测可以发现，我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。看下图可以明白这句话的意思，n为table的长度，图（a）表示扩容前的key1和key2两种key确定索引位置的示例，图（b）表示扩容后key1和key2两种key确定索引位置的示例，其中hash1是key1对应的哈希与高位运算结果。元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化：因此，我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”，可以看看下图为16扩充为32的resize示意图：这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。这一块就是JDK1.8新增的优化点。有一点注意区别，JDK1.7中rehash的时候，旧链表迁移新链表的时候，如果在新表的数组索引位置相同，则链表元素会倒置，但是从上图可以看出，JDK1.8不会倒置。有兴趣的同学可以研究下JDK1.8的resize源码，写的很赞，如下: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) &#123; if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold &#125; else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; else &#123; // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; @SuppressWarnings(&#123;"rawtypes","unchecked"&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; if (oldTab != null) &#123; for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; // preserve order Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab;&#125; 线程安全性在多线程使用场景中，应该尽量避免使用线程不安全的HashMap，而使用线程安全的ConcurrentHashMap。那么为什么说HashMap是线程不安全的，下面举例子说明在并发的多线程使用场景中使用HashMap可能造成死循环。代码例子如下(便于理解，仍然使用JDK1.7的环境)： 1234567891011121314151617181920public class HashMapInfiniteLoop &#123; private static HashMap&lt;Integer,String&gt; map = new HashMap&lt;Integer,String&gt;(2，0.75f); public static void main(String[] args) &#123; map.put(5， "C"); new Thread("Thread1") &#123; public void run() &#123; map.put(7, "B"); System.out.println(map); &#125;; &#125;.start(); new Thread("Thread2") &#123; public void run() &#123; map.put(3, "A); System.out.println(map); &#125;; &#125;.start(); &#125; &#125; 其中，map初始化为一个长度为2的数组，loadFactor=0.75，threshold=2*0.75=1，也就是说当put第二个key的时候，map就需要进行resize。 通过设置断点让线程1和线程2同时debug到transfer方法(3.3小节代码块)的首行。注意此时两个线程已经成功添加数据。放开thread1的断点至transfer方法的“Entry next = e.next;” 这一行；然后放开线程2的的断点，让线程2进行resize。结果如下图。注意，Thread1的 e 指向了key(3)，而next指向了key(7)，其在线程二rehash后，指向了线程二重组后的链表。 线程一被调度回来执行，先是执行 newTalbe[i] = e， 然后是e = next，导致了e指向了key(7)，而下一次循环的next = e.next导致了next指向了key(3)。e.next = newTable[i] 导致 key(3).next 指向了 key(7)。注意：此时的key(7).next 已经指向了key(3)， 环形链表就这样出现了。于是，当我们用线程一调用map.get(11)时，悲剧就出现了——Infinite Loop。 JDK1.8与JDK1.7的性能对比HashMap中，如果key经过hash算法得出的数组索引位置全部不相同，即Hash算法非常好，那样的话，getKey方法的时间复杂度就是O(1)，如果Hash算法技术的结果碰撞非常多，假如Hash算极其差，所有的Hash算法结果得出的索引位置一样，那样所有的键值对都集中到一个桶中，或者在一个链表中，或者在一个红黑树中，时间复杂度分别为O(n)和O(lgn)。 鉴于JDK1.8做了多方面的优化，总体性能优于JDK1.7，下面我们从两个方面用例子证明这一点。 Hash较均匀的情况为了便于测试，我们先写一个类Key，如下： 123456789101112131415161718192021222324252627class Key implements Comparable&lt;Key&gt; &#123; private final int value; Key(int value) &#123; this.value = value; &#125; @Override public int compareTo(Key o) &#123; return Integer.compare(this.value, o.value); &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Key key = (Key) o; return value == key.value; &#125; @Override public int hashCode() &#123; return value; &#125;&#125; 这个类复写了equals方法，并且提供了相当好的hashCode函数，任何一个值的hashCode都不会相同，因为直接使用value当做hashcode。为了避免频繁的GC，我将不变的Key实例缓存了起来，而不是一遍一遍的创建它们。代码如下：123456789101112131415public class Keys &#123; public static final int MAX_KEY = 10_000_000; private static final Key[] KEYS_CACHE = new Key[MAX_KEY]; static &#123; for (int i = 0; i &lt; MAX_KEY; ++i) &#123; KEYS_CACHE[i] = new Key(i); &#125; &#125; public static Key of(int value) &#123; return KEYS_CACHE[value]; &#125;&#125; 现在开始我们的试验，测试需要做的仅仅是，创建不同size的HashMap（1、10、100、……10000000），屏蔽了扩容的情况，代码如下：1234567891011121314151617181920static void test(int mapSize) &#123; HashMap&lt;Key, Integer&gt; map = new HashMap&lt;Key,Integer&gt;(mapSize); for (int i = 0; i &lt; mapSize; ++i) &#123; map.put(Keys.of(i), i); &#125; long beginTime = System.nanoTime(); //获取纳秒 for (int i = 0; i &lt; mapSize; i++) &#123; map.get(Keys.of(i)); &#125; long endTime = System.nanoTime(); System.out.println(endTime - beginTime);&#125;public static void main(String[] args) &#123; for(int i=10;i&lt;= 1000 0000;i*= 10)&#123; test(i); &#125;&#125; 在测试中会查找不同的值，然后度量花费的时间，为了计算getKey的平均时间，我们遍历所有的get方法，计算总的时间，除以key的数量，计算一个平均值，主要用来比较，绝对值可能会受很多环境因素的影响。结果如下：通过观测测试结果可知，JDK1.8的性能要高于JDK1.7 15%以上，在某些size的区域上，甚至高于100%。由于Hash算法较均匀，JDK1.8引入的红黑树效果不明显，下面我们看看Hash不均匀的的情况。 Hash极不均匀的情况假设我们又一个非常差的Key，它们所有的实例都返回相同的hashCode值。这是使用HashMap最坏的情况。代码修改如下：123456789class Key implements Comparable&lt;Key&gt; &#123; //... @Override public int hashCode() &#123; return 1; &#125;&#125; 仍然执行main方法，得出的结果如下表所示：从表中结果中可知，随着size的变大，JDK1.7的花费时间是增长的趋势，而JDK1.8是明显的降低趋势，并且呈现对数增长稳定。当一个链表太长的时候，HashMap会动态的将它替换成一个红黑树，这话的话会将时间复杂度从O(n)降为O(logn)。hash算法均匀和不均匀所花费的时间明显也不相同，这两种情况的相对比较，可以说明一个好的hash算法的重要性。 测试环境：处理器为2.2 GHz Intel Core i7，内存为16 GB 1600 MHz DDR3，SSD硬盘，使用默认的JVM参数，运行在64位的OS X 10.10.1上。 小结(1) 扩容是一个特别耗性能的操作，所以当程序员在使用HashMap的时候，估算map的大小，初始化的时候给一个大致的数值，避免map进行频繁的扩容。 (2) 负载因子是可以修改的，也可以大于1，但是建议不要轻易修改，除非情况非常特殊。 (3) HashMap是线程不安全的，不要在并发的环境中同时操作HashMap，建议使用ConcurrentHashMap。 (4) JDK1.8引入红黑树大程度优化了HashMap的性能。 (5) 还没升级JDK1.8的，现在开始升级吧。HashMap的性能提升仅仅是JDK1.8的冰山一角。 参考 JDK1.7&amp;JDK1.8 源码。 CSDN博客频道，HashMap多线程死循环问题，2014。 红黑联盟，Java类集框架之HashMap(JDK1.8)源码剖析，2015。 CSDN博客频道， 教你初步了解红黑树，2010。 Java Code Geeks，HashMap performance improvements in Java 8，2014。 Importnew，危险！在HashMap中将可变对象用作Key，2014。 CSDN博客频道，为什么一般hashtable的桶数会取一个素数，2013。 注：本文转载于美团点评技术团队 知乎：https://zhuanlan.zhihu.com/p/21673805 源: https://tech.meituan.com/java-hashmap.html]]></content>
      <categories>
        <category>JAVASE</category>
        <category>集合框架</category>
      </categories>
      <tags>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[442. Find All Duplicates in an Array]]></title>
    <url>%2F%2Fpost%2F2017%2F442.%20Find%20All%20Duplicates%20in%20an%20Array.html</url>
    <content type="text"><![CDATA[Given an array of integers, 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once. Find all the elements that appear twice in this array. Could you do it without extra space and in O(n) runtime?12345Example:Input:[4,3,2,7,8,2,3,1]Output:[2,3] 题目大意：给定一个整数数组，1 &lt;= a[i] &lt;= n (n = 数组长度)，某些元素出现两次，某些出现一次。寻找数组中所有出现两次的元素。你可以不使用额外空间并且在O(n)运行时间内完成题目吗？ 思路：解法一（自己的想法）：首先对数组进行排列，例如[4,3,3,2,1] 排列后变为[1,2,3,3,4]，遍历nums，当nums[i] - nums[i + 1] == 0时，也就是当前数字等于下一个数字，再将当前数字存入数组中。 代码： 1234567891011public static List&lt;Integer&gt; findDuplicates1(int[] nums) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); Arrays.sort(nums); for (int i = 0; i &lt; nums.length - 1; i++) &#123; if (nums[i] - nums[ i+1 ] == 0)&#123; res.add(nums[i]); i++; &#125; &#125; return res;&#125; 解法二：正负号标记法（一趟遍历） 遍历nums，记当前数字为n（取绝对值），将数字n视为下标（因为a[i]∈[1, n]） 当n首次出现时，nums[n - 1]-1 当n再次出现时，则nums[n - 1]一定＜0，将n加入答案 参考：https://discuss.leetcode.com/topic/64735/java-simple-solution代码： 123456789101112131415public class Solution &#123; // when find a number i, flip the number at position i-1 to negative. // if the number at position i-1 is already negative, i is the number that occurs twice. public List&lt;Integer&gt; findDuplicates(int[] nums) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; nums.length; ++i) &#123; int index = Math.abs(nums[i])-1; if (nums[index] &lt; 0) res.add(Math.abs(index+1)); nums[index] = -nums[index]; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>Array</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[561. Array Partition I]]></title>
    <url>%2F%2Fpost%2F2017%2F561.%20Array%20Partition%20I.html</url>
    <content type="text"><![CDATA[Given an array of 2n integers, your task is to group these integers into n pairs of integer, say (a1, b1), (a2, b2), …, (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible. Example 1: 123Input: [1,4,3,2]Output: 4Explanation: n is 2, and the maximum sum of pairs is 4 = min(1, 2) + min(3, 4). Note: n is a positive integer, which is in the range of [1, 10000]. All the integers in the array will be in the range of [-10000, 10000]. 题目大意： 给定一个长度为2n(偶数)的数组，分成n个小组，返回每组中较小值的和sum，使sum尽量大 思路：先将数组从大到小进行排列，将相邻两个数分为一组，每组较小数都在左边，求和即可。 代码如下： 1234567891011121314151617181920212223package cn.caoler.Array.No561;import java.util.Arrays;/** * Author: Caole * CreateDateTime: 2017/10/11 15:46 * Description: */public class main &#123; public static int arrayPairSum(int[] nums) &#123; Arrays.sort(nums); int sum = 0; for (int i = 0; i &lt; nums.length; i += 2) &#123; sum += nums[i]; &#125; return sum; &#125; public static void main(String[] args) &#123; int[] num = &#123;1,2,3,4,5,6,7,8&#125;; System.out.println(arrayPairSum(num)); &#125;&#125; 其中使用了Arrays.sort()函数，其功能参照API文档如下： 1static void sort(byte[] a) 按照数字顺序排列指定的数组。 且 for循环时直接使用 i += 2 提升效率。]]></content>
      <categories>
        <category>leetcode</category>
        <category>Array</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA迭代器（Interator）详解]]></title>
    <url>%2F%2Fpost%2F2017%2FJAVA%E8%BF%AD%E4%BB%A3%E5%99%A8%EF%BC%88Interator%EF%BC%89%E8%AF%A6%E8%A7%A3.html</url>
    <content type="text"><![CDATA[一、迭代器概述1、什么是迭代器？在Java中，有很多的数据容器，对于这些的操作有很多的共性。Java采用了迭代器来为各种容器提供了公共的操作接口。这样使得对容器的遍历操作与其具体的底层实现相隔离，达到解耦的效果。 在Iterator接口中定义了四个方法： 方法 功能 default void forEachRemaining(Consumer&lt;? super E&gt; action) 对每个剩余元素执行给定的操作，直到所有元素都被处理或动作引发异常。 boolean hasNext() 如果迭代具有更多元素，则返回 true 。 E next() 返回迭代中的下一个元素。 default void remove() 从底层集合中删除此迭代器返回的最后一个元素（可选操作）。 2、迭代器使用12345678910111213public void testIterator() &#123; Collection collection = new ArrayList(); collection.add(123); collection.add("AA"); collection.add(new Date()); collection.add("BB"); collection.add(new Employee("Caole",23)); Iterator iterator = collection.iterator(); while (iterator.hasNext())&#123; System.out.println(iterator.next()); &#125;&#125; 执行结果： 12345123AAWed Nov 01 17:53:43 CST 2017BBEmployee&#123;id=598, name='Caole', salary=23.0&#125; 二、ArrayList的Iterator实现前段代码的输出结果不用多说，这里的iterator更像是“游标”，不过这游标具体做了啥，我们还得通过list.iterator()好好看看。通过源码了解到该方法产生了一个实现Iterator接口的对象。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364private class Itr implements Iterator&lt;E&gt; &#123; int cursor; // index of next element to return int lastRet = -1; // index of last element returned; -1 if no such int expectedModCount = modCount; public boolean hasNext() &#123; return cursor != size; &#125; @SuppressWarnings("unchecked") public E next() &#123; checkForComodification(); int i = cursor; if (i &gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i]; &#125; public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; ArrayList.this.remove(lastRet); cursor = lastRet; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; @Override @SuppressWarnings("unchecked") public void forEachRemaining(Consumer&lt;? super E&gt; consumer) &#123; Objects.requireNonNull(consumer); final int size = ArrayList.this.size; int i = cursor; if (i &gt;= size) &#123; return; &#125; final Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) &#123; throw new ConcurrentModificationException(); &#125; while (i != size &amp;&amp; modCount == expectedModCount) &#123; consumer.accept((E) elementData[i++]); &#125; // update once at end of iteration to reduce heap write traffic cursor = i; lastRet = i - 1; checkForComodification(); &#125; final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125;&#125; 其中： 123456private class Itr implements Iterator&lt;E&gt; &#123; int cursor; // index of next element to return int lastRet = -1; // index of last element returned; -1 if no such int expectedModCount = modCount; ...&#125; 在ArrayList内部定义了一个内部类Itr，该类实现了Iterator接口。 在Itr中，有三个变量分别是 cursor：表示下一个元素的索引位置 lastRet：表示上一个元素的索引位置 expectModCount：预期被修改的次数 下面看一下Itr类实现了Iterator接口的三个方法： 123public boolean hasNext() &#123; return cursor != size;//当cursor不等于size时，表示仍有索引元素&#125; 1234567891011public E next() //返回下一个元素&#123; checkForComodification(); int i = cursor; if (i &gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i];&#125; 在next()方法中有一个checkForComodification()方法，其实现为： 1234final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException();&#125; 可以看到，该函数是用来判断集合的修改次数是否合法。 在集合内部维护一个字段modCount用于记录集合被修改的次数，每当集合内部结构发生变化(add,remove，set)时，modCount+1。 在迭代器内部也维护一个字段expectedModCount，同样记录当前集合修改的次数，初始化为集合的modCount值。当我们在调用Iterator进行遍历操作时，如果有其他线程修改list会出现modCount!=expectedModCount的情况，就会报并发修改异常java.util.ConcurrentModificationException。下面为示例代码： 12345678910111213141516171819public static void main(String[] args)&#123; ArrayList&lt;String&gt; aList=new ArrayList&lt;String&gt;(); aList.add("bbc"); aList.add("abc"); aList.add("ysc"); aList.add("saa"); System.out.println("移除前："+aList); Iterator&lt;String&gt; it=aList.iterator(); while(it.hasNext()) &#123; if("abc".equals(it.next())) &#123; aList.remove("abc"); &#125; &#125; System.out.println("移除后："+aList);&#125; 12345移除前：[bbc, abc, ysc, saa]java.util.ConcurrentModificationException at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:901) at java.util.ArrayList$Itr.next(ArrayList.java:851) 上面的代码中，如果我们只使用迭代器来进行删除，则不会出现并发修改异常错误。12345678910111213141516171819public static void main(String[] args)&#123; ArrayList&lt;String&gt; aList=new ArrayList&lt;String&gt;(); aList.add("bbc"); aList.add("abc"); aList.add("ysc"); aList.add("saa"); System.out.println("移除前："+aList); Iterator&lt;String&gt; it=aList.iterator(); while(it.hasNext()) &#123; if("abc".equals(it.next())) &#123; it.remove(); &#125; &#125; System.out.println("移除后："+aList);&#125; 12移除前：[bbc, abc, ysc, saa]移除后：[bbc, ysc, saa] 1234567891011121314public void remove()&#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; ArrayList.this.remove(lastRet); cursor = lastRet; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125;&#125; 在执行remove操作时，同样先执行checkForComodification()，然后会执行ArrayList的remove()方法，该方法会将modCount值加1，这里我们将expectedModCount=modCount，使之保持统一。 三、ListIterator上面可以看到，Iterator只提供了删除元素的方法remove，如果我们想要在遍历的时候添加元素怎么办？ ListIterator接口继承了Iterator接口，它允许程序员按照任一方向遍历列表，迭代期间修改列表，并获得迭代器在列表中的当前位置。 ListIterator接口定义了下面几个方法： 方法 说明 void add(E e) 将指定的元素插入列表（可选操作）。 boolean hasNext() 返回 true如果遍历正向列表，列表迭代器有多个元素。 boolean hasPrevious() 返回 true如果遍历反向列表，列表迭代器有多个元素。 E next() 返回列表中的下一个元素，并且前进光标位置。 int nextIndex() 返回随后调用 next()返回的元素的索引。 E previous() 返回列表中的上一个元素，并向后移动光标位置。 int previousIndex() 返回由后续调用 previous()返回的元素的索引。 void remove() 从列表中删除由 next()或 previous()返回的最后一个元素（可选操作）。 void set(E e) 用 指定的元素替换由 next()或 previous()返回的最后一个元素（可选操作）。 下面使用ListIterator来对list进行边遍历边添加元素操作：123456789101112131415161718public static void main(String[] args)&#123; ArrayList&lt;String&gt; aList = new ArrayList&lt;String&gt;(); aList.add("bbc"); aList.add("abc"); aList.add("ysc"); aList.add("saa"); System.out.println("移除前：" + aList); ListIterator&lt;String&gt; listIt = aList.listIterator(); while (listIt.hasNext()) &#123; if ("abc".equals(listIt.next())) &#123; listIt.add("haha"); &#125; &#125; System.out.println("移除后：" + aList);&#125; 12移除前：[bbc, abc, ysc, saa]移除后：[bbc, abc, haha, ysc, saa]]]></content>
      <categories>
        <category>JAVASE</category>
        <category>集合框架</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F%2Fpost%2F2017%2Fhello-world.html</url>
    <content type="text"><![CDATA[HelloWorld！]]></content>
  </entry>
</search>
